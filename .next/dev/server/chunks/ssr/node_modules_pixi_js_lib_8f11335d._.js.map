{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts"],"sourcesContent":["/** @internal */\nexport const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\n/** @internal */\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\n/** @internal */\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n"],"names":[],"mappings":";;;;;;;;;AACO,MAAM,eAAkB,GAAA;IAC3B,IAAM,EAAA,mBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;;;QAAA,CAAA;QAUlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;;QAAA,CAAA;QAIhB,GAAA,EAAA,QAAA,GAAe,CAAA;;;;;QAAA,CAAA;IAAA,CAMnB;AACJ,EAAA;AAIO,MAAM,qBAAwB,GAAA;IACjC,GAAG,eAAA;IACH,MAAQ,EAAA;QACJ,GAAG,eAAgB,CAAA,MAAA;QAAA,qBAAA;QAEnB,QAAQ,eAAgB,CAAA,MAAA,CAAO,MAAO,CAAA,OAAA,CAAQ,YAAY,UAAU,CAAA;IAAA,CACxE;AACJ,EAAA;AAGO,MAAM,iBAAoB,GAAA;IAC7B,IAAM,EAAA,mBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;QAAA,CAAA;QAMlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;;QAAA,CAAA;QAIhB,GAAA,EAAA,QAAA,GAAe,CAAA;;;;;QAAA,CAAA;IAAA,CAMnB;AACJ"}},
    {"offset": {"line": 73, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/scene/graphics/gpu/GpuGraphicsAdaptor.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { type Renderer } from '../../../rendering/renderers/types';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { GpuEncoderSystem } from '../../../rendering/renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses the GPU to render graphics.\n * @category rendering\n * @ignore\n */\nexport class GpuGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    private _maxTextures = 0;\n\n    public contextChange(renderer: Renderer): void\n    {\n        const localUniforms = new UniformGroup({\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        this._maxTextures = renderer.limits.maxBatchableTextures;\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'graphics',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(this._maxTextures),\n\n                localUniformBitGroup2,\n                roundPixelsBit\n            ]\n        });\n\n        this.shader = new Shader({\n            gpuProgram,\n            resources: {\n                // added on the fly!\n                localUniforms,\n            },\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGPURenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            batcher, instructions\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGPU specific...\n\n        // TODO perf test this a bit...\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n\n        const localBindGroup = (renderer as WebGPURenderer)\n            .renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n\n        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        let topology: Topology = null;\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            if (batch.topology !== topology)\n            {\n                topology = batch.topology;\n\n                encoder.setPipelineFromGeometryProgramAndState(\n                    batcher.geometry,\n                    shader.gpuProgram,\n                    graphicsPipe.state,\n                    batch.topology\n                );\n            }\n\n            shader.groups[1] = batch.bindGroup;\n\n            if (!batch.gpuBindGroup)\n            {\n                const textureBatch = batch.textures;\n\n                batch.bindGroup = getTextureBatchBindGroup(\n                    textureBatch.textures,\n                    textureBatch.count,\n                    this._maxTextures\n                );\n\n                batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n                    batch.bindGroup, shader.gpuProgram, 1\n                );\n            }\n\n            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n\n            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAwBO,MAAM,kBACb,CAAA;IADO,WAAA,EAAA;QAYH,IAAA,CAAQ,YAAe,GAAA,CAAA,CAAA;IAAA,CAAA;IAEhB,cAAc,QACrB,EAAA;QACU,MAAA,aAAA,GAAgB,IAAI,gNAAa,CAAA;YACnC,kBAAkB;gBAAE,KAAA,EAAO,IAAI,yKAAO,EAAA;gBAAG,MAAM,aAAc;YAAA,CAAA;YAC7D,MAAQ,EAAA;gBAAE,KAAO,EAAA,IAAI,YAAa,CAAA;oBAAC,CAAG;oBAAA,CAAA;oBAAG,CAAG;oBAAA,CAAC;iBAAC,CAAA;gBAAG,MAAM,WAAY;YAAA,CAAA;YACnE,MAAQ,EAAA;gBAAE,KAAO,EAAA,CAAA;gBAAG,MAAM,KAAM;YAAA,CAAA;QAAA,CACnC,CAAA,CAAA;QAEI,IAAA,CAAA,YAAA,GAAe,SAAS,MAAO,CAAA,oBAAA,CAAA;QAEpC,MAAM,iBAAa,8NAA4B,EAAA;YAC3C,IAAM,EAAA,UAAA;YACN,IAAM,EAAA;gBACF,2MAAA;oBACA,yOAAA,EAAwB,IAAA,CAAK,YAAY,CAAA;gBAEzC,+NAAA;gBACA,uNAAA;aACJ;QAAA,CACH,CAAA,CAAA;QAEI,IAAA,CAAA,MAAA,GAAS,IAAI,oMAAO,CAAA;YACrB,UAAA;YACA,SAAW,EAAA;gBAAA,oBAAA;gBAEP,aAAA;YAAA,CACJ;QAAA,CACH,CAAA,CAAA;IAAA,CACL;IAEO,OAAA,CAAQ,YAAA,EAA4B,UAC3C,EAAA;QACI,MAAM,UAAU,UAAW,CAAA,OAAA,CAAA;QACrB,MAAA,MAAA,GAAS,OAAQ,CAAA,YAAA,IAAgB,IAAK,CAAA,MAAA,CAAA;QAC5C,MAAM,WAAW,YAAa,CAAA,QAAA,CAAA;QAC9B,MAAM,gBAAgB,QAAS,CAAA,eAAA,CAAA;QAEzB,MAAA,EACF,OAAA,EAAS,YAAA,EACb,GAAI,aAAc,CAAA,oBAAA,CAAqB,OAAO,CAAA,CAAA;QAK9C,MAAM,UAAU,QAAS,CAAA,OAAA,CAAA;QAEzB,OAAA,CAAQ,WAAY,CAAA,OAAA,CAAQ,QAAU,EAAA,MAAA,CAAO,UAAU,CAAA,CAAA;QAEjD,MAAA,uBAAA,GAA0B,SAAS,cAAe,CAAA,SAAA,CAAA;QAExD,OAAA,CAAQ,YAAa,CAAA,CAAA,EAAG,uBAAyB,EAAA,MAAA,CAAO,UAAU,CAAA,CAAA;QAE5D,MAAA,cAAA,GAAkB,SACnB,WAAY,CAAA,YAAA,CAAa,mBAAA,CAAoB,MAAO,CAAA,SAAA,CAAU,aAAA,EAAe,IAAI,CAAA,CAAA;QAEtF,OAAA,CAAQ,YAAa,CAAA,CAAA,EAAG,cAAgB,EAAA,MAAA,CAAO,UAAU,CAAA,CAAA;QAEzD,MAAM,UAAU,YAAa,CAAA,YAAA,CAAA;QAE7B,IAAI,QAAqB,GAAA,IAAA,CAAA;QAEzB,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,YAAA,CAAa,eAAA,EAAiB,CAClD,EAAA,CAAA;YACU,MAAA,KAAA,GAAQ,OAAA,CAAQ,CAAC,CAAA,CAAA;YAEnB,IAAA,KAAA,CAAM,QAAA,KAAa,QACvB,EAAA;gBACI,QAAA,GAAW,KAAM,CAAA,QAAA,CAAA;gBAET,OAAA,CAAA,sCAAA,CACJ,OAAQ,CAAA,QAAA,EACR,MAAO,CAAA,UAAA,EACP,YAAa,CAAA,KAAA,EACb,KAAM,CAAA,QAAA;YACV,CACJ;YAEO,MAAA,CAAA,MAAA,CAAO,CAAC,CAAA,GAAI,KAAM,CAAA,SAAA,CAAA;YAErB,IAAA,CAAC,MAAM,YACX,EAAA;gBACI,MAAM,eAAe,KAAM,CAAA,QAAA,CAAA;gBAE3B,KAAA,CAAM,SAAY,OAAA,yNAAA,EACd,YAAa,CAAA,QAAA,EACb,YAAa,CAAA,KAAA,EACb,IAAK,CAAA,YAAA;gBAGH,KAAA,CAAA,YAAA,GAAe,SAAS,SAAU,CAAA,YAAA,CACpC,KAAM,CAAA,SAAA,EAAW,MAAO,CAAA,UAAA,EAAY,CAAA;YACxC,CACJ;YAEA,OAAA,CAAQ,YAAa,CAAA,CAAA,EAAG,KAAM,CAAA,SAAA,EAAW,OAAO,UAAU,CAAA,CAAA;YAE1D,OAAA,CAAQ,iBAAA,CAAkB,WAAY,CAAA,KAAA,CAAM,IAAM,EAAA,CAAA,EAAG,MAAM,KAAK,CAAA,CAAA;QAAA,CACpE;IAAA,CACJ;IAEO,OACP,GAAA;QACS,IAAA,CAAA,MAAA,CAAO,OAAA,CAAQ,IAAI,CAAA,CAAA;QACxB,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;IAAA,CAClB;AACJ,CAAA;AAAA,YAAA,GAvHa,kBAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,kBAAA;KAClB;IACA,IAAM,EAAA,UAAA;AACV,CAAA"}},
    {"offset": {"line": 187, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/high-shader/shader-bits/textureBit.ts"],"sourcesContent":["/** @internal */\nexport const textureBit = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* wgsl */`\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `,\n        main: /* wgsl */`\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        `,\n        main: /* wgsl */`\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    }\n};\n\n/** @internal */\nexport const textureBitGl = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureMatrix;\n        `,\n        main: /* glsl */`\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n        uniform sampler2D uTexture;\n\n\n        `,\n        main: /* glsl */`\n            outColor = texture(uTexture, vUV);\n        `\n    }\n};\n\n"],"names":[],"mappings":";;;;;;;AACO,MAAM,UAAa,GAAA;IACtB,IAAM,EAAA,aAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;QAAA,CAAA;QAQlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;IACA,QAAU,EAAA;QACN,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;QAAA,CAAA;QAMlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;AACJ,EAAA;AAGO,MAAM,YAAe,GAAA;IACxB,IAAM,EAAA,aAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;QAAA,CAAA;QAGlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;IACA,QAAU,EAAA;QACN,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;QAAA,CAAA;QAKlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAGpB;AACJ"}},
    {"offset": {"line": 248, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/scene/mesh/gpu/GpuMeshAdapter.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * The WebGL adaptor for the mesh system. Allows the Mesh System to be used with the WebGl renderer\n * @category rendering\n * @ignore\n */\nexport class GpuMeshAdapter implements MeshAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBit,\n                textureBit,\n                roundPixelsBit,\n            ]\n        });\n\n        this._shader = new Shader({\n            gpuProgram,\n            resources: {\n                uTexture: Texture.EMPTY._source,\n                uSampler: Texture.EMPTY._source.style,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh)\n    {\n        const renderer = meshPipe.renderer as WebGPURenderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);\n        }\n        else if (!shader.gpuProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no gpuProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        const gpuProgram = shader.gpuProgram;\n        // GPU..\n\n        if (gpuProgram.autoAssignGlobalUniforms)\n        {\n            shader.groups[0] = renderer.globalUniforms.bindGroup;\n        }\n\n        if (gpuProgram.autoAssignLocalUniforms)\n        {\n            const localUniforms = meshPipe.localUniforms;\n\n            shader.groups[1] = (renderer as WebGPURenderer)\n                .renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n        }\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAmBO,MAAM,cACb,CAAA;IAWW,IACP,GAAA;QACI,MAAM,iBAAa,8NAA4B,EAAA;YAC3C,IAAM,EAAA,MAAA;YACN,IAAM,EAAA;gBACF,yNAAA;gBACA,+MAAA;gBACA,uNAAA;aACJ;QAAA,CACH,CAAA,CAAA;QAEI,IAAA,CAAA,OAAA,GAAU,IAAI,oMAAO,CAAA;YACtB,UAAA;YACA,SAAW,EAAA;gBACP,QAAA,EAAU,uMAAA,CAAQ,KAAM,CAAA,OAAA;gBACxB,QAAA,EAAU,uMAAQ,CAAA,KAAA,CAAM,OAAQ,CAAA,KAAA;gBAChC,eAAiB,EAAA;oBACb,gBAAgB;wBAAE,IAAA,EAAM;wBAAe,KAAO,EAAA,IAAI,yKAAA,EAAS;oBAAA,CAAA;gBAAA,CAC/D;YAAA,CACJ;QAAA,CACH,CAAA,CAAA;IAAA,CACL;IAEO,OAAA,CAAQ,QAAA,EAAoB,IACnC,EAAA;QACI,MAAM,WAAW,QAAS,CAAA,QAAA,CAAA;QAE1B,IAAI,SAAiB,IAAK,CAAA,OAAA,CAAA;QAE1B,IAAI,CAAC,MACL,EAAA;YACI,MAAA,GAAS,IAAK,CAAA,OAAA,CAAA;YAEd,MAAA,CAAO,MAAA,CAAO,CAAC,CAAA,GAAI,SAAS,OAAQ,CAAA,mBAAA,CAAoB,KAAK,OAAO,CAAA,CAAA;QAAA,CACxE,MAAA,IACS,CAAC,MAAA,CAAO,UACjB,EAAA;gBAES,sKAAA,EAAA,+BAAA,EAAiC,KAAK,MAAM,CAAA,CAAA;YAGjD,OAAA;QAAA,CACJ;QAEA,MAAM,aAAa,MAAO,CAAA,UAAA,CAAA;QAG1B,IAAI,WAAW,wBACf,EAAA;YACI,MAAA,CAAO,MAAO,CAAA,CAAC,CAAI,GAAA,QAAA,CAAS,cAAe,CAAA,SAAA,CAAA;QAAA,CAC/C;QAEA,IAAI,WAAW,uBACf,EAAA;YACI,MAAM,gBAAgB,QAAS,CAAA,aAAA,CAAA;YAExB,MAAA,CAAA,MAAA,CAAO,CAAC,CAAK,GAAA,QAAA,CACf,WAAA,CAAY,YAAa,CAAA,mBAAA,CAAoB,eAAe,IAAI,CAAA,CAAA;QAAA,CACzE;QAEA,QAAA,CAAS,OAAA,CAAQ,IAAK,CAAA;YAClB,UAAU,IAAK,CAAA,SAAA;YACf,MAAA;YACA,OAAO,IAAK,CAAA,KAAA;QAAA,CACf,CAAA,CAAA;IAAA,CACL;IAEO,OACP,GAAA;QACS,IAAA,CAAA,OAAA,CAAQ,OAAA,CAAQ,IAAI,CAAA,CAAA;QACzB,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;IAAA,CACnB;AACJ,CAAA;AAAA,YAAA,GApFa,cAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,kBAAA;KAClB;IACA,IAAM,EAAA,MAAA;AACV,CAAA"}},
    {"offset": {"line": 336, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts"],"sourcesContent":["import type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link GlStateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @category rendering\n * @advanced\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    /** @internal */\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 491, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/batcher/gpu/GpuBatchAdaptor.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup';\n\nimport type { GpuEncoderSystem } from '../../renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../renderers/gpu/WebGPURenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\nconst tempState = State.for2d();\n\n/**\n * A BatcherAdaptor that uses the GPU to render batches.\n * @category rendering\n * @ignore\n */\nexport class GpuBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private _shader: Shader;\n    private _geometry: Geometry;\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    {\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n        const program = shader.gpuProgram;\n\n        this._shader = shader;\n        this._geometry = geometry;\n\n        encoder.setGeometry(geometry, program);\n\n        tempState.blendMode = 'normal';\n\n        // this just initiates the pipeline, so we can then set bind groups on it\n        renderer.pipeline.getPipeline(\n            geometry,\n            program,\n            tempState\n        );\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        // low level - we need to reset the bind group at location 1 to null\n        // this is because we directly manipulate the bound buffer in the execute function for\n        // performance reasons.\n        // setting it to null ensures that the next bind group we set at location 1 will\n        // be the one we want.\n        encoder.resetBindGroup(1);\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, program);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const program = this._shader.gpuProgram;\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        if (!batch.bindGroup)\n        {\n            const textureBatch = batch.textures;\n\n            batch.bindGroup = getTextureBatchBindGroup(\n                textureBatch.textures,\n                textureBatch.count,\n                renderer.limits.maxBatchableTextures\n            );\n        }\n\n        tempState.blendMode = batch.blendMode;\n\n        const gpuBindGroup = renderer.bindGroup.getBindGroup(\n            batch.bindGroup, program, 1\n        );\n\n        const pipeline = renderer.pipeline.getPipeline(\n            this._geometry,\n            program,\n            tempState,\n            batch.topology\n        );\n\n        batch.bindGroup._touch(renderer.gc.now, renderer.tick);\n\n        encoder.setPipeline(pipeline);\n\n        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAWA,MAAM,SAAA,GAAY,iMAAA,CAAM,KAAM,EAAA,CAAA;AAOvB,MAAM,eACb,CAAA;IAYW,KAAA,CAAM,SAAwB,EAAA,QAAA,EAAoB,MACzD,EAAA;QACI,MAAM,WAAW,SAAU,CAAA,QAAA,CAAA;QAC3B,MAAM,UAAU,QAAS,CAAA,OAAA,CAAA;QACzB,MAAM,UAAU,MAAO,CAAA,UAAA,CAAA;QAEvB,IAAA,CAAK,OAAU,GAAA,MAAA,CAAA;QACf,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;QAET,OAAA,CAAA,WAAA,CAAY,UAAU,OAAO,CAAA,CAAA;QAErC,SAAA,CAAU,SAAY,GAAA,QAAA,CAAA;QAGtB,QAAA,CAAS,QAAS,CAAA,WAAA,CACd,QAAA,EACA,OAAA,EACA,SAAA;QAGE,MAAA,uBAAA,GAA0B,SAAS,cAAe,CAAA,SAAA,CAAA;QAOxD,OAAA,CAAQ,cAAA,CAAe,CAAC,CAAA,CAAA;QAEhB,OAAA,CAAA,YAAA,CAAa,CAAG,EAAA,uBAAA,EAAyB,OAAO,CAAA,CAAA;IAAA,CAC5D;IAEO,OAAA,CAAQ,SAAA,EAAwB,KACvC,EAAA;QACU,MAAA,OAAA,GAAU,IAAA,CAAK,OAAQ,CAAA,UAAA,CAAA;QAC7B,MAAM,WAAW,SAAU,CAAA,QAAA,CAAA;QAC3B,MAAM,UAAU,QAAS,CAAA,OAAA,CAAA;QAErB,IAAA,CAAC,MAAM,SACX,EAAA;YACI,MAAM,eAAe,KAAM,CAAA,QAAA,CAAA;YAE3B,KAAA,CAAM,SAAY,OAAA,yNAAA,EACd,YAAa,CAAA,QAAA,EACb,YAAa,CAAA,KAAA,EACb,SAAS,MAAO,CAAA,oBAAA;QACpB,CACJ;QAEA,SAAA,CAAU,SAAA,GAAY,KAAM,CAAA,SAAA,CAAA;QAEtB,MAAA,YAAA,GAAe,SAAS,SAAU,CAAA,YAAA,CACpC,KAAM,CAAA,SAAA,EAAW,OAAA,EAAS,CAAA;QAGxB,MAAA,QAAA,GAAW,SAAS,QAAS,CAAA,WAAA,CAC/B,IAAK,CAAA,SAAA,EACL,OAAA,EACA,SAAA,EACA,KAAM,CAAA,QAAA;QAGV,KAAA,CAAM,SAAA,CAAU,MAAO,CAAA,QAAA,CAAS,EAAG,CAAA,GAAA,EAAK,SAAS,IAAI,CAAA,CAAA;QAErD,OAAA,CAAQ,WAAA,CAAY,QAAQ,CAAA,CAAA;QAEpB,OAAA,CAAA,iBAAA,CAAkB,YAAa,CAAA,CAAA,EAAG,YAAY,CAAA,CAAA;QACtD,OAAA,CAAQ,iBAAA,CAAkB,WAAY,CAAA,KAAA,CAAM,IAAM,EAAA,CAAA,EAAG,MAAM,KAAK,CAAA,CAAA;IAAA,CACpE;AACJ,CAAA;AAAA,YAAA,GAlFa,eAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,kBAAA;KAClB;IACA,IAAM,EAAA,OAAA;AACV,CAAA"}},
    {"offset": {"line": 546, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/scene/container/CustomRenderPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe, RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderContainer } from './RenderContainer';\n\n/**\n * The CustomRenderPipe is a render pipe that allows for custom rendering logic for your renderable objects.\n * @example\n * import { RenderContainer } from 'pixi.js';\n *\n * const renderContainer = new RenderContainer(\n * (renderer) =>  {\n *     renderer.clear({\n *       clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * })\n * @category rendering\n * @internal\n */\nexport class CustomRenderPipe implements InstructionPipe<RenderContainer>, RenderPipe<RenderContainer>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'customRender',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public updateRenderable() { /** empty */ }\n    public destroyRenderable() { /** empty */ }\n    public validateRenderable() { return false; }\n\n    public addRenderable(container: RenderContainer, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add(container);\n    }\n\n    public execute(container: RenderContainer)\n    {\n        if (!container.isRenderable) return;\n\n        container.render(this._renderer);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAqBO,MAAM,gBACb,CAAA;IAYI,YAAY,QACZ,CAAA;QACI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEO,gBAAmB,GAAA,CAAA,CAAe;IAClC,iBAAoB,GAAA,CAAA,CAAe;IACnC,kBAAqB,GAAA;QAAS,OAAA,KAAA,CAAA;IAAA,CAAO;IAErC,aAAA,CAAc,SAAA,EAA4B,cACjD,EAAA;QACI,IAAA,CAAK,SAAU,CAAA,WAAA,CAAY,KAAM,CAAA,KAAA,CAAM,cAAc,CAAA,CAAA;QAErD,cAAA,CAAe,GAAA,CAAI,SAAS,CAAA,CAAA;IAAA,CAChC;IAEO,QAAQ,SACf,EAAA;QACI,IAAI,CAAC,SAAU,CAAA,YAAA,EAAc,OAAA;QAEnB,SAAA,CAAA,MAAA,CAAO,IAAA,CAAK,SAAS,CAAA,CAAA;IAAA,CACnC;IAEO,OACP,GAAA;QACI,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;IAAA,CACrB;AACJ,CAAA;AAxCa,gBAAA,CAEK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,UAAA;QACd,+KAAc,CAAA,WAAA;QACd,+KAAc,CAAA,WAAA;KAClB;IACA,IAAM,EAAA,cAAA;AACV,CAAA"}},
    {"offset": {"line": 588, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts"],"sourcesContent":["import { type GPUData } from '../view/ViewContainer';\n\nimport type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @internal\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement, GPUData\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n\n    public destroy()\n    {\n        this.reset();\n    }\n}\n"],"names":[],"mappings":";;;;;AAcO,MAAM,eACb,CAAA;IADO,WAAA,EAAA;QAEH,IAAA,CAAO,WAAc,GAAA,SAAA,CAAA;QACrB,IAAA,CAAO,QAAqB,GAAA,eAAA,CAAA;QAG5B,mBAAA;QAAA,IAAA,CAAgB,aAAgB,GAAA,CAAA,CAAA;QAChC,IAAA,CAAgB,SAAY,GAAA,CAAA,CAAA;QAC5B,IAAA,CAAgB,UAAa,GAAA,IAAA,CAAA;QAQ7B,IAAA,CAAO,WAAqB,GAAA,CAAA,CAAA;QAI5B,IAAA,CAAO,eAAkB,GAAA,CAAA,CAAA;QACzB,yBAAA;QAAA,IAAA,CAAO,QAAoB,GAAA,IAAA,CAAA;QAC3B,IAAA,CAAO,MAAgB,GAAA,IAAA,CAAA;IAAA,CAAA;IAEvB,IAAI,SAAY,GAAA;QAAE,OAAO,IAAA,CAAK,UAAW,CAAA,cAAA,CAAA;IAAA,CAAgB;IACzD,IAAI,KAAQ,GAAA;QAAE,OAAO,IAAA,CAAK,UAAW,CAAA,eAAA,CAAA;IAAA,CAAiB;IAE/C,KACP,GAAA;QACI,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;QAClB,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;QACf,IAAA,CAAK,QAAW,GAAA,IAAA,CAAA;QAChB,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;QACd,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;IAAA,CAClB;IAEO,OACP,GAAA;QACI,IAAA,CAAK,KAAM,EAAA,CAAA;IAAA,CACf;AACJ"}},
    {"offset": {"line": 630, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/scene/container/utils/executeInstructions.ts"],"sourcesContent":["import type { InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\n/**\n * @param renderGroup\n * @param renderer\n * @internal\n */\nexport function executeInstructions(renderGroup: RenderGroup, renderer: RenderPipes)\n{\n    const instructionSet = renderGroup.instructionSet;\n    const instructions = instructionSet.instructions;\n\n    for (let i = 0; i < instructionSet.instructionSize; i++)\n    {\n        const instruction = instructions[i];\n\n        (renderer[instruction.renderPipeId as keyof RenderPipes] as InstructionPipe<any>).execute(instruction);\n    }\n}\n"],"names":[],"mappings":";;;;;AASgB,SAAA,mBAAA,CAAoB,WAAA,EAA0B,QAC9D,EAAA;IACI,MAAM,iBAAiB,WAAY,CAAA,cAAA,CAAA;IACnC,MAAM,eAAe,cAAe,CAAA,YAAA,CAAA;IAEpC,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,cAAA,CAAe,eAAA,EAAiB,CACpD,EAAA,CAAA;QACU,MAAA,WAAA,GAAc,YAAA,CAAa,CAAC,CAAA,CAAA;QAEjC,QAAS,CAAA,WAAA,CAAY,YAAiC,CAAA,CAA2B,OAAA,CAAQ,WAAW,CAAA,CAAA;IAAA,CACzG;AACJ"}},
    {"offset": {"line": 649, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/scene/container/RenderGroupPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\nimport { executeInstructions } from './utils/executeInstructions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The RenderGroupPipe is a render pipe for rendering RenderGroups.\n * @internal\n */\nexport class RenderGroupPipe implements InstructionPipe<RenderGroup>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderGroup(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n        }\n        else\n        {\n            this._addRenderableDirect(renderGroup, instructionSet);\n        }\n    }\n\n    public execute(renderGroup: RenderGroup)\n    {\n        if (!renderGroup.isRenderable) return;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._executeCacheAsTexture(renderGroup);\n        }\n        else\n        {\n            this._executeDirect(renderGroup);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n\n    private _addRenderableDirect(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        if (renderGroup._batchableRenderGroup)\n        {\n            BigPool.return(renderGroup._batchableRenderGroup);\n            renderGroup._batchableRenderGroup = null;\n        }\n\n        instructionSet.add(renderGroup);\n    }\n\n    private _addRenderableCacheAsTexture(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        const batchableRenderGroup = renderGroup._batchableRenderGroup ??= BigPool.get(BatchableSprite);\n\n        batchableRenderGroup.renderable = renderGroup.root;\n        batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n        batchableRenderGroup.texture = renderGroup.texture;\n        batchableRenderGroup.bounds = renderGroup._textureBounds;\n\n        instructionSet.add(renderGroup);\n\n        this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);\n        this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n        this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);\n    }\n\n    private _executeCacheAsTexture(renderGroup: RenderGroup): void\n    {\n        if (renderGroup.textureNeedsUpdate)\n        {\n            renderGroup.textureNeedsUpdate = false;\n\n            const worldTransformMatrix = tempMatrix\n                .identity()\n                .translate(\n                    -renderGroup._textureBounds.x,\n                    -renderGroup._textureBounds.y\n                );\n\n            this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n\n            this._renderer.globalUniforms.push({\n                worldTransformMatrix,\n                worldColor: 0xFFFFFFFF,\n                offset: { x: 0, y: 0 },\n            });\n\n            executeInstructions(renderGroup, this._renderer.renderPipes);\n\n            this._renderer.renderTarget.finishRenderPass();\n\n            this._renderer.renderTarget.pop();\n            this._renderer.globalUniforms.pop();\n        }\n\n        renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n        renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n    }\n\n    private _executeDirect(renderGroup: RenderGroup): void\n    {\n        this._renderer.globalUniforms.push({\n            worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n            worldColor: renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(renderGroup, this._renderer.renderPipes);\n\n        this._renderer.globalUniforms.pop();\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 750, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/scene/container/utils/clearList.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/scene/container/utils/clearList.ts"],"sourcesContent":["/**\n * nulls all slots in an array from a certain index.\n * assume that when a null item is hit, the rest are also null.\n * Which will be the case for where this is used!\n * @param list - the array to clean\n * @param index - the index to start from\n * @category utils\n * @internal\n */\nexport function clearList(list: Array<unknown>, index?: number)\n{\n    index ||= 0;\n\n    for (let j = index; j < list.length; j++)\n    {\n        if (list[j])\n        {\n            list[j] = null;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n"],"names":[],"mappings":";;;;;AASgB,SAAA,SAAA,CAAU,IAAA,EAAsB,KAChD,EAAA;IACc,KAAA,IAAA,CAAA,KAAA,GAAA,CAAA,CAAA,CAAA;IAEV,IAAA,IAAS,CAAI,GAAA,KAAA,EAAO,CAAI,GAAA,IAAA,CAAK,MAAA,EAAQ,CACrC,EAAA,CAAA;QACQ,IAAA,IAAA,CAAK,CAAC,CACV,EAAA;YACI,IAAA,CAAK,CAAC,CAAI,GAAA,IAAA,CAAA;QAAA,CAGd,MAAA;YACI,MAAA;QAAA,CACJ;IAAA,CACJ;AACJ"}},
    {"offset": {"line": 771, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/scene/container/utils/updateRenderGroupTransforms.ts"],"sourcesContent":["import { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_VISIBLE } from '../Container';\nimport { clearList } from './clearList';\nimport { multiplyColors } from './multiplyColors';\n\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { RenderGroup } from '../RenderGroup';\n\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\n\n/**\n * @param renderGroup\n * @param updateChildRenderGroups\n * @internal\n */\nexport function updateRenderGroupTransforms(renderGroup: RenderGroup, updateChildRenderGroups = false)\n{\n    updateRenderGroupTransform(renderGroup);\n\n    const childrenToUpdate = renderGroup.childrenToUpdate;\n\n    const updateTick = renderGroup.updateTick++;\n\n    for (const j in childrenToUpdate)\n    {\n        const renderGroupDepth = Number(j);\n\n        const childrenAtDepth = childrenToUpdate[j];\n\n        const list = childrenAtDepth.list;\n        const index = childrenAtDepth.index;\n\n        for (let i = 0; i < index; i++)\n        {\n            const child = list[i];\n\n            // check that these things match our layer and depth - if the renderGroup does not match,\n            // the child has been re-parented into another rendergroup since it asked to be updated so we can ignore it here\n            // secondly if the relativeRenderGroupDepth has changed, then the it means it will have been nested at a\n            // different different level in the render group - so we can wait for the update that does in fact match\n            if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth)\n            {\n                updateTransformAndChildren(child, updateTick, 0);\n            }\n        }\n\n        clearList(list, index);\n\n        childrenAtDepth.index = 0;\n    }\n\n    if (updateChildRenderGroups)\n    {\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n        }\n    }\n}\n\n/**\n * @param renderGroup\n * @internal\n */\nexport function updateRenderGroupTransform(renderGroup: RenderGroup)\n{\n    const root = renderGroup.root;\n\n    let worldAlpha;\n\n    if (renderGroup.renderGroupParent)\n    {\n        const renderGroupParent = renderGroup.renderGroupParent;\n\n        renderGroup.worldTransform.appendFrom(\n            root.relativeGroupTransform,\n            renderGroupParent.worldTransform,\n        );\n\n        renderGroup.worldColor = multiplyColors(\n            root.groupColor,\n            renderGroupParent.worldColor,\n        );\n\n        worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n    }\n    else\n    {\n        renderGroup.worldTransform.copyFrom(root.localTransform);\n        renderGroup.worldColor = root.localColor;\n        worldAlpha = root.localAlpha;\n    }\n\n    // eslint-disable-next-line no-nested-ternary\n    worldAlpha = worldAlpha < 0 ? 0 : (worldAlpha > 1 ? 1 : worldAlpha);\n    renderGroup.worldAlpha = worldAlpha;\n\n    renderGroup.worldColorAlpha = renderGroup.worldColor\n            + (((worldAlpha * 255) | 0) << 24);\n}\n\n/**\n * @param container\n * @param updateTick\n * @param updateFlags\n * @internal\n */\nexport function updateTransformAndChildren(container: Container, updateTick: number, updateFlags: number)\n{\n    if (updateTick === container.updateTick) return;\n    container.updateTick = updateTick;\n\n    container.didChange = false;\n\n    const localTransform = container.localTransform;\n\n    container.updateLocalTransform();\n\n    const parent = container.parent;\n\n    if ((parent && !parent.renderGroup))\n    {\n        updateFlags |= container._updateFlags;\n\n        container.relativeGroupTransform.appendFrom(\n            localTransform,\n            parent.relativeGroupTransform,\n        );\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, parent, updateFlags);\n        }\n    }\n    else\n    {\n        updateFlags = container._updateFlags;\n\n        container.relativeGroupTransform.copyFrom(localTransform);\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, tempContainer, updateFlags);\n        }\n    }\n\n    // don't update children if its a layer..\n    if (!container.renderGroup)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            updateTransformAndChildren(children[i], updateTick, updateFlags);\n        }\n\n        const renderGroup = container.parentRenderGroup;\n        const renderable = container as ViewContainer;\n\n        if (renderable.renderPipeId && !renderGroup.structureDidChange)\n        {\n            renderGroup.updateRenderable(renderable);\n        }\n    }\n}\n\nfunction updateColorBlendVisibility(\n    container: Container,\n    parent: Container,\n    updateFlags: number,\n): void\n{\n    if (updateFlags & UPDATE_COLOR)\n    {\n        container.groupColor = multiplyColors(\n            container.localColor,\n            parent.groupColor\n        );\n\n        let groupAlpha = container.localAlpha * parent.groupAlpha;\n\n        // eslint-disable-next-line no-nested-ternary\n        groupAlpha = groupAlpha < 0 ? 0 : (groupAlpha > 1 ? 1 : groupAlpha);\n\n        container.groupAlpha = groupAlpha;\n        container.groupColorAlpha = container.groupColor + (((groupAlpha * 255) | 0) << 24);\n    }\n\n    if (updateFlags & UPDATE_BLEND)\n    {\n        container.groupBlendMode = container.localBlendMode === 'inherit' ? parent.groupBlendMode : container.localBlendMode;\n    }\n\n    if (updateFlags & UPDATE_VISIBLE)\n    {\n        container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n    }\n\n    container._updateFlags = 0;\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 884, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/scene/container/utils/validateRenderables.ts"],"sourcesContent":["import type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\n/**\n * @param renderGroup\n * @param renderPipes\n * @internal\n */\nexport function validateRenderables(renderGroup: RenderGroup, renderPipes: RenderPipes): boolean\n{\n    const { list } = renderGroup.childrenRenderablesToUpdate;\n\n    let rebuildRequired = false;\n\n    for (let i = 0; i < renderGroup.childrenRenderablesToUpdate.index; i++)\n    {\n        const container = list[i];\n\n        // note to self: there is no need to check if container.parentRenderGroup || !container.renderGroup\n        // exist here, as this function is only called if the structure did NOT change\n        // which means they have to be valid if this function is called\n\n        const renderable = container;\n        const pipe = renderPipes[renderable.renderPipeId as keyof RenderPipes] as RenderPipe<any>;\n\n        rebuildRequired = pipe.validateRenderable(container);\n\n        if (rebuildRequired)\n        {\n            break;\n        }\n    }\n\n    renderGroup.structureDidChange = rebuildRequired;\n\n    return rebuildRequired;\n}\n"],"names":[],"mappings":";;;;;AASgB,SAAA,mBAAA,CAAoB,WAAA,EAA0B,WAC9D,EAAA;IACU,MAAA,EAAE,IAAK,EAAA,GAAI,WAAY,CAAA,2BAAA,CAAA;IAE7B,IAAI,eAAkB,GAAA,KAAA,CAAA;IAEtB,IAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,WAAY,CAAA,2BAAA,CAA4B,KAAA,EAAO,CACnE,EAAA,CAAA;QACU,MAAA,SAAA,GAAY,IAAA,CAAK,CAAC,CAAA,CAAA;QAMxB,MAAM,UAAa,GAAA,SAAA,CAAA;QACb,MAAA,IAAA,GAAO,WAAY,CAAA,UAAA,CAAW,YAAiC,CAAA,CAAA;QAEnD,eAAA,GAAA,IAAA,CAAK,kBAAA,CAAmB,SAAS,CAAA,CAAA;QAEnD,IAAI,eACJ,EAAA;YACI,MAAA;QAAA,CACJ;IAAA,CACJ;IAEA,WAAA,CAAY,kBAAqB,GAAA,eAAA,CAAA;IAE1B,OAAA,eAAA,CAAA;AACX"}},
    {"offset": {"line": 910, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/scene/container/RenderGroupSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { Bounds } from './bounds/Bounds';\nimport { clearList } from './utils/clearList';\nimport { executeInstructions } from './utils/executeInstructions';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms';\nimport { validateRenderables } from './utils/validateRenderables';\n\nimport type { WebGPURenderer } from '../../rendering/renderers/gpu/WebGPURenderer';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer, RenderPipes } from '../../rendering/renderers/types';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Container } from './Container';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @internal\n */\nexport class RenderGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected render({ container, transform }: {container: Container, transform: Matrix}): void\n    {\n        // we need to save the parent and renderGroupParent, so we can restore them later\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n\n        // we set the transforms and parents to null, so we can render the container without any transforms\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n\n        const renderer = this._renderer;\n\n        // collect all the renderGroups in the scene and then render them one by one..\n        const originalLocalTransform: Matrix = tempMatrix;\n\n        if (transform)\n        {\n            originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n\n        //  this._assignTop(container.renderGroup, null);\n        const renderPipes = (renderer as WebGPURenderer).renderPipes;\n\n        this._updateCachedRenderGroups(container.renderGroup, null);\n\n        this._updateRenderGroups(container.renderGroup);\n\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(container.renderGroup, renderPipes);\n\n        // TODO need to add some events / runners for things like this to hook up to\n        if (renderPipes.uniformBatch)\n        {\n            renderPipes.uniformBatch.renderEnd();\n        }\n\n        // now return the transforms back to normal..\n        if (transform)\n        {\n            container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        }\n\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n\n    private _updateCachedRenderGroups(renderGroup: RenderGroup, closestCacheAsTexture: RenderGroup | null): void\n    {\n        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            // Early out as nothing further needs to be updated!\n            if (!renderGroup.textureNeedsUpdate) return;\n\n            closestCacheAsTexture = renderGroup;\n        }\n\n        // Update the closest cache reference for children if this render group is cached as texture\n        for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--)\n        {\n            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n        }\n\n        renderGroup.invalidateMatrices();\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            if (renderGroup.textureNeedsUpdate)\n            {\n                // lets get the texture ready for rendering\n                // but the rendering will not happen until the renderGroup is rendered!\n                // We also want to know now, what the bounds of the texture will be.\n                // as if the texture changes, we need to invalidate the parent render group!\n                const bounds = renderGroup.root.getLocalBounds();\n\n                bounds.ceil();\n\n                const lastTexture = renderGroup.texture;\n\n                if (renderGroup.texture)\n                {\n                    TexturePool.returnTexture(renderGroup.texture, true);\n                }\n\n                const renderer = this._renderer;\n                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n                const scaleMode = renderGroup.textureOptions.scaleMode ?? 'linear';\n                const texture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    resolution,\n                    antialias\n                );\n\n                texture._source.style = new TextureStyle({ scaleMode });\n                renderGroup.texture = texture;\n                renderGroup._textureBounds ||= new Bounds();\n                renderGroup._textureBounds.copyFrom(bounds);\n\n                if (lastTexture !== renderGroup.texture)\n                {\n                    if (renderGroup.renderGroupParent)\n                    {\n                        renderGroup.renderGroupParent.structureDidChange = true;\n                    }\n                }\n            }\n        }\n        else if (renderGroup.texture)\n        {\n            TexturePool.returnTexture(renderGroup.texture, true);\n            renderGroup.texture = null;\n        }\n    }\n\n    private _updateRenderGroups(renderGroup: RenderGroup): void\n    {\n        const renderer = this._renderer;\n        const renderPipes = renderer.renderPipes;\n\n        renderGroup.runOnRender(renderer);\n\n        renderGroup.instructionSet.renderPipes = renderPipes;\n\n        if (!renderGroup.structureDidChange)\n        {\n            // phase 1 - validate all the renderables\n            validateRenderables(renderGroup, renderPipes);\n        }\n        else\n        {\n            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n        }\n\n        // phase 2 - update all the transforms\n        // including updating the renderables..\n        updateRenderGroupTransforms(renderGroup);\n\n        if (renderGroup.structureDidChange)\n        {\n            renderGroup.structureDidChange = false;\n\n            // build the renderables\n            this._buildInstructions(renderGroup, renderer);\n        }\n        else\n        {\n            // update remaining renderables\n            this._updateRenderables(renderGroup);\n        }\n\n        // reset the renderables to update\n        renderGroup.childrenRenderablesToUpdate.index = 0;\n\n        // upload all the things!\n        renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n\n        // early out if it's a texture and it hasn't changed!\n        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n        }\n    }\n\n    private _updateRenderables(renderGroup: RenderGroup)\n    {\n        const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n        for (let i = 0; i < index; i++)\n        {\n            const container = list[i];\n\n            if (container.didViewUpdate)\n            {\n                renderGroup.updateRenderable(container as ViewContainer);\n            }\n        }\n\n        clearList(list, index);\n    }\n\n    /**\n     * @param renderGroup\n     * @param renderPipes\n     * @deprecated since 8.3.0\n     */\n    private _buildInstructions(renderGroup: RenderGroup, renderPipes: RenderPipes): void;\n    private _buildInstructions(renderGroup: RenderGroup, renderer: Renderer): void;\n    private _buildInstructions(renderGroup: RenderGroup, rendererOrPipes: RenderPipes | Renderer): void\n    {\n    // rebuild the scene graph based on layers...\n        const root = renderGroup.root;\n        const instructionSet = renderGroup.instructionSet;\n\n        instructionSet.reset();\n\n        // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n        const renderer = (rendererOrPipes as Renderer).renderPipes\n            ? (rendererOrPipes as Renderer)\n            : (rendererOrPipes as RenderPipes).batch.renderer;\n        const renderPipes = renderer.renderPipes;\n\n        // TODO add some events / runners for build start\n        renderPipes.batch.buildStart(instructionSet);\n        renderPipes.blendMode.buildStart();\n        renderPipes.colorMask.buildStart();\n\n        if (root.sortableChildren)\n        {\n            root.sortChildren();\n        }\n\n        root.collectRenderablesWithEffects(instructionSet, renderer, null);\n\n        // TODO add some events / runners for build end\n        renderPipes.batch.buildEnd(instructionSet);\n        renderPipes.blendMode.buildEnd(instructionSet);\n    }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1074, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/scene/sprite/SpritePipe.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { BatchableSprite } from './BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { Sprite } from './Sprite';\n\n/** @internal */\nexport class SpritePipe implements RenderPipe<Sprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'sprite',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: Sprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        // TODO visibility\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: Sprite)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: Sprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture)\n        ;\n    }\n\n    private _updateBatchableSprite(sprite: Sprite, batchableSprite: BatchableSprite)\n    {\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: Sprite): BatchableSprite\n    {\n        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: Sprite): BatchableSprite\n    {\n        const batchableSprite = new BatchableSprite();\n\n        batchableSprite.renderable = sprite;\n\n        batchableSprite.transform = sprite.groupTransform;\n        batchableSprite.texture = sprite._texture;\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        sprite._gpuData[this._renderer.uid] = batchableSprite;\n\n        return batchableSprite;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AASO,MAAM,UACb,CAAA;IAaI,YAAY,QACZ,CAAA;QACI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEO,aAAA,CAAc,MAAA,EAAgB,cACrC,EAAA;QACU,MAAA,SAAA,GAAY,IAAK,CAAA,aAAA,CAAc,MAAM,CAAA,CAAA;QAE3C,IAAI,MAAO,CAAA,aAAA,EAAoB,IAAA,CAAA,sBAAA,CAAuB,QAAQ,SAAS,CAAA,CAAA;QAGvE,IAAA,CAAK,SAAU,CAAA,WAAA,CAAY,KAAM,CAAA,UAAA,CAAW,WAAW,cAAc,CAAA,CAAA;IAAA,CACzE;IAEO,iBAAiB,MACxB,EAAA;QACU,MAAA,SAAA,GAAY,IAAK,CAAA,aAAA,CAAc,MAAM,CAAA,CAAA;QAE3C,IAAI,MAAO,CAAA,aAAA,EAAoB,IAAA,CAAA,sBAAA,CAAuB,QAAQ,SAAS,CAAA,CAAA;QAE7D,SAAA,CAAA,QAAA,CAAS,aAAA,CAAc,SAAS,CAAA,CAAA;IAAA,CAC9C;IAEO,mBAAmB,MAC1B,EAAA;QACU,MAAA,SAAA,GAAY,IAAK,CAAA,aAAA,CAAc,MAAM,CAAA,CAAA;QAEpC,OAAA,CAAC,UAAU,QAAS,CAAA,qBAAA,CACvB,SAAA,EACA,MAAO,CAAA,QAAA;IAAQ,CAEvB;IAEQ,sBAAA,CAAuB,MAAA,EAAgB,eAC/C,EAAA;QACI,eAAA,CAAgB,MAAA,GAAS,MAAO,CAAA,YAAA,CAAA;QAChC,eAAA,CAAgB,OAAA,GAAU,MAAO,CAAA,QAAA,CAAA;IAAA,CACrC;IAEQ,cAAc,MACtB,EAAA;QACW,OAAA,MAAA,CAAO,QAAA,CAAS,IAAK,CAAA,SAAA,CAAU,GAAG,CAAK,IAAA,IAAA,CAAK,cAAA,CAAe,MAAM,CAAA,CAAA;IAAA,CAC5E;IAEQ,eAAe,MACvB,EAAA;QACU,MAAA,eAAA,GAAkB,IAAI,2LAAgB,EAAA,CAAA;QAE5C,eAAA,CAAgB,UAAa,GAAA,MAAA,CAAA;QAE7B,eAAA,CAAgB,SAAA,GAAY,MAAO,CAAA,cAAA,CAAA;QACnC,eAAA,CAAgB,OAAA,GAAU,MAAO,CAAA,QAAA,CAAA;QACjC,eAAA,CAAgB,MAAA,GAAS,MAAO,CAAA,YAAA,CAAA;QAChC,eAAA,CAAgB,WAAe,GAAA,IAAA,CAAK,SAAU,CAAA,YAAA,GAAe,MAAO,CAAA,YAAA,CAAA;QAEpE,MAAA,CAAO,QAAS,CAAA,IAAA,CAAK,SAAU,CAAA,GAAG,CAAI,GAAA,eAAA,CAAA;QAE/B,OAAA,eAAA,CAAA;IAAA,CACX;IAEO,OACP,GAAA;QACI,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;IAAA,CACrB;AACJ,CAAA;AAAA,YAAA,GA/Ea,UAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,UAAA;QACd,+KAAc,CAAA,WAAA;QACd,+KAAc,CAAA,WAAA;KAClB;IACA,IAAM,EAAA,QAAA;AACV,CAAA"}},
    {"offset": {"line": 1136, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/batcher/shared/BatcherPipe.ts"],"sourcesContent":["import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { DefaultBatcher } from './DefaultBatcher';\n\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Renderer } from '../../renderers/types';\nimport type { Batch, BatchableElement, Batcher } from './Batcher';\n\n/** @internal */\nexport interface BatcherAdaptor\n{\n    start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    init?(batchPipe: BatcherPipe): void;\n    execute(batchPipe: BatcherPipe, batch: Batch): void\n    contextChange?(): void;\n}\n\n/**\n * A pipe that batches elements into batches and sends them to the renderer.\n *\n * You can install new Batchers using ExtensionType.Batcher. Each render group will\n * have a default batcher and any required ones will be created on demand.\n * @category rendering\n * @advanced\n */\nexport class BatcherPipe implements InstructionPipe<Batch>, BatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'batch',\n    } as const;\n\n    public state: State = State.for2d();\n    public renderer: Renderer;\n\n    private readonly _batchersByInstructionSet: Record<number, Record<string, Batcher>> = Object.create(null);\n\n    private _adaptor: BatcherAdaptor;\n\n    /** A record of all active batchers, keyed by their names */\n    private _activeBatches: Record<string, Batcher> = Object.create(null);\n\n    /** The currently active batcher being used to batch elements */\n    private _activeBatch: Batcher;\n\n    public static _availableBatchers: Record<string, new () => Batcher> = Object.create(null);\n\n    public static getBatcher(name: string): Batcher\n    {\n        return new this._availableBatchers[name as keyof typeof this._availableBatchers]();\n    }\n\n    constructor(renderer: Renderer, adaptor: BatcherAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init?.(this);\n    }\n\n    public buildStart(instructionSet: InstructionSet)\n    {\n        let batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        if (!batchers)\n        {\n            batchers = this._batchersByInstructionSet[instructionSet.uid] = Object.create(null);\n            batchers.default ||= new DefaultBatcher({\n                maxTextures: this.renderer.limits.maxBatchableTextures,\n            });\n        }\n\n        this._activeBatches = batchers;\n\n        this._activeBatch = this._activeBatches.default;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].begin();\n        }\n    }\n\n    public addToBatch(batchableObject: BatchableElement, instructionSet: InstructionSet)\n    {\n        if (this._activeBatch.name !== batchableObject.batcherName)\n        {\n            this._activeBatch.break(instructionSet);\n\n            let batch = this._activeBatches[batchableObject.batcherName];\n\n            if (!batch)\n            {\n                batch = this._activeBatches[batchableObject.batcherName]\n                    = BatcherPipe.getBatcher(batchableObject.batcherName);\n                batch.begin();\n            }\n\n            this._activeBatch = batch;\n        }\n\n        this._activeBatch.add(batchableObject);\n    }\n\n    public break(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n    }\n\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n\n        const batches = this._activeBatches;\n\n        for (const i in batches)\n        {\n            const batch = batches[i as keyof typeof batches];\n            const geometry = batch.geometry;\n\n            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n\n            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n        }\n    }\n\n    public upload(instructionSet: InstructionSet)\n    {\n        const batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        for (const i in batchers)\n        {\n            const batcher = batchers[i as keyof typeof batchers];\n            const geometry = batcher.geometry;\n\n            if (batcher.dirty)\n            {\n                batcher.dirty = false;\n\n                geometry.buffers[0].update(batcher.attributeSize * 4);\n            }\n        }\n    }\n\n    public execute(batch: Batch)\n    {\n        if (batch.action === 'startBatch')\n        {\n            const batcher = batch.batcher;\n            const geometry = batcher.geometry;\n            const shader = batcher.shader;\n\n            this._adaptor.start(this, geometry, shader);\n        }\n\n        this._adaptor.execute(this, batch);\n    }\n\n    public destroy()\n    {\n        this.state = null;\n        this.renderer = null;\n\n        this._adaptor = null;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].destroy();\n        }\n\n        this._activeBatches = null;\n    }\n}\n\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\n\nextensions.add(DefaultBatcher);\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1246, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/Filter.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/filters/Filter.ts"],"sourcesContent":["import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader';\nimport { State } from '../rendering/renderers/shared/state/State';\n\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type {\n    IShaderWithResources,\n    ShaderFromResources,\n    ShaderWithResources\n} from '../rendering/renderers/shared/shader/Shader';\nimport type { BLEND_MODES } from '../rendering/renderers/shared/state/const';\nimport type { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport type { FilterSystem } from './FilterSystem';\n\n/**\n * The options to use when creating a new filter.\n * @category filters\n * @advanced\n */\nexport interface FilterOptions\n{\n    /** optional blend mode used by the filter when rendering (defaults to 'normal') */\n    blendMode?: BLEND_MODES;\n    /**\n     * the resolution the filter should be rendered at. The lower the resolution, the more performant\n     * the filter will be, but the lower the quality of the output. (default 1)\n     * If 'inherit', the resolution of the render target is used.\n     * Consider lowering this for things like blurs filters\n     */\n    resolution?: number | 'inherit';\n    /**\n     * the amount of pixels to pad the container with when applying the filter. For example a blur extends the\n     * container out as it blurs, so padding is applied to ensure that extra detail is rendered as well\n     * without clipping occurring. (default 0)\n     */\n    padding?: number;\n    /**\n     * If true the filter will make use of antialiasing. Although it looks better this can have a performance impact.\n     * If set to 'inherit', the filter will detect the antialiasing of the render target and change this automatically.\n     * Definitely don't set this to true if the render target has antialiasing set to false. As it will antialias,\n     * but you won't see the difference. (default 'off')\n     *\n     * This can be a boolean or [FilterAntialias]{@link FilterAntialias} string.\n     */\n    antialias?: FilterAntialias | boolean;\n    /**\n     * If this is set to true, the filter system will grab a snap shot of the area being rendered\n     * to and pass this into the shader. This is useful for blend modes that need to be aware of the pixels\n     * they are rendering to. Only use if you need that data, otherwise its an extra gpu copy you don't need!\n     * (default false)\n     *\n     * If given, the shader should have a uniform named `uBackTexture`, which is where the pixels of the\n     * area being rendered to can be sampled from.\n     */\n    blendRequired?: boolean;\n    /**\n     * If this is set to true, the filter system will clip filter texture into viewport\n     * This is useful for filters that applied to whole texture.\n     * (default true)\n     */\n    clipToViewport?: boolean;\n}\n\n/**\n * Filter options mixed with shader resources. A filter needs a shader and some resources to work.\n * @category filters\n * @advanced\n * @see {@link FilterOptions}\n */\nexport type FilterWithShader = FilterOptions & IShaderWithResources;\n\n/**\n * The antialiasing mode of the filter. This can be either:\n * - `on` - the filter is always antialiased regardless of the render target settings\n * - `off` - (default) the filter is never antialiased regardless of the render target settings\n * - `inherit` - the filter uses the antialias settings of the render target\n * @category filters\n * @advanced\n */\nexport type FilterAntialias = 'on' | 'off' | 'inherit';\n\n/**\n * The Filter class is the base for all filter effects used in Pixi.js\n * As it extends a shader, it requires that a glProgram is parsed in to work with WebGL and a gpuProgram for WebGPU.\n * If you don't proved one, then the filter is skipped and just rendered as if it wasn't there for that renderer.\n *\n * A filter can be applied to anything that extends Container in Pixi.js which also includes Sprites, Graphics etc.\n *\n * Its worth noting Performance-wise filters can be pretty expensive if used too much in a single scene.\n * The following happens under the hood when a filter is applied:\n *\n * .1. Break the current batch\n * <br>\n * .2. The target is measured using getGlobalBounds\n * (recursively go through all children and figure out how big the object is)\n * <br>\n * .3. Get the closest Po2 Textures from the texture pool\n * <br>\n * .4. Render the target to that texture\n * <br>\n * .5. Render that texture back to the main frame buffer as a quad using the filters program.\n * <br>\n * <br>\n * Some filters (such as blur) require multiple passes too which can result in an even bigger performance hit. So be careful!\n * Its not generally the complexity of the shader that is the bottle neck,\n * but all the framebuffer / shader switching that has to take place.\n * One filter applied to a container with many objects is MUCH faster than many filter applied to many objects.\n * @category filters\n * @advanced\n * @example\n * import { Filter } from 'pixi.js';\n *\n * const customFilter = new Filter({\n *     glProgram: new GlProgram({\n *         fragment,\n *         vertex,\n *     }),\n *     resources: {\n *         timeUniforms: {\n *             uTime: { value: 0.0, type: 'f32' },\n *         },\n *     },\n * });\n *\n * // Apply the filter\n * sprite.filters = [customFilter];\n *\n * // Update uniform\n * app.ticker.add((ticker) => {\n *     filter.resources.timeUniforms.uniforms.uTime += 0.04 * ticker.deltaTime;\n * });\n */\nexport class Filter extends Shader\n{\n    /** The default filter settings */\n    public static defaultOptions: FilterOptions = {\n        blendMode: 'normal',\n        resolution: 1,\n        padding: 0,\n        antialias: 'off',\n        blendRequired: false,\n        clipToViewport: true,\n    };\n\n    /**\n     * The padding of the filter. Some filters require extra space to breath such as a blur.\n     * Increasing this will add extra width and height to the bounds of the object that the\n     * filter is applied to.\n     * @default 0\n     */\n    public padding: number;\n\n    /**\n     * should the filter use antialiasing?\n     * @default inherit\n     */\n    public antialias: FilterAntialias;\n\n    /** If enabled is true the filter is applied, if false it will not. */\n    public enabled = true;\n\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     */\n    public _state = State.for2d();\n\n    /**\n     * The resolution of the filter. Setting this to be lower will lower the quality but\n     * increase the performance of the filter.\n     * @default 1\n     */\n    public resolution: number | 'inherit';\n\n    /**\n     * Whether or not this filter requires the previous render texture for blending.\n     * @default false\n     */\n    public blendRequired: boolean;\n\n    /**\n     * Clip texture into viewport or not\n     * @default true\n     */\n    public clipToViewport: boolean;\n\n    /**\n     * @param options - The optional parameters of this filter.\n     */\n    constructor(options: FilterWithShader)\n    {\n        options = { ...Filter.defaultOptions, ...options };\n\n        super(options as ShaderWithResources);\n\n        this.blendMode = options.blendMode;\n        this.padding = options.padding;\n\n        // check if is boolean\n        if (typeof options.antialias === 'boolean')\n        {\n            this.antialias = options.antialias ? 'on' : 'off';\n        }\n        else\n        {\n            this.antialias = options.antialias;\n        }\n\n        this.resolution = options.resolution;\n        this.blendRequired = options.blendRequired;\n        this.clipToViewport = options.clipToViewport;\n\n        // this is where the filter system will attach the filter texture\n        this.addResource('uTexture', 0, 1);\n\n        if (options.blendRequired)\n        {\n            // this is where the filter system will attach the back texture\n            this.addResource('uBackTexture', 0, 3);\n        }\n    }\n\n    /**\n     * Applies the filter\n     * @param filterManager - The renderer to retrieve the filter from\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Get the blend mode of the filter.\n     * @default \"normal\"\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._state.blendMode;\n    }\n\n    /** Sets the blend mode of the filter. */\n    set blendMode(value: BLEND_MODES)\n    {\n        this._state.blendMode = value;\n    }\n\n    /**\n     * A short hand function to create a filter based of a vertex and fragment shader src.\n     * @param options\n     * @returns A shiny new PixiJS filter!\n     */\n    public static from(options: FilterOptions & ShaderFromResources): Filter\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Filter({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAqIO,MAAM,OAAA,GAAN,MAAM,OAAA,SAAe,oMAC5B,CAAA;IAAA;;GAAA,GAwDI,YAAY,OACZ,CAAA;QACI,OAAA,GAAU;YAAE,GAAG,OAAO,CAAA,cAAA;YAAgB,GAAG,OAAQ;QAAA,CAAA,CAAA;QAEjD,KAAA,CAAM,OAA8B,CAAA,CAAA;QAlCxC,oEAAA,GAAA,IAAA,CAAO,OAAU,GAAA,IAAA,CAAA;QAMjB;;;KAAA,GAAO,IAAA,CAAA,MAAA,GAAS,iMAAA,CAAM,KAAM,EAAA,CAAA;QA8BxB,IAAA,CAAK,SAAA,GAAY,OAAQ,CAAA,SAAA,CAAA;QACzB,IAAA,CAAK,OAAA,GAAU,OAAQ,CAAA,OAAA,CAAA;QAGnB,IAAA,OAAO,OAAQ,CAAA,SAAA,KAAc,SACjC,EAAA;YACS,IAAA,CAAA,SAAA,GAAY,OAAQ,CAAA,SAAA,GAAY,IAAO,GAAA,KAAA,CAAA;QAAA,CAGhD,MAAA;YACI,IAAA,CAAK,SAAA,GAAY,OAAQ,CAAA,SAAA,CAAA;QAAA,CAC7B;QAEA,IAAA,CAAK,UAAA,GAAa,OAAQ,CAAA,UAAA,CAAA;QAC1B,IAAA,CAAK,aAAA,GAAgB,OAAQ,CAAA,aAAA,CAAA;QAC7B,IAAA,CAAK,cAAA,GAAiB,OAAQ,CAAA,cAAA,CAAA;QAGzB,IAAA,CAAA,WAAA,CAAY,UAAY,EAAA,CAAA,EAAG,CAAC,CAAA,CAAA;QAEjC,IAAI,QAAQ,aACZ,EAAA;YAES,IAAA,CAAA,WAAA,CAAY,cAAgB,EAAA,CAAA,EAAG,CAAC,CAAA,CAAA;QAAA,CACzC;IAAA,CACJ;IAAA;;;;;;GAAA,GASO,KACH,CAAA,aAAA,EACA,KACA,EAAA,MAAA,EACA,SAEJ,EAAA;QACI,aAAA,CAAc,WAAY,CAAA,IAAA,EAAM,KAAO,EAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;IAAA,CAC5D;IAAA;;;GAAA,GAMA,IAAI,SACJ,GAAA;QACI,OAAO,IAAA,CAAK,MAAO,CAAA,SAAA,CAAA;IAAA,CACvB;IAAA,uCAAA,GAGA,IAAI,UAAU,KACd,EAAA;QACI,IAAA,CAAK,MAAA,CAAO,SAAY,GAAA,KAAA,CAAA;IAAA,CAC5B;IAAA;;;;GAAA,GAOA,OAAc,KAAK,OACnB,EAAA;QACI,MAAM,EAAE,GAAA,EAAK,EAAI,EAAA,GAAG,MAAS,GAAA,OAAA,CAAA;QAEzB,IAAA,UAAA,CAAA;QACA,IAAA,SAAA,CAAA;QAEJ,IAAI,GACJ,EAAA;YACiB,UAAA,GAAA,yMAAA,CAAW,IAAA,CAAK,GAAG,CAAA,CAAA;QAAA,CACpC;QAEA,IAAI,EACJ,EAAA;YACgB,SAAA,GAAA,sMAAA,CAAU,IAAA,CAAK,EAAE,CAAA,CAAA;QAAA,CACjC;QAEA,OAAO,IAAI,OAAO,CAAA;YACd,UAAA;YACA,SAAA;YACA,GAAG,IAAA;QAAA,CACN,CAAA,CAAA;IAAA,CACL;AACJ,CAAA,CAAA;AAAA,gCAAA,GAtJa,OAAA,CAGK,cAAgC,GAAA;IAC1C,SAAW,EAAA,QAAA;IACX,UAAY,EAAA,CAAA;IACZ,OAAS,EAAA,CAAA;IACT,SAAW,EAAA,KAAA;IACX,aAAe,EAAA,KAAA;IACf,cAAgB,EAAA,IAAA;AACpB,CAAA,CAAA;AAVG,IAAM,MAAN,GAAA"}},
    {"offset": {"line": 1342, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/mask/mask.frag.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 1353, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/mask/mask.vert.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 1364, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":""}},
    {"offset": {"line": 1375, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/filters/mask/MaskFilter.ts"],"sourcesContent":["import { Matrix } from '../../maths/matrix/Matrix';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix';\nimport { Filter } from '../Filter';\nimport fragment from './mask.frag';\nimport vertex from './mask.vert';\nimport source from './mask.wgsl';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Sprite } from '../../scene/sprite/Sprite';\nimport type { FilterOptions } from '../Filter';\nimport type { FilterSystem } from '../FilterSystem';\n\n/** @internal */\nexport interface MaskFilterOptions extends FilterOptions\n{\n    sprite: Sprite,\n    inverse?: boolean;\n    scale?: number | { x: number, y: number },\n}\n\n/** @internal */\nexport class MaskFilter extends Filter\n{\n    public sprite: Sprite;\n    private readonly _textureMatrix: TextureMatrix;\n\n    constructor(options: MaskFilterOptions)\n    {\n        const { sprite, ...rest } = options;\n\n        const textureMatrix = new TextureMatrix(sprite.texture);\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uMaskClamp: { value: textureMatrix.uClampFrame, type: 'vec4<f32>' },\n            uAlpha: { value: 1, type: 'f32' },\n            uInverse: { value: options.inverse ? 1 : 0, type: 'f32' },\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'mask-filter',\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            clipToViewport: false,\n            resources: {\n                filterUniforms,\n                uMaskTexture: sprite.texture.source,\n            },\n        });\n\n        this.sprite = sprite;\n\n        this._textureMatrix = textureMatrix;\n    }\n\n    set inverse(value: boolean)\n    {\n        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n    }\n\n    get inverse(): boolean\n    {\n        return this.resources.filterUniforms.uniforms.uInverse === 1;\n    }\n\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        // will trigger an update if the texture changed..\n        this._textureMatrix.texture = this.sprite.texture;\n\n        filterManager.calculateSpriteMatrix(\n            this.resources.filterUniforms.uniforms.uFilterMatrix as Matrix,\n            this.sprite\n        ).prepend(this._textureMatrix.mapCoord);\n\n        this.resources.uMaskTexture = this.sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAwBO,MAAM,mBAAmB,iKAChC,CAAA;IAII,YAAY,OACZ,CAAA;QACI,MAAM,EAAE,MAAA,EAAQ,GAAG,IAAA,EAAS,GAAA,OAAA,CAAA;QAE5B,MAAM,aAAgB,GAAA,IAAI,mNAAc,CAAA,MAAA,CAAO,OAAO,CAAA,CAAA;QAEhD,MAAA,cAAA,GAAiB,IAAI,gNAAa,CAAA;YACpC,eAAe;gBAAE,KAAA,EAAO,IAAI,yKAAO,EAAA;gBAAG,MAAM,aAAc;YAAA,CAAA;YAC1D,YAAY;gBAAE,KAAA,EAAO,aAAc,CAAA,WAAA;gBAAa,MAAM,WAAY;YAAA,CAAA;YAClE,MAAQ,EAAA;gBAAE,KAAO,EAAA,CAAA;gBAAG,MAAM,KAAM;YAAA,CAAA;YAChC,QAAA,EAAU;gBAAE,KAAO,EAAA,OAAA,CAAQ,OAAA,GAAU,CAAI,GAAA,CAAA;gBAAG,MAAM,KAAM;YAAA,CAAA;QAAA,CAC3D,CAAA,CAAA;QAEK,MAAA,UAAA,GAAa,yMAAA,CAAW,IAAK,CAAA;YAC/B,MAAQ,EAAA;wBACJ,gLAAA;gBACA,UAAY,EAAA,YAAA;YAAA,CAChB;YACA,QAAU,EAAA;wBACN,gLAAA;gBACA,UAAY,EAAA,cAAA;YAAA,CAChB;QAAA,CACH,CAAA,CAAA;QAEK,MAAA,SAAA,GAAY,sMAAA,CAAU,IAAK,CAAA;oBAC7B,gLAAA;sBACA,gLAAA;YACA,IAAM,EAAA,aAAA;QAAA,CACT,CAAA,CAAA;QAEK,KAAA,CAAA;YACF,GAAG,IAAA;YACH,UAAA;YACA,SAAA;YACA,cAAgB,EAAA,KAAA;YAChB,SAAW,EAAA;gBACP,cAAA;gBACA,YAAA,EAAc,OAAO,OAAQ,CAAA,MAAA;YAAA,CACjC;QAAA,CACH,CAAA,CAAA;QAED,IAAA,CAAK,MAAS,GAAA,MAAA,CAAA;QAEd,IAAA,CAAK,cAAiB,GAAA,aAAA,CAAA;IAAA,CAC1B;IAEA,IAAI,QAAQ,KACZ,EAAA;QACI,IAAA,CAAK,SAAU,CAAA,cAAA,CAAe,QAAS,CAAA,QAAA,GAAW,QAAQ,CAAI,GAAA,CAAA,CAAA;IAAA,CAClE;IAEA,IAAI,OACJ,GAAA;QACI,OAAO,IAAK,CAAA,SAAA,CAAU,cAAe,CAAA,QAAA,CAAS,QAAa,KAAA,CAAA,CAAA;IAAA,CAC/D;IAEO,KACH,CAAA,aAAA,EACA,KACA,EAAA,MAAA,EACA,SAEJ,EAAA;QAES,IAAA,CAAA,cAAA,CAAe,OAAU,GAAA,IAAA,CAAK,MAAO,CAAA,OAAA,CAAA;QAE5B,aAAA,CAAA,qBAAA,CACV,IAAA,CAAK,SAAU,CAAA,cAAA,CAAe,QAAS,CAAA,aAAA,EACvC,IAAK,CAAA,MAAA,EACP,OAAA,CAAQ,IAAK,CAAA,cAAA,CAAe,QAAQ,CAAA,CAAA;QAEtC,IAAA,CAAK,SAAU,CAAA,YAAA,GAAe,IAAK,CAAA,MAAA,CAAO,OAAQ,CAAA,MAAA,CAAA;QAElD,aAAA,CAAc,WAAY,CAAA,IAAA,EAAM,KAAO,EAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;IAAA,CAC5D;AACJ"}},
    {"offset": {"line": 1467, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/mask/alpha/AlphaMaskPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter';\nimport { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../renderers/types';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { RenderTarget } from '../../renderers/shared/renderTarget/RenderTarget';\nimport type { Renderer } from '../../renderers/types';\nimport type { AlphaMask } from './AlphaMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nconst tempBounds = new Bounds();\n\n/** @internal */\nclass AlphaMaskEffect extends FilterEffect implements PoolItem\n{\n    constructor()\n    {\n        super();\n\n        this.filters = [new MaskFilter({\n            sprite: new Sprite(Texture.EMPTY),\n            inverse: false,\n            resolution: 'inherit',\n            antialias: 'inherit'\n        })];\n    }\n\n    get sprite(): Sprite\n    {\n        return (this.filters[0] as MaskFilter).sprite;\n    }\n\n    set sprite(value: Sprite)\n    {\n        (this.filters[0] as MaskFilter).sprite = value;\n    }\n\n    get inverse(): boolean\n    {\n        return (this.filters[0] as MaskFilter).inverse;\n    }\n\n    set inverse(value: boolean)\n    {\n        (this.filters[0] as MaskFilter).inverse = value;\n    }\n\n    public init: () => void;\n}\n\n/** @internal */\nexport interface AlphaMaskInstruction extends Instruction\n{\n    renderPipeId: 'alphaMask',\n    action: MaskMode,\n    mask: AlphaMask,\n    inverse: boolean;\n    maskedContainer: Container,\n    renderMask: boolean,\n}\n\n/** @internal */\nexport interface AlphaMaskData\n{\n    filterEffect: AlphaMaskEffect,\n    maskedContainer: Container,\n    previousRenderTarget?: RenderTarget,\n    filterTexture?: Texture,\n}\n\n/** @internal */\nexport class AlphaMaskPipe implements InstructionPipe<AlphaMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'alphaMask',\n    } as const;\n\n    private _renderer: Renderer;\n    private _activeMaskStage: AlphaMaskData[] = [];\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n            maskedContainer\n        } as AlphaMaskInstruction);\n\n        (mask as AlphaMask).inverse = maskedContainer._maskOptions.inverse;\n\n        if ((mask as AlphaMask).renderMaskToTexture)\n        {\n            const maskContainer = (mask as AlphaMask).mask;\n\n            maskContainer.includeInBuild = true;\n\n            maskContainer.collectRenderables(\n                instructionSet,\n                renderer,\n                null\n            );\n\n            maskContainer.includeInBuild = false;\n        }\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskEnd',\n            mask,\n            maskedContainer,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public pop(mask: Effect, _maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'popMaskEnd',\n            mask,\n            inverse: _maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public execute(instruction: AlphaMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderMask = instruction.mask.renderMaskToTexture;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            const filterEffect = BigPool.get(AlphaMaskEffect);\n\n            filterEffect.inverse = instruction.inverse;\n\n            if (renderMask)\n            {\n                instruction.mask.mask.measurable = true;\n\n                const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n\n                instruction.mask.mask.measurable = false;\n\n                bounds.ceil();\n\n                const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n                const filterTexture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    colorTextureSource._resolution,\n                    colorTextureSource.antialias\n                );\n\n                renderer.renderTarget.push(filterTexture, true);\n\n                renderer.globalUniforms.push({\n                    offset: bounds,\n                    worldColor: 0xFFFFFFFF\n                });\n\n                const sprite = filterEffect.sprite;\n\n                sprite.texture = filterTexture;\n\n                sprite.worldTransform.tx = bounds.minX;\n                sprite.worldTransform.ty = bounds.minY;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                    filterTexture,\n                });\n            }\n            else\n            {\n                filterEffect.sprite = instruction.mask.mask as Sprite;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                });\n            }\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n\n            if (renderMask)\n            {\n                // WebGPU blit's automatically, but WebGL does not!\n                if (renderer.type === RendererType.WEBGL)\n                {\n                    renderer.renderTarget.finishRenderPass();\n                }\n\n                renderer.renderTarget.pop();\n                renderer.globalUniforms.pop();\n            }\n\n            renderer.filter.push({\n                renderPipeId: 'filter',\n                action: 'pushFilter',\n                container: maskData.maskedContainer,\n                filterEffect: maskData.filterEffect,\n                canBundle: false,\n            });\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.filter.pop();\n\n            const maskData = this._activeMaskStage.pop();\n\n            if (renderMask)\n            {\n                TexturePool.returnTexture(maskData.filterTexture);\n            }\n\n            BigPool.return(maskData.filterEffect);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._activeMaskStage = null;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1640, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/mask/color/ColorMaskPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../renderers/types';\nimport type { ColorMask } from './ColorMask';\n\n/** @internal */\nexport interface ColorMaskInstruction extends Instruction\n{\n    renderPipeId: 'colorMask',\n    colorMask: number,\n}\n\n/** @internal */\nexport class ColorMaskPipe implements InstructionPipe<ColorMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private _colorStack: number[] = [];\n    private _colorStackIndex = 0;\n    private _currentColor = 0;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public buildStart()\n    {\n        this._colorStack[0] = 0xF;\n        this._colorStackIndex = 1;\n        this._currentColor = 0xF;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & (mask as ColorMask).mask;\n\n        const currentColor = this._colorStack[this._colorStackIndex];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n\n        this._colorStackIndex++;\n    }\n\n    public pop(_mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        this._colorStackIndex--;\n\n        const currentColor = colorStack[this._colorStackIndex - 1];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n    }\n\n    public execute(instruction: ColorMaskInstruction)\n    {\n        const renderer = this._renderer;\n\n        renderer.colorMask.setMask(instruction.colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorStack = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAkBO,MAAM,aACb,CAAA;IAgBI,YAAY,QACZ,CAAA;QALA,IAAA,CAAQ,WAAA,GAAwB,EAAC,CAAA;QACjC,IAAA,CAAQ,gBAAmB,GAAA,CAAA,CAAA;QAC3B,IAAA,CAAQ,aAAgB,GAAA,CAAA,CAAA;QAIpB,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEO,UACP,GAAA;QACS,IAAA,CAAA,WAAA,CAAY,CAAC,CAAI,GAAA,EAAA,CAAA;QACtB,IAAA,CAAK,gBAAmB,GAAA,CAAA,CAAA;QACxB,IAAA,CAAK,aAAgB,GAAA,EAAA,CAAA;IAAA,CACzB;IAEO,IAAA,CAAK,IAAc,EAAA,UAAA,EAAuB,cACjD,EAAA;QACI,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;QAEb,QAAA,CAAA,WAAA,CAAY,KAAM,CAAA,KAAA,CAAM,cAAc,CAAA,CAAA;QAE/C,MAAM,aAAa,IAAK,CAAA,WAAA,CAAA;QAEb,UAAA,CAAA,IAAA,CAAK,gBAAgB,CAAI,GAAA,UAAA,CAAW,IAAA,CAAK,gBAAmB,GAAA,CAAC,CAAA,GAAK,IAAmB,CAAA,IAAA,CAAA;QAEhG,MAAM,YAAe,GAAA,IAAA,CAAK,WAAY,CAAA,IAAA,CAAK,gBAAgB,CAAA,CAAA;QAEvD,IAAA,YAAA,KAAiB,IAAA,CAAK,aAC1B,EAAA;YACI,IAAA,CAAK,aAAgB,GAAA,YAAA,CAAA;YACrB,cAAA,CAAe,GAAI,CAAA;gBACf,YAAc,EAAA,WAAA;gBACd,SAAW,EAAA,YAAA;gBACX,SAAW,EAAA,KAAA;YAAA,CACU,CAAA,CAAA;QAAA,CAC7B;QAEK,IAAA,CAAA,gBAAA,EAAA,CAAA;IAAA,CACT;IAEO,GAAA,CAAI,KAAe,EAAA,UAAA,EAAuB,cACjD,EAAA;QACI,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;QAEb,QAAA,CAAA,WAAA,CAAY,KAAM,CAAA,KAAA,CAAM,cAAc,CAAA,CAAA;QAE/C,MAAM,aAAa,IAAK,CAAA,WAAA,CAAA;QAEnB,IAAA,CAAA,gBAAA,EAAA,CAAA;QAEL,MAAM,YAAe,GAAA,UAAA,CAAW,IAAK,CAAA,gBAAA,GAAmB,CAAC,CAAA,CAAA;QAErD,IAAA,YAAA,KAAiB,IAAA,CAAK,aAC1B,EAAA;YACI,IAAA,CAAK,aAAgB,GAAA,YAAA,CAAA;YAErB,cAAA,CAAe,GAAI,CAAA;gBACf,YAAc,EAAA,WAAA;gBACd,SAAW,EAAA,YAAA;gBACX,SAAW,EAAA,KAAA;YAAA,CACU,CAAA,CAAA;QAAA,CAC7B;IAAA,CACJ;IAEO,QAAQ,WACf,EAAA;QACI,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;QAEb,QAAA,CAAA,SAAA,CAAU,OAAQ,CAAA,WAAA,CAAY,SAAS,CAAA,CAAA;IAAA,CACpD;IAEO,OACP,GAAA;QACK,IAAA,CAAK,SAAqB,GAAA,IAAA,CAAA;QAC3B,IAAA,CAAK,WAAc,GAAA,IAAA,CAAA;IAAA,CACvB;AACJ,CAAA;AAAA,YAAA,GA1Fa,aAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,UAAA;QACd,+KAAc,CAAA,WAAA;QACd,+KAAc,CAAA,WAAA;KAClB;IACA,IAAM,EAAA,WAAA;AACV,CAAA"}},
    {"offset": {"line": 1713, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/mask/stencil/StencilMaskPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { CLEAR } from '../../renderers/gl/const';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../renderers/shared/Renderable';\nimport type { Renderer } from '../../renderers/types';\nimport type { StencilMask } from './StencilMask';\n\n/** @internal */\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\n/** @internal */\nexport interface StencilMaskInstruction extends Instruction\n{\n    renderPipeId: 'stencilMask',\n    action: MaskMode,\n    inverse: boolean,\n    mask: StencilMask,\n}\n\n/** @internal */\nexport class StencilMaskPipe implements InstructionPipe<StencilMaskInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'stencilMask',\n    } as const;\n\n    private _renderer: Renderer;\n\n    // used when building and also when executing..\n    private _maskStackHash: Record<number, number> = {};\n\n    private _maskHash = new WeakMap<StencilMask, {\n        instructionsStart: number,\n        instructionsLength: number,\n    }>();\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskContainer = effect.mask;\n\n        maskContainer.includeInBuild = true;\n\n        if (!this._maskHash.has(effect))\n        {\n            this._maskHash.set(effect, {\n                instructionsStart: 0,\n                instructionsLength: 0,\n            });\n        }\n\n        const maskData = this._maskHash.get(effect);\n\n        maskData.instructionsStart = instructionSet.instructionSize;\n\n        maskContainer.collectRenderables(\n            instructionSet,\n            renderer,\n            null\n        );\n\n        maskContainer.includeInBuild = false;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskEnd',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n\n        maskData.instructionsLength = instructionsLength;\n\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        this._maskStackHash[renderTargetUid] ??= 0;\n    }\n\n    public pop(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        // stencil is stored based on current render target..\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskBegin',\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskData = this._maskHash.get(mask as StencilMask);\n\n        for (let i = 0; i < maskData.instructionsLength; i++)\n        {\n            // eslint-disable-next-line max-len\n            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n        }\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskEnd',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: StencilMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        let maskStackIndex = this._maskStackHash[renderTargetUid] ??= 0;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            // we create the depth and stencil buffers JIT\n            // as no point allocating the memory if we don't use it\n            renderer.renderTarget.ensureDepthStencil();\n\n            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n\n            maskStackIndex++;\n\n            renderer.colorMask.setMask(0);\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n        else if (instruction.action === 'popMaskBegin')\n        {\n            renderer.colorMask.setMask(0);\n\n            if (maskStackIndex !== 0)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.renderTarget.clear(null, CLEAR.STENCIL);\n                renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n            }\n\n            maskStackIndex--;\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n\n        this._maskStackHash[renderTargetUid] = maskStackIndex;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n        this._maskStackHash = null;\n        this._maskHash = null;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1846, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/background/BackgroundSystem.ts"],"sourcesContent":["import { Color } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { System } from '../system/System';\n/**\n * Options for the background system.\n * @category rendering\n * @advanced\n */\nexport interface BackgroundSystemOptions\n{\n    /**\n     * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n     * @default 'black'\n     */\n    backgroundColor: ColorSource;\n    /** Alias for `backgroundColor` */\n    background?: ColorSource\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * This value determines whether the canvas is initialized with alpha transparency support.\n     * Note: This cannot be changed after initialization. If set to `1`, the canvas will remain opaque,\n     * even if a transparent background color is set later.\n     * @default 1\n     */\n    backgroundAlpha?: number;\n    /**\n     * Whether to clear the canvas before new render passes.\n     * @default true\n     */\n    clearBeforeRender?: boolean;\n}\n\n/**\n * The background system manages the background color and alpha of the main view.\n * @category rendering\n * @advanced\n */\nexport class BackgroundSystem implements System<BackgroundSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'background',\n        priority: 0,\n    } as const;\n\n    /** default options used by the system */\n    public static defaultOptions: BackgroundSystemOptions = {\n        /**\n         * {@link WebGLOptions.backgroundAlpha}\n         * @default 1\n         */\n        backgroundAlpha: 1,\n        /**\n         * {@link WebGLOptions.backgroundColor}\n         * @default 0x000000\n         */\n        backgroundColor: 0x0,\n        /**\n         * {@link WebGLOptions.clearBeforeRender}\n         * @default true\n         */\n        clearBeforeRender: true,\n    };\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every\n     * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect\n     * to clear the canvas every frame. Disable this by setting this to false. For example, if\n     * your game has a canvas filling background image you often don't need this set.\n     */\n    public clearBeforeRender: boolean;\n\n    private readonly _backgroundColor: Color;\n\n    constructor()\n    {\n        this.clearBeforeRender = true;\n\n        this._backgroundColor = new Color(0x000000);\n\n        this.color = this._backgroundColor; // run bg color setter\n        this.alpha = 1;\n    }\n\n    /**\n     * initiates the background system\n     * @param options - the options for the background colors\n     */\n    public init(options: BackgroundSystemOptions): void\n    {\n        options = { ...BackgroundSystem.defaultOptions, ...options };\n\n        this.clearBeforeRender = options.clearBeforeRender;\n        this.color = options.background || options.backgroundColor || this._backgroundColor; // run bg color setter\n        this.alpha = options.backgroundAlpha;\n\n        this._backgroundColor.setAlpha(options.backgroundAlpha);\n    }\n\n    /** The background color to fill if not transparent */\n    get color(): Color\n    {\n        return this._backgroundColor;\n    }\n\n    set color(value: ColorSource)\n    {\n        // #if _DEBUG\n\n        const incoming = Color.shared.setValue(value);\n\n        if (incoming.alpha < 1 && this._backgroundColor.alpha === 1)\n        {\n            warn(\n                'Cannot set a transparent background on an opaque canvas. '\n                + 'To enable transparency, set backgroundAlpha < 1 when initializing your Application.'\n            );\n        }\n        // #endif\n        this._backgroundColor.setValue(value);\n    }\n\n    /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n    get alpha(): number\n    {\n        return this._backgroundColor.alpha;\n    }\n\n    set alpha(value: number)\n    {\n        this._backgroundColor.setAlpha(value);\n    }\n\n    /** The background color as an [R, G, B, A] array. */\n    get colorRgba(): RgbaArray\n    {\n        return this._backgroundColor.toArray() as RgbaArray;\n    }\n\n    /**\n     * destroys the background system\n     * @internal\n     */\n    public destroy(): void\n    {\n        // No cleanup required\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAwCO,MAAM,iBAAA,GAAN,MAAM,iBACb,CAAA;IA0CI,WACA,EAAA;QACI,IAAA,CAAK,iBAAoB,GAAA,IAAA,CAAA;QAEpB,IAAA,CAAA,gBAAA,GAAmB,IAAI,6JAAA,CAAM,CAAQ,CAAA,CAAA;QAE1C,IAAA,CAAK,KAAA,GAAQ,IAAK,CAAA,gBAAA,CAAA;QAClB,IAAA,CAAK,KAAQ,GAAA,CAAA,CAAA;IAAA,CACjB;IAAA;;;GAAA,GAMO,KAAK,OACZ,EAAA;QACI,OAAA,GAAU;YAAE,GAAG,iBAAiB,CAAA,cAAA;YAAgB,GAAG,OAAQ;QAAA,CAAA,CAAA;QAE3D,IAAA,CAAK,iBAAA,GAAoB,OAAQ,CAAA,iBAAA,CAAA;QACjC,IAAA,CAAK,KAAQ,GAAA,OAAA,CAAQ,UAAc,IAAA,OAAA,CAAQ,eAAA,IAAmB,IAAK,CAAA,gBAAA,CAAA;QACnE,IAAA,CAAK,KAAA,GAAQ,OAAQ,CAAA,eAAA,CAAA;QAEhB,IAAA,CAAA,gBAAA,CAAiB,QAAS,CAAA,OAAA,CAAQ,eAAe,CAAA,CAAA;IAAA,CAC1D;IAAA,oDAAA,GAGA,IAAI,KACJ,GAAA;QACI,OAAO,IAAK,CAAA,gBAAA,CAAA;IAAA,CAChB;IAEA,IAAI,MAAM,KACV,EAAA;QAGI,MAAM,QAAW,GAAA,6JAAA,CAAM,MAAO,CAAA,QAAA,CAAS,KAAK,CAAA,CAAA;QAE5C,IAAI,SAAS,KAAQ,GAAA,CAAA,IAAK,IAAK,CAAA,gBAAA,CAAiB,KAAA,KAAU,CAC1D,EAAA;gBACI,sKAAA,EACI,8IAAA;QAEJ,CACJ;QAEK,IAAA,CAAA,gBAAA,CAAiB,QAAA,CAAS,KAAK,CAAA,CAAA;IAAA,CACxC;IAAA,oFAAA,GAGA,IAAI,KACJ,GAAA;QACI,OAAO,IAAA,CAAK,gBAAiB,CAAA,KAAA,CAAA;IAAA,CACjC;IAEA,IAAI,MAAM,KACV,EAAA;QACS,IAAA,CAAA,gBAAA,CAAiB,QAAA,CAAS,KAAK,CAAA,CAAA;IAAA,CACxC;IAAA,mDAAA,GAGA,IAAI,SACJ,GAAA;QACW,OAAA,IAAA,CAAK,gBAAA,CAAiB,OAAQ,EAAA,CAAA;IAAA,CACzC;IAAA;;;GAAA,GAMO,OACP,GAAA,CAAA,CAEA;AACJ,CAAA,CAAA;AAAA,YAAA,GApHa,iBAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,WAAA;QACd,+KAAc,CAAA,YAAA;QACd,+KAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,YAAA;IACN,QAAU,EAAA,CAAA;AACd,CAAA,CAAA;AAAA,uCAAA,GAXS,iBAAA,CAcK,cAA0C,GAAA;IAAA;;;GAAA,GAKpD,eAAiB,EAAA,CAAA;IAAA;;;GAAA,GAKjB,eAAiB,EAAA,CAAA;IAAA;;;GAAA,GAKjB,iBAAmB,EAAA,IAAA;AACvB,CAAA,CAAA;AA9BG,IAAM,gBAAN,GAAA"}},
    {"offset": {"line": 1931, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/blendModes/BlendModePipe.ts"],"sourcesContent":["import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { FilterEffect } from '../../../../filters/FilterEffect';\nimport { RenderGroup } from '../../../../scene/container/RenderGroup';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { BlendModeFilter } from '../../../../filters/blend-modes/BlendModeFilter';\nimport type { FilterInstruction } from '../../../../filters/FilterSystem';\nimport type { Renderer } from '../../types';\nimport type { Instruction } from '../instructions/Instruction';\nimport type { InstructionSet } from '../instructions/InstructionSet';\nimport type { InstructionPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { BLEND_MODES } from '../state/const';\n\ninterface AdvancedBlendInstruction extends Instruction\n{\n    renderPipeId: 'blendMode',\n    blendMode: BLEND_MODES,\n    activeBlend: Renderable[],\n}\n\n// class map\nconst BLEND_MODE_FILTERS: Partial<Record<BLEND_MODES, new () => BlendModeFilter>> = {} as const;\n\nextensions.handle(ExtensionType.BlendMode, (value) =>\n{\n    if (!value.name)\n    {\n        throw new Error('BlendMode extension must have a name property');\n    }\n    BLEND_MODE_FILTERS[value.name as BLEND_MODES] = value.ref;\n}, (value) =>\n{\n    delete BLEND_MODE_FILTERS[value.name as BLEND_MODES];\n});\n\n/**\n * This Pipe handles the blend mode switching of the renderer.\n * It will insert instructions into the {@link InstructionSet} to switch the blend mode according to the\n * blend modes of the scene graph.\n *\n * This pipe is were wwe handle Advanced blend modes. Advanced blend modes essentially wrap the renderables\n * in a filter that applies the blend mode.\n *\n * You only need to use this class if you are building your own render instruction set rather than letting PixiJS build\n * the instruction set for you by traversing the scene graph\n * @category rendering\n * @internal\n */\nexport class BlendModePipe implements InstructionPipe<AdvancedBlendInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'blendMode',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _renderableList?: Renderable[];\n    private _activeBlendMode: BLEND_MODES;\n    private readonly _blendModeStack: BLEND_MODES[] = [];\n\n    private _isAdvanced = false;\n\n    private _filterHash: Partial<Record<BLEND_MODES, FilterEffect>> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.prerender.add(this);\n    }\n\n    public prerender()\n    {\n        // make sure we reset the blend modes to normal\n        // this way the next render will register any changes\n        this._activeBlendMode = 'normal';\n        this._isAdvanced = false;\n    }\n\n    /**\n     * Push a blend mode onto the internal stack and apply it to the instruction set if needed.\n     * @param renderable - The renderable or {@link RenderGroup} associated with the change.\n     * @param blendMode - The blend mode to activate.\n     * @param instructionSet - The instruction set being built.\n     */\n    public pushBlendMode(renderable: Renderable | RenderGroup, blendMode: BLEND_MODES, instructionSet: InstructionSet): void\n    {\n        this._blendModeStack.push(blendMode);\n\n        this.setBlendMode(renderable, blendMode, instructionSet);\n    }\n\n    /**\n     * Pop the last blend mode from the stack and apply the new top-of-stack mode.\n     * @param instructionSet - The instruction set being built.\n     */\n    public popBlendMode(instructionSet: InstructionSet): void\n    {\n        this._blendModeStack.pop();\n        const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? 'normal';\n\n        this.setBlendMode(null, blendMode, instructionSet);\n    }\n\n    /**\n     * Ensure a blend mode switch is added to the instruction set when the mode changes.\n     * If an advanced blend mode is active, subsequent renderables will be collected so they can be\n     * rendered within a single filter pass.\n     * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.\n     * @param blendMode - The target blend mode.\n     * @param instructionSet - The instruction set being built.\n     */\n    public setBlendMode(\n        renderable: Renderable | RenderGroup | null,\n        blendMode: BLEND_MODES,\n        instructionSet: InstructionSet\n    )\n    {\n        const isRenderGroup = renderable instanceof RenderGroup;\n\n        if (this._activeBlendMode === blendMode)\n        {\n            if (this._isAdvanced && renderable && !isRenderGroup)\n            {\n                this._renderableList?.push(renderable);\n            }\n\n            return;\n        }\n\n        if (this._isAdvanced) this._endAdvancedBlendMode(instructionSet);\n\n        this._activeBlendMode = blendMode;\n\n        if (!renderable) return;\n\n        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n\n        if (this._isAdvanced) this._beginAdvancedBlendMode(renderable, instructionSet);\n    }\n\n    private _beginAdvancedBlendMode(renderable: Renderable | RenderGroup, instructionSet: InstructionSet)\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        const blendMode = this._activeBlendMode;\n\n        if (!BLEND_MODE_FILTERS[blendMode])\n        {\n            // #if _DEBUG\n            warn(`Unable to assign BlendMode: '${blendMode}'. `\n                + `You may want to include: import 'pixi.js/advanced-blend-modes'`);\n            // #endif\n\n            return;\n        }\n\n        const filterEffect = this._ensureFilterEffect(blendMode);\n        const isRenderGroup = renderable instanceof RenderGroup;\n        const instruction: FilterInstruction = {\n            renderPipeId: 'filter',\n            action: 'pushFilter',\n            filterEffect,\n            renderables: isRenderGroup ? null : [renderable],\n            container: isRenderGroup ? renderable.root : null,\n            canBundle: false\n        };\n\n        this._renderableList = instruction.renderables;\n\n        instructionSet.add(instruction);\n    }\n\n    private _ensureFilterEffect(blendMode: BLEND_MODES): FilterEffect\n    {\n        let filterEffect: FilterEffect = this._filterHash[blendMode];\n\n        if (!filterEffect)\n        {\n            filterEffect = this._filterHash[blendMode] = new FilterEffect();\n            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS]()];\n        }\n\n        return filterEffect;\n    }\n\n    private _endAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._isAdvanced = false;\n        this._renderableList = null;\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    /**\n     * called when the instruction build process is starting this will reset internally to the default blend mode\n     * @internal\n     */\n    public buildStart()\n    {\n        this._isAdvanced = false;\n    }\n\n    /**\n     * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n     * active, we add the final render instructions added to the instruction set\n     * @param instructionSet - The instruction set we are adding to\n     * @internal\n     */\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        if (!this._isAdvanced) return;\n\n        this._endAdvancedBlendMode(instructionSet);\n    }\n\n    /** @internal */\n    public destroy()\n    {\n        this._renderer = null;\n        this._renderableList = null;\n\n        for (const i in this._filterHash)\n        {\n            this._filterHash[i as BLEND_MODES].destroy();\n        }\n\n        this._filterHash = null;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2083, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/extract/ExtractSystem.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Container } from '../../../../scene/container/Container';\nimport { Texture } from '../texture/Texture';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { GetPixelsOutput } from '../texture/GenerateCanvas';\nimport type { GenerateTextureOptions } from './GenerateTextureSystem';\n\nconst imageTypes = {\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    webp: 'image/webp',\n};\n\ntype Formats = keyof typeof imageTypes;\n\n/**\n * Options for creating an image from a renderer.\n * Controls the output format and quality of extracted images.\n * @example\n * ```ts\n * // Extract as PNG (default)\n * const pngImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png'\n * });\n *\n * // Extract as JPEG with quality setting\n * const jpgImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'jpg',\n *     quality: 0.8\n * });\n *\n * // Extract as WebP for better compression\n * const webpImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'webp',\n *     quality: 0.9\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport interface ImageOptions\n{\n    /**\n     * The format of the extracted image.\n     * - 'png': Lossless format, best for images with text or sharp edges\n     * - 'jpg': Lossy format, smaller file size, good for photos\n     * - 'webp': Modern format with better compression\n     * @example\n     * ```ts\n     * // Extract as PNG\n     * const pngImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'png'\n     * });\n     * // Extract as JPEG\n     * const jpgImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'jpg',\n     * });\n     * ```\n     * @default 'png'\n     */\n    format?: Formats;\n\n    /**\n     * The quality of the extracted image, between 0 and 1.\n     * Only applies to lossy formats (jpg, webp).\n     * - 1: Maximum quality\n     * - 0: Maximum compression\n     * @example\n     * ```ts\n     * // Extract as JPEG with 80% quality\n     * const jpgImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'jpg',\n     *     quality: 0.8\n     * });\n     * // Extract as WebP with 90% quality\n     * const webpImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'webp',\n     *     quality: 0.9\n     * });\n     * ```\n     * @default 1\n     */\n    quality?: number;\n}\n\n/**\n * Options for extracting content from a renderer.\n * These options control how content is extracted and processed from the renderer.\n * @example\n * ```ts\n * // Basic extraction\n * const pixels = renderer.extract.pixels({\n *     target: sprite,\n * });\n *\n * // Extract with custom region and resolution\n * const canvas = renderer.extract.canvas({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2,\n * });\n *\n * // Extract with background color and anti-aliasing\n * const image = await renderer.extract.image({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport interface BaseExtractOptions\n{\n    /**\n     * The target to extract. Can be a Container or Texture.\n     * @example\n     * ```ts\n     * // Extract from a sprite\n     * const sprite = new Sprite(texture);\n     * renderer.extract.pixels({ target: sprite });\n     *\n     * // Extract from a texture directly\n     * renderer.extract.pixels({ target: texture });\n     * ```\n     */\n    target: Container | Texture;\n\n    /**\n     * The region of the target to extract. If not specified, extracts the entire target.\n     * @example\n     * ```ts\n     * // Extract a specific region\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     frame: new Rectangle(10, 10, 100, 100)\n     * });\n     * ```\n     */\n    frame?: Rectangle;\n\n    /**\n     * The resolution of the extracted content. Higher values create sharper images.\n     * @default 1\n     * @example\n     * ```ts\n     * // Extract at 2x resolution for retina displays\n     * renderer.extract.image({\n     *     target: sprite,\n     *     resolution: 2\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * The color used to clear the extracted content before rendering.\n     * Can be a hex number, string, or array of numbers.\n     * @example\n     * ```ts\n     * // Clear with red background\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Clear with semi-transparent black\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     clearColor: [0, 0, 0, 0.5]\n     * });\n     * ```\n     */\n    clearColor?: ColorSource;\n\n    /**\n     * Whether to enable anti-aliasing during extraction.\n     * Improves quality but may affect performance.\n     * @default false\n     * @example\n     * ```ts\n     * // Enable anti-aliasing for smoother edges\n     * renderer.extract.image({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     */\n    antialias?: boolean;\n}\n/**\n * Options for extracting an HTMLImage from the renderer.\n * Combines base extraction options with image-specific settings.\n * @example\n * ```ts\n * // Basic PNG extraction\n * const image = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png'\n * });\n *\n * // High-quality JPEG with custom region\n * const image = await renderer.extract.image({\n *     target: container,\n *     format: 'jpg',\n *     quality: 0.9,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // WebP with background and anti-aliasing\n * const image = await renderer.extract.image({\n *     target: graphics,\n *     format: 'webp',\n *     quality: 0.8,\n *     clearColor: '#ff0000',\n *     antialias: true\n * });\n * ```\n *\n * Combines all options from:\n * - {@link BaseExtractOptions} for basic extraction settings\n * - {@link ImageOptions} for image format and quality settings\n *\n * Common use cases:\n * - Capturing game screenshots\n * - Saving rendered content\n * - Creating image thumbnails\n * - Exporting canvas content\n * @see {@link ExtractSystem.image} For the method that uses these options\n * @see {@link ExtractSystem.base64} For base64 encoding\n * @category rendering\n * @advanced\n * @interface\n */\nexport type ExtractImageOptions = BaseExtractOptions & ImageOptions;\n/**\n * Options for extracting and downloading content from a renderer.\n * Combines base extraction options with download-specific settings.\n * @example\n * ```ts\n * // Basic download with default filename\n * renderer.extract.download({\n *     target: sprite\n * });\n *\n * // Download with custom filename and region\n * renderer.extract.download({\n *     target: container,\n *     filename: 'screenshot.png',\n *     frame: new Rectangle(0, 0, 100, 100)\n * });\n *\n * // Download with high resolution and background\n * renderer.extract.download({\n *     target: stage,\n *     filename: 'hd-capture.png',\n *     resolution: 2,\n *     clearColor: '#ff0000'\n * });\n *\n * // Download with anti-aliasing\n * renderer.extract.download({\n *     target: graphics,\n *     filename: 'smooth.png',\n *     antialias: true\n * });\n * ```\n *\n * Combines all options from:\n * - {@link BaseExtractOptions} for basic extraction settings\n * - Additional download-specific options\n *\n * Common use cases:\n * - Saving game screenshots\n * - Exporting rendered content\n * - Creating downloadable assets\n * - Saving canvas state\n * @see {@link ExtractSystem.download} For the method that uses these options\n * @see {@link ExtractSystem.image} For creating images without download\n * @category rendering\n * @advanced\n * @interface\n */\nexport type ExtractDownloadOptions = BaseExtractOptions & {\n    /**\n     * The filename to use when downloading the content.\n     * Should include the desired file extension (e.g., .png).\n     * @default 'image.png'\n     * @example\n     * ```ts\n     * renderer.extract.download({\n     *     target: sprite,\n     *     filename: 'my-screenshot.png'\n     * });\n     * ```\n     */\n    filename: string;\n};\n/**\n * Options for extracting content from a renderer. Represents a union of all possible extraction option types.\n * Used by various extraction methods to support different output formats and configurations.\n * @example\n * ```ts\n * // Basic canvas extraction\n * const canvas = renderer.extract.canvas({\n *     target: sprite\n * });\n *\n * // Image extraction with format\n * const image = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png',\n *     quality: 1\n * });\n *\n * // Download with filename\n * renderer.extract.download({\n *     target: sprite,\n *     filename: 'screenshot.png'\n * });\n *\n * // Advanced extraction with multiple options\n * const image = await renderer.extract.image({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     format: 'webp',\n *     quality: 0.8\n * });\n * ```\n *\n * Supports three types of options:\n * - {@link BaseExtractOptions} - Basic extraction settings\n * - {@link ExtractImageOptions} - Image-specific settings with format and quality\n * - {@link ExtractDownloadOptions} - Download settings with filename\n *\n * Common use cases:\n * - Extracting raw pixels\n * - Creating canvas elements\n * - Generating downloadable images\n * - Taking screenshots\n * - Creating thumbnails\n * @see {@link ExtractSystem.canvas} For canvas extraction\n * @see {@link ExtractSystem.image} For image extraction\n * @see {@link ExtractSystem.download} For downloading content\n * @category rendering\n * @advanced\n */\nexport type ExtractOptions = BaseExtractOptions | ExtractImageOptions | ExtractDownloadOptions;\n\n/**\n * System for exporting content from a renderer. It provides methods to extract content as images,\n * canvases, or raw pixel data. Available through `renderer.extract`.\n * @example\n * ```ts\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application\n * const app = new Application();\n * await app.init();\n *\n * // Draw something to extract\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill(0xFF0000);\n *\n * // Basic extraction examples\n * const image = await app.renderer.extract.image(graphics);    // As IImage (HTMLImageElement)\n * const canvas = app.renderer.extract.canvas(graphics);        // As Canvas\n * const pixels = app.renderer.extract.pixels(graphics);        // As pixel data\n * const base64 = await app.renderer.extract.base64(graphics); // As base64 string\n *\n * // Advanced extraction with options\n * const customImage = await app.renderer.extract.image({\n *     target: graphics,\n *     format: 'png',\n *     resolution: 2,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     clearColor: '#00000000'\n * });\n *\n * // Download content\n * app.renderer.extract.download({\n *     target: graphics,\n *     filename: 'my-image.png'\n * });\n *\n * // Debug visualization\n * app.renderer.extract.log(graphics);\n * ```\n *\n * Features:\n * - Extract as various formats (PNG, JPEG, WebP)\n * - Control output quality and resolution\n * - Extract specific regions\n * - Download extracted content\n * - Debug visualization\n *\n * Common Use Cases:\n * - Creating thumbnails\n * - Saving game screenshots\n * - Processing visual content\n * - Debugging renders\n * - Creating textures from rendered content\n *\n * Performance Considerations:\n * - Extraction operations are relatively expensive\n * - Consider caching results for frequently used content\n * - Be mindful of resolution and format choices\n * - Large extractions may impact performance\n * @category rendering\n * @standard\n */\nexport class ExtractSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'extract',\n    } as const;\n\n    /**\n     * Default options for image extraction.\n     * @example\n     * ```ts\n     * // Customize default options\n     * ExtractSystem.defaultImageOptions.format = 'webp';\n     * ExtractSystem.defaultImageOptions.quality = 0.8;\n     *\n     * // Use defaults\n     * const image = await renderer.extract.image(sprite);\n     * ```\n     */\n    public static defaultImageOptions: ImageOptions = {\n        format: 'png' as Formats,\n        quality: 1,\n    };\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    private _normalizeOptions<T extends ExtractOptions>(\n        options: ExtractImageOptions | Container | Texture,\n        defaults: Partial<T> = {},\n    ): T\n    {\n        if (options instanceof Container || options instanceof Texture)\n        {\n            return {\n                target: options,\n                ...defaults\n            } as T;\n        }\n\n        return {\n            ...defaults,\n            ...options,\n        } as T;\n    }\n\n    /**\n     * Creates an IImage from a display object or texture.\n     * @param options - Options for creating the image, or the target to extract\n     * @returns Promise that resolves with the generated IImage\n     * @example\n     * ```ts\n     * // Basic usage with a sprite\n     * const sprite = new Sprite(texture);\n     * const image = await renderer.extract.image(sprite);\n     * document.body.appendChild(image);\n     *\n     * // Advanced usage with options\n     * const image = await renderer.extract.image({\n     *     target: container,\n     *     format: 'webp',\n     *     quality: 0.8,\n     *     frame: new Rectangle(0, 0, 100, 100),\n     *     resolution: 2,\n     *     clearColor: '#ff0000',\n     *     antialias: true\n     * });\n     *\n     * // Extract directly from a texture\n     * const texture = Texture.from('myTexture.png');\n     * const image = await renderer.extract.image(texture);\n     * ```\n     * @see {@link ExtractImageOptions} For detailed options\n     * @see {@link ExtractSystem.base64} For base64 string output\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ImageLike} For the image interface\n     * @category rendering\n     */\n    public async image(options: ExtractImageOptions | Container | Texture): Promise<ImageLike>\n    {\n        const image = DOMAdapter.get().createImage();\n\n        image.src = await this.base64(options);\n\n        return image;\n    }\n\n    /**\n     * Converts the target into a base64 encoded string.\n     *\n     * This method works by first creating\n     * a canvas using `Extract.canvas` and then converting it to a base64 string.\n     * @param options - The options for creating the base64 string, or the target to extract\n     * @returns Promise that resolves with the base64 encoded string\n     * @example\n     * ```ts\n     * // Basic usage with a sprite\n     * const sprite = new Sprite(texture);\n     * const base64 = await renderer.extract.base64(sprite);\n     * console.log(base64); // data:image/png;base64,...\n     *\n     * // Advanced usage with options\n     * const base64 = await renderer.extract.base64({\n     *     target: container,\n     *     format: 'webp',\n     *     quality: 0.8,\n     *     frame: new Rectangle(0, 0, 100, 100),\n     *     resolution: 2\n     * });\n     * ```\n     * @throws Will throw an error if the platform doesn't support any of:\n     * - ICanvas.toDataURL\n     * - ICanvas.toBlob\n     * - ICanvas.convertToBlob\n     * @see {@link ExtractImageOptions} For detailed options\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ExtractSystem.image} For HTMLImage output\n     * @category rendering\n     */\n    public async base64(options: ExtractImageOptions | Container | Texture): Promise<string>\n    {\n        options = this._normalizeOptions<ExtractImageOptions>(\n            options,\n            ExtractSystem.defaultImageOptions\n        );\n\n        const { format, quality } = options;\n\n        const canvas = this.canvas(options);\n\n        if (canvas.toBlob !== undefined)\n        {\n            return new Promise<string>((resolve, reject) =>\n            {\n                canvas.toBlob!((blob) =>\n                {\n                    if (!blob)\n                    {\n                        reject(new Error('ICanvas.toBlob failed!'));\n\n                        return;\n                    }\n\n                    const reader = new FileReader();\n\n                    reader.onload = () => resolve(reader.result as string);\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }, imageTypes[format], quality);\n            });\n        }\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(imageTypes[format], quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n\n            return new Promise<string>((resolve, reject) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, '\n            + 'or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders the target to it and returns it.\n     * This method is useful for creating static images or when you need direct canvas access.\n     * @param options - The options for creating the canvas, or the target to extract\n     * @returns A Canvas element with the texture rendered on\n     * @example\n     * ```ts\n     * // Basic canvas extraction from a sprite\n     * const sprite = new Sprite(texture);\n     * const canvas = renderer.extract.canvas(sprite);\n     * document.body.appendChild(canvas);\n     *\n     * // Extract with custom region\n     * const canvas = renderer.extract.canvas({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const canvas = renderer.extract.canvas({\n     *     target: sprite,\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Extract directly from a texture\n     * const texture = Texture.from('myTexture.png');\n     * const canvas = renderer.extract.canvas(texture);\n     *\n     * // Extract with anti-aliasing\n     * const canvas = renderer.extract.canvas({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link ExtractSystem.image} For HTMLImage output\n     * @see {@link ExtractSystem.pixels} For raw pixel data\n     * @category rendering\n     */\n    public canvas(options: ExtractOptions | Container | Texture): ICanvas\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n\n        if (target instanceof Texture)\n        {\n            return renderer.texture.generateCanvas(target);\n        }\n\n        const texture = renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const canvas = renderer.texture.generateCanvas(texture);\n\n        texture.destroy(true);\n\n        return canvas;\n    }\n\n    /**\n     * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,\n     * with integer values between 0 and 255 (inclusive).\n     * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA\n     * @param options - The options for extracting the image, or the target to extract\n     * @returns One-dimensional Uint8Array containing the pixel data in RGBA format\n     * @example\n     * ```ts\n     * // Basic pixel extraction\n     * const sprite = new Sprite(texture);\n     * const pixels = renderer.extract.pixels(sprite);\n     * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values\n     *\n     * // Extract with custom region\n     * const pixels = renderer.extract.pixels({\n     *     target: sprite,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const pixels = renderer.extract.pixels({\n     *     target: sprite,\n     *     resolution: 2\n     * });\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ExtractSystem.image} For image output\n     * @category rendering\n     */\n    public pixels(options: ExtractOptions | Container | Texture): GetPixelsOutput\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n        const texture = target instanceof Texture\n            ? target\n            : renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const pixelInfo = renderer.texture.getPixels(texture);\n\n        if (target instanceof Container)\n        {\n            // destroy generated texture\n            texture.destroy(true);\n        }\n\n        return pixelInfo;\n    }\n\n    /**\n     * Creates a texture from a display object or existing texture.\n     *\n     * This is useful for creating\n     * reusable textures from rendered content or making copies of existing textures.\n     * > [!NOTE] The returned texture should be destroyed when no longer needed\n     * @param options - The options for creating the texture, or the target to extract\n     * @returns A new texture containing the extracted content\n     * @example\n     * ```ts\n     * // Basic texture extraction from a sprite\n     * const sprite = new Sprite(texture);\n     * const extractedTexture = renderer.extract.texture(sprite);\n     *\n     * // Extract with custom region\n     * const regionTexture = renderer.extract.texture({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const hiResTexture = renderer.extract.texture({\n     *     target: sprite,\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Create a new sprite from extracted texture\n     * const newSprite = new Sprite(\n     *     renderer.extract.texture({\n     *         target: graphics,\n     *         antialias: true\n     *     })\n     * );\n     *\n     * // Clean up when done\n     * extractedTexture.destroy(true);\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link Texture} For texture management\n     * @see {@link GenerateTextureSystem} For texture generation\n     * @category rendering\n     */\n    public texture(options: ExtractOptions | Container | Texture): Texture\n    {\n        options = this._normalizeOptions(options);\n\n        if (options.target instanceof Texture) return options.target;\n\n        return this._renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n    }\n\n    /**\n     * Extracts and downloads content from the renderer as an image file.\n     * This is a convenient way to save screenshots or export rendered content.\n     * > [!NOTE] The download will use PNG format regardless of the filename extension\n     * @param options - The options for downloading and extracting the image, or the target to extract\n     * @example\n     * ```ts\n     * // Basic download with default filename\n     * const sprite = new Sprite(texture);\n     * renderer.extract.download(sprite); // Downloads as 'image.png'\n     *\n     * // Download with custom filename\n     * renderer.extract.download({\n     *     target: sprite,\n     *     filename: 'screenshot.png'\n     * });\n     *\n     * // Download with custom region\n     * renderer.extract.download({\n     *     target: container,\n     *     filename: 'region.png',\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Download with high resolution and background\n     * renderer.extract.download({\n     *     target: stage,\n     *     filename: 'hd-screenshot.png',\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Download with anti-aliasing\n     * renderer.extract.download({\n     *     target: graphics,\n     *     filename: 'smooth.png',\n     *     antialias: true\n     * });\n     * ```\n     * @see {@link ExtractDownloadOptions} For detailed options\n     * @see {@link ExtractSystem.image} For creating images without download\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @category rendering\n     */\n    public download(options: ExtractDownloadOptions | Container | Texture)\n    {\n        /* eslint-disable no-restricted-globals */\n        options = this._normalizeOptions<ExtractDownloadOptions>(options);\n\n        const canvas = this.canvas(options);\n\n        const link = document.createElement('a');\n\n        link.download = options.filename ?? 'image.png';\n        link.href = canvas.toDataURL('image/png');\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        /* eslint-enable no-restricted-globals */\n    }\n\n    /**\n     * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n     * The image will be displayed in the browser's console using CSS background images.\n     * @param options - The options for logging the image, or the target to log\n     * @param options.width - The width of the logged image preview in the console (in pixels)\n     * @example\n     * ```ts\n     * // Basic usage\n     * const sprite = new Sprite(texture);\n     * renderer.extract.log(sprite);\n     * ```\n     * @see {@link ExtractSystem.canvas} For getting raw canvas output\n     * @see {@link ExtractSystem.pixels} For raw pixel data\n     * @category rendering\n     * @advanced\n     */\n    public log(options: (ExtractOptions & {width?: number}) | Container | Texture)\n    {\n        const width = options.width ?? 200;\n\n        options = this._normalizeOptions(options);\n\n        const canvas = this.canvas(options);\n\n        const base64 = canvas.toDataURL();\n\n        // eslint-disable-next-line no-console\n        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n\n        const style = [\n            'font-size: 1px;',\n            `padding: ${width}px ${300}px;`,\n            `background: url(${base64}) no-repeat;`,\n            'background-size: contain;',\n        ].join(' ');\n\n        // eslint-disable-next-line no-console\n        console.log('%c ', style);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2472, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderTexture.ts"],"sourcesContent":["import { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\n/**\n * A render texture, extends `Texture`.\n * @see {@link Texture}\n * @category rendering\n * @advanced\n */\nexport class RenderTexture extends Texture\n{\n    /**\n     * Creates a RenderTexture. Pass `dynamic: true` in options to allow resizing after creation.\n     * @param options - Options for the RenderTexture, including width, height, and dynamic.\n     * @returns A new RenderTexture instance.\n     * @example\n     * const rt = RenderTexture.create({ width: 100, height: 100, dynamic: true });\n     * rt.resize(500, 500);\n     */\n    public static create(options: TextureSourceOptions): RenderTexture\n    {\n        // Pass dynamic to the RenderTexture constructor if present in options\n        const { dynamic, ...rest } = options;\n\n        return new RenderTexture({\n            source: new TextureSource(rest),\n            dynamic: dynamic ?? false,\n        });\n    }\n\n    /**\n     * Resizes the render texture.\n     * @param width - The new width of the render texture.\n     * @param height - The new height of the render texture.\n     * @param resolution - The new resolution of the render texture.\n     * @returns This texture.\n     */\n    public resize(width: number, height: number, resolution?: number): this\n    {\n        this.source.resize(width, height, resolution);\n\n        return this;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AAWO,MAAM,sBAAsB,uMACnC,CAAA;IAAA;;;;;;;GAAA,GASI,OAAc,OAAO,OACrB,EAAA;QAEI,MAAM,EAAE,OAAA,EAAS,GAAG,IAAA,EAAS,GAAA,OAAA,CAAA;QAE7B,OAAO,IAAI,aAAc,CAAA;YACrB,MAAA,EAAQ,IAAI,8NAAA,CAAc,IAAI,CAAA;YAC9B,SAAS,OAAW,IAAA,KAAA;QAAA,CACvB,CAAA,CAAA;IAAA,CACL;IAAA;;;;;;GAAA,GASO,MAAA,CAAO,KAAe,EAAA,MAAA,EAAgB,UAC7C,EAAA;QACI,IAAA,CAAK,MAAO,CAAA,MAAA,CAAO,KAAO,EAAA,MAAA,EAAQ,UAAU,CAAA,CAAA;QAErC,OAAA,IAAA,CAAA;IAAA,CACX;AACJ"}},
    {"offset": {"line": 2513, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/extract/GenerateTextureSystem.ts"],"sourcesContent":["import { Color, type ColorSource } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds';\nimport { Container } from '../../../../scene/container/Container';\nimport { RenderTexture } from '../texture/RenderTexture';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { TextureSourceOptions } from '../texture/sources/TextureSource';\n\n/**\n * Options for generating a texture source.\n * @category rendering\n * @advanced\n * @interface\n */\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, 'resource' | 'width' | 'height' | 'resolution'>;\n\n/**\n * Options for generating a texture from a container.\n * Used to create reusable textures from display objects, which can improve performance\n * when the same content needs to be rendered multiple times.\n * @example\n * ```ts\n * // Basic texture generation\n * const sprite = new Sprite(texture);\n * const generatedTexture = renderer.generateTexture({\n *     target: sprite\n * });\n *\n * // Generate with custom region and resolution\n * const texture = renderer.generateTexture({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // Generate with background color and anti-aliasing\n * const highQualityTexture = renderer.generateTexture({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     textureSourceOptions: {\n *         scaleMode: 'linear'\n *     }\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport type GenerateTextureOptions = {\n    /**\n     * The container to generate the texture from.\n     * This can be any display object like Sprite, Container, or Graphics.\n     * @example\n     * ```ts\n     * const graphics = new Graphics()\n     *     .circle(0, 0, 50)\n     *     .fill('red');\n     *\n     * const texture = renderer.generateTexture({\n     *     target: graphics\n     * });\n     * ```\n     */\n    target: Container;\n\n    /**\n     * The region of the container that should be rendered.\n     * If not specified, defaults to the local bounds of the container.\n     * @example\n     * ```ts\n     * // Extract only a portion of the container\n     * const texture = renderer.generateTexture({\n     *     target: container,\n     *     frame: new Rectangle(10, 10, 100, 100)\n     * });\n     * ```\n     */\n    frame?: Rectangle;\n\n    /**\n     * The resolution of the texture being generated.\n     * Higher values create sharper textures at the cost of memory.\n     * @default renderer.resolution\n     * @example\n     * ```ts\n     * // Generate a high-resolution texture\n     * const hiResTexture = renderer.generateTexture({\n     *     target: sprite,\n     *     resolution: 2 // 2x resolution\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * The color used to clear the texture before rendering.\n     * Can be a hex number, string, or array of numbers.\n     * @example\n     * ```ts\n     * // Clear with red background\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Clear with semi-transparent black\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     clearColor: [0, 0, 0, 0.5]\n     * });\n     * ```\n     */\n    clearColor?: ColorSource;\n\n    /**\n     * Whether to enable anti-aliasing. This may affect performance.\n     * @default false\n     * @example\n     * ```ts\n     * // Generate a smooth texture\n     * const texture = renderer.generateTexture({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     */\n    antialias?: boolean;\n\n    /**\n     * Advanced options for configuring the texture source.\n     * Controls texture properties like scale mode and filtering.\n     * @advanced\n     * @example\n     * ```ts\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     textureSourceOptions: {\n     *         scaleMode: 'linear',\n     *     }\n     * });\n     * ```\n     */\n    textureSourceOptions?: GenerateTextureSourceOptions;\n};\n\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor: ColorSource = [0, 0, 0, 0];\n\n/**\n * System that manages the generation of textures from display objects in the renderer.\n * This system is responsible for creating reusable textures from containers, sprites, and other display objects.\n * Available through `renderer.textureGenerator`.\n * @example\n * ```ts\n * import { Application, Sprite, Graphics } from 'pixi.js';\n *\n * const app = new Application();\n * await app.init();\n *\n * // Create a complex display object\n * const container = new Container();\n *\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill('red');\n *\n * const sprite = new Sprite(texture);\n * sprite.x = 100;\n *\n * container.addChild(graphics, sprite);\n *\n * // Generate a texture from the container\n * const generatedTexture = app.renderer.textureGenerator.generateTexture({\n *     target: container,\n *     resolution: 2,\n *     antialias: true\n * });\n *\n * // Use the generated texture\n * const newSprite = new Sprite(generatedTexture);\n * app.stage.addChild(newSprite);\n *\n * // Clean up when done\n * generatedTexture.destroy(true);\n * ```\n *\n * Features:\n * - Convert any display object to a texture\n * - Support for custom regions and resolutions\n * - Anti-aliasing support\n * - Background color configuration\n * - Texture source options customization\n *\n * Common Use Cases:\n * - Creating texture atlases dynamically\n * - Caching complex container content\n * - Generating thumbnails\n * - Creating reusable textures from rendered content\n *\n * Performance Considerations:\n * - Generating textures is relatively expensive\n * - Cache results when possible\n * - Be mindful of resolution and size\n * - Clean up unused textures\n * @see {@link GenerateTextureOptions} For detailed texture generation options\n * @see {@link AbstractRenderer.generateTexture} For the main renderer method\n * @see {@link RenderTexture} For the resulting texture type\n * @category rendering\n * @standard\n */\nexport class GenerateTextureSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGenerator',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Creates a texture from a display object that can be used for creating sprites and other textures.\n     * This is particularly useful for optimizing performance when a complex container needs to be reused.\n     * @param options - Generate texture options or a container to convert to texture\n     * @returns A new RenderTexture containing the rendered display object\n     * @example\n     * ```ts\n     * // Basic usage with a container\n     * const container = new Container();\n     * container.addChild(\n     *     new Graphics()\n     *         .circle(0, 0, 50)\n     *         .fill('red')\n     * );\n     *\n     * const texture = renderer.textureGenerator.generateTexture(container);\n     *\n     * // Advanced usage with options\n     * const texture = renderer.textureGenerator.generateTexture({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n     *     resolution: 2,                        // High DPI\n     *     clearColor: '#ff0000',               // Red background\n     *     antialias: true                      // Smooth edges\n     * });\n     *\n     * // Create a sprite from the generated texture\n     * const sprite = new Sprite(texture);\n     *\n     * // Clean up when done\n     * texture.destroy(true);\n     * ```\n     * @see {@link GenerateTextureOptions} For detailed texture generation options\n     * @see {@link RenderTexture} For the type of texture created\n     * @category rendering\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): RenderTexture\n    {\n        if (options instanceof Container)\n        {\n            options = {\n                target: options,\n                frame: undefined,\n                textureSourceOptions: {},\n                resolution: undefined,\n            };\n        }\n\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n\n        const container = options.target;\n\n        let clearColor = options.clearColor;\n\n        if (clearColor)\n        {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n\n            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n        }\n        else\n        {\n            clearColor = noColor;\n        }\n\n        const region = options.frame?.copyTo(tempRect)\n            || getLocalBounds(container, tempBounds).rectangle;\n\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n\n        const target = RenderTexture.create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution,\n            antialias,\n        });\n\n        const transform = Matrix.shared.translate(-region.x, -region.y);\n\n        this._renderer.render({\n            container,\n            transform,\n            target,\n            clearColor,\n        });\n\n        target.source.updateMipmaps();\n\n        return target;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAsJA,MAAM,QAAA,GAAW,IAAI,+KAAU,EAAA,CAAA;AAC/B,MAAM,UAAA,GAAa,IAAI,sLAAO,EAAA,CAAA;AAC9B,MAAM,OAAuB,GAAA;IAAC,CAAG;IAAA,CAAA;IAAG;IAAG,CAAC;CAAA,CAAA;AAgEjC,MAAM,qBACb,CAAA;IAYI,YAAY,QACZ,CAAA;QACI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAAA,GAsCO,gBAAgB,OACvB,EAAA;QACI,IAAI,mBAAmB,kLACvB,EAAA;YACc,OAAA,GAAA;gBACN,MAAQ,EAAA,OAAA;gBACR,KAAO,EAAA,KAAA,CAAA;gBACP,sBAAsB,CAAA,CAAC;gBACvB,UAAY,EAAA,KAAA,CAAA;YAAA,CAChB,CAAA;QAAA,CACJ;QAEA,MAAM,UAAa,GAAA,OAAA,CAAQ,UAAc,IAAA,IAAA,CAAK,SAAU,CAAA,UAAA,CAAA;QACxD,MAAM,SAAY,GAAA,OAAA,CAAQ,SAAa,IAAA,IAAA,CAAK,SAAA,CAAU,IAAK,CAAA,SAAA,CAAA;QAE3D,MAAM,YAAY,OAAQ,CAAA,MAAA,CAAA;QAE1B,IAAI,aAAa,OAAQ,CAAA,UAAA,CAAA;QAEzB,IAAI,UACJ,EAAA;YACI,MAAM,cAAc,KAAM,CAAA,OAAA,CAAQ,UAAU,CAAA,IAAK,WAAW,MAAW,KAAA,CAAA,CAAA;YAEvE,UAAA,GAAa,cAAc,UAAa,GAAA,6JAAA,CAAM,MAAA,CAAO,QAAS,CAAA,UAAU,EAAE,OAAQ,EAAA,CAAA;QAAA,CAGtF,MAAA;YACiB,UAAA,GAAA,OAAA,CAAA;QAAA,CACjB;QAEM,MAAA,MAAA,GAAS,QAAQ,KAAO,EAAA,MAAA,CAAO,QAAQ,CACtC,QAAA,sMAAA,EAAe,SAAW,EAAA,UAAU,CAAE,CAAA,SAAA,CAAA;QAE7C,MAAA,CAAO,KAAA,GAAQ,IAAK,CAAA,GAAA,CAAI,OAAO,KAAO,EAAA,CAAA,GAAI,UAAU,CAAI,GAAA,CAAA,CAAA;QACxD,MAAA,CAAO,MAAA,GAAS,IAAK,CAAA,GAAA,CAAI,OAAO,MAAQ,EAAA,CAAA,GAAI,UAAU,CAAI,GAAA,CAAA,CAAA;QAEpD,MAAA,MAAA,GAAS,mNAAA,CAAc,MAAO,CAAA;YAChC,GAAG,OAAQ,CAAA,oBAAA;YACX,OAAO,MAAO,CAAA,KAAA;YACd,QAAQ,MAAO,CAAA,MAAA;YACf,UAAA;YACA,SAAA;QAAA,CACH,CAAA,CAAA;QAEK,MAAA,SAAA,GAAY,yKAAA,CAAO,MAAO,CAAA,SAAA,CAAU,CAAC,MAAO,CAAA,CAAA,EAAG,CAAC,MAAA,CAAO,CAAC,CAAA,CAAA;QAE9D,IAAA,CAAK,SAAA,CAAU,MAAO,CAAA;YAClB,SAAA;YACA,SAAA;YACA,MAAA;YACA,UAAA;QAAA,CACH,CAAA,CAAA;QAED,MAAA,CAAO,MAAA,CAAO,aAAc,EAAA,CAAA;QAErB,OAAA,MAAA,CAAA;IAAA,CACX;IAEO,OACP,GAAA;QACK,IAAA,CAAK,SAAqB,GAAA,IAAA,CAAA;IAAA,CAC/B;AACJ,CAAA;AAAA,YAAA,GApHa,qBAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,WAAA;QACd,+KAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,kBAAA;AACV,CAAA"}},
    {"offset": {"line": 2637, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/GCSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/GCSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { type RenderGroup } from '../../../scene/container/RenderGroup';\nimport { type GPUDataOwner, type Renderer } from '../types';\nimport { type Renderable } from './Renderable';\nimport { type RenderOptions } from './system/AbstractRenderer';\n\nimport type EventEmitter from 'eventemitter3';\nimport type { System } from './system/System';\n\n/**\n * Data stored on a GC-managed resource.\n * @category rendering\n * @advanced\n */\nexport interface GCData\n{\n    /** Index in the managed resources array */\n    index?: number;\n    /** Type of the resource */\n    type: 'resource' | 'renderable';\n}\n\n/**\n * Interface for resources that can be garbage collected.\n * @category rendering\n * @advanced\n */\nexport interface GCable extends GPUDataOwner\n{\n    /** Timestamp of last use */\n    _gcLastUsed: number;\n    /** GC tracking data, null if not being tracked */\n    _gcData?: GCData | null;\n    /** If set to true, the resource will be garbage collected automatically when it is not used. */\n    autoGarbageCollect?: boolean;\n    /** An optional callback for when an item is touched */\n    _onTouch?(now: number): void;\n}\n\ntype GCableEventEmitter = GCable & Pick<EventEmitter, 'once' | 'off'>;\n\ninterface GCResourceHashEntry\n{\n    context: any;\n    hash: string;\n    type: GCData['type'];\n    priority: number;\n}\n\n/**\n * Options for the {@link GCSystem}.\n * @category rendering\n * @advanced\n */\nexport interface GCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector.\n     * @default true\n     */\n    gcActive: boolean;\n    /**\n     * The maximum time in milliseconds a resource can be unused before being garbage collected.\n     * @default 60000\n     */\n    gcMaxUnusedTime: number;\n    /**\n     * How frequently to run garbage collection in milliseconds.\n     * @default 30000\n     */\n    gcFrequency: number;\n}\n\n/**\n * A unified garbage collection system for managing GPU resources.\n * Resources register themselves with a cleanup callback and are automatically\n * cleaned up when they haven't been used for a specified amount of time.\n * @example\n * ```ts\n * // Register a resource for GC\n * gc.addResource(myResource, () => {\n *     // cleanup logic here\n *     myResource.unload();\n * });\n *\n * // Touch the resource when used (resets idle timer)\n * gc.touch(myResource);\n *\n * // Remove from GC tracking (e.g., on manual destroy)\n * gc.removeResource(myResource);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GCSystem implements System<GCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'gc',\n        priority: 0,\n    } as const;\n\n    /** Default options for the GCSystem */\n    public static defaultOptions: GCSystemOptions = {\n        /** Enable/disable the garbage collector */\n        gcActive: true,\n        /** Time in ms before an unused resource is collected (default 1 minute) */\n        gcMaxUnusedTime: 60000,\n        /** How often to run garbage collection in ms (default 30 seconds) */\n        gcFrequency: 30000,\n    };\n\n    /** Maximum time in ms a resource can be unused before being garbage collected */\n    public maxUnusedTime: number;\n\n    /** Reference to the renderer this system belongs to */\n    private _renderer: Renderer;\n\n    /** Array of resources being tracked for garbage collection */\n    private readonly _managedResources: GCableEventEmitter[] = [];\n    private readonly _managedResourceHashes: GCResourceHashEntry[] = [];\n\n    /** ID of the GC scheduler handler */\n    private _handler: number;\n\n    /** How frequently GC runs in ms */\n    private _frequency: number;\n\n    /** Current timestamp used for age calculations */\n    public now: number;\n\n    private _ready = false;\n\n    /**\n     * Creates a new GCSystem instance.\n     * @param renderer - The renderer this garbage collection system works for\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Initializes the garbage collection system with the provided options.\n     * @param options - Configuration options\n     */\n    public init(options: GCSystemOptions): void\n    {\n        options = { ...GCSystem.defaultOptions, ...options };\n\n        this.maxUnusedTime = options.gcMaxUnusedTime;\n        this._frequency = options.gcFrequency;\n\n        this.enabled = options.gcActive;\n        this.now = performance.now();\n    }\n\n    /**\n     * Gets whether the garbage collection system is currently enabled.\n     * @returns True if GC is enabled, false otherwise\n     */\n    get enabled(): boolean\n    {\n        return !!this._handler;\n    }\n\n    /**\n     * Enables or disables the garbage collection system.\n     * When enabled, schedules periodic cleanup of resources.\n     * When disabled, cancels all scheduled cleanups.\n     */\n    set enabled(value: boolean)\n    {\n        if (this.enabled === value) return;\n\n        if (value)\n        {\n            this._handler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    this._ready = true;\n                },\n                this._frequency,\n                false\n            );\n        }\n        else\n        {\n            this._renderer.scheduler.cancel(this._handler);\n            this._handler = 0;\n        }\n    }\n\n    /**\n     * Called before rendering. Updates the current timestamp.\n     * @param options - The render options\n     * @param options.container - The container to render\n     */\n    protected prerender({ container }: RenderOptions): void\n    {\n        this.now = performance.now();\n        container.renderGroup.gcTick = this._renderer.tick++;\n\n        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n    }\n\n    /** Performs garbage collection after rendering. */\n    protected postrender(): void\n    {\n        if (!this._ready || !this.enabled) return;\n\n        this.run();\n        this._ready = false;\n    }\n\n    /**\n     * Updates the GC tick counter for a render group and its children.\n     * @param renderGroup - The render group to update\n     * @param gcTick - The new tick value\n     */\n    private _updateInstructionGCTick(renderGroup: RenderGroup, gcTick: number): void\n    {\n        renderGroup.instructionSet.gcTick = gcTick;\n\n        for (const child of renderGroup.renderGroupChildren)\n        {\n            this._updateInstructionGCTick(child, gcTick);\n        }\n    }\n\n    /**\n     * Registers a resource for garbage collection tracking.\n     * @param resource - The resource to track\n     * @param type - The type of resource to track\n     */\n    public addResource(resource: GCableEventEmitter, type: GCData['type']): void\n    {\n        // Already being tracked\n        if (resource._gcLastUsed !== -1)\n        {\n            resource._gcLastUsed = this.now;\n            resource._onTouch?.(this.now);\n\n            return;\n        }\n\n        const index = this._managedResources.length;\n\n        resource._gcData = {\n            index,\n            type,\n        };\n        resource._gcLastUsed = this.now;\n        resource._onTouch?.(this.now);\n        resource.once('unload', this.removeResource, this);\n\n        this._managedResources.push(resource);\n    }\n\n    /**\n     * Removes a resource from garbage collection tracking.\n     * Call this when manually destroying a resource.\n     * @param resource - The resource to stop tracking\n     */\n    public removeResource(resource: GCable): void\n    {\n        const gcData = resource._gcData;\n\n        if (!gcData) return;\n\n        const index = gcData.index;\n        const last = this._managedResources.length - 1;\n\n        // Swap with last element for O(1) removal\n        if (index !== last)\n        {\n            const lastResource = this._managedResources[last];\n\n            this._managedResources[index] = lastResource;\n            lastResource._gcData.index = index;\n        }\n\n        this._managedResources.length--;\n        resource._gcData = null;\n        resource._gcLastUsed = -1;\n    }\n\n    /**\n     * Registers a hash-based resource collection for garbage collection tracking.\n     * Resources in the hash will be automatically tracked and cleaned up when unused.\n     * @param context - The object containing the hash property\n     * @param hash - The property name on context that holds the resource hash\n     * @param type - The type of resources in the hash ('resource' or 'renderable')\n     * @param priority - Processing priority (lower values are processed first)\n     */\n    public addResourceHash(context: any, hash: string, type: GCData['type'], priority: number = 0): void\n    {\n        this._managedResourceHashes.push({\n            context,\n            hash,\n            type,\n            priority,\n        });\n\n        this._managedResourceHashes.sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Performs garbage collection by cleaning up unused resources.\n     * Removes resources that haven't been used for longer than maxUnusedTime.\n     */\n    public run(): void\n    {\n        const now = performance.now();\n        const managedResourceHashes = this._managedResourceHashes;\n\n        for (const hashEntry of managedResourceHashes)\n        {\n            this.runOnHash(hashEntry, now);\n        }\n\n        let writeIndex = 0;\n\n        for (let i = 0; i < this._managedResources.length; i++)\n        {\n            const resource = this._managedResources[i];\n\n            writeIndex = this.runOnResource(resource, now, writeIndex);\n        }\n\n        this._managedResources.length = writeIndex;\n    }\n\n    protected updateRenderableGCTick(renderable: Renderable & GCable, now: number): void\n    {\n        const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n        const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n\n        // Update last used time if the renderable's group was rendered this tick\n        if ((renderGroup?.gcTick ?? 0) === currentTick)\n        {\n            renderable._gcLastUsed = now;\n            renderable._onTouch?.(now);\n        }\n    }\n\n    protected runOnResource(resource: GCableEventEmitter, now: number, writeIndex: number): number\n    {\n        const gcData = resource._gcData;\n\n        // special case for renderables as we do not check every frame if they are being used\n        if (gcData.type === 'renderable')\n        {\n            this.updateRenderableGCTick(resource as Renderable, now);\n        }\n\n        const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;\n\n        if (isRecentlyUsed || !resource.autoGarbageCollect)\n        {\n            this._managedResources[writeIndex] = resource;\n            gcData.index = writeIndex;\n            writeIndex++;\n        }\n        else\n        {\n            // Call the cleanup function\n            resource.unload();\n            resource._gcData = null;\n            resource._gcLastUsed = -1;\n            resource.off('unload', this.removeResource, this);\n        }\n\n        return writeIndex;\n    }\n\n    /**\n     * Creates a clone of the hash, copying all non-null entries up to (but not including) the stop key.\n     * @param hashValue - The original hash to clone from\n     * @param stopKey - The key to stop at (exclusive)\n     * @returns A new hash object with copied entries\n     */\n    private _createHashClone(hashValue: Record<string, GCable>, stopKey: string): Record<string, GCable>\n    {\n        const hashClone: Record<string, GCable> = Object.create(null);\n\n        for (const k in hashValue)\n        {\n            if (k === stopKey) break;\n            if (hashValue[k] !== null) hashClone[k] = hashValue[k];\n        }\n\n        return hashClone;\n    }\n\n    protected runOnHash(hashEntry: GCResourceHashEntry, now: number): void\n    {\n        const { context, hash, type } = hashEntry;\n\n        const hashValue = context[hash] as Record<string, GCable>;\n        let hashClone: Record<string, GCable> | null = null;\n        let nullCount = 0;\n\n        for (const key in hashValue)\n        {\n            const resource = hashValue[key];\n\n            // check if the value is null\n            if (resource === null)\n            {\n                nullCount++;\n\n                // Lazily create the clone to clean up null entries when threshold is reached\n                if (nullCount === 10000 && !hashClone)\n                {\n                    hashClone = this._createHashClone(hashValue, key);\n                }\n\n                continue;\n            }\n\n            // If no GC data, then the resource has been added since the last garbage collection\n            if (resource._gcLastUsed === -1)\n            {\n                resource._gcLastUsed = now;\n                resource._onTouch?.(now);\n\n                if (hashClone) hashClone[key] = resource;\n\n                continue;\n            }\n\n            // special case for renderables as we do not check every frame if they are being used\n            if (type === 'renderable')\n            {\n                this.updateRenderableGCTick(resource as Renderable, now);\n            }\n\n            const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;\n\n            if (!isRecentlyUsed && resource.autoGarbageCollect)\n            {\n                // Lazily create the clone only when we need to remove something\n                if (!hashClone)\n                {\n                    // we can set the value to null here to avoid having to create a new hash object\n                    // only when it crosses the 10000 threshold do we need to create a new hash object\n                    if (nullCount + 1 !== 10000)\n                    {\n                        hashValue[key] = null;\n                        nullCount++;\n                    }\n                    else\n                    {\n                        hashClone = this._createHashClone(hashValue, key);\n                    }\n                }\n\n                // Call the cleanup function\n                resource.unload();\n                resource._gcData = null;\n                resource._gcLastUsed = -1;\n            }\n            else if (hashClone)\n            {\n                hashClone[key] = resource;\n            }\n        }\n\n        // Only replace the hash if something was removed\n        if (hashClone)\n        {\n            context[hash] = hashClone;\n        }\n    }\n\n    /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n    public destroy(): void\n    {\n        this.enabled = false;\n\n        this._managedResources.forEach((resource) =>\n        {\n            resource.off('unload', this.removeResource, this);\n        });\n        this._managedResources.length = 0;\n        this._managedResourceHashes.length = 0;\n        this._renderer = null as any as Renderer;\n    }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2895, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts"],"sourcesContent":["/**\n * @param rgb\n * @param alpha\n * @param out\n * @param offset\n * @internal\n */\nexport function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\n/**\n * @param abgr\n * @param out\n * @param offset\n * @internal\n */\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n"],"names":[],"mappings":";;;;;;;AAOO,SAAS,cAAe,CAAA,GAAA,EAAa,KAAe,EAAA,GAAA,EAAmB,MAC9E,EAAA;IAEI,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAM,GAAO,IAAA,EAAA,GAAM,GAAQ,IAAA,GAAA,CAAA;IACvC,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAM,GAAO,IAAA,CAAA,GAAK,GAAQ,IAAA,GAAA,CAAA;IAClC,GAAA,CAAA,MAAA,EAAQ,CAAK,GAAA,CAAA,GAAA,GAAM,GAAQ,IAAA,GAAA,CAAA;IAC/B,GAAA,CAAI,QAAQ,CAAI,GAAA,KAAA,CAAA;AACpB,CAAA;AAQgB,SAAA,mBAAA,CAAoB,IAAc,EAAA,GAAA,EAAmB,MACrE,EAAA;IACU,MAAA,KAAA,GAAA,CAAU,IAAQ,IAAA,EAAA,GAAM,GAAQ,IAAA,GAAA,CAAA;IAEtC,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAM,IAAO,GAAA,GAAA,IAAQ,GAAO,GAAA,KAAA,CAAA;IACxC,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAO,IAAQ,IAAA,CAAA,GAAK,GAAA,IAAQ,GAAO,GAAA,KAAA,CAAA;IAC/C,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAO,IAAQ,IAAA,EAAA,GAAM,GAAA,IAAQ,GAAO,GAAA,KAAA,CAAA;IAChD,GAAA,CAAI,QAAQ,CAAI,GAAA,KAAA,CAAA;AACpB"}},
    {"offset": {"line": 2921, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/GlobalUniformSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Point } from '../../../../maths/point/Point';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { type Renderer, RendererType } from '../../types';\nimport { UniformGroup } from '../shader/UniformGroup';\n\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { GlRenderTargetSystem } from '../../gl/renderTarget/GlRenderTargetSystem';\nimport type { GpuRenderTargetSystem } from '../../gpu/renderTarget/GpuRenderTargetSystem';\nimport type { WebGPURenderer } from '../../gpu/WebGPURenderer';\nimport type { UboSystem } from '../shader/UboSystem';\nimport type { System } from '../system/System';\n\n/**\n * Type definition for the global uniforms used in the renderer.\n * This includes projection matrix, world transform matrix, world color, and resolution.\n * @category rendering\n * @advanced\n */\nexport type GlobalUniformGroup = UniformGroup<{\n    uProjectionMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldTransformMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldColorAlpha: { value: Float32Array; type: 'vec4<f32>' }\n    uResolution: { value: number[]; type: 'vec2<f32>' }\n}>;\n\n/**\n * Options for the global uniforms system.\n * This includes size, projection matrix, world transform matrix, world color, and offset.\n * @category rendering\n * @advanced\n */\nexport interface GlobalUniformOptions\n{\n    size?: number[],\n    projectionMatrix?: Matrix,\n    worldTransformMatrix?: Matrix\n    worldColor?: number\n    offset?: PointData\n}\n\n/**\n * Data structure for the global uniforms used in the renderer.\n * This includes the projection matrix, world transform matrix, world color, resolution, and bind group.\n * @category rendering\n * @advanced\n */\nexport interface GlobalUniformData\n{\n    projectionMatrix: Matrix\n    worldTransformMatrix: Matrix\n    worldColor: number\n    resolution: number[]\n    offset: PointData\n    bindGroup: BindGroup\n}\n\n/** @internal */\nexport interface GlobalUniformRenderer\n{\n    renderTarget: GlRenderTargetSystem | GpuRenderTargetSystem\n    renderPipes: Renderer['renderPipes'];\n    ubo: UboSystem;\n    type: RendererType;\n}\n\n/**\n * System plugin to the renderer to manage global uniforms for the renderer.\n * @category rendering\n * @advanced\n */\nexport class GlobalUniformSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'globalUniforms',\n    } as const;\n\n    private readonly _renderer: GlobalUniformRenderer;\n\n    private _stackIndex = 0;\n    private _globalUniformDataStack: GlobalUniformData[] = [];\n\n    private readonly _uniformsPool: GlobalUniformGroup[] = [];\n    private readonly _activeUniforms: GlobalUniformGroup[] = [];\n\n    private readonly _bindGroupPool: BindGroup[] = [];\n    private readonly _activeBindGroups: BindGroup[] = [];\n\n    private _currentGlobalUniformData: GlobalUniformData;\n\n    constructor(renderer: GlobalUniformRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public reset()\n    {\n        this._stackIndex = 0;\n\n        for (let i = 0; i < this._activeUniforms.length; i++)\n        {\n            this._uniformsPool.push(this._activeUniforms[i]);\n        }\n\n        for (let i = 0; i < this._activeBindGroups.length; i++)\n        {\n            this._bindGroupPool.push(this._activeBindGroups[i]);\n        }\n\n        this._activeUniforms.length = 0;\n        this._activeBindGroups.length = 0;\n    }\n\n    public start(options: GlobalUniformOptions): void\n    {\n        this.reset();\n\n        this.push(options);\n    }\n\n    public bind({\n        size,\n        projectionMatrix,\n        worldTransformMatrix,\n        worldColor,\n        offset,\n    }: GlobalUniformOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.renderTarget;\n\n        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n            projectionData: renderTarget,\n            worldTransformMatrix: new Matrix(),\n            worldColor: 0xFFFFFFFF,\n            offset: new Point(),\n        };\n\n        const globalUniformData: GlobalUniformData = {\n            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n            resolution: size || renderTarget.size,\n            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n            worldColor: worldColor || currentGlobalUniformData.worldColor,\n            offset: offset || currentGlobalUniformData.offset,\n            bindGroup: null,\n        };\n\n        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n\n        this._activeUniforms.push(uniformGroup);\n\n        const uniforms = uniformGroup.uniforms;\n\n        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n\n        uniforms.uResolution = globalUniformData.resolution;\n\n        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n\n        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n\n        color32BitToUniform(\n            globalUniformData.worldColor,\n            uniforms.uWorldColorAlpha,\n            0\n        );\n\n        uniformGroup.update();\n\n        let bindGroup: BindGroup;\n\n        if ((this._renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            bindGroup = (this._renderer as WebGPURenderer).renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n        }\n        else\n        {\n            bindGroup = this._bindGroupPool.pop() || new BindGroup();\n            this._activeBindGroups.push(bindGroup);\n            bindGroup.setResource(uniformGroup, 0);\n        }\n\n        globalUniformData.bindGroup = bindGroup;\n\n        this._currentGlobalUniformData = globalUniformData;\n    }\n\n    public push(options: GlobalUniformOptions)\n    {\n        this.bind(options);\n\n        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n    }\n\n    public pop()\n    {\n        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n\n        // for webGL we need to update the uniform group here\n        // as we are not using bind groups\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            (this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup).update();\n        }\n    }\n\n    get bindGroup(): BindGroup\n    {\n        return this._currentGlobalUniformData.bindGroup;\n    }\n\n    get globalUniformData()\n    {\n        return this._currentGlobalUniformData;\n    }\n\n    get uniformGroup()\n    {\n        return this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup;\n    }\n\n    private _createUniforms(): GlobalUniformGroup\n    {\n        const globalUniforms = new UniformGroup({\n            uProjectionMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uWorldTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n            uWorldColorAlpha: { value: new Float32Array(4), type: 'vec4<f32>' },\n            uResolution: { value: [0, 0], type: 'vec2<f32>' },\n        }, {\n            isStatic: true,\n        });\n\n        return globalUniforms;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._globalUniformDataStack.length = 0;\n        this._uniformsPool.length = 0;\n        this._activeUniforms.length = 0;\n        this._bindGroupPool.length = 0;\n        this._activeBindGroups.length = 0;\n        this._currentGlobalUniformData = null;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3072, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/SchedulerSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Ticker } from '../../../ticker/Ticker';\n\nimport type { System } from './system/System';\n\n// start at one too keep it positive!\nlet uid = 1;\n\n/**\n * The SchedulerSystem manages scheduled tasks with specific intervals.\n * @category rendering\n * @advanced\n */\nexport class SchedulerSystem implements System<null>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'scheduler',\n        priority: 0,\n    } as const;\n\n    private readonly _tasks: {\n        func: (elapsed: number) => void;\n        duration: number;\n        offset: number\n        start: number;\n        last: number;\n        repeat: boolean;\n        id: number;\n    }[] = [];\n\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    private _offset = 0;\n\n    /** Initializes the scheduler system and starts the ticker. */\n    public init(): void\n    {\n        Ticker.system.add(this._update, this);\n    }\n\n    /**\n     * Schedules a repeating task.\n     * @param func - The function to execute.\n     * @param duration - The interval duration in milliseconds.\n     * @param useOffset - this will spread out tasks so that they do not all run at the same time\n     * @returns The unique identifier for the scheduled task.\n     */\n    public repeat(func: (elapsed: number) => void, duration: number, useOffset = true): number\n    {\n        const id = uid++;\n\n        let offset = 0;\n\n        if (useOffset)\n        {\n            this._offset += 1000;\n            offset = this._offset;\n        }\n\n        this._tasks.push({\n            func,\n            duration,\n            start: performance.now(),\n            offset,\n            last: performance.now(),\n            repeat: true,\n            id\n        });\n\n        return id;\n    }\n\n    /**\n     * Cancels a scheduled task.\n     * @param id - The unique identifier of the task to cancel.\n     */\n    public cancel(id: number): void\n    {\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            if (this._tasks[i].id === id)\n            {\n                this._tasks.splice(i, 1);\n\n                return;\n            }\n        }\n    }\n\n    /**\n     * Updates and executes the scheduled tasks.\n     * @private\n     */\n    private _update(): void\n    {\n        const now = performance.now();\n\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            const task = this._tasks[i];\n\n            if ((now - task.offset) - task.last >= task.duration)\n            {\n                const elapsed = now - task.start;\n\n                task.func(elapsed);\n                task.last = now;\n            }\n        }\n    }\n\n    /**\n     * Destroys the scheduler system and removes all tasks.\n     * @internal\n     */\n    public destroy(): void\n    {\n        Ticker.system.remove(this._update, this);\n\n        this._tasks.length = 0;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AAMA,IAAI,GAAM,GAAA,CAAA,CAAA;AAOH,MAAM,eACb,CAAA;IADO,WAAA,EAAA;QAaH,IAAA,CAAiB,MAAA,GAQX,EAAC,CAAA;QAGP,qHAAA,GAAA,IAAA,CAAQ,OAAU,GAAA,CAAA,CAAA;IAAA,CAAA;IAAA,4DAAA,GAGX,IACP,GAAA;QACI,gKAAA,CAAO,MAAO,CAAA,GAAA,CAAI,IAAK,CAAA,OAAA,EAAS,IAAI,CAAA,CAAA;IAAA,CACxC;IAAA;;;;;;GAAA,GASO,MAAO,CAAA,IAAA,EAAiC,QAAkB,EAAA,SAAA,GAAY,IAC7E,EAAA;QACI,MAAM,EAAK,GAAA,GAAA,EAAA,CAAA;QAEX,IAAI,MAAS,GAAA,CAAA,CAAA;QAEb,IAAI,SACJ,EAAA;YACI,IAAA,CAAK,OAAW,IAAA,GAAA,CAAA;YAChB,MAAA,GAAS,IAAK,CAAA,OAAA,CAAA;QAAA,CAClB;QAEA,IAAA,CAAK,MAAA,CAAO,IAAK,CAAA;YACb,IAAA;YACA,QAAA;YACA,KAAA,EAAO,YAAY,GAAI,EAAA;YACvB,MAAA;YACA,IAAA,EAAM,YAAY,GAAI,EAAA;YACtB,MAAQ,EAAA,IAAA;YACR,EAAA;QAAA,CACH,CAAA,CAAA;QAEM,OAAA,EAAA,CAAA;IAAA,CACX;IAAA;;;GAAA,GAMO,OAAO,EACd,EAAA;QACI,IAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,MAAA,CAAO,MAAA,EAAQ,CACxC,EAAA,CAAA;YACI,IAAI,IAAK,CAAA,MAAA,CAAO,CAAC,CAAA,CAAE,EAAA,KAAO,EAC1B,EAAA;gBACS,IAAA,CAAA,MAAA,CAAO,MAAO,CAAA,CAAA,EAAG,CAAC,CAAA,CAAA;gBAEvB,OAAA;YAAA,CACJ;QAAA,CACJ;IAAA,CACJ;IAAA;;;GAAA,GAMQ,OACR,GAAA;QACU,MAAA,GAAA,GAAM,YAAY,GAAI,EAAA,CAAA;QAE5B,IAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,MAAA,CAAO,MAAA,EAAQ,CACxC,EAAA,CAAA;YACU,MAAA,IAAA,GAAO,IAAK,CAAA,MAAA,CAAO,CAAC,CAAA,CAAA;YAE1B,IAAK,MAAM,IAAK,CAAA,MAAA,GAAU,IAAK,CAAA,IAAA,IAAQ,KAAK,QAC5C,EAAA;gBACU,MAAA,OAAA,GAAU,MAAM,IAAK,CAAA,KAAA,CAAA;gBAE3B,IAAA,CAAK,IAAA,CAAK,OAAO,CAAA,CAAA;gBACjB,IAAA,CAAK,IAAO,GAAA,GAAA,CAAA;YAAA,CAChB;QAAA,CACJ;IAAA,CACJ;IAAA;;;GAAA,GAMO,OACP,GAAA;QACI,gKAAA,CAAO,MAAO,CAAA,MAAA,CAAO,IAAK,CAAA,OAAA,EAAS,IAAI,CAAA,CAAA;QAEvC,IAAA,CAAK,MAAA,CAAO,MAAS,GAAA,CAAA,CAAA;IAAA,CACzB;AACJ,CAAA;AAAA,YAAA,GAjHa,eAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,WAAA;QACd,+KAAc,CAAA,YAAA;QACd,+KAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,WAAA;IACN,QAAU,EAAA,CAAA;AACd,CAAA"}},
    {"offset": {"line": 3162, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/utils/sayHello.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/utils/sayHello.ts"],"sourcesContent":["import { DOMAdapter } from '../environment/adapter';\nimport { VERSION } from './const';\n\nlet saidHello = false;\n\n/**\n * Prints out the version and renderer information for this running instance of PixiJS.\n * @param type - The name of the renderer this instance is using.\n * @returns {void}\n * @category utils\n * @advanced\n */\nexport function sayHello(type: string): void\n{\n    if (saidHello)\n    {\n        return;\n    }\n\n    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf('chrome') > -1)\n    {\n        const args = [\n            `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\\n\\n`,\n            'background: #E72264; padding:5px 0;',\n            'background: #6CA2EA; padding:5px 0;',\n            'background: #B5D33D; padding:5px 0;',\n            'background: #FED23F; padding:5px 0;',\n            'color: #FFFFFF; background: #E72264; padding:5px 0;',\n            'color: #E72264; background: #FFFFFF; padding:5px 0;',\n        ];\n\n        globalThis.console.log(...args);\n    }\n    else if (globalThis.console)\n    {\n        globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n    }\n\n    saidHello = true;\n}\n"],"names":[],"mappings":";;;;;;;;;AAGA,IAAI,SAAY,GAAA,KAAA,CAAA;AAST,SAAS,SAAS,IACzB,EAAA;IACI,IAAI,SACJ,EAAA;QACI,OAAA;IAAA,CACJ;IAEI,IAAA,0KAAA,CAAW,GAAI,EAAA,CAAE,YAAa,EAAA,CAAE,SAAU,CAAA,WAAA,EAAc,CAAA,OAAA,CAAQ,QAAQ,CAAA,GAAI,CAChF,CAAA,EAAA;QACI,MAAM,IAAO,GAAA;YACT,CAAA,8BAAA,EAAiC,+KAAO,CAAA,EAAA,EAAK,IAAI,CAAA;;AAAA,CAAA;YACjD,qCAAA;YACA,qCAAA;YACA,qCAAA;YACA,qCAAA;YACA,qDAAA;YACA,qDAAA;SACJ,CAAA;QAEW,UAAA,CAAA,OAAA,CAAQ,GAAI,CAAA,GAAG,IAAI,CAAA,CAAA;IAAA,CAClC,MAAA,IACS,WAAW,OACpB,EAAA;QACI,UAAA,CAAW,OAAA,CAAQ,GAAI,CAAA,CAAA,OAAA,EAAU,+KAAO,CAAA,GAAA,EAAM,IAAI,CAA2B,yBAAA,CAAA,CAAA,CAAA;IAAA,CACjF;IAEY,SAAA,GAAA,IAAA,CAAA;AAChB"}},
    {"offset": {"line": 3200, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/startup/HelloSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { sayHello } from '../../../../utils/sayHello';\nimport { type Renderer, RendererType } from '../../types';\n\nimport type { WebGLRenderer } from '../../gl/WebGLRenderer';\nimport type { System } from '../system/System';\n\n/**\n * Options for the startup system.\n * @property {boolean} [hello=false] - Whether to log the version and type information of renderer to console.\n * @category rendering\n * @advanced\n */\nexport interface HelloSystemOptions\n{\n    /**\n     * Whether to log the version and type information of renderer to console.\n     * @default false\n     */\n    hello: boolean;\n}\n\n/**\n * A simple system responsible for initiating the renderer.\n * @category rendering\n * @advanced\n */\nexport class HelloSystem implements System<HelloSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'hello',\n        priority: -2,\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: HelloSystemOptions = {\n        /** {@link WebGLOptions.hello} */\n        hello: false,\n    };\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * It all starts here! This initiates every system, passing in the options for any system by name.\n     * @param options - the config for the renderer and all its systems\n     */\n    public init(options: HelloSystemOptions): void\n    {\n        if (options.hello)\n        {\n            let name = this._renderer.name;\n\n            if (this._renderer.type === RendererType.WEBGL)\n            {\n                name += ` ${(this._renderer as WebGLRenderer).context.webGLVersion}`;\n            }\n\n            sayHello(name);\n        }\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AA2BO,MAAM,WACb,CAAA;IAoBI,YAAY,QACZ,CAAA;QACI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAAA;;;GAAA,GAMO,KAAK,OACZ,EAAA;QACI,IAAI,QAAQ,KACZ,EAAA;YACQ,IAAA,IAAA,GAAO,IAAA,CAAK,SAAU,CAAA,IAAA,CAAA;YAE1B,IAAI,IAAK,CAAA,SAAA,CAAU,IAAS,KAAA,qLAAA,CAAa,KACzC,EAAA;gBACI,IAAA,IAAQ,CAAK,CAAA,EAAA,IAAA,CAAK,SAA4B,CAAA,OAAA,CAAQ,YAAY,CAAA,CAAA,CAAA;YAAA,CACtE;gBAEA,mKAAA,EAAS,IAAI,CAAA,CAAA;QAAA,CACjB;IAAA,CACJ;AACJ,CAAA;AAAA,YAAA,GA5Ca,WAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,WAAA;QACd,+KAAc,CAAA,YAAA;QACd,+KAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,OAAA;IACN,QAAU,EAAA,CAAA,CAAA;AACd,CAAA,CAAA;AAAA,wCAAA,GAXS,WAAA,CAcK,cAAqC,GAAA;IAAA,+BAAA,GAE/C,KAAO,EAAA,KAAA;AACX,CAAA"}},
    {"offset": {"line": 3246, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/utils/data/clean.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/utils/data/clean.ts"],"sourcesContent":["/**\n * Takes a hash and removes all the `undefined`/`null` values from it.\n * In PixiJS, we tend to null properties instead of using 'delete' for performance reasons.\n * However, in some cases, this could be a problem if the hash grows too large over time,\n * this function can be used to clean a hash.\n * @param hash - The hash to clean.\n * @returns A new hash with all the `undefined`/`null` values removed.\n * @category utils\n * @internal\n */\nexport function cleanHash<T>(hash: Record<string, T>): Record<string, T>\n{\n    let clean = false;\n\n    for (const i in hash)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (hash[i] == undefined)\n        {\n            clean = true;\n            break;\n        }\n    }\n\n    if (!clean) return hash;\n\n    const cleanHash = Object.create(null);\n\n    for (const i in hash)\n    {\n        const value = hash[i];\n\n        if (value)\n        {\n            cleanHash[i] = value;\n        }\n    }\n\n    return cleanHash;\n}\n\n/**\n * Removes all `undefined`/`null` elements from the given array and compacts the array.\n *\n * This function iterates through the array, shifting non-undefined elements to the left\n * to fill gaps created by `undefined` elements. The length of the array is then adjusted\n * to remove the trailing `undefined` elements.\n * @param arr - The array to be cleaned.\n * @returns The cleaned array with all `undefined` elements removed.\n * @example\n * // Example usage:\n * const arr = [1, undefined, 2, undefined, 3];\n * const cleanedArr = cleanArray(arr);\n * console.log(cleanedArr); // Output: [1, 2, 3]\n * @category utils\n * @internal\n */\nexport function cleanArray<T>(arr: T[]): T[]\n{\n    let offset = 0;\n\n    for (let i = 0; i < arr.length; i++)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (arr[i] == undefined)\n        {\n            offset++;\n        }\n        else\n        {\n            arr[i - offset] = arr[i];\n        }\n    }\n\n    arr.length -= offset;\n\n    return arr;\n}\n"],"names":["cleanHash"],"mappings":";;;;;;;AAUO,SAAS,UAAa,IAC7B,EAAA;IACI,IAAI,KAAQ,GAAA,KAAA,CAAA;IAEZ,IAAA,MAAW,KAAK,IAChB,CAAA;QAEQ,IAAA,IAAA,CAAK,CAAC,CAAA,IAAK,KACf,CAAA,EAAA;YACY,KAAA,GAAA,IAAA,CAAA;YACR,MAAA;QAAA,CACJ;IAAA,CACJ;IAEA,IAAI,CAAC,KAAA,EAAc,OAAA,IAAA,CAAA;IAEbA,MAAAA,UAAAA,GAAAA,aAAAA,GAAmB,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;IAEpC,IAAA,MAAW,KAAK,IAChB,CAAA;QACU,MAAA,KAAA,GAAQ,IAAA,CAAK,CAAC,CAAA,CAAA;QAEpB,IAAI,KACJ,EAAA;YACIA,UAAAA,CAAU,CAAC,CAAI,GAAA,KAAA,CAAA;QAAA,CACnB;IAAA,CACJ;IAEOA,OAAAA,UAAAA,CAAAA;AACX,CAAA;AAkBO,SAAS,WAAc,GAC9B,EAAA;IACI,IAAI,MAAS,GAAA,CAAA,CAAA;IAEb,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,GAAA,CAAI,MAAA,EAAQ,CAChC,EAAA,CAAA;QAEQ,IAAA,GAAA,CAAI,CAAC,CAAA,IAAK,KACd,CAAA,EAAA;YACI,MAAA,EAAA,CAAA;QAAA,CAGJ,MAAA;YACI,GAAA,CAAI,CAAI,GAAA,MAAM,CAAI,GAAA,GAAA,CAAI,CAAC,CAAA,CAAA;QAAA,CAC3B;IAAA,CACJ;IAEA,GAAA,CAAI,MAAU,IAAA,MAAA,CAAA;IAEP,OAAA,GAAA,CAAA;AACX"}},
    {"offset": {"line": 3289, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderableGCSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { type RenderGroup } from '../../../../scene/container/RenderGroup';\nimport { cleanArray, cleanHash } from '../../../../utils/data/clean';\nimport { type RenderOptions } from '../system/AbstractRenderer';\n\nimport type { Container } from '../../../../scene/container/Container';\nimport type { Renderer } from '../../types';\nimport type { RenderPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { System } from '../system/System';\n\nlet renderableGCTick = 0;\n\n/**\n * Options for the {@link RenderableGCSystem}.\n * @category rendering\n * @property {boolean} [renderableGCActive=true] - If set to true, this will enable the garbage collector on the renderables.\n * @property {number} [renderableGCAMaxIdle=60000] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [renderableGCCheckCountMax=60000] - time between two garbage collections.\n * @advanced\n */\nexport interface RenderableGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     */\n    renderableGCActive: boolean;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     */\n    renderableGCMaxUnusedTime: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     */\n    renderableGCFrequency: number;\n}\n\n/**\n * The RenderableGCSystem is responsible for cleaning up GPU resources that are no longer being used.\n *\n * When rendering objects like sprites, text, etc - GPU resources are created and managed by the renderer.\n * If these objects are no longer needed but not properly destroyed (via sprite.destroy()), their GPU resources\n * would normally leak. This system prevents that by automatically cleaning up unused GPU resources.\n *\n * Key features:\n * - Runs every 30 seconds by default to check for unused resources\n * - Cleans up resources not rendered for over 1 minute\n * - Works independently of rendering - will clean up even when not actively rendering\n * - When cleaned up resources are needed again, new GPU objects are quickly assigned from a pool\n * - Can be disabled with renderableGCActive:false for manual control\n *\n * Best practices:\n * - Always call destroy() explicitly when done with renderables (e.g. sprite.destroy())\n * - This system is a safety net, not a replacement for proper cleanup\n * - Adjust frequency and timeouts via options if needed\n * @example\n * ```js\n * // Sprite created but reference lost without destroy\n * let sprite = new Sprite(texture);\n *\n * // internally the renderer will assign a resource to the sprite\n * renderer.render(sprite);\n *\n * sprite = null; // Reference lost but GPU resources still exist\n *\n * // After 1 minute of not being rendered:\n * // - RenderableGC will clean up the sprite's GPU resources\n * // - JS garbage collector can then clean up the sprite itself\n * ```\n * @category rendering\n * @advanced\n */\nexport class RenderableGCSystem implements System<RenderableGCSystemOptions>\n{\n    /**\n     * Extension metadata for registering this system with the renderer.\n     * @ignore\n     */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'renderableGC',\n        priority: 0\n    } as const;\n\n    /**\n     * Default configuration options for the garbage collection system.\n     * These can be overridden when initializing the renderer.\n     */\n    public static defaultOptions: RenderableGCSystemOptions = {\n        /** Enable/disable the garbage collector */\n        renderableGCActive: true,\n        /** Time in ms before an unused resource is collected (default 1 minute) */\n        renderableGCMaxUnusedTime: 60000,\n        /** How often to run garbage collection in ms (default 30 seconds) */\n        renderableGCFrequency: 30000,\n    };\n\n    /** Maximum time in ms a resource can be unused before being garbage collected */\n    public maxUnusedTime: number;\n\n    /** Reference to the renderer this system belongs to */\n    private _renderer: Renderer;\n\n    /** Array of renderables being tracked for garbage collection */\n    private readonly _managedRenderables: Renderable[] = [];\n    /** ID of the main GC scheduler handler */\n    private _handler: number;\n    /** How frequently GC runs in ms */\n    private _frequency: number;\n    /** Current timestamp used for age calculations */\n    private _now: number;\n\n    /** Array of hash objects being tracked for cleanup */\n    private readonly _managedHashes: {context: any, hash: string}[] = [];\n    /** ID of the hash cleanup scheduler handler */\n    private _hashHandler: number;\n\n    /** Array of arrays being tracked for cleanup */\n    private readonly _managedArrays: {context: any, hash: string}[] = [];\n    /** ID of the array cleanup scheduler handler */\n    private _arrayHandler: number;\n\n    /**\n     * Creates a new RenderableGCSystem instance.\n     * @param renderer - The renderer this garbage collection system works for\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Initializes the garbage collection system with the provided options.\n     * @param options - Configuration options for the renderer\n     */\n    public init(options: RenderableGCSystemOptions): void\n    {\n        options = { ...RenderableGCSystem.defaultOptions, ...options };\n\n        this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n        this._frequency = options.renderableGCFrequency;\n\n        this.enabled = options.renderableGCActive;\n    }\n\n    /**\n     * Gets whether the garbage collection system is currently enabled.\n     * @returns True if GC is enabled, false otherwise\n     */\n    get enabled(): boolean\n    {\n        return !!this._handler;\n    }\n\n    /**\n     * Enables or disables the garbage collection system.\n     * When enabled, schedules periodic cleanup of resources.\n     * When disabled, cancels all scheduled cleanups.\n     */\n    set enabled(value: boolean)\n    {\n        if (this.enabled === value) return;\n\n        if (value)\n        {\n            // Schedule periodic garbage collection\n            this._handler = this._renderer.scheduler.repeat(\n                () => this.run(),\n                this._frequency,\n                false\n            );\n\n            // Schedule periodic hash table cleanup\n            this._hashHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const hash of this._managedHashes)\n                    {\n                        hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n                    }\n                },\n                this._frequency\n            );\n\n            // Schedule periodic array cleanup\n            this._arrayHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const array of this._managedArrays)\n                    {\n                        cleanArray(array.context[array.hash]);\n                    }\n                },\n                this._frequency\n            );\n        }\n        else\n        {\n            // Cancel all scheduled cleanups\n            this._renderer.scheduler.cancel(this._handler);\n            this._renderer.scheduler.cancel(this._hashHandler);\n            this._renderer.scheduler.cancel(this._arrayHandler);\n        }\n    }\n\n    /**\n     * Adds a hash table to be managed by the garbage collector.\n     * @param context - The object containing the hash table\n     * @param hash - The property name of the hash table\n     */\n    public addManagedHash<T>(context: T, hash: string): void\n    {\n        this._managedHashes.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Adds an array to be managed by the garbage collector.\n     * @param context - The object containing the array\n     * @param hash - The property name of the array\n     */\n    public addManagedArray<T>(context: T, hash: string): void\n    {\n        this._managedArrays.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Updates the GC timestamp and tracking before rendering.\n     * @param options - The render options\n     * @param options.container - The container to render\n     */\n    public prerender({\n        container\n    }: RenderOptions): void\n    {\n        this._now = performance.now();\n\n        // The gcTick is a monotonically increasing counter that tracks render cycles\n        // Each time we render, we increment the global renderableGCTick counter\n        // and assign the new tick value to the render group being rendered.\n        // This lets us know which render groups were rendered in the current frame\n        // versus ones that haven't been rendered recently.\n        // The instruction set also gets updated with this tick value to track\n        // when its renderables were last used.\n        container.renderGroup.gcTick = renderableGCTick++;\n\n        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n    }\n\n    /**\n     * Starts tracking a renderable for garbage collection.\n     * @param renderable - The renderable to track\n     */\n    public addRenderable(renderable: Renderable): void\n    {\n        if (!this.enabled) return;\n\n        if (renderable._lastUsed === -1)\n        {\n            this._managedRenderables.push(renderable);\n            renderable.once('destroyed', this._removeRenderable, this);\n        }\n\n        renderable._lastUsed = this._now;\n    }\n\n    /**\n     * Performs garbage collection by cleaning up unused renderables.\n     * Removes renderables that haven't been used for longer than maxUnusedTime.\n     */\n    public run(): void\n    {\n        const now = this._now;\n        const managedRenderables = this._managedRenderables;\n        const renderPipes = this._renderer.renderPipes;\n        let offset = 0;\n\n        for (let i = 0; i < managedRenderables.length; i++)\n        {\n            const renderable = managedRenderables[i];\n\n            if (renderable === null)\n            {\n                offset++;\n                continue;\n            }\n\n            const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n            const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n\n            // Update last used time if the renderable's group was rendered this tick\n            if ((renderGroup?.gcTick ?? 0) === currentTick)\n            {\n                renderable._lastUsed = now;\n            }\n\n            // Clean up if unused for too long\n            if (now - renderable._lastUsed > this.maxUnusedTime)\n            {\n                if (!renderable.destroyed)\n                {\n                    const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n                    if (renderGroup)renderGroup.structureDidChange = true;\n\n                    rp[renderable.renderPipeId].destroyRenderable(renderable);\n                }\n\n                renderable._lastUsed = -1;\n                offset++;\n                renderable.off('destroyed', this._removeRenderable, this);\n            }\n            else\n            {\n                managedRenderables[i - (offset)] = renderable;\n            }\n        }\n\n        managedRenderables.length -= offset;\n    }\n\n    /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n    public destroy(): void\n    {\n        this.enabled = false;\n        this._renderer = null as any as Renderer;\n        this._managedRenderables.length = 0;\n        this._managedHashes.length = 0;\n        this._managedArrays.length = 0;\n    }\n\n    /**\n     * Removes a renderable from being tracked when it's destroyed.\n     * @param renderable - The renderable to stop tracking\n     */\n    private _removeRenderable(renderable: Container): void\n    {\n        const index = this._managedRenderables.indexOf(renderable as Renderable);\n\n        if (index >= 0)\n        {\n            renderable.off('destroyed', this._removeRenderable, this);\n            this._managedRenderables[index] = null;\n        }\n    }\n\n    /**\n     * Updates the GC tick counter for a render group and its children.\n     * @param renderGroup - The render group to update\n     * @param gcTick - The new tick value\n     */\n    private _updateInstructionGCTick(renderGroup: RenderGroup, gcTick: number): void\n    {\n        renderGroup.instructionSet.gcTick = gcTick;\n\n        for (const child of renderGroup.renderGroupChildren)\n        {\n            this._updateInstructionGCTick(child, gcTick);\n        }\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3479, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureGCSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { deprecation } from '../../../../utils/logging/deprecation';\nimport { type Renderer } from '../../types';\n\nimport type { System } from '../system/System';\n\n/**\n * Options for the {@link TextureGCSystem}.\n * @category rendering\n * @advanced\n * @deprecated since 8.15.0\n * @see {@link GCSystem}\n */\nexport interface TextureGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     * @deprecated since 8.15.0\n     */\n    textureGCActive: boolean;\n    /**\n     * @deprecated since 8.3.0\n     * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n     */\n    textureGCAMaxIdle: number;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     * @deprecated since 8.15.0\n     */\n    textureGCMaxIdle: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     * @deprecated since 8.15.0\n     */\n    textureGCCheckCountMax: number;\n}\n/**\n * System plugin to the renderer to manage texture garbage collection on the GPU,\n * ensuring that it does not get clogged up with textures that are no longer being used.\n * @category rendering\n * @advanced\n * @deprecated since 8.15.0\n * @see {@link GCSystem}\n */\nexport class TextureGCSystem implements System<TextureGCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGC',\n    } as const;\n\n    /**\n     * Default options for the TextureGCSystem\n     * @deprecated since 8.15.0\n     */\n    public static defaultOptions: TextureGCSystemOptions = {\n        /**\n         * If set to true, this will enable the garbage collector on the GPU.\n         * @default true\n         */\n        textureGCActive: true,\n        /**\n         * @deprecated since 8.3.0\n         * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n         */\n        textureGCAMaxIdle: null,\n        /**\n         * The maximum idle frames before a texture is destroyed by garbage collection.\n         * @default 60 * 60\n         */\n        textureGCMaxIdle: 60 * 60,\n        /**\n         * Frames between two garbage collections.\n         * @default 600\n         */\n        textureGCCheckCountMax: 600,\n    };\n\n    /**\n     * Frame count since started.\n     * @readonly\n     * @deprecated since 8.15.0\n     */\n    public get count() { return this._renderer.tick; }\n\n    /**\n     * Frame count since last garbage collection.\n     * @readonly\n     * @deprecated since 8.15.0\n     */\n    public get checkCount() { return this._checkCount; }\n    public set checkCount(value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._checkCount = value;\n    }\n    private _checkCount: number;\n\n    /**\n     * Maximum idle frames before a texture is destroyed by garbage collection.\n     * @see TextureGCSystem.defaultMaxIdle\n     * @deprecated since 8.15.0\n     */\n    public get maxIdle() { return (this._renderer.gc.maxUnusedTime / 1000) * 60; }\n    public set maxIdle(value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._renderer.gc.maxUnusedTime = (value / 60) * 1000;\n    }\n\n    /**\n     * Frames between two garbage collections.\n     * @see TextureGCSystem.defaultCheckCountMax\n     * @deprecated since 8.15.0\n     */\n    // eslint-disable-next-line dot-notation\n    public get checkCountMax() { return Math.floor(this._renderer.gc['_frequency'] / 1000); }\n    public set checkCountMax(_value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n    }\n\n    /**\n     * Current garbage collection mode.\n     * @see TextureGCSystem.defaultMode\n     * @deprecated since 8.15.0\n     */\n    public get active() { return this._renderer.gc.enabled; }\n    public set active(value: boolean)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._renderer.gc.enabled = value;\n    }\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._checkCount = 0;\n    }\n\n    public init(options: TextureGCSystemOptions): void\n    {\n        if (options.textureGCActive !== TextureGCSystem.defaultOptions.textureGCActive)\n        { this.active = options.textureGCActive; }\n        if (options.textureGCMaxIdle !== TextureGCSystem.defaultOptions.textureGCMaxIdle)\n        { this.maxIdle = options.textureGCMaxIdle; }\n        if (options.textureGCCheckCountMax !== TextureGCSystem.defaultOptions.textureGCCheckCountMax)\n        { this.checkCountMax = options.textureGCCheckCountMax; }\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     * @deprecated since 8.15.0\n     */\n    public run(): void\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._renderer.gc.run();\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3602, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTarget.ts"],"sourcesContent":["// what we are building is a platform and a framework.\n// import { Matrix } from '../../shared/maths/Matrix';\nimport { uid } from '../../../../utils/data/uid';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\n\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * Options for creating a render target.\n * @category rendering\n * @advanced\n */\nexport interface RenderTargetOptions\n{\n    /** the width of the RenderTarget */\n    width?: number;\n    /** the height of the RenderTarget */\n    height?: number;\n    /** the resolution of the RenderTarget */\n    resolution?: number;\n    /** an array of textures, or a number indicating how many color textures there should be */\n    colorTextures?: BindableTexture[] | number;\n    /** should this render target have a stencil buffer? */\n    stencil?: boolean;\n    /** should this render target have a depth buffer? */\n    depth?: boolean;\n    /** a depth stencil texture that the depth and stencil outputs will be written to */\n    depthStencilTexture?: BindableTexture | boolean;\n    /** should this render target be antialiased? */\n    antialias?: boolean;\n    /** is this a root element, true if this is gl context owners render target */\n    isRoot?: boolean;\n}\n\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @category rendering\n * @advanced\n */\nexport class RenderTarget\n{\n    /** The default options for a render target */\n    public static defaultOptions: RenderTargetOptions = {\n        /** the width of the RenderTarget */\n        width: 0,\n        /** the height of the RenderTarget */\n        height: 0,\n        /** the resolution of the RenderTarget */\n        resolution: 1,\n        /** an array of textures, or a number indicating how many color textures there should be */\n        colorTextures: 1,\n        /** should this render target have a stencil buffer? */\n        stencil: false,\n        /** should this render target have a depth buffer? */\n        depth: false,\n        /** should this render target be antialiased? */\n        antialias: false, // save on perf by default!\n        /** is this a root element, true if this is gl context owners render target */\n        isRoot: false\n    };\n\n    /** unique id for this render target */\n    public readonly uid: number = uid('renderTarget');\n\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    public colorTextures: TextureSource[] = [];\n    /** the stencil and depth buffer will right to this texture in WebGPU */\n    public depthStencilTexture: TextureSource;\n    /** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public stencil: boolean;\n    /** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public depth: boolean;\n\n    public dirtyId = 0;\n    public isRoot = false;\n\n    private readonly _size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    private readonly _managedColorTextures: boolean = false;\n\n    /**\n     * @param [descriptor] - Options for creating a render target.\n     */\n    constructor(descriptor: RenderTargetOptions = {})\n    {\n        descriptor = { ...RenderTarget.defaultOptions, ...descriptor };\n\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n\n        if (typeof descriptor.colorTextures === 'number')\n        {\n            this._managedColorTextures = true;\n\n            for (let i = 0; i < descriptor.colorTextures; i++)\n            {\n                this.colorTextures.push(new TextureSource({\n                    width: descriptor.width,\n                    height: descriptor.height,\n                    resolution: descriptor.resolution,\n                    antialias: descriptor.antialias,\n                })\n                );\n            }\n        }\n        else\n        {\n            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n\n            const colorSource = this.colorTexture.source;\n\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n\n        // the first color texture drives the size of all others..\n        this.colorTexture.source.on('resize', this.onSourceResize, this);\n\n        // TODO should listen for texture destroyed?\n\n        if (descriptor.depthStencilTexture || this.stencil)\n        {\n            // TODO add a test\n            if (descriptor.depthStencilTexture instanceof Texture\n                || descriptor.depthStencilTexture instanceof TextureSource)\n            {\n                this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            }\n            else\n            {\n                this.ensureDepthStencilTexture();\n            }\n        }\n    }\n\n    get size(): [number, number]\n    {\n        const _size = this._size;\n\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n\n        return _size as any as [number, number];\n    }\n\n    get width(): number\n    {\n        return this.colorTexture.source.width;\n    }\n\n    get height(): number\n    {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth(): number\n    {\n        return this.colorTexture.source.pixelWidth;\n    }\n\n    get pixelHeight(): number\n    {\n        return this.colorTexture.source.pixelHeight;\n    }\n\n    get resolution(): number\n    {\n        return this.colorTexture.source._resolution;\n    }\n\n    get colorTexture(): TextureSource\n    {\n        return this.colorTextures[0];\n    }\n\n    protected onSourceResize(source: TextureSource)\n    {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n\n    /**\n     * This will ensure a depthStencil texture is created for this render target.\n     * Most likely called by the mask system to make sure we have stencil buffer added.\n     * @internal\n     */\n    public ensureDepthStencilTexture()\n    {\n        if (!this.depthStencilTexture)\n        {\n            this.depthStencilTexture = new TextureSource({\n                width: this.width,\n                height: this.height,\n                resolution: this.resolution,\n                format: 'depth24plus-stencil8',\n                autoGenerateMipmaps: false,\n                antialias: false,\n                mipLevelCount: 1,\n                // sampleCount: handled by the render target system..\n            });\n        }\n    }\n\n    public resize(width: number, height: number, resolution = this.resolution, skipColorTexture = false)\n    {\n        this.dirtyId++;\n\n        this.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (skipColorTexture && i === 0) return;\n\n            colorTexture.source.resize(width, height, resolution);\n        });\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.source.resize(width, height, resolution);\n        }\n    }\n\n    public destroy()\n    {\n        this.colorTexture.source.off('resize', this.onSourceResize, this);\n\n        if (this._managedColorTextures)\n        {\n            this.colorTextures.forEach((texture) =>\n            {\n                texture.destroy();\n            });\n        }\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3744, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/getCanvasTexture.ts"],"sourcesContent":["import { GlobalResourceRegistry } from '../../../../../utils/pool/GlobalResourceRegistry';\nimport { CanvasSource } from '../sources/CanvasSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\n\nconst canvasCache: Map<ICanvas, Texture<CanvasSource>> = new Map();\n\nGlobalResourceRegistry.register(canvasCache);\n\n/**\n * @param canvas\n * @param options\n * @internal\n */\nexport function getCanvasTexture(canvas: ICanvas, options?: CanvasSourceOptions): Texture<CanvasSource>\n{\n    if (!canvasCache.has(canvas))\n    {\n        const texture = new Texture({\n            source: new CanvasSource({\n                resource: canvas,\n                ...options,\n            })\n        });\n\n        const onDestroy = () =>\n        {\n            if (canvasCache.get(canvas) === texture)\n            {\n                canvasCache.delete(canvas);\n            }\n        };\n\n        texture.once('destroy', onDestroy);\n        texture.source.once('destroy', onDestroy);\n\n        canvasCache.set(canvas, texture);\n    }\n\n    return canvasCache.get(canvas);\n}\n\n/**\n * @param canvas\n * @internal\n */\nexport function hasCachedCanvasTexture(canvas: ICanvas): boolean\n{\n    return canvasCache.has(canvas);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAOA,MAAM,WAAA,GAAA,aAAA,GAAA,IAAuD,GAAI,EAAA,CAAA;AAEjE,uMAAA,CAAuB,QAAA,CAAS,WAAW,CAAA,CAAA;AAO3B,SAAA,gBAAA,CAAiB,MAAA,EAAiB,OAClD,EAAA;IACI,IAAI,CAAC,WAAA,CAAY,GAAI,CAAA,MAAM,CAC3B,EAAA;QACU,MAAA,OAAA,GAAU,IAAI,uMAAQ,CAAA;YACxB,MAAA,EAAQ,IAAI,4NAAa,CAAA;gBACrB,QAAU,EAAA,MAAA;gBACV,GAAG,OAAA;YAAA,CACN,CAAA;QAAA,CACJ,CAAA,CAAA;QAED,MAAM,YAAY,MAClB;YACI,IAAI,WAAY,CAAA,GAAA,CAAI,MAAM,CAAA,KAAM,OAChC,EAAA;gBACI,WAAA,CAAY,MAAA,CAAO,MAAM,CAAA,CAAA;YAAA,CAC7B;QAAA,CACJ,CAAA;QAEQ,OAAA,CAAA,IAAA,CAAK,WAAW,SAAS,CAAA,CAAA;QACzB,OAAA,CAAA,MAAA,CAAO,IAAK,CAAA,SAAA,EAAW,SAAS,CAAA,CAAA;QAE5B,WAAA,CAAA,GAAA,CAAI,QAAQ,OAAO,CAAA,CAAA;IAAA,CACnC;IAEO,OAAA,WAAA,CAAY,GAAA,CAAI,MAAM,CAAA,CAAA;AACjC,CAAA;AAMO,SAAS,uBAAuB,MACvC,EAAA;IACW,OAAA,WAAA,CAAY,GAAA,CAAI,MAAM,CAAA,CAAA;AACjC"}},
    {"offset": {"line": 3787, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/view/ViewSystem.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { type RendererOptions } from '../../types';\nimport { RenderTarget } from '../renderTarget/RenderTarget';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { System } from '../system/System';\nimport type { CanvasSource } from '../texture/sources/CanvasSource';\nimport type { Texture } from '../texture/Texture';\n\n/**\n * Options passed to the ViewSystem\n * @category rendering\n * @advanced\n */\nexport interface ViewSystemOptions\n{\n    /**\n     * The width of the screen.\n     * @default 800\n     */\n    width?: number;\n    /**\n     * The height of the screen.\n     * @default 600\n     */\n    height?: number;\n    /** The canvas to use as a view, optional. */\n    canvas?: ICanvas;\n    /**\n     * Alias for `canvas`.\n     * @deprecated since 8.0.0\n     */\n    view?: ICanvas;\n    /**\n     * Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n     *\n     * This is only supported for HTMLCanvasElement\n     * and will be ignored if the canvas is an OffscreenCanvas.\n     */\n    autoDensity?: boolean;\n    /** The resolution / device pixel ratio of the renderer. */\n    resolution?: number;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n    /** Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer. */\n    depth?: boolean;\n}\n\n/**\n * Options for destroying the ViewSystem.\n * @category rendering\n * @advanced\n */\nexport interface ViewSystemDestroyOptions\n{\n    /** Whether to remove the view element from the DOM. Defaults to `false`. */\n    removeView?: boolean;\n}\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @advanced\n */\nexport class ViewSystem implements System<ViewSystemOptions, TypeOrBool<ViewSystemDestroyOptions> >\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'view',\n        priority: 0,\n    } as const;\n\n    /** The default options for the view system. */\n    public static defaultOptions: ViewSystemOptions = {\n        /**\n         * {@link WebGLOptions.width}\n         * @default 800\n         */\n        width: 800,\n        /**\n         * {@link WebGLOptions.height}\n         * @default 600\n         */\n        height: 600,\n        /**\n         * {@link WebGLOptions.autoDensity}\n         * @default false\n         */\n        autoDensity: false,\n        /**\n         * {@link WebGLOptions.antialias}\n         * @default false\n         */\n        antialias: false,\n    };\n\n    /** The canvas element that everything is drawn to. */\n    public canvas!: ICanvas;\n\n    /** The texture that is used to draw the canvas to the screen. */\n    public texture: Texture<CanvasSource>;\n\n    /**\n     * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n     * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n     * @type {boolean}\n     */\n    public get autoDensity(): boolean\n    {\n        return this.texture.source.autoDensity;\n    }\n    public set autoDensity(value: boolean)\n    {\n        this.texture.source.autoDensity = value;\n    }\n\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    public antialias: boolean;\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    public screen: Rectangle;\n    /** The render target that the view is drawn to. */\n    public renderTarget: RenderTarget;\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.texture.source._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.texture.source.resize(\n            this.texture.source.width,\n            this.texture.source.height,\n            value\n        );\n    }\n\n    /**\n     * initiates the view system\n     * @param options - the options for the view\n     */\n    public init(options: ViewSystemOptions): void\n    {\n        options = {\n            ...ViewSystem.defaultOptions,\n            ...options,\n        };\n\n        if (options.view)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'ViewSystem.view has been renamed to ViewSystem.canvas');\n            // #endif\n\n            options.canvas = options.view;\n        }\n\n        this.screen = new Rectangle(0, 0, options.width, options.height);\n        this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n        this.antialias = !!options.antialias;\n        this.texture = getCanvasTexture(this.canvas, options);\n        this.renderTarget = new RenderTarget({\n            colorTextures: [this.texture],\n            depth: !!options.depth,\n            isRoot: true,\n        });\n\n        this.texture.source.transparent = (options as RendererOptions).backgroundAlpha < 1;\n        this.resolution = options.resolution;\n    }\n\n    /**\n     * Resizes the screen and canvas to the specified dimensions.\n     * @param desiredScreenWidth - The new width of the screen.\n     * @param desiredScreenHeight - The new height of the screen.\n     * @param resolution\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution: number): void\n    {\n        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n\n        this.screen.width = this.texture.frame.width;\n        this.screen.height = this.texture.frame.height;\n    }\n\n    /**\n     * Destroys this System and optionally removes the canvas from the dom.\n     * @param {options | false} options - The options for destroying the view, or \"false\".\n     * @example\n     * viewSystem.destroy();\n     * viewSystem.destroy(true);\n     * viewSystem.destroy({ removeView: true });\n     */\n    public destroy(options: TypeOrBool<ViewSystemDestroyOptions> = false): void\n    {\n        const removeView = typeof options === 'boolean' ? options : !!options?.removeView;\n\n        if (removeView && this.canvas.parentNode)\n        {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n\n        this.texture.destroy();\n\n        // note: don't nullify the element\n        //       other systems may need to unbind from it during the destroy iteration (eg. GLContextSystem)\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3906, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/system/SharedSystems.ts"],"sourcesContent":["import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe';\nimport { BackgroundSystem } from '../background/BackgroundSystem';\nimport { BlendModePipe } from '../blendModes/BlendModePipe';\nimport { ExtractSystem } from '../extract/ExtractSystem';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport { GCSystem } from '../GCSystem';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem';\nimport { SchedulerSystem } from '../SchedulerSystem';\nimport { HelloSystem } from '../startup/HelloSystem';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem';\nimport { TextureGCSystem } from '../texture/TextureGCSystem';\nimport { ViewSystem } from '../view/ViewSystem';\n\nimport type { ExtractRendererOptions } from './utils/typeUtils';\n\n/**\n * Shared systems for the renderer.\n * @category rendering\n * @internal\n */\nexport const SharedSystems = [\n    BackgroundSystem,\n    GlobalUniformSystem,\n    HelloSystem,\n    ViewSystem,\n    RenderGroupSystem,\n    GCSystem,\n    TextureGCSystem,\n    GenerateTextureSystem,\n    ExtractSystem,\n    RendererInitHook,\n    RenderableGCSystem,\n    SchedulerSystem,\n];\n\n/**\n * Shared render pipes for the renderer.\n * @category rendering\n * @internal\n */\nexport const SharedRenderPipes = [\n    BlendModePipe,\n    BatcherPipe,\n    SpritePipe,\n    RenderGroupPipe,\n    AlphaMaskPipe,\n    StencilMaskPipe,\n    ColorMaskPipe,\n    CustomRenderPipe\n];\n\n/**\n * Options for the shared systems of a renderer.\n * @category rendering\n * @advanced\n */\nexport interface SharedRendererOptions extends ExtractRendererOptions<typeof SharedSystems>, PixiMixins.RendererOptions\n{\n    /**\n     * Whether to stop PixiJS from dynamically importing default extensions for the renderer.\n     * It is false by default, and means PixiJS will load all the default extensions, based\n     * on the environment e.g browser/webworker.\n     * If you set this to true, then you will need to manually import the systems and extensions you need.\n     *\n     * e.g.\n     * ```js\n     * import 'accessibility';\n     * import 'app';\n     * import 'events';\n     * import 'spritesheet';\n     * import 'graphics';\n     * import 'mesh';\n     * import 'text';\n     * import 'text-bitmap';\n     * import 'text-html';\n     * import { autoDetectRenderer } from 'pixi.js';\n     *\n     * const renderer = await autoDetectRenderer({\n     *   width: 800,\n     *   height: 600,\n     *   skipExtensionImports: true,\n     * });\n     * ```\n     * @default false\n     */\n    skipExtensionImports?: boolean;\n    /**\n     * @default true\n     * @deprecated since 8.1.6\n     * @see `skipExtensionImports`\n     */\n    manageImports?: boolean;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BO,MAAM,aAAgB,GAAA;IACzB,4NAAA;IACA,oOAAA;IACA,+MAAA;IACA,0MAAA;IACA,kMAAA;IACA,8LAAA;IACA,uNAAA;IACA,mOAAA;IACA,mNAAA;IACA,wLAAA;IACA,6NAAA;IACA,4MAAA;CACJ,CAAA;AAOO,MAAM,iBAAoB,GAAA;IAC7B,sNAAA;IACA,kMAAA;IACA,iLAAA;IACA,8LAAA;IACA,kMAAA;IACA,wMAAA;IACA,kMAAA;IACA,gMAAA;CACJ"}},
    {"offset": {"line": 3983, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/BindGroupSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { BufferResource } from '../shared/buffer/BufferResource';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { System } from '../shared/system/System';\nimport type { TextureSource } from '../shared/texture/sources/TextureSource';\nimport type { TextureStyle } from '../shared/texture/TextureStyle';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { BindResource } from './shader/BindResource';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the WebGPU bind groups. this is how data is bound to a shader when rendering\n * @category rendering\n * @advanced\n */\nexport class BindGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'bindGroup',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _hash: Record<string, GPUBindGroup> = Object.create(null);\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getBindGroup(bindGroup: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        bindGroup._updateKey();\n\n        const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n\n        return gpuBindGroup;\n    }\n\n    private _createBindGroup(group: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        const device = this._gpu.device;\n        const groupLayout = program.layout[groupIndex];\n        const entries: GPUBindGroupEntry[] = [];\n        const renderer = this._renderer;\n\n        for (const j in groupLayout)\n        {\n            const resource: BindResource = group.resources[j] ?? group.resources[groupLayout[j]];\n            let gpuResource: GPUSampler | GPUTextureView | GPUExternalTexture | GPUBufferBinding;\n            // TODO make this dynamic..\n\n            if (resource._resourceType === 'uniformGroup')\n            {\n                const uniformGroup = resource as UniformGroup;\n\n                renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n\n                const buffer = uniformGroup.buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'buffer')\n            {\n                const buffer = resource as Buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'bufferResource')\n            {\n                const bufferResource = resource as BufferResource;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n                    offset: bufferResource.offset,\n                    size: bufferResource.size,\n                };\n            }\n            else if (resource._resourceType === 'textureSampler')\n            {\n                const sampler = resource as TextureStyle;\n\n                gpuResource = renderer.texture.getGpuSampler(sampler);\n            }\n            else if (resource._resourceType === 'textureSource')\n            {\n                const texture = resource as TextureSource;\n\n                gpuResource = renderer.texture.getGpuSource(texture).createView();\n            }\n\n            entries.push({\n                binding: groupLayout[j],\n                resource: gpuResource,\n            });\n        }\n\n        const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n\n        const gpuBindGroup = device.createBindGroup({\n            layout,\n            entries,\n        });\n\n        this._hash[group._key] = gpuBindGroup;\n\n        return gpuBindGroup;\n    }\n\n    public destroy(): void\n    {\n        this._hash = null;\n        (this._renderer as null) = null;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4071, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/buffer/GpuBufferSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { type GPUData } from '../../../../scene/view/ViewContainer';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash';\nimport { uid } from '../../../../utils/data/uid';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/** @internal */\nexport class GpuBufferData implements GPUData\n{\n    public gpuBuffer: GPUBuffer;\n\n    constructor(gpuBuffer: GPUBuffer)\n    {\n        this.gpuBuffer = gpuBuffer;\n    }\n\n    public destroy()\n    {\n        this.gpuBuffer.destroy();\n        this.gpuBuffer = null;\n    }\n}\n\n/**\n * System plugin to the renderer to manage buffers.\n * @category rendering\n * @advanced\n */\nexport class GpuBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    protected CONTEXT_UID: number;\n    private readonly _renderer: WebGPURenderer;\n    private readonly _managedBuffers: GCManagedHash<Buffer>;\n\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        this._managedBuffers = new GCManagedHash({\n            renderer,\n            type: 'resource',\n            onUnload: this.onBufferUnload.bind(this),\n            name: 'gpuBuffer'\n        });\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        buffer._gcLastUsed = this._renderer.gc.now;\n\n        return (buffer._gpuData[this._renderer.uid] as GpuBufferData)?.gpuBuffer || this.createGPUBuffer(buffer);\n    }\n\n    public updateBuffer(buffer: Buffer): GPUBuffer\n    {\n        const gpuBuffer = this.getGPUBuffer(buffer);\n\n        const data = buffer.data;\n\n        // TODO this can be better...\n        if (buffer._updateID && data)\n        {\n            buffer._updateID = 0;\n\n            // make sure\n            this._gpu.device.queue.writeBuffer(\n                gpuBuffer, 0, data.buffer, 0,\n                // round to the nearest 4 bytes\n                ((buffer._updateSize || data.byteLength) + 3) & ~3\n            );\n        }\n\n        return gpuBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        this._managedBuffers.removeAll();\n    }\n\n    protected onBufferUnload(buffer: Buffer): void\n    {\n        buffer.off('update', this.updateBuffer, this);\n        buffer.off('change', this.onBufferChange, this);\n    }\n\n    public createGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n\n        buffer._updateID = 0;\n        buffer._resourceId = uid('resource');\n\n        if (buffer.data)\n        {\n            // TODO if data is static, this can be mapped at creation\n            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n\n            gpuBuffer.unmap();\n        }\n\n        buffer._gpuData[this._renderer.uid] = new GpuBufferData(gpuBuffer);\n        if (this._managedBuffers.add(buffer))\n        {\n            buffer.on('update', this.updateBuffer, this);\n            buffer.on('change', this.onBufferChange, this);\n        }\n\n        return gpuBuffer;\n    }\n\n    protected onBufferChange(buffer: Buffer)\n    {\n        this._managedBuffers.remove(buffer);\n        buffer._updateID = 0;\n        this.createGPUBuffer(buffer);\n    }\n\n    public destroy(): void\n    {\n        this._managedBuffers.destroy();\n        (this._renderer as null) = null;\n        this._gpu = null;\n    }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4167, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/GpuColorMaskSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles color masking for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.pipeline.setColorMask(colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorMaskCache = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAUO,MAAM,kBACb,CAAA;IAaI,YAAY,QACZ,CAAA;QAHA,IAAA,CAAQ,eAAkB,GAAA,EAAA,CAAA;QAItB,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEO,QAAQ,SACf,EAAA;QACI,IAAI,IAAA,CAAK,eAAoB,KAAA,SAAA,EAAW,OAAA;QACxC,IAAA,CAAK,eAAkB,GAAA,SAAA,CAAA;QAElB,IAAA,CAAA,SAAA,CAAU,QAAS,CAAA,YAAA,CAAa,SAAS,CAAA,CAAA;IAAA,CAClD;IAEO,OACP,GAAA;QACK,IAAA,CAAK,SAAqB,GAAA,IAAA,CAAA;QAC3B,IAAA,CAAK,eAAkB,GAAA,IAAA,CAAA;IAAA,CAC3B;AACJ,CAAA;AAAA,YAAA,GAhCa,kBAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,WAAA;AACV,CAAA"}},
    {"offset": {"line": 4201, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/GpuDeviceSystem.ts"],"sourcesContent":["import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { GpuPowerPreference } from '../types';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The GPU object.\n * Contains the GPU adapter and device.\n * @category rendering\n * @advanced\n */\nexport interface GPU\n{\n    /** The GPU adapter */\n    adapter: GPUAdapter;\n    /** The GPU device */\n    device: GPUDevice;\n}\n\n/**\n * Options for the WebGPU context.\n * @property {GpuPowerPreference} [powerPreference=default] - An optional hint indicating what configuration of GPU\n * is suitable for the WebGPU context, can be `'high-performance'` or `'low-power'`.\n * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n * while setting to `'low-power'` will prioritize power saving over rendering performance.\n * @property {boolean} [forceFallbackAdapter=false] - Force the use of the fallback adapter\n * @category rendering\n * @advanced\n */\nexport interface GpuContextOptions\n{\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGPU context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @default undefined\n     */\n    powerPreference?: GpuPowerPreference;\n    /**\n     * Force the use of the fallback adapter\n     * @default false\n     */\n    forceFallbackAdapter: boolean;\n    /** Using shared device and adaptor from other engine */\n    gpu?: GPU;\n}\n\n/**\n * System plugin to the renderer to manage the context.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GpuDeviceSystem implements System<GpuContextOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'device',\n    } as const;\n\n    /** The default options for the GpuDeviceSystem. */\n    public static defaultOptions: GpuContextOptions = {\n        /**\n         * {@link WebGPUOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * Force the use of the fallback adapter\n         * @default false\n         */\n        forceFallbackAdapter: false,\n    };\n\n    /** The GPU device */\n    public gpu: GPU;\n\n    private _renderer: WebGPURenderer;\n    private _initPromise: Promise<void>;\n\n    /**\n     * @param {WebGPURenderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public async init(options: GpuContextOptions): Promise<void>\n    {\n        if (this._initPromise) return this._initPromise;\n\n        this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options))\n            .then((gpu) =>\n            {\n                this.gpu = gpu;\n\n                this._renderer.runners.contextChange.emit(this.gpu);\n            });\n\n        return this._initPromise;\n    }\n\n    /**\n     * Handle the context change event\n     * @param gpu\n     */\n    protected contextChange(gpu: GPU): void\n    {\n        this._renderer.gpu = gpu;\n    }\n\n    /**\n     * Helper class to create a WebGL Context\n     * @param {object} options - An options object that gets passed in to the canvas element containing the\n     *    context attributes\n     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n     * @returns {WebGLRenderingContext} the WebGL context\n     */\n    private async _createDeviceAndAdaptor(options: GpuContextOptions): Promise<GPU>\n    {\n        // TODO we only need one of these..\n        const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({\n            powerPreference: options.powerPreference,\n            forceFallbackAdapter: options.forceFallbackAdapter,\n        });\n\n        const requiredFeatures = [\n            'texture-compression-bc',\n            'texture-compression-astc',\n            'texture-compression-etc2',\n        ].filter((feature) => adapter.features.has(feature)) as GPUFeatureName[];\n\n        // TODO and one of these!\n        const device = await adapter.requestDevice({\n            requiredFeatures\n        });\n\n        return { adapter, device };\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n        this._renderer = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AAwDO,MAAM,eACb,CAAA;IAAA;;GAAA,GAgCI,YAAY,QACZ,CAAA;QACI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEA,MAAa,KAAK,OAClB,EAAA;QACI,IAAI,IAAK,CAAA,YAAA,EAAc,OAAO,IAAK,CAAA,YAAA,CAAA;QAEnC,IAAA,CAAK,YAAgB,GAAA,CAAA,OAAA,CAAQ,GAAM,GAAA,OAAA,CAAQ,OAAA,CAAQ,OAAQ,CAAA,GAAG,CAAI,GAAA,IAAA,CAAK,uBAAwB,CAAA,OAAO,CACjG,EAAA,IAAA,CAAK,CAAC,GACP,KAAA;YACI,IAAA,CAAK,GAAM,GAAA,GAAA,CAAA;YAEX,IAAA,CAAK,SAAU,CAAA,OAAA,CAAQ,aAAc,CAAA,IAAA,CAAK,IAAA,CAAK,GAAG,CAAA,CAAA;QAAA,CACrD,CAAA,CAAA;QAEL,OAAO,IAAK,CAAA,YAAA,CAAA;IAAA,CAChB;IAAA;;;GAAA,GAMU,cAAc,GACxB,EAAA;QACI,IAAA,CAAK,SAAA,CAAU,GAAM,GAAA,GAAA,CAAA;IAAA,CACzB;IAAA;;;;;;GAAA,GASA,MAAc,wBAAwB,OACtC,EAAA;QAEU,MAAA,OAAA,GAAU,MAAM,0KAAW,CAAA,GAAA,GAAM,YAAa,EAAA,CAAE,GAAA,CAAI,cAAe,CAAA;YACrE,iBAAiB,OAAQ,CAAA,eAAA;YACzB,sBAAsB,OAAQ,CAAA,oBAAA;QAAA,CACjC,CAAA,CAAA;QAED,MAAM,gBAAmB,GAAA;YACrB,wBAAA;YACA,0BAAA;YACA,0BAAA;SACJ,CAAE,MAAA,CAAO,CAAC,OAAA,GAAY,QAAQ,QAAS,CAAA,GAAA,CAAI,OAAO,CAAC,CAAA,CAAA;QAG7C,MAAA,MAAA,GAAS,MAAM,OAAA,CAAQ,aAAc,CAAA;YACvC,gBAAA;QAAA,CACH,CAAA,CAAA;QAEM,OAAA;YAAE;YAAS,MAAO;QAAA,CAAA,CAAA;IAAA,CAC7B;IAEO,OACP,GAAA;QACI,IAAA,CAAK,GAAM,GAAA,IAAA,CAAA;QACX,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;IAAA,CACrB;AACJ,CAAA;AAAA,YAAA,GAhGa,eAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,QAAA;AACV,CAAA,CAAA;AAAA,iDAAA,GARS,eAAA,CAWK,cAAoC,GAAA;IAAA;;;GAAA,GAK9C,eAAiB,EAAA,KAAA,CAAA;IAAA;;;GAAA,GAKjB,oBAAsB,EAAA,KAAA;AAC1B,CAAA"}},
    {"offset": {"line": 4281, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/GpuEncoderSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { GpuRenderTarget } from './renderTarget/GpuRenderTarget';\nimport type { GpuRenderTargetAdaptor } from './renderTarget/GpuRenderTargetAdaptor';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles encoding commands for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'encoder',\n        priority: 1\n    } as const;\n\n    public commandEncoder: GPUCommandEncoder;\n    public renderPassEncoder: GPURenderPassEncoder;\n    public commandFinished: Promise<void>;\n\n    private _resolveCommandFinished: (value: void) => void;\n\n    private _gpu: GPU;\n    private _boundBindGroup: Record<number, BindGroup> = Object.create(null);\n    private _boundVertexBuffer: Record<number, Buffer> = Object.create(null);\n    private _boundIndexBuffer: Buffer;\n    private _boundPipeline: GPURenderPipeline;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public renderStart(): void\n    {\n        this.commandFinished = new Promise((resolve) =>\n        {\n            this._resolveCommandFinished = resolve;\n        });\n\n        // generate a render pass description..\n        // create an encoder..\n        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    }\n\n    public beginRenderPass(gpuRenderTarget: GpuRenderTarget)\n    {\n        this.endRenderPass();\n\n        this._clearCache();\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n    }\n\n    public endRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n        }\n\n        this.renderPassEncoder = null;\n    }\n\n    public setViewport(viewport: Rectangle): void\n    {\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    }\n\n    public setPipelineFromGeometryProgramAndState(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: any,\n        topology?: Topology,\n    ): void\n    {\n        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n\n        this.setPipeline(pipeline);\n    }\n\n    public setPipeline(pipeline: GPURenderPipeline)\n    {\n        if (this._boundPipeline === pipeline) return;\n        this._boundPipeline = pipeline;\n\n        this.renderPassEncoder.setPipeline(pipeline);\n    }\n\n    private _setVertexBuffer(index: number, buffer: Buffer)\n    {\n        if (this._boundVertexBuffer[index] === buffer) return;\n\n        this._boundVertexBuffer[index] = buffer;\n\n        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n    }\n\n    private _setIndexBuffer(buffer: Buffer)\n    {\n        if (this._boundIndexBuffer === buffer) return;\n\n        this._boundIndexBuffer = buffer;\n\n        const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? 'uint16' : 'uint32';\n\n        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n    }\n\n    public resetBindGroup(index: number)\n    {\n        this._boundBindGroup[index] = null;\n    }\n\n    public setBindGroup(index: number, bindGroup: BindGroup, program: GpuProgram)\n    {\n        if (this._boundBindGroup[index] === bindGroup) return;\n        this._boundBindGroup[index] = bindGroup;\n\n        bindGroup._touch(this._renderer.gc.now, this._renderer.tick);\n\n        // TODO getting the bind group works as it looks at th e assets and generates a key\n        // should this just be hidden behind a dirty flag?\n        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n\n        // mark each item as having been used..\n        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n    }\n\n    public setGeometry(geometry: Geometry, program: GpuProgram)\n    {\n        // when binding a buffers for geometry, there is no need to bind a buffer more than once if it is interleaved.\n        // which is often the case for Pixi. This is a performance optimisation.\n        // Instead of looping through the attributes, we instead call getBufferNamesToBind\n        // which returns a list of buffer names that need to be bound.\n        // we can then loop through this list and bind the buffers.\n        // essentially only binding a single time for any buffers that are interleaved.\n        const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);\n\n        for (const i in buffersToBind)\n        {\n            this._setVertexBuffer(parseInt(i, 10), geometry.attributes[buffersToBind[i]].buffer);\n        }\n\n        if (geometry.indexBuffer)\n        {\n            this._setIndexBuffer(geometry.indexBuffer);\n        }\n    }\n\n    private _setShaderBindGroups(shader: Shader, skipSync?: boolean)\n    {\n        for (const i in shader.groups)\n        {\n            const bindGroup = shader.groups[i] as BindGroup;\n\n            // update any uniforms?\n            if (!skipSync)\n            {\n                this._syncBindGroup(bindGroup);\n            }\n\n            this.setBindGroup(i as unknown as number, bindGroup, shader.gpuProgram);\n        }\n    }\n\n    private _syncBindGroup(bindGroup: BindGroup)\n    {\n        for (const j in bindGroup.resources)\n        {\n            const resource = bindGroup.resources[j];\n\n            if ((resource as UniformGroup).isUniformGroup)\n            {\n                this._renderer.ubo.updateUniformGroup(resource as UniformGroup);\n            }\n        }\n    }\n\n    public draw(options: {\n        geometry: Geometry;\n        shader: Shader;\n        state?: State;\n        topology?: Topology;\n        size?: number;\n        start?: number;\n        instanceCount?: number;\n        skipSync?: boolean;\n    })\n    {\n        const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n\n        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n        this.setGeometry(geometry, shader.gpuProgram);\n        this._setShaderBindGroups(shader, skipSync);\n\n        if (geometry.indexBuffer)\n        {\n            this.renderPassEncoder.drawIndexed(\n                size || geometry.indexBuffer.data.length,\n                instanceCount ?? geometry.instanceCount,\n                start || 0\n            );\n        }\n        else\n        {\n            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);\n        }\n    }\n\n    public finishRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n            this.renderPassEncoder = null;\n        }\n    }\n\n    public postrender()\n    {\n        this.finishRenderPass();\n\n        this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n\n        this._resolveCommandFinished();\n\n        this.commandEncoder = null;\n    }\n\n    // restores a render pass if finishRenderPass was called\n    // not optimised as really used for debugging!\n    // used when we want to stop drawing and log a texture..\n    public restoreRenderPass()\n    {\n        const descriptor = (this._renderer.renderTarget.adaptor as GpuRenderTargetAdaptor).getDescriptor(\n            this._renderer.renderTarget.renderTarget,\n            false,\n            [0, 0, 0, 1],\n        );\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n\n        const boundPipeline = this._boundPipeline;\n        const boundVertexBuffer = { ...this._boundVertexBuffer };\n        const boundIndexBuffer = this._boundIndexBuffer;\n        const boundBindGroup = { ...this._boundBindGroup };\n\n        this._clearCache();\n\n        const viewport = this._renderer.renderTarget.viewport;\n\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n        // reinstate the cache...\n\n        this.setPipeline(boundPipeline);\n\n        for (const i in boundVertexBuffer)\n        {\n            this._setVertexBuffer(i as unknown as number, boundVertexBuffer[i]);\n        }\n\n        for (const i in boundBindGroup)\n        {\n            this.setBindGroup(i as unknown as number, boundBindGroup[i], null);\n        }\n\n        this._setIndexBuffer(boundIndexBuffer);\n    }\n\n    private _clearCache()\n    {\n        for (let i = 0; i < 16; i++)\n        {\n            this._boundBindGroup[i] = null;\n            this._boundVertexBuffer[i] = null;\n        }\n\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._gpu = null;\n        this._boundBindGroup = null;\n        this._boundVertexBuffer = null;\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4459, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/GpuLimitsSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { type System } from '../shared/system/System';\nimport { type WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The GpuLimitsSystem provides information about the capabilities and limitations of the underlying GPU.\n * These limits, such as the maximum number of textures that can be used in a shader\n * (`maxTextures`) or the maximum number of textures that can be batched together (`maxBatchableTextures`),\n * are determined by the specific graphics hardware and driver.\n *\n * The values for these limits are not available immediately upon instantiation of the class.\n * They are populated when the WebGPU Device rendering context is successfully initialized and ready,\n * which occurs after the `renderer.init()` method has completed.\n * Attempting to access these properties before the context is ready will result in undefined or default values.\n *\n * This system allows the renderer to adapt its behavior and resource allocation strategies\n * to stay within the supported boundaries of the GPU, ensuring optimal performance and stability.\n * @example\n * ```ts\n * const renderer = new WebGPURenderer();\n * await renderer.init(); // GPU limits are populated after this call\n *\n * console.log(renderer.limits.maxTextures);\n * console.log(renderer.limits.maxBatchableTextures);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GpuLimitsSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'limits',\n    } as const;\n\n    /** The maximum number of textures that can be used by a shader */\n    public maxTextures: number;\n    /** The maximum number of batchable textures */\n    public maxBatchableTextures: number;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public contextChange(): void\n    {\n        this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;\n        this.maxBatchableTextures = this.maxTextures;\n    }\n\n    public destroy(): void\n    {\n        // boom!\n    }\n}\n"],"names":[],"mappings":";;;;;;;AA4BO,MAAM,eACb,CAAA;IAgBI,YAAY,QACZ,CAAA;QACI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEO,aACP,GAAA;QACI,IAAA,CAAK,WAAA,GAAc,IAAK,CAAA,SAAA,CAAU,MAAO,CAAA,GAAA,CAAI,MAAA,CAAO,MAAO,CAAA,gCAAA,CAAA;QAC3D,IAAA,CAAK,oBAAA,GAAuB,IAAK,CAAA,WAAA,CAAA;IAAA,CACrC;IAEO,OACP,GAAA,CAAA,CAEA;AACJ,CAAA;AAAA,YAAA,GAhCa,eAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,QAAA;AACV,CAAA"}},
    {"offset": {"line": 4488, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/GpuStencilSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @category rendering\n * @advanced\n */\nexport class GpuStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        this._activeRenderTarget = renderTarget;\n\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        const renderer = this._renderer;\n\n        renderer.pipeline.setStencilMode(stencilMode);\n        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n    }\n\n    public destroy()\n    {\n        this._renderer.renderTarget.onRenderTargetChange.remove(this);\n\n        (this._renderer as null) = null;\n\n        this._activeRenderTarget = null;\n        this._renderTargetStencilState = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AAYO,MAAM,gBACb,CAAA;IAkBI,YAAY,QACZ,CAAA;QARQ,IAAA,CAAA,yBAAA,GAAA,aAAA,GAGI,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;QAMnB,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;QAER,QAAA,CAAA,YAAA,CAAa,oBAAqB,CAAA,GAAA,CAAI,IAAI,CAAA,CAAA;IAAA,CACvD;IAEU,qBAAqB,YAC/B,EAAA;QACI,IAAI,YAAe,GAAA,IAAA,CAAK,yBAA0B,CAAA,YAAA,CAAa,GAAG,CAAA,CAAA;QAElE,IAAI,CAAC,YACL,EAAA;YACI,YAAA,GAAe,IAAK,CAAA,yBAAA,CAA0B,YAAa,CAAA,GAAG,CAAI,GAAA;gBAC9D,aAAa,yMAAc,CAAA,QAAA;gBAC3B,gBAAkB,EAAA,CAAA;YAAA,CACtB,CAAA;QAAA,CACJ;QAEA,IAAA,CAAK,mBAAsB,GAAA,YAAA,CAAA;QAE3B,IAAA,CAAK,cAAe,CAAA,YAAA,CAAa,WAAa,EAAA,YAAA,CAAa,gBAAgB,CAAA,CAAA;IAAA,CAC/E;IAEO,cAAA,CAAe,WAAA,EAA4B,gBAClD,EAAA;QACI,MAAM,YAAe,GAAA,IAAA,CAAK,yBAA0B,CAAA,IAAA,CAAK,mBAAA,CAAoB,GAAG,CAAA,CAAA;QAEhF,YAAA,CAAa,WAAc,GAAA,WAAA,CAAA;QAC3B,YAAA,CAAa,gBAAmB,GAAA,gBAAA,CAAA;QAEhC,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;QAEb,QAAA,CAAA,QAAA,CAAS,cAAA,CAAe,WAAW,CAAA,CAAA;QACnC,QAAA,CAAA,OAAA,CAAQ,iBAAkB,CAAA,mBAAA,CAAoB,gBAAgB,CAAA,CAAA;IAAA,CAC3E;IAEO,OACP,GAAA;QACI,IAAA,CAAK,SAAU,CAAA,YAAA,CAAa,oBAAqB,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;QAE3D,IAAA,CAAK,SAAqB,GAAA,IAAA,CAAA;QAE3B,IAAA,CAAK,mBAAsB,GAAA,IAAA,CAAA;QAC3B,IAAA,CAAK,yBAA4B,GAAA,IAAA,CAAA;IAAA,CACrC;AACJ,CAAA;AAAA,YAAA,GAjEa,gBAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,SAAA;AACV,CAAA"}},
    {"offset": {"line": 4541, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/shader/UboSystem.ts"],"sourcesContent":["import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { Buffer } from '../buffer/Buffer';\nimport { BufferUsage } from '../buffer/const';\n\nimport type { System } from '../system/System';\nimport type { UboElement, UboLayout, UniformData, UniformsSyncCallback } from './types';\nimport type { UniformGroup } from './UniformGroup';\n\n/** @internal */\nexport interface UboAdaptor\n{\n    createUboElements: (uniformData: UniformData[]) => UboLayout;\n    generateUboSync: (uboElements: UboElement[]) => UniformsSyncCallback;\n}\n\n/**\n * System plugin to the renderer to manage uniform buffers.\n * @category rendering\n * @advanced\n */\nexport class UboSystem implements System\n{\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    private _syncFunctionHash: Record<string, {\n        layout: UboLayout,\n        syncFunction: (uniforms: Record<string, any>, data: Float32Array, dataInt32: Int32Array, offset: number) => void\n    }> = Object.create(null);\n\n    private readonly _adaptor: UboAdaptor;\n\n    constructor(adaptor: UboAdaptor)\n    {\n        this._adaptor = adaptor;\n\n        // Validation check that this environment support `new Function`\n        this._systemCheck();\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     */\n    private _systemCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n                 + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n\n    public ensureUniformGroup(uniformGroup: UniformGroup): void\n    {\n        const uniformData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n    }\n\n    public getUniformGroupData(uniformGroup: UniformGroup)\n    {\n        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n    }\n\n    private _initUniformGroup(uniformGroup: UniformGroup)\n    {\n        const uniformGroupSignature = uniformGroup._signature;\n\n        let uniformData = this._syncFunctionHash[uniformGroupSignature];\n\n        if (!uniformData)\n        {\n            const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n\n            const layout = this._adaptor.createUboElements(elements);\n\n            const syncFunction = this._generateUboSync(layout.uboElements);\n\n            uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n                layout,\n                syncFunction\n            };\n        }\n\n        return this._syncFunctionHash[uniformGroupSignature];\n    }\n\n    private _generateUboSync(\n        uboElements: UboElement[],\n    ): UniformsSyncCallback\n    {\n        return this._adaptor.generateUboSync(uboElements);\n    }\n\n    public syncUniformGroup(uniformGroup: UniformGroup, data?: Float32Array, offset?: number): boolean\n    {\n        const uniformGroupData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformGroupData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n\n        let dataInt32: Int32Array = null;\n\n        if (!data)\n        {\n            data = uniformGroup.buffer.data as Float32Array;\n            dataInt32 = uniformGroup.buffer.dataInt32;\n        }\n        offset ||= 0;\n\n        uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n\n        return true;\n    }\n\n    public updateUniformGroup(uniformGroup: UniformGroup): boolean\n    {\n        if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;\n        uniformGroup._dirtyId = 0;\n\n        const synced = this.syncUniformGroup(uniformGroup);\n\n        uniformGroup.buffer.update();\n\n        return synced;\n    }\n\n    public destroy(): void\n    {\n        this._syncFunctionHash = null;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4626, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.ts"],"sourcesContent":["import type { UboElement, UboLayout, UNIFORM_TYPES, UniformData } from '../../../shared/shader/types';\n\n/** @internal */\nexport const WGSL_ALIGN_SIZE_DATA: Record<UNIFORM_TYPES | string, {align: number, size: number}> = {\n    i32: { align: 4, size: 4 },\n    u32: { align: 4, size: 4 },\n    f32: { align: 4, size: 4 },\n    f16: { align: 2, size: 2 },\n    'vec2<i32>': { align: 8, size: 8 },\n    'vec2<u32>': { align: 8, size: 8 },\n    'vec2<f32>': { align: 8, size: 8 },\n    'vec2<f16>': { align: 4, size: 4 },\n    'vec3<i32>': { align: 16, size: 12 },\n    'vec3<u32>': { align: 16, size: 12 },\n    'vec3<f32>': { align: 16, size: 12 },\n    'vec3<f16>': { align: 8, size: 6 },\n    'vec4<i32>': { align: 16, size: 16 },\n    'vec4<u32>': { align: 16, size: 16 },\n    'vec4<f32>': { align: 16, size: 16 },\n    'vec4<f16>': { align: 8, size: 8 },\n    'mat2x2<f32>': { align: 8, size: 16 },\n    'mat2x2<f16>': { align: 4, size: 8 },\n    'mat3x2<f32>': { align: 8, size: 24 },\n    'mat3x2<f16>': { align: 4, size: 12 },\n    'mat4x2<f32>': { align: 8, size: 32 },\n    'mat4x2<f16>': { align: 4, size: 16 },\n    'mat2x3<f32>': { align: 16, size: 32 },\n    'mat2x3<f16>': { align: 8, size: 16 },\n    'mat3x3<f32>': { align: 16, size: 48 },\n    'mat3x3<f16>': { align: 8, size: 24 },\n    'mat4x3<f32>': { align: 16, size: 64 },\n    'mat4x3<f16>': { align: 8, size: 32 },\n    'mat2x4<f32>': { align: 16, size: 32 },\n    'mat2x4<f16>': { align: 8, size: 16 },\n    'mat3x4<f32>': { align: 16, size: 48 },\n    'mat3x4<f16>': { align: 8, size: 24 },\n    'mat4x4<f32>': { align: 16, size: 64 },\n    'mat4x4<f16>': { align: 8, size: 32 },\n};\n\n/**\n * @param uniformData\n * @internal\n */\nexport function createUboElementsWGSL(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n        const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n\n        if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type])\n        {\n            throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, align) * uboElement.data.size;\n        }\n\n        offset = Math.ceil((offset) / align) * align;\n\n        // TODO deal with Arrays\n        uboElement.size = size;\n\n        uboElement.offset = offset;\n\n        offset += size;\n    }\n\n    // must align to 16 bits!\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4805, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uniformParsers.ts"],"sourcesContent":["// Parsers, each one of these will take a look at the type of shader property and uniform.\n// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.\n// Shader upload code is automagically generated with these parsers.\n// If no parser is valid then the default upload functions are used.\n// exposing Parsers means that custom upload logic can be added to pixi's shaders.\n// A good example would be a pixi rectangle can be directly set on a uniform.\n// If the shader sees it it knows how to upload the rectangle structure as a vec4\n// format is as follows:\n//\n// {\n//     test: (data, uniform) => {} <--- test is this code should be used for this uniform\n//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform\n//     codeUbo: (name, uniform) => {} <--- returns the string of the piece of code that uploads the\n//                                         uniform to a uniform buffer\n// }\n// import { Texture } from '../../texture/Texture';\n\nimport type { Color } from '../../../../../color/Color';\nimport type { Matrix } from '../../../../../maths/matrix/Matrix';\nimport type { PointLike } from '../../../../../maths/point/PointLike';\nimport type { Rectangle } from '../../../../../maths/shapes/Rectangle';\nimport type { UNIFORM_TYPES, UniformData } from '../types';\n\ninterface UniformParserDefinition\n{\n    type: UNIFORM_TYPES;\n    test(data: UniformData): boolean;\n    ubo?: string;\n    uboWgsl?: string;\n    uboStd40?: string;\n    uniform?: string;\n}\n\n/** @internal */\nexport const uniformParsers: UniformParserDefinition[] = [\n    // uploading pixi matrix object to mat3\n    {\n        type: 'mat3x3<f32>',\n        test: (data: UniformData): boolean =>\n        {\n            const value = data.value as Matrix;\n\n            return value.a !== undefined;\n        },\n        ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n        uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n    },\n    // uploading a pixi rectangle as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Rectangle).width !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n    },\n    // uploading a pixi point as a vec2\n    {\n        type: 'vec2<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec2<f32>' && data.size === 1 && (data.value as PointLike).x !== undefined,\n        ubo:  `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n    },\n    // uploading a pixi color as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n    },\n    // uploading a pixi color as a vec3\n    {\n        type: 'vec3<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec3<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n    },\n];\n"],"names":[],"mappings":";;;;;AAkCO,MAAM,cAA4C,GAAA;IAAA,uCAAA;IAErD;QACI,IAAM,EAAA,aAAA;QACN,IAAA,EAAM,CAAC,IACP,KAAA;YACI,MAAM,QAAQ,IAAK,CAAA,KAAA,CAAA;YAEnB,OAAO,MAAM,CAAM,KAAA,KAAA,CAAA,CAAA;QAAA,CACvB;QACA,GAAK,EAAA,CAAA;;;;;;;;;;;QAAA,CAAA;QAYL,OAAS,EAAA,CAAA;;QAAA,CAAA;IAAA,CAGb;IAAA,uCAAA;IAEA;QACI,IAAM,EAAA,WAAA;QACN,IAAA,EAAM,CAAC,IAAA,GACH,IAAK,CAAA,IAAA,KAAS,WAAe,IAAA,IAAA,CAAK,IAAS,KAAA,CAAA,IAAM,IAAK,CAAA,KAAA,CAAoB,KAAU,KAAA,KAAA,CAAA;QACxF,GAAK,EAAA,CAAA;;;;;;QAAA,CAAA;QAOL,OAAS,EAAA,CAAA;;;;;;;;;;QAAA,CAAA;IAAA,CAWb;IAAA,mCAAA;IAEA;QACI,IAAM,EAAA,WAAA;QACN,IAAA,EAAM,CAAC,IAAA,GACH,IAAK,CAAA,IAAA,KAAS,WAAe,IAAA,IAAA,CAAK,IAAS,KAAA,CAAA,IAAM,IAAK,CAAA,KAAA,CAAoB,CAAM,KAAA,KAAA,CAAA;QACpF,GAAM,EAAA,CAAA;;;;QAAA,CAAA;QAKN,OAAS,EAAA,CAAA;;;;;;;;QAAA,CAAA;IAAA,CASb;IAAA,mCAAA;IAEA;QACI,IAAM,EAAA,WAAA;QACN,IAAA,EAAM,CAAC,IAAA,GACH,IAAK,CAAA,IAAA,KAAS,WAAe,IAAA,IAAA,CAAK,IAAS,KAAA,CAAA,IAAM,IAAK,CAAA,KAAA,CAAgB,GAAQ,KAAA,KAAA,CAAA;QAClF,GAAK,EAAA,CAAA;;;;;;QAAA,CAAA;QAOL,OAAS,EAAA,CAAA;;;;;;;;;;QAAA,CAAA;IAAA,CAWb;IAAA,mCAAA;IAEA;QACI,IAAM,EAAA,WAAA;QACN,IAAA,EAAM,CAAC,IAAA,GACH,IAAK,CAAA,IAAA,KAAS,WAAe,IAAA,IAAA,CAAK,IAAS,KAAA,CAAA,IAAM,IAAK,CAAA,KAAA,CAAgB,GAAQ,KAAA,KAAA,CAAA;QAClF,GAAK,EAAA,CAAA;;;;;QAAA,CAAA;QAML,OAAS,EAAA,CAAA;;;;;;;;;QAAA,CAAA;IAAA,CAUb;CACJ"}},
    {"offset": {"line": 4927, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/createUboSyncFunction.ts"],"sourcesContent":["import { uniformParsers } from './uniformParsers';\n\nimport type { UboElement, UNIFORM_TYPES_SINGLE, UniformsSyncCallback } from '../types';\n\n/**\n * @param uboElements\n * @param parserCode\n * @param arrayGenerationFunction\n * @param singleSettersMap\n * @internal\n */\nexport function createUboSyncFunction(\n    uboElements: UboElement[],\n    parserCode: 'uboWgsl' | 'uboStd40',\n    arrayGenerationFunction: (uboElement: UboElement, offsetToAdd: number) => string,\n    singleSettersMap: Record<UNIFORM_TYPES_SINGLE, string>,\n): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n\n    let prev = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        const name = uboElement.data.name;\n\n        let parsed = false;\n        let offset = 0;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const uniformParser = uniformParsers[j];\n\n            if (uniformParser.test(uboElement.data))\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(\n                    `name = \"${name}\";`,\n                    `offset += ${offset - prev};`,\n                    uniformParsers[j][parserCode] || uniformParsers[j].ubo);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            if (uboElement.data.size > 1)\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n            }\n            else\n            {\n                const template = singleSettersMap[uboElement.data.type as UNIFORM_TYPES_SINGLE];\n\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(/* wgsl */`\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `);\n            }\n        }\n\n        prev = offset;\n    }\n\n    const fragmentSrc = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function(\n        'uv',\n        'data',\n        'dataInt32',\n        'offset',\n        fragmentSrc,\n    ) as UniformsSyncCallback;\n}\n"],"names":[],"mappings":";;;;;;;AAWO,SAAS,qBACZ,CAAA,WAAA,EACA,UACA,EAAA,uBAAA,EACA,gBAEJ,EAAA;IACI,MAAM,gBAAgB;QAAC,CAAA;;;;;;;IAOtB,CAAA;KAAA,CAAA;IAED,IAAI,IAAO,GAAA,CAAA,CAAA;IAEX,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,CAAY,MAAA,EAAQ,CACxC,EAAA,CAAA;QACU,MAAA,UAAA,GAAa,WAAA,CAAY,CAAC,CAAA,CAAA;QAE1B,MAAA,IAAA,GAAO,WAAW,IAAK,CAAA,IAAA,CAAA;QAE7B,IAAI,MAAS,GAAA,KAAA,CAAA;QACb,IAAI,MAAS,GAAA,CAAA,CAAA;QAEb,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,6NAAA,CAAe,MAAA,EAAQ,CAC3C,EAAA,CAAA;YACU,MAAA,aAAA,GAAgB,6NAAA,CAAe,CAAC,CAAA,CAAA;YAEtC,IAAI,aAAc,CAAA,IAAA,CAAK,UAAW,CAAA,IAAI,CACtC,EAAA;gBACI,MAAA,GAAS,WAAW,MAAS,GAAA,CAAA,CAAA;gBAEf,aAAA,CAAA,IAAA,CACV,CAAA,QAAA,EAAW,IAAI,CAAA,EAAA,CAAA,EACf,CAAA,UAAA,EAAa,SAAS,IAAI,CAAA,CAAA,CAAA,EAC1B,6NAAA,CAAe,CAAC,CAAA,CAAE,UAAU,CAAK,IAAA,6NAAA,CAAe,CAAC,CAAE,CAAA,GAAA;gBAC9C,MAAA,GAAA,IAAA,CAAA;gBAET,MAAA;YAAA,CACJ;QAAA,CACJ;QAEA,IAAI,CAAC,MACL,EAAA;YACQ,IAAA,UAAA,CAAW,IAAK,CAAA,IAAA,GAAO,CAC3B,EAAA;gBACI,MAAA,GAAS,WAAW,MAAS,GAAA,CAAA,CAAA;gBAE7B,aAAA,CAAc,IAAK,CAAA,uBAAA,CAAwB,UAAY,EAAA,MAAA,GAAS,IAAI,CAAC,CAAA,CAAA;YAAA,CAGzE,MAAA;gBACI,MAAM,QAAW,GAAA,gBAAA,CAAiB,UAAW,CAAA,IAAA,CAAK,IAA4B,CAAA,CAAA;gBAE9E,MAAA,GAAS,WAAW,MAAS,GAAA,CAAA,CAAA;gBAEf,aAAA,CAAA,IAAA,CAAA,QAAA,GAAe,CAAA;2BAAA,EAChB,IAAI,CAAA;8BAAA,EACD,SAAS,IAAI,CAAA;oBAAA,EACvB,QAAQ,CAAA;gBAAA,CAAA;YACb,CACL;QAAA,CACJ;QAEO,IAAA,GAAA,MAAA,CAAA;IAAA,CACX;IAEM,MAAA,WAAA,GAAc,aAAc,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;IAG3C,OAAO,IAAI,QAAA,CACP,IAAA,EACA,MAAA,EACA,WAAA,EACA,QAAA,EACA,WAAA;AAER"}},
    {"offset": {"line": 4985, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uboSyncFunctions.ts"],"sourcesContent":["import type { UNIFORM_TYPES_SINGLE } from '../types';\n\nfunction loopMatrix(col: number, row: number)\n{\n    const total = col * row;\n\n    return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\n\n/** @internal */\nexport const uboSyncFunctionsSTD40: Record<UNIFORM_TYPES_SINGLE, string> = {\n    f32: `\n        data[offset] = v;`,\n    i32: `\n        dataInt32[offset] = v;`,\n    'vec2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n    'vec3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n    'vec4<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n    'vec2<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n    'vec3<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n    'vec4<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n    'mat3x3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n    'mat4x4<f32>': `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n    'mat3x2<f32>': loopMatrix(3, 2),\n    'mat4x2<f32>': loopMatrix(4, 2),\n    'mat2x3<f32>': loopMatrix(2, 3),\n    'mat4x3<f32>': loopMatrix(4, 3),\n    'mat2x4<f32>': loopMatrix(2, 4),\n    'mat3x4<f32>': loopMatrix(3, 4),\n};\n\n/** @internal */\nexport const uboSyncFunctionsWGSL: Record<UNIFORM_TYPES_SINGLE, string> = {\n    ...uboSyncFunctionsSTD40,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `,\n};\n"],"names":[],"mappings":";;;;;;;AAEA,SAAS,UAAA,CAAW,GAAA,EAAa,GACjC,EAAA;IACI,MAAM,QAAQ,GAAM,GAAA,GAAA,CAAA;IAEb,OAAA,CAAA;4BAAA,EACmB,KAAK,CAAA;iCACA,EAAA,GAAG,CAAA,iBAAA,EAAoB,GAAG,CAAA;;IAAA,CAAA,CAAA;AAG7D,CAAA;AAGO,MAAM,qBAA8D,GAAA;IACvE,GAAK,EAAA,CAAA;yBAAA,CAAA;IAEL,GAAK,EAAA,CAAA;8BAAA,CAAA;IAEL,WAAa,EAAA,CAAA;;gCAAA,CAAA;IAGb,WAAa,EAAA,CAAA;;;gCAAA,CAAA;IAIb,WAAa,EAAA,CAAA;;;;gCAAA,CAAA;IAKb,WAAa,EAAA,CAAA;;qCAAA,CAAA;IAGb,WAAa,EAAA,CAAA;;;qCAAA,CAAA;IAIb,WAAa,EAAA,CAAA;;;;qCAAA,CAAA;IAKb,aAAe,EAAA,CAAA;;;;gCAAA,CAAA;IAKf,aAAe,EAAA,CAAA;;;;;;;;;iCAAA,CAAA;IAUf,aAAe,EAAA,CAAA;;;SAAA,CAAA;IAIf,aAAA,EAAe,UAAW,CAAA,CAAA,EAAG,CAAC,CAAA;IAC9B,aAAA,EAAe,UAAW,CAAA,CAAA,EAAG,CAAC,CAAA;IAC9B,aAAA,EAAe,UAAW,CAAA,CAAA,EAAG,CAAC,CAAA;IAC9B,aAAA,EAAe,UAAW,CAAA,CAAA,EAAG,CAAC,CAAA;IAC9B,aAAA,EAAe,UAAW,CAAA,CAAA,EAAG,CAAC,CAAA;IAC9B,aAAA,EAAe,UAAW,CAAA,CAAA,EAAG,CAAC,CAAA;AAClC,EAAA;AAGO,MAAM,oBAA6D,GAAA;IACtE,GAAG,qBAAA;IACH,aAAe,EAAA,CAAA;;;;;IAAA,CAAA;AAMnB"}},
    {"offset": {"line": 5070, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.ts"],"sourcesContent":["import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL';\n\nimport type { UboElement } from '../../../shared/shader/types';\n\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the wgsl layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n * @internal\n */\nexport function generateArraySyncWGSL(uboElement: UboElement, offsetToAdd: number): string\n{\n    // this is in byte..\n    const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n\n    const remainder = (align - size) / 4;\n    const data = uboElement.data.type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';\n\n    return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ''}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 ${data}[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ''}\n         }\n     `;\n}\n"],"names":[],"mappings":";;;;;;;AAYgB,SAAA,qBAAA,CAAsB,UAAA,EAAwB,WAC9D,EAAA;IAEI,MAAM,EAAE,IAAM,EAAA,KAAA,EAAA,GAAU,uOAAqB,CAAA,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA,CAAA;IAE3D,MAAA,SAAA,GAAA,CAAa,QAAQ,IAAQ,IAAA,CAAA,CAAA;IAC7B,MAAA,IAAA,GAAO,WAAW,IAAK,CAAA,IAAA,CAAK,OAAA,CAAQ,KAAK,CAAA,IAAK,IAAI,WAAc,GAAA,MAAA,CAAA;IAE/D,OAAA,CAAA;gBACO,EAAA,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;SAAA,EAC3B,WAAgB,KAAA,CAAA,GAAI,CAAa,UAAA,EAAA,WAAW,CAAA,CAAA,CAAA,GAAM,EAAE,CAAA;;;;;;0BAAA,EAMnC,UAAW,CAAA,IAAA,CAAK,IAAQ,GAAA,CAAA,IAAA,GAAO,CAAE,CAAA,CAAA;;gCAAA,EAE3B,OAAO,CAAC,CAAA;;iBAAA,EAEvB,IAAI,CAAA;;aAAA,EAER,SAAc,KAAA,CAAA,GAAI,CAAkB,eAAA,EAAA,SAAS,CAAA,CAAA,CAAA,GAAM,EAAE,CAAA;;KAAA,CAAA,CAAA;AAGpE"}},
    {"offset": {"line": 5105, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.ts"],"sourcesContent":["import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL';\n\nimport type { UboElement, UniformsSyncCallback } from '../../../shared/shader/types';\n\n/**\n * @param uboElements\n * @internal\n */\nexport function createUboSyncFunctionWGSL(\n    uboElements: UboElement[],\n): UniformsSyncCallback\n{\n    return createUboSyncFunction(\n        uboElements,\n        'uboWgsl',\n        generateArraySyncWGSL,\n        uboSyncFunctionsWGSL,\n    );\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAUO,SAAS,0BACZ,WAEJ,EAAA;IACW,WAAA,2OAAA,EACH,WAAA,EACA,SAAA,EACA,wOAAA,EACA,qOAAA;AAER"}},
    {"offset": {"line": 5125, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/GpuUboSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL';\n\n/**\n * System plugin to the renderer to manage uniform buffers. With a WGSL twist!\n * @category rendering\n * @advanced\n */\nexport class GpuUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsWGSL,\n            generateUboSync: createUboSyncFunctionWGSL,\n        });\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAUO,MAAM,qBAAqB,0MAClC,CAAA;IAOI,WACA,EAAA;QACU,KAAA,CAAA;YACF,iBAAmB,EAAA,wOAAA;YACnB,eAAiB,EAAA,gPAAA;QAAA,CACpB,CAAA,CAAA;IAAA,CACL;AACJ,CAAA;AAAA,YAAA,GAfa,YAAA,CAGK,SAAY,GAAA;IACtB,IAAA,EAAM;QAAC,+KAAA,CAAc,YAAY;KAAA;IACjC,IAAM,EAAA,KAAA;AACV,CAAA"}},
    {"offset": {"line": 5158, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/buffer/BufferResource.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from './Buffer';\n\n/**\n * A resource that can be bound to a bind group and used in a shader.\n * Whilst a buffer can be used as a resource, this class allows you to specify an offset and size of the buffer to use.\n * This is useful if you have a large buffer and only part of it is used in a shader.\n *\n * This resource, will listen for changes on the underlying buffer and emit a itself if the buffer changes shape.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array(1000),\n *    usage: BufferUsage.UNIFORM,\n * });\n * // Create a buffer resource that uses the first 100 bytes of a buffer\n * const bufferResource = new BufferResource({\n *    buffer,\n *    offset: 0,\n *    size: 100,\n * });\n * @category rendering\n * @advanced\n */\nexport class BufferResource extends EventEmitter<{\n    change: BindResource,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    public readonly _resourceType = 'bufferResource';\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    public _touched = 0;\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    public _resourceId = uid('resource');\n\n    /** the underlying buffer that this resource is using */\n    public buffer: Buffer;\n    /** the offset of the buffer this resource is using. If not provided, then it will use the offset of the buffer. */\n    public readonly offset: number;\n    /** the size of the buffer this resource is using. If not provided, then it will use the size of the buffer. */\n    public readonly size: number;\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     */\n    public readonly _bufferResource = true;\n\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Create a new Buffer Resource.\n     * @param options - The options for the buffer resource\n     * @param options.buffer - The underlying buffer that this resource is using\n     * @param options.offset - The offset of the buffer this resource is using.\n     * If not provided, then it will use the offset of the buffer.\n     * @param options.size - The size of the buffer this resource is using.\n     * If not provided, then it will use the size of the buffer.\n     */\n    constructor({ buffer, offset, size }: { buffer: Buffer; offset?: number; size?: number; })\n    {\n        super();\n\n        this.buffer = buffer;\n        this.offset = offset | 0;\n        this.size = size;\n\n        this.buffer.on('change', this.onBufferChange, this);\n    }\n\n    protected onBufferChange(): void\n    {\n        this._resourceId = uid('resource');\n\n        this.emit('change', this);\n    }\n\n    /**\n     * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n     * if you want to destroy it as well, or code will explode\n     * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n     */\n    public destroy(destroyBuffer = false): void\n    {\n        this.destroyed = true;\n\n        if (destroyBuffer)\n        {\n            this.buffer.destroy();\n        }\n\n        this.emit('change', this);\n\n        this.buffer = null;\n        this.removeAllListeners();\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AA2BO,MAAM,uBAAuB,kKAGpC,CAAA;IAAA;;;;;;;;GAAA,GAuDI,WAAY,CAAA,EAAE,MAAQ,EAAA,MAAA,EAAQ,IAAA,EAC9B,CAAA;QACU,KAAA,EAAA,CAAA;QAjDV;;;;KAAA,GAAA,iEAAA,GAAgB,IAAA,CAAA,GAAA,OAAc,iKAAA,EAAI,QAAQ,CAAA,CAAA;QAM1C;;;KAAA,GAAA,IAAA,CAAgB,aAAgB,GAAA,gBAAA,CAAA;QAMhC;;;KAAA,GAAA,IAAA,CAAO,QAAW,GAAA,CAAA,CAAA;QAMlB;;;KAAA,GAAO,IAAA,CAAA,WAAA,OAAc,iKAAA,EAAI,UAAU,CAAA,CAAA;QAYnC;;;KAAA,GAAA,IAAA,CAAgB,eAAkB,GAAA,IAAA,CAAA;QAMlC;;;KAAA,GAAA,IAAA,CAAO,SAAY,GAAA,KAAA,CAAA;QAef,IAAA,CAAK,MAAS,GAAA,MAAA,CAAA;QACd,IAAA,CAAK,MAAA,GAAS,MAAS,GAAA,CAAA,CAAA;QACvB,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;QAEZ,IAAA,CAAK,MAAO,CAAA,EAAA,CAAG,QAAU,EAAA,IAAA,CAAK,cAAA,EAAgB,IAAI,CAAA,CAAA;IAAA,CACtD;IAEU,cACV,GAAA;QACS,IAAA,CAAA,WAAA,OAAc,iKAAA,EAAI,UAAU,CAAA,CAAA;QAE5B,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;IAAA,CAC5B;IAAA;;;;GAAA,GAOO,OAAA,CAAQ,gBAAgB,KAC/B,EAAA;QACI,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;QAEjB,IAAI,aACJ,EAAA;YACI,IAAA,CAAK,MAAA,CAAO,OAAQ,EAAA,CAAA;QAAA,CACxB;QAEK,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;QAExB,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;QACd,IAAA,CAAK,kBAAmB,EAAA,CAAA;IAAA,CAC5B;AACJ"}},
    {"offset": {"line": 5232, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/buffer/UboBatch.ts"],"sourcesContent":["/** @internal */\nexport class UboBatch\n{\n    public data: Float32Array;\n    private readonly _minUniformOffsetAlignment: number = 256;\n\n    public byteIndex = 0;\n\n    constructor({ minUniformOffsetAlignment }: {minUniformOffsetAlignment: number})\n    {\n        this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n        this.data = new Float32Array(65535);\n    }\n\n    public clear(): void\n    {\n        this.byteIndex = 0;\n    }\n\n    public addEmptyGroup(size: number): number\n    {\n        // update the buffer.. only float32 for now!\n        if (size > this._minUniformOffsetAlignment / 4)\n        {\n            throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n        }\n\n        const start = this.byteIndex;\n\n        let newSize = start + (size * 4);\n\n        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n\n        if (newSize > this.data.length * 4)\n        {\n            // TODO push a new buffer\n            throw new Error('UniformBufferBatch: ubo batch got too big');\n        }\n\n        this.byteIndex = newSize;\n\n        return start;\n    }\n\n    public addGroup(array: Float32Array): number\n    {\n        const offset = this.addEmptyGroup(array.length);\n\n        for (let i = 0; i < array.length; i++)\n        {\n            this.data[(offset / 4) + i] = array[i];\n        }\n\n        return offset;\n    }\n\n    public destroy()\n    {\n        this.data = null;\n    }\n}\n"],"names":[],"mappings":";;;;;AACO,MAAM,QACb,CAAA;IAMI,WAAA,CAAY,EAAE,yBAAA,EACd,CAAA;QALA,IAAA,CAAiB,0BAAqC,GAAA,GAAA,CAAA;QAEtD,IAAA,CAAO,SAAY,GAAA,CAAA,CAAA;QAIf,IAAA,CAAK,0BAA6B,GAAA,yBAAA,CAAA;QAC7B,IAAA,CAAA,IAAA,GAAO,IAAI,YAAA,CAAa,KAAK,CAAA,CAAA;IAAA,CACtC;IAEO,KACP,GAAA;QACI,IAAA,CAAK,SAAY,GAAA,CAAA,CAAA;IAAA,CACrB;IAEO,cAAc,IACrB,EAAA;QAEQ,IAAA,IAAA,GAAO,IAAK,CAAA,0BAAA,GAA6B,CAC7C,EAAA;YACI,MAAM,IAAI,KAAA,CAAM,CAA2C,wCAAA,EAAA,IAAA,GAAO,CAAC,CAAE,CAAA,CAAA,CAAA;QAAA,CACzE;QAEA,MAAM,QAAQ,IAAK,CAAA,SAAA,CAAA;QAEf,IAAA,OAAA,GAAU,QAAS,IAAO,GAAA,CAAA,CAAA;QAE9B,OAAA,GAAU,KAAK,IAAK,CAAA,OAAA,GAAU,IAAK,CAAA,0BAA0B,IAAI,IAAK,CAAA,0BAAA,CAAA;QAEtE,IAAI,OAAU,GAAA,IAAA,CAAK,IAAK,CAAA,MAAA,GAAS,CACjC,EAAA;YAEU,MAAA,IAAI,MAAM,2CAA2C,CAAA,CAAA;QAAA,CAC/D;QAEA,IAAA,CAAK,SAAY,GAAA,OAAA,CAAA;QAEV,OAAA,KAAA,CAAA;IAAA,CACX;IAEO,SAAS,KAChB,EAAA;QACI,MAAM,MAAS,GAAA,IAAA,CAAK,aAAc,CAAA,KAAA,CAAM,MAAM,CAAA,CAAA;QAE9C,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,KAAA,CAAM,MAAA,EAAQ,CAClC,EAAA,CAAA;YACI,IAAA,CAAK,IAAA,CAAM,MAAS,GAAA,CAAA,GAAK,CAAC,CAAA,GAAI,KAAA,CAAM,CAAC,CAAA,CAAA;QAAA,CACzC;QAEO,OAAA,MAAA,CAAA;IAAA,CACX;IAEO,OACP,GAAA;QACI,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;IAAA,CAChB;AACJ"}},
    {"offset": {"line": 5277, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/GpuUniformBatchPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Buffer } from '../shared/buffer/Buffer';\nimport { BufferResource } from '../shared/buffer/BufferResource';\nimport { BufferUsage } from '../shared/buffer/const';\nimport { UboBatch } from './buffer/UboBatch';\nimport { BindGroup } from './shader/BindGroup';\n\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\nconst minUniformOffsetAlignment = 128;// 256 / 2;\n\n/** @internal */\nexport class GpuUniformBatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'uniformBatch',\n    } as const;\n\n    private _renderer: WebGPURenderer;\n\n    private _bindGroupHash: Record<number, BindGroup> = Object.create(null);\n    private readonly _batchBuffer: UboBatch;\n\n    // number of buffers..\n    private _buffers: Buffer[] = [];\n\n    private _bindGroups: BindGroup[] = [];\n    private _bufferResources: BufferResource[] = [];\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n\n        const totalBuffers = (256 / minUniformOffsetAlignment);\n\n        for (let i = 0; i < totalBuffers; i++)\n        {\n            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n\n            if (i === 0) usage |= BufferUsage.COPY_SRC;\n\n            this._buffers.push(new Buffer({\n                data: this._batchBuffer.data,\n                usage\n            }));\n        }\n    }\n\n    public renderEnd()\n    {\n        this._uploadBindGroups();\n        this._resetBindGroups();\n    }\n\n    private _resetBindGroups()\n    {\n        this._bindGroupHash = Object.create(null);\n        this._batchBuffer.clear();\n    }\n\n    // just works for single bind groups for now\n    public getUniformBindGroup(group: UniformGroup<any>, duplicate: boolean): BindGroup\n    {\n        if (!duplicate && this._bindGroupHash[group.uid])\n        {\n            return this._bindGroupHash[group.uid];\n        }\n\n        this._renderer.ubo.ensureUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addEmptyGroup(data.length);\n\n        this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n\n        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n\n        return this._bindGroupHash[group.uid];\n    }\n\n    public getUboResource(group: UniformGroup<any>): BufferResource\n    {\n        this._renderer.ubo.updateUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBufferResource(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBindGroup(data: Float32Array): BindGroup\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBindGroup(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBufferResource(data: Float32Array): BufferResource\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        const index = offset / minUniformOffsetAlignment;\n\n        return this._getBufferResource(index);\n    }\n\n    private _getBufferResource(index: number): BufferResource\n    {\n        if (!this._bufferResources[index])\n        {\n            const buffer = this._buffers[index % 2];\n\n            this._bufferResources[index] = new BufferResource({\n                buffer,\n                offset: ((index / 2) | 0) * 256,\n                size: minUniformOffsetAlignment\n            });\n        }\n\n        return this._bufferResources[index];\n    }\n\n    private _getBindGroup(index: number): BindGroup\n    {\n        if (!this._bindGroups[index])\n        {\n            // even!\n            const bindGroup = new BindGroup({\n                0: this._getBufferResource(index),\n            });\n\n            this._bindGroups[index] = bindGroup;\n        }\n\n        return this._bindGroups[index];\n    }\n\n    private _uploadBindGroups()\n    {\n        const bufferSystem = this._renderer.buffer;\n\n        const firstBuffer = this._buffers[0];\n\n        firstBuffer.update(this._batchBuffer.byteIndex);\n\n        bufferSystem.updateBuffer(firstBuffer);\n\n        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n\n        for (let i = 1; i < this._buffers.length; i++)\n        {\n            const buffer = this._buffers[i];\n\n            commandEncoder.copyBufferToBuffer(\n                bufferSystem.getGPUBuffer(firstBuffer),\n                minUniformOffsetAlignment,\n                bufferSystem.getGPUBuffer(buffer),\n                0,\n                this._batchBuffer.byteIndex\n            );\n        }\n\n        // TODO make a system that will que up all commands in to one array?\n        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this._bindGroups.length; i++)\n        {\n            this._bindGroups[i]?.destroy();\n        }\n\n        this._bindGroups = null;\n        this._bindGroupHash = null;\n\n        for (let i = 0; i < this._buffers.length; i++)\n        {\n            this._buffers[i].destroy();\n        }\n        this._buffers = null;\n\n        for (let i = 0; i < this._bufferResources.length; i++)\n        {\n            this._bufferResources[i].destroy();\n        }\n\n        this._bufferResources = null;\n\n        this._batchBuffer.destroy();\n\n        this._renderer = null;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5415, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/ensureAttributes.ts"],"sourcesContent":["import { warn } from '../../../../../utils/logging/warn';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { Geometry } from '../../../shared/geometry/Geometry';\nimport type { ExtractedAttributeData } from './extractAttributesFromGlProgram';\n\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in any gaps. We do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of the time users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way,\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n * @internal\n */\nexport function ensureAttributes(\n    geometry: Geometry,\n    extractedData: Record<string, ExtractedAttributeData>\n): void\n{\n    for (const i in geometry.attributes)\n    {\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n\n        if (attributeData)\n        {\n            attribute.format ??= attributeData.format;\n            attribute.offset ??= attributeData.offset;\n            attribute.instance ??= attributeData.instance;\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n        }\n    }\n\n    ensureStartAndStride(geometry);\n}\n\nfunction ensureStartAndStride(geometry: Geometry): void\n{\n    const { buffers, attributes } = geometry;\n\n    const tempStride: Record<string, number> = {};\n    const tempStart: Record<string, number> = {};\n\n    for (const j in buffers)\n    {\n        const buffer = buffers[j];\n\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        attribute.stride ??= tempStride[attribute.buffer.uid];\n\n        attribute.start ??= tempStart[attribute.buffer.uid];\n\n        tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AAkBgB,SAAA,gBAAA,CACZ,QAAA,EACA,aAEJ,EAAA;IACe,IAAA,MAAA,CAAA,IAAK,SAAS,UACzB,CAAA;QACU,MAAA,SAAA,GAAY,QAAS,CAAA,UAAA,CAAW,CAAC,CAAA,CAAA;QACjC,MAAA,aAAA,GAAgB,aAAA,CAAc,CAAC,CAAA,CAAA;QAErC,IAAI,aACJ,EAAA;YACc,SAAA,CAAA,MAAA,IAAA,CAAV,SAAU,CAAA,MAAA,GAAW,aAAc,CAAA,MAAA,CAAA,CAAA;YACzB,SAAA,CAAA,MAAA,IAAA,CAAV,SAAU,CAAA,MAAA,GAAW,aAAc,CAAA,MAAA,CAAA,CAAA;YACzB,SAAA,CAAA,QAAA,IAAA,CAAV,SAAU,CAAA,QAAA,GAAa,aAAc,CAAA,QAAA,CAAA,CAAA;QAAA,CAGzC,MAAA;gBAES,sKAAA,EAAA,CAAA,UAAA,EAAa,CAAC,CAAmG,iGAAA,CAAA,CAAA,CAAA;QAAA,CAC1H;IAAA,CACJ;IAEA,oBAAA,CAAqB,QAAQ,CAAA,CAAA;AACjC,CAAA;AAEA,SAAS,qBAAqB,QAC9B,EAAA;IACU,MAAA,EAAE,OAAS,EAAA,UAAA,EAAe,GAAA,QAAA,CAAA;IAEhC,MAAM,aAAqC,CAAA,CAAC,CAAA;IAC5C,MAAM,YAAoC,CAAA,CAAC,CAAA;IAE3C,IAAA,MAAW,KAAK,OAChB,CAAA;QACU,MAAA,MAAA,GAAS,OAAA,CAAQ,CAAC,CAAA,CAAA;QAEb,UAAA,CAAA,MAAA,CAAO,GAAG,CAAI,GAAA,CAAA,CAAA;QACf,SAAA,CAAA,MAAA,CAAO,GAAG,CAAI,GAAA,CAAA,CAAA;IAAA,CAC5B;IAEA,IAAA,MAAW,KAAK,UAChB,CAAA;QACU,MAAA,SAAA,GAAY,UAAA,CAAW,CAAC,CAAA,CAAA;QAE9B,UAAA,CAAW,UAAU,MAAO,CAAA,GAAG,CAAA,QAAK,uPAA2B,EAAA,SAAA,CAAU,MAAM,CAAE,CAAA,MAAA,CAAA;IAAA,CACrF;IAEA,IAAA,MAAW,KAAK,UAChB,CAAA;QACU,MAAA,SAAA,GAAY,UAAA,CAAW,CAAC,CAAA,CAAA;QAE9B,SAAA,CAAU,MAAA,IAAA,CAAV,SAAU,CAAA,MAAA,GAAW,UAAW,CAAA,SAAA,CAAU,MAAA,CAAO,GAAG,CAAA,CAAA,CAAA;QAEpD,SAAA,CAAU,KAAA,IAAA,CAAV,SAAU,CAAA,KAAA,GAAU,SAAU,CAAA,SAAA,CAAU,MAAA,CAAO,GAAG,CAAA,CAAA,CAAA;QAElD,SAAA,CAAU,UAAU,MAAO,CAAA,GAAG,CAAA,QAAK,uPAA2B,EAAA,SAAA,CAAU,MAAM,CAAE,CAAA,MAAA,CAAA;IAAA,CACpF;AACJ"}},
    {"offset": {"line": 5464, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStencilModesToPixi.ts"],"sourcesContent":["import { STENCIL_MODES } from '../../shared/state/const';\n\n/**\n * The stencil state for the GPU renderer.\n * This is used to define how the stencil buffer should be configured.\n * @category rendering\n * @advanced\n */\nexport interface StencilState\n{\n    stencilWriteMask?: number\n    stencilReadMask?: number;\n    stencilFront?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    },\n    stencilBack?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    }\n}\n\n/** @internal */\nexport const GpuStencilModesToPixi: StencilState[] = [];\n\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = undefined;\n\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n    stencilWriteMask: 0,\n    stencilReadMask: 0,\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'not-equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'not-equal',\n        passOp: 'keep',\n    },\n};\n"],"names":[],"mappings":";;;;;;;AAuBO,MAAM,wBAAwC,EAAA,CAAC;AAEtD,qBAAsB,CAAA,yMAAA,CAAc,IAAI,CAAI,GAAA,KAAA,CAAA,CAAA;AAE5C,qBAAsB,CAAA,yMAAA,CAAc,QAAQ,CAAI,GAAA;IAC5C,gBAAkB,EAAA,CAAA;IAClB,eAAiB,EAAA,CAAA;AACrB,CAAA,CAAA;AAEA,qBAAsB,CAAA,yMAAA,CAAc,kBAAkB,CAAI,GAAA;IACtD,YAAc,EAAA;QACV,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,iBAAA;IAAA,CACZ;IACA,WAAa,EAAA;QACT,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,iBAAA;IAAA,CACZ;AACJ,CAAA,CAAA;AAEA,qBAAsB,CAAA,yMAAA,CAAc,qBAAqB,CAAI,GAAA;IACzD,YAAc,EAAA;QACV,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,iBAAA;IAAA,CACZ;IACA,WAAa,EAAA;QACT,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,iBAAA;IAAA,CACZ;AACJ,CAAA,CAAA;AAEA,qBAAsB,CAAA,yMAAA,CAAc,WAAW,CAAI,GAAA;IAC/C,gBAAkB,EAAA,CAAA;IAClB,YAAc,EAAA;QACV,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,MAAA;IAAA,CACZ;IACA,WAAa,EAAA;QACT,OAAS,EAAA,OAAA;QACT,MAAQ,EAAA,MAAA;IAAA,CACZ;AACJ,CAAA,CAAA;AAEA,qBAAsB,CAAA,yMAAA,CAAc,mBAAmB,CAAI,GAAA;IACvD,gBAAkB,EAAA,CAAA;IAClB,YAAc,EAAA;QACV,OAAS,EAAA,WAAA;QACT,MAAQ,EAAA,MAAA;IAAA,CACZ;IACA,WAAa,EAAA;QACT,OAAS,EAAA,WAAA;QACT,MAAQ,EAAA,MAAA;IAAA,CACZ;AACJ,CAAA"}},
    {"offset": {"line": 5525, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/pipeline/PipelineSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes';\nimport { STENCIL_MODES } from '../../shared/state/const';\nimport { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { State } from '../../shared/state/State';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuRenderTarget } from '../renderTarget/GpuRenderTarget';\nimport type { GpuProgram } from '../shader/GpuProgram';\nimport type { StencilState } from '../state/GpuStencilModesToPixi';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\nconst topologyStringToId = {\n    'point-list': 0,\n    'line-list': 1,\n    'line-strip': 2,\n    'triangle-list': 3,\n    'triangle-strip': 4,\n};\n\n// geometryLayouts = 256; // 8 bits // 256 states // value 0-255;\n// shaderKeys = 256; // 8 bits // 256 states // value 0-255;\n// state = 64; // 6 bits // 64 states // value 0-63;\n// blendMode = 32; // 5 bits // 32 states // value 0-31;\n// topology = 8; // 3 bits // 8 states // value 0-7;\nfunction getGraphicsStateKey(\n    geometryLayout: number,\n    shaderKey: number,\n    state: number,\n    blendMode: number,\n    topology: number,\n): number\n{\n    return (geometryLayout << 24) // Allocate the 8 bits for geometryLayouts at the top\n         | (shaderKey << 16) // Next 8 bits for shaderKeys\n         | (state << 10) // 6 bits for state\n         | (blendMode << 5) // 5 bits for blendMode\n         | topology; // And 3 bits for topology at the least significant position\n}\n\n// colorMask = 16;// 4 bits // 16 states // value 0-15;\n// stencilState = 8; // 3 bits // 8 states // value 0-7;\n// renderTarget = 1; // 2 bit // 3 states // value 0-3; // none, stencil, depth, depth-stencil\n// multiSampleCount = 1; // 1 bit // 2 states // value 0-1;\n// colorTargetCount = 4; // 2 bits // 4 states // value 0-3; // supports 1-4 color targets\nfunction getGlobalStateKey(\n    stencilStateId: number,\n    multiSampleCount: number,\n    colorMask: number,\n    renderTarget: number,\n    colorTargetCount: number,\n): number\n{\n    return (colorMask << 8) // Allocate the 4 bits for colorMask at the top\n         | (stencilStateId << 5) // Next 3 bits for stencilStateId\n         | (renderTarget << 3) // 2 bits for renderTarget\n         | (colorTargetCount << 1) // 2 bits for colorTargetCount\n         | multiSampleCount; // And 1 bit for multiSampleCount at the least significant position\n}\n\ntype PipeHash = Record<number, GPURenderPipeline>;\n\n/**\n * A system that creates and manages the GPU pipelines.\n *\n * Caching Mechanism: At its core, the system employs a two-tiered caching strategy to minimize\n * the redundant creation of GPU pipelines (or \"pipes\"). This strategy is based on generating unique\n * keys that represent the state of the graphics settings and the specific requirements of the\n * item being rendered. By caching these pipelines, subsequent draw calls with identical configurations\n * can reuse existing pipelines instead of generating new ones.\n *\n * State Management: The system differentiates between \"global\" state properties (like color masks\n * and stencil masks, which do not change frequently) and properties that may vary between draw calls\n * (such as geometry, shaders, and blend modes). Unique keys are generated for both these categories\n * using getStateKey for global state and getGraphicsStateKey for draw-specific settings. These keys are\n * then then used to caching the pipe. The next time we need a pipe we can check\n * the cache by first looking at the state cache and then the pipe cache.\n * @category rendering\n * @advanced\n */\nexport class PipelineSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'pipeline',\n    } as const;\n    private readonly _renderer: WebGPURenderer;\n\n    protected CONTEXT_UID: number;\n\n    private _moduleCache: Record<string, GPUShaderModule> = Object.create(null);\n    private _bufferLayoutsCache: Record<number, GPUVertexBufferLayout[]> = Object.create(null);\n    private readonly _bindingNamesCache: Record<string, Record<string, string>> = Object.create(null);\n\n    private _pipeCache: PipeHash = Object.create(null);\n    private readonly _pipeStateCaches: Record<number, PipeHash> = Object.create(null);\n\n    private _gpu: GPU;\n    private _stencilState: StencilState;\n\n    private _stencilMode: STENCIL_MODES;\n    private _colorMask = 0b1111;\n    private _multisampleCount = 1;\n    private _colorTargetCount = 1;\n    private _depthStencilAttachment: 0 | 1;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n        this.setStencilMode(STENCIL_MODES.DISABLED);\n\n        this._updatePipeHash();\n    }\n\n    public setMultisampleCount(multisampleCount: number): void\n    {\n        if (this._multisampleCount === multisampleCount) return;\n\n        this._multisampleCount = multisampleCount;\n\n        this._updatePipeHash();\n    }\n\n    public setRenderTarget(renderTarget: GpuRenderTarget)\n    {\n        this._multisampleCount = renderTarget.msaaSamples;\n        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n        this._colorTargetCount = renderTarget.colorTargetCount;\n        this._updatePipeHash();\n    }\n\n    public setColorMask(colorMask: number): void\n    {\n        if (this._colorMask === colorMask) return;\n\n        this._colorMask = colorMask;\n\n        this._updatePipeHash();\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES): void\n    {\n        if (this._stencilMode === stencilMode) return;\n\n        this._stencilMode = stencilMode;\n        this._stencilState = GpuStencilModesToPixi[stencilMode];\n\n        this._updatePipeHash();\n    }\n\n    public setPipeline(geometry: Geometry, program: GpuProgram, state: State, passEncoder: GPURenderPassEncoder): void\n    {\n        const pipeline = this.getPipeline(geometry, program, state);\n\n        passEncoder.setPipeline(pipeline);\n    }\n\n    public getPipeline(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: State,\n        topology?: Topology,\n    ): GPURenderPipeline\n    {\n        if (!geometry._layoutKey)\n        {\n            ensureAttributes(geometry, program.attributeData);\n\n            // prepare the geometry for the pipeline\n            this._generateBufferKey(geometry);\n        }\n\n        topology ||= geometry.topology;\n\n        // now we have set the Ids - the key is different...\n        const key = getGraphicsStateKey(\n            geometry._layoutKey,\n            program._layoutKey,\n            state.data,\n            state._blendModeId,\n            topologyStringToId[topology],\n        );\n\n        if (this._pipeCache[key]) return this._pipeCache[key];\n\n        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n\n        return this._pipeCache[key];\n    }\n\n    private _createPipeline(geometry: Geometry, program: GpuProgram, state: State, topology: Topology): GPURenderPipeline\n    {\n        const device = this._gpu.device;\n\n        const buffers = this._createVertexBufferLayouts(geometry, program);\n\n        const blendModes = this._renderer.state.getColorTargets(state, this._colorTargetCount);\n\n        // Apply write mask to all color targets\n        const writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n\n        for (let i = 0; i < blendModes.length; i++)\n        {\n            blendModes[i].writeMask = writeMask;\n        }\n\n        const layout = this._renderer.shader.getProgramData(program).pipeline;\n\n        const descriptor: GPURenderPipelineDescriptor = {\n            // TODO later check if its helpful to create..\n            // layout,\n            vertex: {\n                module: this._getModule(program.vertex.source),\n                entryPoint: program.vertex.entryPoint,\n                // geometry..\n                buffers,\n            },\n            fragment: {\n                module: this._getModule(program.fragment.source),\n                entryPoint: program.fragment.entryPoint,\n                targets: blendModes,\n            },\n            primitive: {\n                topology,\n                cullMode: state.cullMode,\n            },\n            layout,\n            multisample: {\n                count: this._multisampleCount,\n            },\n            // depthStencil,\n            label: `PIXI Pipeline`,\n        };\n\n        // only apply if the texture has stencil or depth\n        if (this._depthStencilAttachment)\n        {\n            // mask states..\n            descriptor.depthStencil = {\n                ...this._stencilState,\n                format: 'depth24plus-stencil8',\n                depthWriteEnabled: state.depthTest,\n                depthCompare: state.depthTest ? 'less' : 'always',\n            };\n        }\n\n        const pipeline = device.createRenderPipeline(descriptor);\n\n        return pipeline;\n    }\n\n    private _getModule(code: string): GPUShaderModule\n    {\n        return this._moduleCache[code] || this._createModule(code);\n    }\n\n    private _createModule(code: string): GPUShaderModule\n    {\n        const device = this._gpu.device;\n\n        this._moduleCache[code] = device.createShaderModule({\n            code,\n        });\n\n        return this._moduleCache[code];\n    }\n\n    private _generateBufferKey(geometry: Geometry): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(geometry.attributes).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = geometry.attributes[attributeKeys[i]];\n\n            keyGen[index++] = attribute.offset;\n            keyGen[index++] = attribute.format;\n            keyGen[index++] = attribute.stride;\n            keyGen[index++] = attribute.instance;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        geometry._layoutKey = createIdFromString(stringKey, 'geometry');\n\n        return geometry._layoutKey;\n    }\n\n    private _generateAttributeLocationsKey(program: GpuProgram): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(program.attributeData).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = program.attributeData[attributeKeys[i]];\n\n            keyGen[index++] = attribute.location;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        program._attributeLocationsKey = createIdFromString(stringKey, 'programAttributes');\n\n        return program._attributeLocationsKey;\n    }\n\n    /**\n     * Returns a hash of buffer names mapped to bind locations.\n     * This is used to bind the correct buffer to the correct location in the shader.\n     * @param geometry - The geometry where to get the buffer names\n     * @param program - The program where to get the buffer names\n     * @returns An object of buffer names mapped to the bind location.\n     */\n    public getBufferNamesToBind(geometry: Geometry, program: GpuProgram): Record<string, string>\n    {\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bindingNamesCache[key]) return this._bindingNamesCache[key];\n\n        const data = this._createVertexBufferLayouts(geometry, program);\n\n        // now map the data to the buffers..\n        const bufferNamesToBind: Record<string, string> = Object.create(null);\n\n        const attributeData = program.attributeData;\n\n        for (let i = 0; i < data.length; i++)\n        {\n            const attributes = Object.values(data[i].attributes);\n\n            const shaderLocation = attributes[0].shaderLocation;\n\n            for (const j in attributeData)\n            {\n                if (attributeData[j].location === shaderLocation)\n                {\n                    bufferNamesToBind[i] = j;\n                    break;\n                }\n            }\n        }\n\n        this._bindingNamesCache[key] = bufferNamesToBind;\n\n        return bufferNamesToBind;\n    }\n\n    private _createVertexBufferLayouts(geometry: Geometry, program: GpuProgram): GPUVertexBufferLayout[]\n    {\n        if (!program._attributeLocationsKey) this._generateAttributeLocationsKey(program);\n\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bufferLayoutsCache[key])\n        {\n            return this._bufferLayoutsCache[key];\n        }\n\n        const vertexBuffersLayout: GPUVertexBufferLayout[] = [];\n\n        geometry.buffers.forEach((buffer) =>\n        {\n            const bufferEntry: GPUVertexBufferLayout = {\n                arrayStride: 0,\n                stepMode: 'vertex',\n                attributes: [],\n            };\n\n            const bufferEntryAttributes = bufferEntry.attributes as GPUVertexAttribute[];\n\n            for (const i in program.attributeData)\n            {\n                const attribute = geometry.attributes[i];\n\n                if ((attribute.divisor ?? 1) !== 1)\n                {\n                    // TODO: Maybe emulate divisor with storage_buffers/float_textures?\n                    // For now just issue a warning\n                    warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. `\n                        + 'WebGPU only supports a divisor value of 1');\n                }\n\n                if (attribute.buffer === buffer)\n                {\n                    bufferEntry.arrayStride = attribute.stride;\n                    bufferEntry.stepMode = attribute.instance ? 'instance' : 'vertex';\n\n                    bufferEntryAttributes.push({\n                        shaderLocation: program.attributeData[i].location,\n                        offset: attribute.offset,\n                        format: attribute.format,\n                    });\n                }\n            }\n\n            if (bufferEntryAttributes.length)\n            {\n                vertexBuffersLayout.push(bufferEntry);\n            }\n        });\n\n        this._bufferLayoutsCache[key] = vertexBuffersLayout;\n\n        return vertexBuffersLayout;\n    }\n\n    private _updatePipeHash(): void\n    {\n        const key = getGlobalStateKey(\n            this._stencilMode,\n            this._multisampleCount,\n            this._colorMask,\n            this._depthStencilAttachment,\n            this._colorTargetCount,\n        );\n\n        if (!this._pipeStateCaches[key])\n        {\n            this._pipeStateCaches[key] = Object.create(null);\n        }\n\n        this._pipeCache = this._pipeStateCaches[key];\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        this._bufferLayoutsCache = null;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5776, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/calculateProjection.ts"],"sourcesContent":["import type { Matrix } from '../../../../maths/matrix/Matrix';\n\n/**\n * @param pm\n * @param x\n * @param y\n * @param width\n * @param height\n * @param flipY\n * @internal\n */\nexport function calculateProjection(\n    pm: Matrix,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    flipY: boolean\n): Matrix\n{\n    const sign = flipY ? 1 : -1;\n\n    pm.identity();\n\n    pm.a = (1 / width * 2);\n    pm.d = sign * (1 / height * 2);\n\n    pm.tx = -1 - (x * pm.a);\n    pm.ty = -sign - (y * pm.d);\n\n    return pm;\n}\n"],"names":[],"mappings":";;;;;AAWO,SAAS,oBACZ,EACA,EAAA,CAAA,EACA,CACA,EAAA,KAAA,EACA,MAAA,EACA,KAEJ,EAAA;IACU,MAAA,IAAA,GAAO,QAAQ,CAAI,GAAA,CAAA,CAAA,CAAA;IAEzB,EAAA,CAAG,QAAS,EAAA,CAAA;IAET,EAAA,CAAA,CAAA,GAAK,IAAI,KAAQ,GAAA,CAAA,CAAA;IACjB,EAAA,CAAA,CAAA,GAAI,IAAQ,GAAA,CAAA,CAAA,GAAI,MAAS,GAAA,CAAA,CAAA,CAAA;IAEzB,EAAA,CAAA,EAAA,GAAK,CAAM,CAAA,GAAA,CAAA,GAAI,EAAG,CAAA,CAAA,CAAA;IACrB,EAAA,CAAG,EAAK,GAAA,CAAC,IAAQ,GAAA,CAAA,GAAI,EAAG,CAAA,CAAA,CAAA;IAEjB,OAAA,EAAA,CAAA;AACX"}},
    {"offset": {"line": 5796, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/isRenderingToScreen.ts"],"sourcesContent":["/* eslint-disable no-restricted-globals */\nimport type { RenderTarget } from './RenderTarget';\n\n/**\n * Checks if the render target is viewable on the screen\n * Basically, is it a canvas element and is that canvas element in the DOM\n * @param renderTarget - the render target to check\n * @returns true if the render target is viewable on the screen\n * @internal\n */\nexport function isRenderingToScreen(renderTarget: RenderTarget): boolean\n{\n    const resource = renderTarget.colorTexture.source.resource;\n\n    return ((globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement) && document.body.contains(resource));\n}\n"],"names":[],"mappings":";;;;;AAUO,SAAS,oBAAoB,YACpC,EAAA;IACU,MAAA,QAAA,GAAW,YAAa,CAAA,YAAA,CAAa,MAAO,CAAA,QAAA,CAAA;IAElD,OAAS,WAAW,iBAAqB,IAAA,QAAA,YAAoB,qBAAsB,QAAS,CAAA,IAAA,CAAK,QAAA,CAAS,QAAQ,CAAA,CAAA;AACtH"}},
    {"offset": {"line": 5811, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTargetSystem.ts"],"sourcesContent":["import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { CLEAR } from '../../gl/const';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection';\nimport { SystemRunner } from '../system/SystemRunner';\nimport { CanvasSource } from '../texture/sources/CanvasSource';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\nimport { isRenderingToScreen } from './isRenderingToScreen';\nimport { RenderTarget } from './RenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { GlRenderTarget } from '../../gl/GlRenderTarget';\nimport type { GpuRenderTarget } from '../../gpu/renderTarget/GpuRenderTarget';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * A render surface is a texture, canvas, or render target\n * @category rendering\n * @see environment.ICanvas\n * @see Texture\n * @see RenderTarget\n * @advanced\n */\nexport type RenderSurface = ICanvas | BindableTexture | RenderTarget;\n\n/**\n * stores a render target and its frame\n * @ignore\n */\ninterface RenderTargetAndFrame\n{\n    /** the render target */\n    renderTarget: RenderTarget;\n    /** the frame to use when using the render target */\n    frame: Rectangle\n}\n\n/**\n * An adaptor interface for RenderTargetSystem to support WebGL and WebGPU.\n * This is used internally by the renderer, and is not intended to be used directly.\n * @ignore\n */\nexport interface RenderTargetAdaptor<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget>\n{\n    init(\n        /** the renderer */\n        renderer: Renderer,\n        /** the render target system */\n        renderTargetSystem: RenderTargetSystem<RENDER_TARGET>\n    ): void\n\n    /** A function copies the contents of a render surface to a texture */\n    copyToTexture(\n        /** the render surface to copy from  */\n        sourceRenderSurfaceTexture: RenderTarget,\n        /** the texture to copy to */\n        destinationTexture: Texture,\n        /** the origin of the copy */\n        originSrc: { x: number; y: number },\n        /** the size of the copy */\n        size: { width: number; height: number },\n        /** the destination origin (top left to paste from!) */\n        originDest?: { x: number; y: number },\n    ): Texture\n\n    /** starts a render pass on the render target */\n    startRenderPass(\n        /** the render target to start the render pass on */\n        renderTarget: RenderTarget,\n        /* the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111* */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** clears the current render target to the specified color */\n    clear(\n        /** the render target to clear */\n        renderTarget: RenderTarget,\n        /** the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111 */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to   */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** finishes the current render pass */\n    finishRenderPass(renderTarget: RenderTarget): void\n\n    /** called after the render pass is finished */\n    postrender?(renderTarget: RenderTarget): void;\n\n    /** called before the render main pass is started */\n    prerender?(renderTarget: RenderTarget): void;\n\n    /**\n     * initializes a gpu render target. Both renderers use this function to initialize a gpu render target\n     * Its different type of object depending on the renderer.\n     */\n    initGpuRenderTarget(\n        /** the render target to initialize */\n        renderTarget: RenderTarget\n    ): RENDER_TARGET\n\n    /** called when a render target is resized */\n    resizeGpuRenderTarget(\n        /** the render target to resize */\n        renderTarget: RenderTarget\n    ): void\n\n    /** destroys the gpu render target */\n    destroyGpuRenderTarget(\n        /** the render target to destroy */\n        gpuRenderTarget: RENDER_TARGET\n    ): void\n}\n\n/**\n * A system that manages render targets. A render target is essentially a place where the shaders can color in the pixels.\n * The render target system is responsible for binding the render target to the renderer, and managing the viewport.\n * Render targets can be pushed and popped.\n *\n * To make it easier, you can also bind textures and canvases too. This will automatically create a render target for you.\n * The render target itself is a lot more powerful than just a texture or canvas,\n * as it can have multiple textures attached to it.\n * It will also give ou fine grain control over the stencil buffer / depth texture.\n * @example\n *\n * ```js\n *\n * // create a render target\n * const renderTarget = new RenderTarget({\n *   colorTextures: [new TextureSource({ width: 100, height: 100 })],\n * });\n *\n * // bind the render target\n * renderer.renderTarget.bind(renderTarget);\n *\n * // draw something!\n * ```\n * @category rendering\n * @advanced\n */\nexport class RenderTargetSystem<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget> implements System\n{\n    /** When rendering of a scene begins, this is where the root render surface is stored */\n    public rootRenderTarget: RenderTarget;\n    /** This is the root viewport for the render pass*/\n    public rootViewPort = new Rectangle();\n    /** A boolean that lets the dev know if the current render pass is rendering to the screen. Used by some plugins */\n    public renderingToScreen: boolean;\n    /** the current active render target */\n    public renderTarget: RenderTarget;\n    /** the current active render surface that the render target is created from */\n    public renderSurface: RenderSurface;\n    /** the current viewport that the gpu is using */\n    public readonly viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    public readonly onRenderTargetChange = new SystemRunner('onRenderTargetChange');\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    public readonly projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    public readonly defaultClearColor: RgbaArray = [0, 0, 0, 0];\n    /** a reference to the adaptor that interfaces with WebGL / WebGP */\n    public readonly adaptor: RenderTargetAdaptor<RENDER_TARGET>;\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    private readonly _renderSurfaceToRenderTargetHash: Map<RenderSurface, RenderTarget>\n        = new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    private _gpuRenderTargetHash: Record<number, RENDER_TARGET> = Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    private readonly _renderTargetStack: RenderTargetAndFrame[] = [];\n    /** A reference to the renderer */\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuRenderTargetHash');\n    }\n\n    /** called when dev wants to finish a render pass */\n    public finishRenderPass()\n    {\n        this.adaptor.finishRenderPass(this.renderTarget);\n    }\n\n    /**\n     * called when the renderer starts to render a scene.\n     * @param options\n     * @param options.target - the render target to render to\n     * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param options.clearColor - the color to clear to\n     * @param options.frame - the frame to render to\n     */\n    public renderStart({\n        target,\n        clear,\n        clearColor,\n        frame\n    }: {\n        target: RenderSurface;\n        clear: CLEAR_OR_BOOL;\n        clearColor: RgbaArray;\n        frame?: Rectangle\n    }): void\n    {\n        // TODO no need to reset this - use optimised index instead\n        this._renderTargetStack.length = 0;\n\n        this.push(\n            target,\n            clear,\n            clearColor,\n            frame\n        );\n\n        this.rootViewPort.copyFrom(this.viewport);\n        this.rootRenderTarget = this.renderTarget;\n        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n\n        this.adaptor.prerender?.(this.rootRenderTarget);\n    }\n\n    public postrender()\n    {\n        this.adaptor.postrender?.(this.rootRenderTarget);\n    }\n\n    /**\n     * Binding a render surface! This is the main function of the render target system.\n     * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n     * Once bound all draw calls will be rendered to the render surface.\n     *\n     * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n     * @param renderSurface - the render surface to bind\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to render to\n     * @returns the render target that was bound\n     */\n    public bind(\n        renderSurface: RenderSurface,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    ): RenderTarget\n    {\n        const renderTarget = this.getRenderTarget(renderSurface);\n\n        const didChange = this.renderTarget !== renderTarget;\n\n        this.renderTarget = renderTarget;\n        this.renderSurface = renderSurface;\n\n        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.pixelWidth !== gpuRenderTarget.width\n            || renderTarget.pixelHeight !== gpuRenderTarget.height)\n        {\n            this.adaptor.resizeGpuRenderTarget(renderTarget);\n\n            gpuRenderTarget.width = renderTarget.pixelWidth;\n            gpuRenderTarget.height = renderTarget.pixelHeight;\n        }\n\n        const source = renderTarget.colorTexture;\n        const viewport = this.viewport;\n\n        const pixelWidth = source.pixelWidth;\n        const pixelHeight = source.pixelHeight;\n\n        if (!frame && renderSurface instanceof Texture)\n        {\n            frame = renderSurface.frame;\n        }\n\n        if (frame)\n        {\n            const resolution = source._resolution;\n\n            viewport.x = ((frame.x * resolution) + 0.5) | 0;\n            viewport.y = ((frame.y * resolution) + 0.5) | 0;\n            viewport.width = ((frame.width * resolution) + 0.5) | 0;\n            viewport.height = ((frame.height * resolution) + 0.5) | 0;\n        }\n        else\n        {\n            viewport.x = 0;\n            viewport.y = 0;\n            viewport.width = pixelWidth;\n            viewport.height = pixelHeight;\n        }\n\n        calculateProjection(\n            this.projectionMatrix,\n            0, 0,\n            viewport.width / source.resolution,\n            viewport.height / source.resolution,\n            !renderTarget.isRoot\n        );\n\n        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n\n        if (didChange)\n        {\n            this.onRenderTargetChange.emit(renderTarget);\n        }\n\n        return renderTarget;\n    }\n\n    public clear(\n        target?: RenderSurface,\n        clear: CLEAR_OR_BOOL = CLEAR.ALL,\n        clearColor?: RgbaArray,\n    )\n    {\n        if (!clear) return;\n\n        if (target)\n        {\n            target = this.getRenderTarget(target);\n        }\n\n        this.adaptor.clear(\n            (target as RenderTarget) || this.renderTarget,\n            clear,\n            clearColor,\n            this.viewport\n        );\n    }\n\n    protected contextChange(): void\n    {\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    /**\n     * Push a render surface to the renderer. This will bind the render surface to the renderer,\n     * @param renderSurface - the render surface to push\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to use when rendering to the render surface\n     */\n    public push(\n        renderSurface: RenderSurface,\n        clear: CLEAR | boolean = CLEAR.ALL,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    )\n    {\n        const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n\n        this._renderTargetStack.push({\n            renderTarget,\n            frame,\n        });\n\n        return renderTarget;\n    }\n\n    /** Pops the current render target from the renderer and restores the previous render target. */\n    public pop()\n    {\n        this._renderTargetStack.pop();\n\n        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n\n        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n    }\n\n    /**\n     * Gets the render target from the provide render surface. Eg if its a texture,\n     * it will return the render target for the texture.\n     * If its a render target, it will return the same render target.\n     * @param renderSurface - the render surface to get the render target for\n     * @returns the render target for the render surface\n     */\n    public getRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        if (((renderSurface as Texture).isTexture))\n        {\n            renderSurface = (renderSurface as Texture).source;\n        }\n\n        return this._renderSurfaceToRenderTargetHash.get(renderSurface)\n        ?? this._initRenderTarget(renderSurface);\n    }\n\n    /**\n     * Copies a render surface to another texture.\n     *\n     * NOTE:\n     * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n     *\n     * The following is not valid:\n     * @example\n     * const canvas = document.createElement('canvas')\n     * canvas.width = 200;\n     * canvas.height = 200;\n     *\n     * const ctx = canvas2.getContext('2d')!\n     * ctx.fillStyle = 'red'\n     * ctx.fillRect(0, 0, 200, 200);\n     *\n     * const texture = RenderTexture.create({\n     *   width: 200,\n     *   height: 200,\n     * })\n     * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n     *\n     * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n     *\n     * The best way to copy a canvas is to create a texture from it. Then render with that.\n     *\n     * Parsing in a RenderTarget canvas context (with a 2d context)\n     * @param sourceRenderSurfaceTexture - the render surface to copy from\n     * @param destinationTexture - the texture to copy to\n     * @param originSrc - the origin of the copy\n     * @param originSrc.x - the x origin of the copy\n     * @param originSrc.y - the y origin of the copy\n     * @param size - the size of the copy\n     * @param size.width - the width of the copy\n     * @param size.height - the height of the copy\n     * @param originDest - the destination origin (top left to paste from!)\n     * @param originDest.x - the x origin of the paste\n     * @param originDest.y - the y origin of the paste\n     */\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number },\n        size: { width: number; height: number },\n        originDest: { x: number; y: number; },\n    )\n    {\n        // fit the size to the source we don't want to go out of bounds\n\n        if (originSrc.x < 0)\n        {\n            size.width += originSrc.x;\n            originDest.x -= originSrc.x;\n            originSrc.x = 0;\n        }\n\n        if (originSrc.y < 0)\n        {\n            size.height += originSrc.y;\n            originDest.y -= originSrc.y;\n            originSrc.y = 0;\n        }\n\n        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n\n        size.width = Math.min(size.width, pixelWidth - originSrc.x);\n        size.height = Math.min(size.height, pixelHeight - originSrc.y);\n\n        return this.adaptor.copyToTexture(\n            sourceRenderSurfaceTexture,\n            destinationTexture,\n            originSrc,\n            size,\n            originDest\n        );\n    }\n\n    /**\n     * ensures that we have a depth stencil buffer available to render to\n     * This is used by the mask system to make sure we have a stencil buffer.\n     */\n    public ensureDepthStencil()\n    {\n        if (!this.renderTarget.stencil)\n        {\n            this.renderTarget.stencil = true;\n\n            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n        }\n    }\n\n    /** nukes the render target system */\n    public destroy()\n    {\n        (this._renderer as null) = null;\n\n        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) =>\n        {\n            if (renderTarget !== key)\n            {\n                renderTarget.destroy();\n            }\n        });\n\n        this._renderSurfaceToRenderTargetHash.clear();\n\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    private _initRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        let renderTarget: RenderTarget = null;\n\n        if (CanvasSource.test(renderSurface))\n        {\n            renderSurface = getCanvasTexture(renderSurface as ICanvas).source;\n        }\n\n        if (renderSurface instanceof RenderTarget)\n        {\n            renderTarget = renderSurface;\n        }\n        else if (renderSurface instanceof TextureSource)\n        {\n            renderTarget = new RenderTarget({\n                colorTextures: [renderSurface],\n            });\n\n            if (renderSurface.source instanceof CanvasSource)\n            {\n                renderTarget.isRoot = true;\n            }\n\n            // TODO add a test for this\n            renderSurface.once('destroy', () =>\n            {\n                renderTarget.destroy();\n\n                this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n\n                const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n\n                if (gpuRenderTarget)\n                {\n                    this._gpuRenderTargetHash[renderTarget.uid] = null;\n                    this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n                }\n            });\n        }\n\n        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n\n        return renderTarget;\n    }\n\n    public getGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        return this._gpuRenderTargetHash[renderTarget.uid]\n        || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n    }\n\n    public resetState(): void\n    {\n        this.renderTarget = null;\n        this.renderSurface = null;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6092, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTarget.ts"],"sourcesContent":["import type { TextureSource } from '../../shared/texture/sources/TextureSource';\n\n/**\n * A class which holds the canvas contexts and textures for a render target.\n * @category rendering\n * @ignore\n */\nexport class GpuRenderTarget\n{\n    public contexts: GPUCanvasContext[] = [];\n    public msaaTextures: TextureSource[] = [];\n    public msaa: boolean;\n    public msaaSamples = 1;\n    public colorTargetCount: number;\n    public width: number;\n    public height: number;\n    public descriptor: GPURenderPassDescriptor;\n}\n"],"names":[],"mappings":";;;;;AAOO,MAAM,eACb,CAAA;IADO,WAAA,EAAA;QAEH,IAAA,CAAO,QAAA,GAA+B,EAAC,CAAA;QACvC,IAAA,CAAO,YAAA,GAAgC,EAAC,CAAA;QAExC,IAAA,CAAO,WAAc,GAAA,CAAA,CAAA;IAAA,CAAA;AAKzB"}},
    {"offset": {"line": 6110, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.ts"],"sourcesContent":["import { CLEAR } from '../../gl/const';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport { GpuRenderTarget } from './GpuRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * The WebGPU adaptor for the render target system. Allows the Render Target System to\n * be used with the WebGPU renderer\n * @category rendering\n * @ignore\n */\nexport class GpuRenderTargetAdaptor implements RenderTargetAdaptor<GpuRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GpuRenderTarget>;\n    private _renderer: WebGPURenderer<HTMLCanvasElement>;\n\n    public init(renderer: WebGPURenderer, renderTargetSystem: RenderTargetSystem<GpuRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderer = this._renderer;\n\n        const baseGpuTexture = this._getGpuColorTexture(\n            sourceRenderSurfaceTexture\n        );\n\n        const backGpuTexture = renderer.texture.getGpuSource(\n            destinationTexture.source\n        );\n\n        renderer.encoder.commandEncoder.copyTextureToTexture(\n            {\n                texture: baseGpuTexture,\n                origin: originSrc,\n            },\n            {\n                texture: backGpuTexture,\n                origin: originDest,\n            },\n            size\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n        gpuRenderTarget.descriptor = descriptor;\n\n        // TODO we should not finish a render pass each time we bind\n        // for example filters - we would want to push / pop render targets\n        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n        this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n        this._renderer.encoder.setViewport(viewport);\n    }\n\n    public finishRenderPass()\n    {\n        this._renderer.encoder.endRenderPass();\n    }\n\n    /**\n     * returns the gpu texture for the first color texture in the render target\n     * mainly used by the filter manager to get copy the texture for blending\n     * @param renderTarget\n     * @returns a gpu texture\n     */\n    private _getGpuColorTexture(renderTarget: RenderTarget): GPUTexture\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (gpuRenderTarget.contexts[0])\n        {\n            return gpuRenderTarget.contexts[0].getCurrentTexture();\n        }\n\n        return this._renderer.texture.getGpuSource(\n            renderTarget.colorTextures[0].source\n        );\n    }\n\n    public getDescriptor(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearValue: RgbaArray\n    ): GPURenderPassDescriptor\n    {\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const colorAttachments = renderTarget.colorTextures.map(\n            (texture, i) =>\n            {\n                const context = gpuRenderTarget.contexts[i];\n\n                let view: GPUTextureView;\n                let resolveTarget: GPUTextureView;\n\n                if (context)\n                {\n                    const currentTexture = context.getCurrentTexture();\n\n                    const canvasTextureView = currentTexture.createView();\n\n                    view = canvasTextureView;\n                }\n                else\n                {\n                    view = this._renderer.texture.getGpuSource(texture).createView({\n                        mipLevelCount: 1,\n                    });\n                }\n\n                if (gpuRenderTarget.msaaTextures[i])\n                {\n                    resolveTarget = view;\n                    view = this._renderer.texture.getTextureView(\n                        gpuRenderTarget.msaaTextures[i]\n                    );\n                }\n\n                const loadOp = ((clear as CLEAR) & CLEAR.COLOR ? 'clear' : 'load') as GPULoadOp;\n\n                clearValue ??= renderTargetSystem.defaultClearColor;\n\n                return {\n                    view,\n                    resolveTarget,\n                    clearValue,\n                    storeOp: 'store',\n                    loadOp\n                };\n            }\n        ) as GPURenderPassColorAttachment[];\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment;\n\n        // if we have a depth or stencil buffer, we need to ensure we have a texture for it\n        // this is WebGPU specific - as WebGL does not require textures to run a depth / stencil buffer\n        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture)\n        {\n            renderTarget.ensureDepthStencilTexture();\n            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n        }\n\n        if (renderTarget.depthStencilTexture)\n        {\n            const stencilLoadOp = (clear & CLEAR.STENCIL ? 'clear' : 'load') as GPULoadOp;\n            const depthLoadOp = (clear & CLEAR.DEPTH ? 'clear' : 'load') as GPULoadOp;\n\n            depthStencilAttachment = {\n                view: this._renderer.texture\n                    .getGpuSource(renderTarget.depthStencilTexture.source)\n                    .createView(),\n                stencilStoreOp: 'store',\n                stencilLoadOp,\n                depthClearValue: 1.0,\n                depthLoadOp,\n                depthStoreOp: 'store',\n            };\n        }\n\n        const descriptor: GPURenderPassDescriptor = {\n            colorAttachments,\n            depthStencilAttachment,\n        };\n\n        return descriptor;\n    }\n\n    public clear(renderTarget: RenderTarget, clear: CLEAR_OR_BOOL = true, clearColor?: RgbaArray, viewport?: Rectangle)\n    {\n        if (!clear) return;\n\n        const { gpu, encoder } = this._renderer;\n\n        const device = gpu.device;\n\n        const standAlone = encoder.commandEncoder === null;\n\n        if (standAlone)\n        {\n            const commandEncoder = device.createCommandEncoder();\n            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n\n            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n            passEncoder.end();\n\n            const gpuCommands = commandEncoder.finish();\n\n            device.queue.submit([gpuCommands]);\n        }\n        else\n        {\n            this.startRenderPass(renderTarget, clear, clearColor, viewport);\n        }\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GpuRenderTarget\n    {\n        // always true for WebGPU\n        renderTarget.isRoot = true;\n\n        const gpuRenderTarget = new GpuRenderTarget();\n\n        gpuRenderTarget.colorTargetCount = renderTarget.colorTextures.length;\n\n        // create a context...\n        // is a canvas...\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (colorTexture instanceof CanvasSource)\n            {\n                const context = colorTexture.resource.getContext(\n                    'webgpu'\n                ) as unknown as GPUCanvasContext;\n\n                const alphaMode = (colorTexture as CanvasSource).transparent ? 'premultiplied' : 'opaque';\n\n                try\n                {\n                    context.configure({\n                        device: this._renderer.gpu.device,\n                        usage: GPUTextureUsage.TEXTURE_BINDING\n                            | GPUTextureUsage.COPY_DST\n                            | GPUTextureUsage.RENDER_ATTACHMENT\n                            | GPUTextureUsage.COPY_SRC,\n                        format: 'bgra8unorm',\n                        alphaMode,\n                    });\n                }\n                catch (e)\n                {\n                    console.error(e);\n                }\n\n                gpuRenderTarget.contexts[i] = context;\n            }\n\n            gpuRenderTarget.msaa = colorTexture.source.antialias;\n\n            if (colorTexture.source.antialias)\n            {\n                const msaaTexture = new TextureSource({\n                    width: 0,\n                    height: 0,\n                    sampleCount: 4,\n                });\n\n                gpuRenderTarget.msaaTextures[i] = msaaTexture;\n            }\n        });\n\n        if (gpuRenderTarget.msaa)\n        {\n            gpuRenderTarget.msaaSamples = 4;\n\n            if (renderTarget.depthStencilTexture)\n            {\n                renderTarget.depthStencilTexture.source.sampleCount = 4;\n            }\n        }\n\n        return gpuRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GpuRenderTarget)\n    {\n        gpuRenderTarget.contexts.forEach((context) =>\n        {\n            context.unconfigure();\n        });\n\n        gpuRenderTarget.msaaTextures.forEach((texture) =>\n        {\n            texture.destroy();\n        });\n\n        gpuRenderTarget.msaaTextures.length = 0;\n        gpuRenderTarget.contexts.length = 0;\n    }\n\n    public ensureDepthStencilTexture(renderTarget: RenderTarget)\n    {\n        // TODO This function will be more useful once we cache the descriptors\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa)\n        {\n            renderTarget.depthStencilTexture.source.sampleCount = 4;\n        }\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        gpuRenderTarget.width = renderTarget.width;\n        gpuRenderTarget.height = renderTarget.height;\n\n        if (gpuRenderTarget.msaa)\n        {\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const msaaTexture = gpuRenderTarget.msaaTextures[i];\n\n                msaaTexture?.resize(\n                    colorTexture.source.width,\n                    colorTexture.source.height,\n                    colorTexture.source._resolution\n                );\n            });\n        }\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6312, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor';\n\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuRenderTarget } from './GpuRenderTarget';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @category rendering\n * @advanced\n */\nexport class GpuRenderTargetSystem extends RenderTargetSystem<GpuRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GpuRenderTargetAdaptor();\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAYO,MAAM,8BAA8B,kOAC3C,CAAA;IASI,YAAY,QACZ,CAAA;QACI,KAAA,CAAM,QAAQ,CAAA,CAAA;QAJX,IAAA,CAAA,OAAA,GAAU,IAAI,uOAAuB,EAAA,CAAA;QAMnC,IAAA,CAAA,OAAA,CAAQ,IAAK,CAAA,QAAA,EAAU,IAAI,CAAA,CAAA;IAAA,CACpC;AACJ,CAAA;AAAA,YAAA,GAhBa,qBAAA,CAGK,SAAY,GAAA;IACtB,IAAA,EAAM;QAAC,+KAAA,CAAc,YAAY;KAAA;IACjC,IAAM,EAAA,cAAA;AACV,CAAA"}},
    {"offset": {"line": 6342, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuShaderSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuProgram } from './GpuProgram';\n\n/**\n * Data structure for GPU program layout.\n * Contains bind group layouts and pipeline layout.\n * @category rendering\n * @advanced\n */\nexport interface GPUProgramData\n{\n    bindGroups: GPUBindGroupLayout[]\n    pipeline: GPUPipelineLayout\n}\n\n/**\n * A system that manages the rendering of GpuPrograms.\n * @category rendering\n * @advanced\n */\nexport class GpuShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    private _gpu: GPU;\n\n    private readonly _gpuProgramData: Record<number, GPUProgramData> = Object.create(null);\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getProgramData(program: GpuProgram)\n    {\n        return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n    }\n\n    private _createGPUProgramData(program: GpuProgram)\n    {\n        const device = this._gpu.device;\n\n        const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n\n        const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n\n        this._gpuProgramData[program._layoutKey] = {\n            bindGroups,\n            pipeline: device.createPipelineLayout(pipelineLayoutDesc),\n        };\n\n        // generally we avoid having to make this automatically\n        // keeping this for a reminder, if any issues popup\n        // program._gpuLayout = {\n        //     bindGroups: null,\n        //     pipeline: 'auto',\n        // };\n\n        return this._gpuProgramData[program._layoutKey];\n    }\n\n    public destroy(): void\n    {\n        // TODO destroy the _gpuProgramData\n        this._gpu = null;\n        (this._gpuProgramData as null) = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAsBO,MAAM,eACb,CAAA;IADO,WAAA,EAAA;QAYc,IAAA,CAAA,eAAA,GAAA,aAAA,GAAyD,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;IAAA,CAAA;IAE3E,cAAc,GACxB,EAAA;QACI,IAAA,CAAK,IAAO,GAAA,GAAA,CAAA;IAAA,CAChB;IAEO,eAAe,OACtB,EAAA;QACI,OAAO,IAAA,CAAK,eAAgB,CAAA,OAAA,CAAQ,UAAU,CAAK,IAAA,IAAA,CAAK,qBAAA,CAAsB,OAAO,CAAA,CAAA;IAAA,CACzF;IAEQ,sBAAsB,OAC9B,EAAA;QACU,MAAA,MAAA,GAAS,IAAA,CAAK,IAAK,CAAA,MAAA,CAAA;QAEzB,MAAM,UAAa,GAAA,OAAA,CAAQ,SAAU,CAAA,GAAA,CAAI,CAAC,KAAA,GAAU,MAAO,CAAA,qBAAA,CAAsB;gBAAE,OAAA,EAAS,KAAM;YAAA,CAAC,CAAC,CAAA,CAAA;QAE9F,MAAA,kBAAA,GAAqB;YAAE,gBAAA,EAAkB,UAAW;QAAA,CAAA,CAAA;QAErD,IAAA,CAAA,eAAA,CAAgB,OAAQ,CAAA,UAAU,CAAI,GAAA;YACvC,UAAA;YACA,QAAA,EAAU,MAAO,CAAA,oBAAA,CAAqB,kBAAkB,CAAA;QAAA,CAC5D,CAAA;QASO,OAAA,IAAA,CAAK,eAAgB,CAAA,OAAA,CAAQ,UAAU,CAAA,CAAA;IAAA,CAClD;IAEO,OACP,GAAA;QAEI,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;QACX,IAAA,CAAK,eAA2B,GAAA,IAAA,CAAA;IAAA,CACrC;AACJ,CAAA;AAAA,YAAA,GArDa,eAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,QAAA;AACV,CAAA"}},
    {"offset": {"line": 6390, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuBlendModesToPixi.ts"],"sourcesContent":["import type { BLEND_MODES } from '../../shared/state/const';\n\n/** @internal */\nexport const GpuBlendModesToPixi: Partial<Record<BLEND_MODES, GPUBlendState>> = {};\n\nGpuBlendModesToPixi.normal = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.add = {\n    alpha: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.multiply = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'dst',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.screen = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.overlay = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.none = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'zero',\n        operation: 'add',\n    },\n};\n\n// not-premultiplied blend modes\nGpuBlendModesToPixi['normal-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['add-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['screen-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.erase = {\n    alpha: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.min = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'min',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'min',\n    },\n};\n\nGpuBlendModesToPixi.max = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'max',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'max',\n    },\n};\n\n// composite operations\n// GpuBlendModesToPixi[BLEND_MODES.SRC_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OVER] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.XOR] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// TODO - fix me\n// GLBlendModesToPixi[BLEND_MODES.SUBTRACT] = {\n//     alpha: {\n//         srcFactor: 'one',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n"],"names":[],"mappings":";;;;;AAGO,MAAM,sBAAmE,CAAA,EAAC;AAEjF,mBAAA,CAAoB,MAAS,GAAA;IACzB,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,qBAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;IACA,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,qBAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;AACJ,CAAA,CAAA;AAEA,mBAAA,CAAoB,GAAM,GAAA;IACtB,KAAO,EAAA;QACH,SAAW,EAAA,WAAA;QACX,SAAW,EAAA,qBAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;IACA,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;AACJ,CAAA,CAAA;AAEA,mBAAA,CAAoB,QAAW,GAAA;IAC3B,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,qBAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;IACA,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,qBAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;AACJ,CAAA,CAAA;AAEA,mBAAA,CAAoB,MAAS,GAAA;IACzB,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,qBAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;IACA,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,eAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;AACJ,CAAA,CAAA;AAEA,mBAAA,CAAoB,OAAU,GAAA;IAC1B,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,qBAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;IACA,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,eAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;AACJ,CAAA,CAAA;AAEA,mBAAA,CAAoB,IAAO,GAAA;IACvB,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,qBAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;IACA,KAAO,EAAA;QACH,SAAW,EAAA,MAAA;QACX,SAAW,EAAA,MAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;AACJ,CAAA,CAAA;AAGA,mBAAA,CAAoB,YAAY,CAAI,GAAA;IAChC,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,qBAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;IACA,KAAO,EAAA;QACH,SAAW,EAAA,WAAA;QACX,SAAW,EAAA,qBAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;AACJ,CAAA,CAAA;AAEA,mBAAA,CAAoB,SAAS,CAAI,GAAA;IAC7B,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;IACA,KAAO,EAAA;QACH,SAAW,EAAA,WAAA;QACX,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;AACJ,CAAA,CAAA;AAEA,mBAAA,CAAoB,YAAY,CAAI,GAAA;IAChC,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,qBAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;IACA,KAAO,EAAA;QACH,SAAW,EAAA,WAAA;QACX,SAAW,EAAA,eAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;AACJ,CAAA,CAAA;AAEA,mBAAA,CAAoB,KAAQ,GAAA;IACxB,KAAO,EAAA;QACH,SAAW,EAAA,MAAA;QACX,SAAW,EAAA,qBAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;IACA,KAAO,EAAA;QACH,SAAW,EAAA,MAAA;QACX,SAAW,EAAA,eAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;AACJ,CAAA,CAAA;AAEA,mBAAA,CAAoB,GAAM,GAAA;IACtB,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;IACA,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;AACJ,CAAA,CAAA;AAEA,mBAAA,CAAoB,GAAM,GAAA;IACtB,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;IACA,KAAO,EAAA;QACH,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,KAAA;QACX,SAAW,EAAA,KAAA;IAAA,CACf;AACJ,CAAA"}},
    {"offset": {"line": 6546, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStateSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { State } from '../../shared/state/State';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\n\n/**\n * System plugin to the renderer to manage WebGL state machines.\n * @category rendering\n * @advanced\n */\nexport class GpuStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'state',\n    } as const;\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @type {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gpu: GPU;\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    constructor()\n    {\n        this.defaultState = new State();\n        this.defaultState.blend = true;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this.gpu = gpu;\n    }\n\n    /**\n     * Gets the blend mode data for the current state\n     * @param state - The state to get the blend mode from\n     * @param count - The number of color targets to create\n     */\n    public getColorTargets(state: State, count: number): GPUColorTargetState[]\n    {\n        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n\n        const targets: GPUColorTargetState[] = [];\n        const target = {\n            format: 'bgra8unorm',\n            writeMask: 0,\n            blend,\n        } as GPUColorTargetState;\n\n        for (let i = 0; i < count; i++)\n        {\n            targets[i] = target;\n        }\n\n        return targets;\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAaO,MAAM,cACb,CAAA;IA2CI,WACA,EAAA;QACS,IAAA,CAAA,YAAA,GAAe,IAAI,iMAAM,EAAA,CAAA;QAC9B,IAAA,CAAK,YAAA,CAAa,KAAQ,GAAA,IAAA,CAAA;IAAA,CAC9B;IAEU,cAAc,GACxB,EAAA;QACI,IAAA,CAAK,GAAM,GAAA,GAAA,CAAA;IAAA,CACf;IAAA;;;;GAAA,GAOO,eAAA,CAAgB,KAAA,EAAc,KACrC,EAAA;QACI,MAAM,KAAQ,GAAA,0NAAA,CAAoB,KAAM,CAAA,SAAS,CAAA,IAAK,0NAAoB,CAAA,MAAA,CAAA;QAE1E,MAAM,UAAiC,EAAC,CAAA;QACxC,MAAM,MAAS,GAAA;YACX,MAAQ,EAAA,YAAA;YACR,SAAW,EAAA,CAAA;YACX,KAAA;QAAA,CACJ,CAAA;QAEA,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,KAAA,EAAO,CAC3B,EAAA,CAAA;YACI,OAAA,CAAQ,CAAC,CAAI,GAAA,MAAA,CAAA;QAAA,CACjB;QAEO,OAAA,OAAA,CAAA;IAAA,CACX;IAEO,OACP,GAAA;QACI,IAAA,CAAK,GAAM,GAAA,IAAA,CAAA;IAAA,CACf;AACJ,CAAA;AAAA,YAAA,GAnFa,cAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,OAAA;AACV,CAAA"}},
    {"offset": {"line": 6598, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.ts"],"sourcesContent":["import type { BufferImageSource } from '../../../shared/texture/sources/BufferImageSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadBufferImageResource = {\n\n    type: 'image',\n\n    upload(source: BufferImageSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource;\n\n        const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n\n        const bytesPerPixel = resource.byteLength / total;\n\n        gpu.device.queue.writeTexture(\n            { texture: gpuTexture },\n            resource,\n            {\n                offset: 0,\n                rowsPerImage: source.pixelHeight,\n                bytesPerRow: source.pixelWidth * bytesPerPixel,\n            },\n            {\n                width: source.pixelWidth,\n                height: source.pixelHeight,\n                depthOrArrayLayers: 1,\n            }\n        );\n    }\n} as GpuTextureUploader<BufferImageSource>;\n\n"],"names":[],"mappings":";;;;;AAKO,MAAM,4BAA+B,GAAA;IAExC,IAAM,EAAA,OAAA;IAEN,MAAA,EAAO,MAA2B,EAAA,UAAA,EAAwB,GAC1D,EAAA;QACI,MAAM,WAAW,MAAO,CAAA,QAAA,CAAA;QAExB,MAAM,KAAS,GAAA,CAAA,MAAA,CAAO,UAAa,GAAA,CAAA,IAAA,CAAM,OAAO,WAAc,GAAA,CAAA,CAAA,CAAA;QAExD,MAAA,aAAA,GAAgB,SAAS,UAAa,GAAA,KAAA,CAAA;QAE5C,GAAA,CAAI,MAAA,CAAO,KAAM,CAAA,YAAA,CACb;YAAE,SAAS,UAAW;QAAA,CAAA,EACtB,QAAA,EACA;YACI,MAAQ,EAAA,CAAA;YACR,cAAc,MAAO,CAAA,WAAA;YACrB,WAAA,EAAa,OAAO,UAAa,GAAA,aAAA;QAAA,CACrC,EACA;YACI,OAAO,MAAO,CAAA,UAAA;YACd,QAAQ,MAAO,CAAA,WAAA;YACf,kBAAoB,EAAA,CAAA;QAAA,CACxB;IACJ,CACJ;AACJ"}},
    {"offset": {"line": 6628, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.ts"],"sourcesContent":["import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const blockDataMap: Record<string, {blockBytes: number, blockWidth: number, blockHeight: number}> = {\n    'bc1-rgba-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'bc2-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc3-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc7-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'etc1-rgb-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'etc2-rgba8unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'astc-4x4-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n};\n\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n/** @internal */\nexport const gpuUploadCompressedTextureResource = {\n\n    type: 'compressed',\n\n    upload(source: CompressedSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const blockData = blockDataMap[source.format] || defaultBlockData;\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n\n            gpu.device.queue.writeTexture(\n                {\n                    texture: gpuTexture,\n                    mipLevel: i\n                },\n                levelBuffer,\n                {\n                    offset: 0,\n                    bytesPerRow,\n                },\n                {\n                    width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n                    height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n                    depthOrArrayLayers: 1,\n                }\n            );\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GpuTextureUploader<CompressedSource>;\n\n"],"names":[],"mappings":";;;;;;;AAKO,MAAM,YAA8F,GAAA;IACvG,kBAAkB;QAAE,UAAA,EAAY;QAAG,UAAY,EAAA,CAAA;QAAG,aAAa,CAAE;IAAA,CAAA;IACjE,kBAAkB;QAAE,UAAA,EAAY;QAAI,UAAY,EAAA,CAAA;QAAG,aAAa,CAAE;IAAA,CAAA;IAClE,kBAAkB;QAAE,UAAA,EAAY;QAAI,UAAY,EAAA,CAAA;QAAG,aAAa,CAAE;IAAA,CAAA;IAClE,kBAAkB;QAAE,UAAA,EAAY;QAAI,UAAY,EAAA,CAAA;QAAG,aAAa,CAAE;IAAA,CAAA;IAClE,kBAAkB;QAAE,UAAA,EAAY;QAAG,UAAY,EAAA,CAAA;QAAG,aAAa,CAAE;IAAA,CAAA;IACjE,mBAAmB;QAAE,UAAA,EAAY;QAAI,UAAY,EAAA,CAAA;QAAG,aAAa,CAAE;IAAA,CAAA;IACnE,kBAAkB;QAAE,UAAA,EAAY;QAAI,UAAY,EAAA,CAAA;QAAG,aAAa,CAAE;IAAA,CAAA;AACtE,EAAA;AAEA,MAAM,mBAAmB;IAAE,UAAA,EAAY;IAAG,UAAY,EAAA,CAAA;IAAG,aAAa,CAAE;AAAA,CAAA,CAAA;AAGjE,MAAM,kCAAqC,GAAA;IAE9C,IAAM,EAAA,YAAA;IAEN,MAAA,EAAO,MAA0B,EAAA,UAAA,EAAwB,GACzD,EAAA;QACI,IAAI,WAAW,MAAO,CAAA,UAAA,CAAA;QACtB,IAAI,YAAY,MAAO,CAAA,WAAA,CAAA;QAEvB,MAAM,SAAY,GAAA,YAAA,CAAa,MAAO,CAAA,MAAM,CAAK,IAAA,gBAAA,CAAA;QAEjD,IAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,MAAO,CAAA,QAAA,CAAS,MAAA,EAAQ,CAC5C,EAAA,CAAA;YACU,MAAA,WAAA,GAAc,MAAO,CAAA,QAAA,CAAS,CAAC,CAAA,CAAA;YAErC,MAAM,cAAc,IAAK,CAAA,IAAA,CAAK,WAAW,SAAU,CAAA,UAAU,IAAI,SAAU,CAAA,UAAA,CAAA;YAE3E,GAAA,CAAI,MAAA,CAAO,KAAM,CAAA,YAAA,CACb;gBACI,OAAS,EAAA,UAAA;gBACT,QAAU,EAAA,CAAA;YAAA,CACd,EACA,WAAA,EACA;gBACI,MAAQ,EAAA,CAAA;gBACR,WAAA;YAAA,CACJ,EACA;gBACI,OAAO,IAAK,CAAA,IAAA,CAAK,WAAW,SAAU,CAAA,UAAU,IAAI,SAAU,CAAA,UAAA;gBAC9D,QAAQ,IAAK,CAAA,IAAA,CAAK,YAAY,SAAU,CAAA,WAAW,IAAI,SAAU,CAAA,WAAA;gBACjE,kBAAoB,EAAA,CAAA;YAAA,CACxB;YAGJ,QAAA,GAAW,IAAK,CAAA,GAAA,CAAI,QAAY,IAAA,CAAA,EAAG,CAAC,CAAA,CAAA;YACpC,SAAA,GAAY,IAAK,CAAA,GAAA,CAAI,SAAa,IAAA,CAAA,EAAG,CAAC,CAAA,CAAA;QAAA,CAC1C;IAAA,CACJ;AACJ"}},
    {"offset": {"line": 6708, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../../environment/adapter';\nimport { warn } from '../../../../../utils/logging/warn';\n\nimport type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadImageResource = {\n\n    type: 'image',\n\n    upload(source: TextureSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource as ImageBitmap | HTMLCanvasElement | OffscreenCanvas | HTMLImageElement;\n\n        if (!resource) return;\n\n        // WebGPU does not support HTMLImageElement\n        // so we need to convert it to a canvas\n        if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        {\n            const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);\n            const context = canvas.getContext('2d');\n\n            context.drawImage(resource, 0, 0, resource.width, resource.height);\n\n            // replace with the canvas - for future uploads\n            source.resource = canvas;\n\n            // #if _DEBUG\n            warn('ImageSource: Image element passed, converting to canvas and replacing resource.');\n            // #endif\n        }\n\n        const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n        const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        gpu.device.queue.copyExternalImageToTexture(\n            { source: resource },\n            { texture: gpuTexture, premultipliedAlpha },\n            {\n                width,\n                height,\n            }\n        );\n    }\n} as GpuTextureUploader<TextureSource>;\n\n"],"names":[],"mappings":";;;;;;;;;AAQO,MAAM,sBAAyB,GAAA;IAElC,IAAM,EAAA,OAAA;IAEN,MAAA,EAAO,MAAuB,EAAA,UAAA,EAAwB,GACtD,EAAA;QACI,MAAM,WAAW,MAAO,CAAA,QAAA,CAAA;QAExB,IAAI,CAAC,QAAA,EAAU,OAAA;QAIX,IAAA,UAAA,CAAW,gBAAoB,IAAA,QAAA,YAAoB,gBACvD,EAAA;YACU,MAAA,MAAA,GAAS,0KAAA,CAAW,GAAI,EAAA,CAAE,YAAA,CAAa,QAAS,CAAA,KAAA,EAAO,SAAS,MAAM,CAAA,CAAA;YACtE,MAAA,OAAA,GAAU,MAAO,CAAA,UAAA,CAAW,IAAI,CAAA,CAAA;YAEtC,OAAA,CAAQ,SAAA,CAAU,QAAU,EAAA,CAAA,EAAG,GAAG,QAAS,CAAA,KAAA,EAAO,SAAS,MAAM,CAAA,CAAA;YAGjE,MAAA,CAAO,QAAW,GAAA,MAAA,CAAA;gBAGlB,sKAAA,EAAK,iFAAiF,CAAA,CAAA;QAAA,CAE1F;QAEM,MAAA,KAAA,GAAQ,KAAK,GAAI,CAAA,UAAA,CAAW,KAAA,EAAO,MAAO,CAAA,aAAA,IAAiB,OAAO,UAAU,CAAA,CAAA;QAC5E,MAAA,MAAA,GAAS,KAAK,GAAI,CAAA,UAAA,CAAW,MAAA,EAAQ,MAAO,CAAA,cAAA,IAAkB,OAAO,WAAW,CAAA,CAAA;QAEhF,MAAA,kBAAA,GAAqB,OAAO,SAAc,KAAA,6BAAA,CAAA;QAEhD,GAAA,CAAI,MAAA,CAAO,KAAM,CAAA,0BAAA,CACb;YAAE,QAAQ,QAAS;QAAA,CAAA,EACnB;YAAE,OAAS,EAAA,UAAA;YAAY,kBAAmB;QAAA,CAAA,EAC1C;YACI,KAAA;YACA,MAAA;QAAA,CACJ;IACJ,CACJ;AACJ"}},
    {"offset": {"line": 6749, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.ts"],"sourcesContent":["import { gpuUploadImageResource } from './gpuUploadImageSource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadVideoResource = {\n\n    type: 'video',\n\n    upload(source: VideoSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        gpuUploadImageResource.upload(source, gpuTexture, gpu);\n    }\n} as GpuTextureUploader<VideoSource>;\n\n"],"names":[],"mappings":";;;;;;;AAOO,MAAM,sBAAyB,GAAA;IAElC,IAAM,EAAA,OAAA;IAEN,MAAA,EAAO,MAAqB,EAAA,UAAA,EAAwB,GACpD,EAAA;QAC2B,6OAAA,CAAA,MAAA,CAAO,MAAQ,EAAA,UAAA,EAAY,GAAG,CAAA,CAAA;IAAA,CACzD;AACJ"}},
    {"offset": {"line": 6768, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.ts"],"sourcesContent":["/**\n * A class which generates mipmaps for a GPUTexture.\n * Thanks to toji for the original implementation\n * https://github.com/toji/web-texture-tool/blob/main/src/webgpu-mipmap-generator.js\n * @category rendering\n * @ignore\n */\nexport class GpuMipmapGenerator\n{\n    public device: GPUDevice;\n    public sampler: GPUSampler;\n    public pipelines: Record<string, GPURenderPipeline>;\n\n    public mipmapShaderModule: any;\n\n    constructor(device: GPUDevice)\n    {\n        this.device = device;\n        this.sampler = device.createSampler({ minFilter: 'linear' });\n        // We'll need a new pipeline for every texture format used.\n        this.pipelines = {};\n    }\n\n    private _getMipmapPipeline(format: GPUTextureFormat)\n    {\n        let pipeline = this.pipelines[format];\n\n        if (!pipeline)\n        {\n            // Shader modules is shared between all pipelines, so only create once.\n            if (!this.mipmapShaderModule)\n            {\n                this.mipmapShaderModule = this.device.createShaderModule({\n                    code: /* wgsl */ `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `,\n                });\n            }\n\n            pipeline = this.device.createRenderPipeline({\n                layout: 'auto',\n                vertex: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'vertexMain',\n                },\n                fragment: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'fragmentMain',\n                    targets: [{ format }],\n                }\n            });\n\n            this.pipelines[format] = pipeline;\n        }\n\n        return pipeline;\n    }\n\n    /**\n     * Generates mipmaps for the given GPUTexture from the data in level 0.\n     * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n     * @returns {module:External.GPUTexture} - The originally passed texture\n     */\n    public generateMipmap(texture: GPUTexture)\n    {\n        const pipeline = this._getMipmapPipeline(texture.format);\n\n        if (texture.dimension === '3d' || texture.dimension === '1d')\n        {\n            throw new Error('Generating mipmaps for non-2d textures is currently unsupported!');\n        }\n\n        let mipTexture = texture;\n        const arrayLayerCount = texture.depthOrArrayLayers || 1; // Only valid for 2D textures.\n\n        // If the texture was created with RENDER_ATTACHMENT usage we can render directly between mip levels.\n        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n\n        if (!renderToSource)\n        {\n            // Otherwise we have to use a separate texture to render into. It can be one mip level smaller than the source\n            // texture, since we already have the top level.\n            const mipTextureDescriptor = {\n                size: {\n                    width: Math.ceil(texture.width / 2),\n                    height: Math.ceil(texture.height / 2),\n                    depthOrArrayLayers: arrayLayerCount,\n                },\n                format: texture.format,\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n                mipLevelCount: texture.mipLevelCount - 1,\n            };\n\n            mipTexture = this.device.createTexture(mipTextureDescriptor);\n        }\n\n        const commandEncoder = this.device.createCommandEncoder({});\n        // TODO: Consider making this static.\n        const bindGroupLayout = pipeline.getBindGroupLayout(0);\n\n        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer)\n        {\n            let srcView = texture.createView({\n                baseMipLevel: 0,\n                mipLevelCount: 1,\n                dimension: '2d',\n                baseArrayLayer: arrayLayer,\n                arrayLayerCount: 1,\n            });\n\n            let dstMipLevel = renderToSource ? 1 : 0;\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                const dstView = mipTexture.createView({\n                    baseMipLevel: dstMipLevel++,\n                    mipLevelCount: 1,\n                    dimension: '2d',\n                    baseArrayLayer: arrayLayer,\n                    arrayLayerCount: 1,\n                });\n\n                const passEncoder = commandEncoder.beginRenderPass({\n                    colorAttachments: [{\n                        view: dstView,\n                        storeOp: 'store',\n                        loadOp: 'clear',\n                        clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    }],\n                });\n\n                const bindGroup = this.device.createBindGroup({\n                    layout: bindGroupLayout,\n                    entries: [{\n                        binding: 0,\n                        resource: this.sampler,\n                    }, {\n                        binding: 1,\n                        resource: srcView,\n                    }],\n                });\n\n                passEncoder.setPipeline(pipeline);\n                passEncoder.setBindGroup(0, bindGroup);\n                passEncoder.draw(3, 1, 0, 0);\n\n                passEncoder.end();\n\n                srcView = dstView;\n            }\n        }\n\n        // If we didn't render to the source texture, finish by copying the mip results from the temporary mipmap texture\n        // to the source.\n        if (!renderToSource)\n        {\n            const mipLevelSize = {\n                width: Math.ceil(texture.width / 2),\n                height: Math.ceil(texture.height / 2),\n                depthOrArrayLayers: arrayLayerCount,\n            };\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                commandEncoder.copyTextureToTexture({\n                    texture: mipTexture,\n                    mipLevel: i - 1,\n                }, {\n                    texture,\n                    mipLevel: i,\n                }, mipLevelSize);\n\n                mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n                mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n            }\n        }\n\n        this.device.queue.submit([commandEncoder.finish()]);\n\n        if (!renderToSource)\n        {\n            mipTexture.destroy();\n        }\n\n        return texture;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 6945, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/texture/GpuTextureSystem.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { type GPUData } from '../../../../scene/view/ViewContainer';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\nimport { CanvasPool } from '../../shared/texture/CanvasPool';\nimport { BindGroup } from '../shader/BindGroup';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource';\nimport { blockDataMap, gpuUploadCompressedTextureResource } from './uploaders/gpuUploadCompressedTextureResource';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture, Texture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuTextureUploader } from './uploaders/GpuTextureUploader';\n\n/**\n * Stores GPU-specific data for a Texture instance in WebGL context.\n * @internal\n */\nexport class GPUTextureGpuData implements GPUData\n{\n    public gpuTexture: GPUTexture;\n    public textureView: GPUTextureView = null;\n\n    constructor(gpuTexture: GPUTexture)\n    {\n        this.gpuTexture = gpuTexture;\n    }\n\n    /** Destroys this GPU data instance. */\n    public destroy(): void\n    {\n        this.gpuTexture.destroy();\n        this.textureView = null;\n        this.gpuTexture = null;\n    }\n}\n\n/**\n * The system that handles textures for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    protected CONTEXT_UID: number;\n    private _gpuSamplers: Record<string, GPUSampler> = Object.create(null);\n    private _bindGroupHash: Record<string, BindGroup> = Object.create(null);\n\n    private readonly _uploads: Record<string, GpuTextureUploader> = {\n        image: gpuUploadImageResource,\n        buffer: gpuUploadBufferImageResource,\n        video: gpuUploadVideoResource,\n        compressed: gpuUploadCompressedTextureResource\n    };\n\n    private _gpu: GPU;\n    private _mipmapGenerator?: GpuMipmapGenerator;\n\n    private readonly _renderer: WebGPURenderer;\n    private readonly _managedTextures: GCManagedHash<TextureSource>;\n    /**\n     * @deprecated since 8.15.0\n     */\n    public get managedTextures(): Readonly<TextureSource[]> { return Object.values(this._managedTextures.items); }\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_bindGroupHash');\n        this._managedTextures = new GCManagedHash({\n            renderer,\n            type: 'resource',\n            onUnload: this.onSourceUnload.bind(this),\n            name: 'gpuTextureSource'\n        });\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    /**\n     * Initializes a texture source, if it has already been initialized nothing will happen.\n     * @param source - The texture source to initialize.\n     * @returns The initialized texture source.\n     */\n    public initSource(source: TextureSource): GPUTexture\n    {\n        return (source._gpuData[this._renderer.uid] as GPUTextureGpuData)?.gpuTexture || this._initSource(source);\n    }\n\n    private _initSource(source: TextureSource): GPUTexture\n    {\n        if (source.autoGenerateMipmaps)\n        {\n            const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n\n        if (source.uploadMethodId !== 'compressed')\n        {\n            usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n            usage |= GPUTextureUsage.COPY_SRC;\n        }\n\n        const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n        const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n        const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n\n        const textureDescriptor: GPUTextureDescriptor = {\n            label: source.label,\n            size: { width, height },\n            format: source.format,\n            sampleCount: source.sampleCount,\n            mipLevelCount: source.mipLevelCount,\n            dimension: source.dimension,\n            usage\n        };\n\n        const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n\n        source._gpuData[this._renderer.uid] = new GPUTextureGpuData(gpuTexture);\n\n        const added = this._managedTextures.add(source);\n\n        if (added)\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceResize, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n        }\n\n        this.onSourceUpdate(source);\n\n        return gpuTexture;\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gpuTexture = this.getGpuSource(source);\n\n        // destroyed!\n        if (!gpuTexture) return;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source);\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource): void\n    {\n        if (!this._mipmapGenerator)\n        {\n            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n        }\n\n        const gpuTexture = this.getGpuSource(source);\n\n        this._mipmapGenerator.generateMipmap(gpuTexture);\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        source.off('update', this.onSourceUpdate, this);\n        source.off('resize', this.onSourceResize, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n    }\n\n    protected onSourceResize(source: TextureSource): void\n    {\n        source._gcLastUsed = this._renderer.gc.now;\n\n        const gpuData = source._gpuData[this._renderer.uid] as GPUTextureGpuData;\n        const gpuTexture = gpuData?.gpuTexture;\n\n        if (!gpuTexture)\n        {\n            this.initSource(source);\n        }\n        else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight)\n        {\n            gpuData.destroy();\n            this._bindGroupHash[source.uid] = null;\n            source._gpuData[this._renderer.uid] = null;\n            this.initSource(source);\n        }\n    }\n\n    private _initSampler(sampler: TextureStyle): GPUSampler\n    {\n        this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n\n        return this._gpuSamplers[sampler._resourceId];\n    }\n\n    public getGpuSampler(sampler: TextureStyle): GPUSampler\n    {\n        return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGpuSource(source: TextureSource): GPUTexture\n    {\n        source._gcLastUsed = this._renderer.gc.now;\n\n        return (source._gpuData[this._renderer.uid] as GPUTextureGpuData)?.gpuTexture || this.initSource(source);\n    }\n\n    /**\n     * this returns s bind group for a specific texture, the bind group contains\n     * - the texture source\n     * - the texture style\n     * - the texture matrix\n     * This is cached so the bind group should only be created once per texture\n     * @param texture - the texture you want the bindgroup for\n     * @returns the bind group for the texture\n     */\n    public getTextureBindGroup(texture: Texture)\n    {\n        return this._bindGroupHash[texture.uid] || this._createTextureBindGroup(texture);\n    }\n\n    private _createTextureBindGroup(texture: Texture)\n    {\n        const source = texture.source;\n\n        this._bindGroupHash[texture.uid] = new BindGroup({\n            0: source,\n            1: source.style,\n            2: new UniformGroup({\n                uTextureMatrix: { type: 'mat3x3<f32>', value: texture.textureMatrix.mapCoord },\n            })\n        });\n\n        return this._bindGroupHash[texture.uid];\n    }\n\n    public getTextureView(texture: BindableTexture)\n    {\n        const source = texture.source;\n\n        source._gcLastUsed = this._renderer.gc.now;\n        let gpuData = source._gpuData[this._renderer.uid] as GPUTextureGpuData;\n        let textureView: GPUTextureView = null;\n\n        if (!gpuData)\n        {\n            this.initSource(source);\n            gpuData = source._gpuData[this._renderer.uid] as GPUTextureGpuData;\n        }\n\n        textureView = gpuData.textureView || gpuData.gpuTexture.createView();\n\n        return textureView;\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const renderer = this._renderer;\n\n        const commandEncoder = renderer.gpu.device.createCommandEncoder();\n\n        // create canvas\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = texture.source.pixelWidth;\n        canvas.height = texture.source.pixelHeight;\n\n        const context = canvas.getContext('webgpu') as unknown as GPUCanvasContext;\n\n        context.configure({\n            device: renderer.gpu.device,\n\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n            format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),\n            alphaMode: 'premultiplied',\n        });\n\n        commandEncoder.copyTextureToTexture({\n            texture: renderer.texture.getGpuSource(texture.source),\n            origin: {\n                x: 0,\n                y: 0,\n            },\n        }, {\n            texture: context.getCurrentTexture(),\n        }, {\n            width: canvas.width,\n            height: canvas.height,\n        });\n\n        renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const webGPUCanvas = this.generateCanvas(texture);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n\n        const context = canvasAndContext.context;\n\n        context.drawImage(webGPUCanvas, 0, 0);\n\n        const { width, height } = webGPUCanvas;\n\n        const imageData = context.getImageData(0, 0, width, height);\n\n        const pixels = new Uint8ClampedArray(imageData.data.buffer);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return { pixels, width, height };\n    }\n\n    public destroy(): void\n    {\n        this._managedTextures.destroy();\n        for (const k of Object.keys(this._bindGroupHash))\n        {\n            const key = Number(k);\n            const bindGroup = this._bindGroupHash[key];\n\n            bindGroup?.destroy();\n        }\n\n        (this._renderer as null) = null;\n        this._gpu = null;\n        this._mipmapGenerator = null;\n        this._gpuSamplers = null;\n        this._bindGroupHash = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BO,MAAM,iBACb,CAAA;IAII,YAAY,UACZ,CAAA;QAHA,IAAA,CAAO,WAA8B,GAAA,IAAA,CAAA;QAIjC,IAAA,CAAK,UAAa,GAAA,UAAA,CAAA;IAAA,CACtB;IAAA,qCAAA,GAGO,OACP,GAAA;QACI,IAAA,CAAK,UAAA,CAAW,OAAQ,EAAA,CAAA;QACxB,IAAA,CAAK,WAAc,GAAA,IAAA,CAAA;QACnB,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;IAAA,CACtB;AACJ,CAAA;AAOO,MAAM,gBACb,CAAA;IA8BI,YAAY,QACZ,CAAA;QArBQ,IAAA,CAAA,YAAA,GAAA,aAAA,GAAkD,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;QAC7D,IAAA,CAAA,cAAA,GAAA,aAAA,GAAmD,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;QAEtE,IAAA,CAAiB,QAA+C,GAAA;YAC5D,KAAO,EAAA,6OAAA;YACP,MAAQ,EAAA,2PAAA;YACR,KAAO,EAAA,6OAAA;YACP,UAAY,EAAA,uQAAA;QAAA,CAChB,CAAA;QAcI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;QACR,QAAA,CAAA,YAAA,CAAa,cAAe,CAAA,IAAA,EAAM,gBAAgB,CAAA,CAAA;QACtD,IAAA,CAAA,gBAAA,GAAmB,IAAI,qLAAc,CAAA;YACtC,QAAA;YACA,IAAM,EAAA,UAAA;YACN,QAAU,EAAA,IAAA,CAAK,cAAe,CAAA,IAAA,CAAK,IAAI,CAAA;YACvC,IAAM,EAAA,kBAAA;QAAA,CACT,CAAA,CAAA;IAAA,CACL;IAAA;;GAAA,GAZA,IAAW,eAA6C,GAAA;QAAE,OAAO,MAAO,CAAA,MAAA,CAAO,IAAK,CAAA,gBAAA,CAAiB,KAAK,CAAA,CAAA;IAAA,CAAG;IAcnG,cAAc,GACxB,EAAA;QACI,IAAA,CAAK,IAAO,GAAA,GAAA,CAAA;IAAA,CAChB;IAAA;;;;GAAA,GAOO,WAAW,MAClB,EAAA;QACY,OAAA,MAAA,CAAO,QAAA,CAAS,IAAK,CAAA,SAAA,CAAU,GAAG,CAAyB,EAAA,UAAA,IAAc,IAAK,CAAA,WAAA,CAAY,MAAM,CAAA,CAAA;IAAA,CAC5G;IAEQ,YAAY,MACpB,EAAA;QACI,IAAI,OAAO,mBACX,EAAA;YACI,MAAM,mBAAmB,IAAK,CAAA,GAAA,CAAI,MAAO,CAAA,UAAA,EAAY,OAAO,WAAW,CAAA,CAAA;YAEvE,MAAA,CAAO,aAAA,GAAgB,IAAK,CAAA,KAAA,CAAM,KAAK,IAAK,CAAA,gBAAgB,CAAC,CAAI,GAAA,CAAA,CAAA;QAAA,CACrE;QAEI,IAAA,KAAA,GAAQ,eAAgB,CAAA,eAAA,GAAkB,eAAgB,CAAA,QAAA,CAAA;QAE1D,IAAA,MAAA,CAAO,cAAA,KAAmB,YAC9B,EAAA;YACI,KAAA,IAAS,eAAgB,CAAA,iBAAA,CAAA;YACzB,KAAA,IAAS,eAAgB,CAAA,QAAA,CAAA;QAAA,CAC7B;QAEM,MAAA,SAAA,GAAY,iPAAa,CAAA,MAAA,CAAO,MAAM,CAAA,IAAK;YAAE,UAAA,EAAY,CAAG;YAAA,UAAA,EAAY,CAAG;YAAA,WAAA,EAAa,CAAE;QAAA,CAAA,CAAA;QAE1F,MAAA,KAAA,GAAQ,KAAK,IAAK,CAAA,MAAA,CAAO,UAAA,GAAa,SAAU,CAAA,UAAU,IAAI,SAAU,CAAA,UAAA,CAAA;QACxE,MAAA,MAAA,GAAS,KAAK,IAAK,CAAA,MAAA,CAAO,WAAA,GAAc,SAAU,CAAA,WAAW,IAAI,SAAU,CAAA,WAAA,CAAA;QAEjF,MAAM,iBAA0C,GAAA;YAC5C,OAAO,MAAO,CAAA,KAAA;YACd,IAAA,EAAM;gBAAE,KAAA;gBAAO,MAAO;YAAA,CAAA;YACtB,QAAQ,MAAO,CAAA,MAAA;YACf,aAAa,MAAO,CAAA,WAAA;YACpB,eAAe,MAAO,CAAA,aAAA;YACtB,WAAW,MAAO,CAAA,SAAA;YAClB,KAAA;QAAA,CACJ,CAAA;QAEA,MAAM,UAAa,GAAA,IAAA,CAAK,IAAK,CAAA,MAAA,CAAO,aAAA,CAAc,iBAAiB,CAAA,CAAA;QAEnE,MAAA,CAAO,QAAA,CAAS,IAAK,CAAA,SAAA,CAAU,GAAG,CAAI,GAAA,IAAI,kBAAkB,UAAU,CAAA,CAAA;QAEtE,MAAM,KAAQ,GAAA,IAAA,CAAK,gBAAiB,CAAA,GAAA,CAAI,MAAM,CAAA,CAAA;QAE9C,IAAI,KACJ,EAAA;YACI,MAAA,CAAO,EAAG,CAAA,QAAA,EAAU,IAAK,CAAA,cAAA,EAAgB,IAAI,CAAA,CAAA;YAC7C,MAAA,CAAO,EAAG,CAAA,QAAA,EAAU,IAAK,CAAA,cAAA,EAAgB,IAAI,CAAA,CAAA;YAC7C,MAAA,CAAO,EAAG,CAAA,eAAA,EAAiB,IAAK,CAAA,eAAA,EAAiB,IAAI,CAAA,CAAA;QAAA,CACzD;QAEA,IAAA,CAAK,cAAA,CAAe,MAAM,CAAA,CAAA;QAEnB,OAAA,UAAA,CAAA;IAAA,CACX;IAEU,eAAe,MACzB,EAAA;QACU,MAAA,UAAA,GAAa,IAAK,CAAA,YAAA,CAAa,MAAM,CAAA,CAAA;QAG3C,IAAI,CAAC,UAAA,EAAY,OAAA;QAEjB,IAAI,IAAK,CAAA,QAAA,CAAS,MAAO,CAAA,cAAc,CACvC,EAAA;YACS,IAAA,CAAA,QAAA,CAAS,OAAO,cAAc,CAAA,CAAE,MAAA,CAAO,MAAQ,EAAA,UAAA,EAAY,IAAA,CAAK,IAAI,CAAA,CAAA;QAAA,CAC7E;QAEA,IAAI,MAAO,CAAA,mBAAA,IAAuB,MAAO,CAAA,aAAA,GAAgB,CACzD,EAAA;YACI,IAAA,CAAK,eAAA,CAAgB,MAAM,CAAA,CAAA;QAAA,CAC/B;IAAA,CACJ;IAEU,gBAAgB,MAC1B,EAAA;QACQ,IAAA,CAAC,IAAA,CAAK,gBACV,EAAA;YACI,IAAA,CAAK,gBAAmB,GAAA,IAAI,mOAAmB,CAAA,IAAA,CAAK,IAAA,CAAK,MAAM,CAAA,CAAA;QAAA,CACnE;QAEM,MAAA,UAAA,GAAa,IAAK,CAAA,YAAA,CAAa,MAAM,CAAA,CAAA;QAEtC,IAAA,CAAA,gBAAA,CAAiB,cAAA,CAAe,UAAU,CAAA,CAAA;IAAA,CACnD;IAEU,eAAe,MACzB,EAAA;QACI,MAAA,CAAO,GAAI,CAAA,QAAA,EAAU,IAAK,CAAA,cAAA,EAAgB,IAAI,CAAA,CAAA;QAC9C,MAAA,CAAO,GAAI,CAAA,QAAA,EAAU,IAAK,CAAA,cAAA,EAAgB,IAAI,CAAA,CAAA;QAC9C,MAAA,CAAO,GAAI,CAAA,eAAA,EAAiB,IAAK,CAAA,eAAA,EAAiB,IAAI,CAAA,CAAA;IAAA,CAC1D;IAEU,eAAe,MACzB,EAAA;QACW,MAAA,CAAA,WAAA,GAAc,IAAK,CAAA,SAAA,CAAU,EAAG,CAAA,GAAA,CAAA;QAEvC,MAAM,OAAU,GAAA,MAAA,CAAO,QAAS,CAAA,IAAA,CAAK,SAAA,CAAU,GAAG,CAAA,CAAA;QAClD,MAAM,aAAa,OAAS,EAAA,UAAA,CAAA;QAE5B,IAAI,CAAC,UACL,EAAA;YACI,IAAA,CAAK,UAAA,CAAW,MAAM,CAAA,CAAA;QAAA,CAC1B,MAAA,IACS,WAAW,KAAU,KAAA,MAAA,CAAO,UAAA,IAAc,UAAW,CAAA,MAAA,KAAW,OAAO,WAChF,EAAA;YACI,OAAA,CAAQ,OAAQ,EAAA,CAAA;YACX,IAAA,CAAA,cAAA,CAAe,MAAO,CAAA,GAAG,CAAI,GAAA,IAAA,CAAA;YAClC,MAAA,CAAO,QAAS,CAAA,IAAA,CAAK,SAAU,CAAA,GAAG,CAAI,GAAA,IAAA,CAAA;YACtC,IAAA,CAAK,UAAA,CAAW,MAAM,CAAA,CAAA;QAAA,CAC1B;IAAA,CACJ;IAEQ,aAAa,OACrB,EAAA;QACS,IAAA,CAAA,YAAA,CAAa,QAAQ,WAAW,CAAA,GAAI,IAAA,CAAK,IAAK,CAAA,MAAA,CAAO,aAAA,CAAc,OAAO,CAAA,CAAA;QAExE,OAAA,IAAA,CAAK,YAAa,CAAA,OAAA,CAAQ,WAAW,CAAA,CAAA;IAAA,CAChD;IAEO,cAAc,OACrB,EAAA;QACI,OAAO,IAAA,CAAK,YAAa,CAAA,OAAA,CAAQ,WAAW,CAAK,IAAA,IAAA,CAAK,YAAA,CAAa,OAAO,CAAA,CAAA;IAAA,CAC9E;IAEO,aAAa,MACpB,EAAA;QACW,MAAA,CAAA,WAAA,GAAc,IAAK,CAAA,SAAA,CAAU,EAAG,CAAA,GAAA,CAAA;QAE/B,OAAA,MAAA,CAAO,QAAA,CAAS,IAAK,CAAA,SAAA,CAAU,GAAG,CAAyB,EAAA,UAAA,IAAc,IAAK,CAAA,UAAA,CAAW,MAAM,CAAA,CAAA;IAAA,CAC3G;IAAA;;;;;;;;GAAA,GAWO,oBAAoB,OAC3B,EAAA;QACI,OAAO,IAAA,CAAK,cAAe,CAAA,OAAA,CAAQ,GAAG,CAAK,IAAA,IAAA,CAAK,uBAAA,CAAwB,OAAO,CAAA,CAAA;IAAA,CACnF;IAEQ,wBAAwB,OAChC,EAAA;QACI,MAAM,SAAS,OAAQ,CAAA,MAAA,CAAA;QAEvB,IAAA,CAAK,cAAe,CAAA,OAAA,CAAQ,GAAG,CAAA,GAAI,IAAI,uMAAU,CAAA;YAC7C,CAAG,EAAA,MAAA;YACH,GAAG,MAAO,CAAA,KAAA;YACV,CAAA,EAAG,IAAI,gNAAa,CAAA;gBAChB,gBAAgB;oBAAE,IAAA,EAAM;oBAAe,KAAO,EAAA,OAAA,CAAQ,aAAA,CAAc,QAAS;gBAAA,CAAA;YAAA,CAChF,CAAA;QAAA,CACJ,CAAA,CAAA;QAEM,OAAA,IAAA,CAAK,cAAe,CAAA,OAAA,CAAQ,GAAG,CAAA,CAAA;IAAA,CAC1C;IAEO,eAAe,OACtB,EAAA;QACI,MAAM,SAAS,OAAQ,CAAA,MAAA,CAAA;QAEhB,MAAA,CAAA,WAAA,GAAc,IAAK,CAAA,SAAA,CAAU,EAAG,CAAA,GAAA,CAAA;QACvC,IAAI,OAAU,GAAA,MAAA,CAAO,QAAS,CAAA,IAAA,CAAK,SAAA,CAAU,GAAG,CAAA,CAAA;QAChD,IAAI,WAA8B,GAAA,IAAA,CAAA;QAElC,IAAI,CAAC,OACL,EAAA;YACI,IAAA,CAAK,UAAA,CAAW,MAAM,CAAA,CAAA;YACtB,OAAA,GAAU,MAAO,CAAA,QAAA,CAAS,IAAK,CAAA,SAAA,CAAU,GAAG,CAAA,CAAA;QAAA,CAChD;QAEA,WAAA,GAAc,OAAQ,CAAA,WAAA,IAAe,OAAQ,CAAA,UAAA,CAAW,UAAW,EAAA,CAAA;QAE5D,OAAA,WAAA,CAAA;IAAA,CACX;IAEO,eAAe,OACtB,EAAA;QACI,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;QAEtB,MAAM,cAAiB,GAAA,QAAA,CAAS,GAAI,CAAA,MAAA,CAAO,oBAAqB,EAAA,CAAA;QAGhE,MAAM,MAAS,GAAA,0KAAA,CAAW,GAAI,EAAA,CAAE,YAAa,EAAA,CAAA;QAEtC,MAAA,CAAA,KAAA,GAAQ,QAAQ,MAAO,CAAA,UAAA,CAAA;QACvB,MAAA,CAAA,MAAA,GAAS,QAAQ,MAAO,CAAA,WAAA,CAAA;QAEzB,MAAA,OAAA,GAAU,MAAO,CAAA,UAAA,CAAW,QAAQ,CAAA,CAAA;QAE1C,OAAA,CAAQ,SAAU,CAAA;YACd,MAAA,EAAQ,SAAS,GAAI,CAAA,MAAA;YAErB,KAAA,EAAO,eAAgB,CAAA,QAAA,GAAW,eAAgB,CAAA,QAAA;YAClD,QAAQ,0KAAW,CAAA,GAAA,GAAM,YAAa,EAAA,CAAE,GAAA,CAAI,wBAAyB,EAAA;YACrE,SAAW,EAAA,eAAA;QAAA,CACd,CAAA,CAAA;QAED,cAAA,CAAe,oBAAqB,CAAA;YAChC,OAAS,EAAA,QAAA,CAAS,OAAQ,CAAA,YAAA,CAAa,QAAQ,MAAM,CAAA;YACrD,MAAQ,EAAA;gBACJ,CAAG,EAAA,CAAA;gBACH,CAAG,EAAA,CAAA;YAAA,CACP;QAAA,CACD,EAAA;YACC,OAAA,EAAS,QAAQ,iBAAkB,EAAA;QAAA,CACpC,EAAA;YACC,OAAO,MAAO,CAAA,KAAA;YACd,QAAQ,MAAO,CAAA,MAAA;QAAA,CAClB,CAAA,CAAA;QAEQ,QAAA,CAAA,GAAA,CAAI,MAAA,CAAO,KAAM,CAAA,MAAA,CAAO;YAAC,cAAe,CAAA,MAAA,EAAQ;SAAC,CAAA,CAAA;QAEnD,OAAA,MAAA,CAAA;IAAA,CACX;IAEO,UAAU,OACjB,EAAA;QACU,MAAA,YAAA,GAAe,IAAK,CAAA,cAAA,CAAe,OAAO,CAAA,CAAA;QAEhD,MAAM,mBAAmB,6MAAW,CAAA,0BAAA,CAA2B,YAAa,CAAA,KAAA,EAAO,aAAa,MAAM,CAAA,CAAA;QAEtG,MAAM,UAAU,gBAAiB,CAAA,OAAA,CAAA;QAEzB,OAAA,CAAA,SAAA,CAAU,YAAc,EAAA,CAAA,EAAG,CAAC,CAAA,CAAA;QAE9B,MAAA,EAAE,KAAO,EAAA,MAAA,EAAW,GAAA,YAAA,CAAA;QAE1B,MAAM,YAAY,OAAQ,CAAA,YAAA,CAAa,CAAG,EAAA,CAAA,EAAG,OAAO,MAAM,CAAA,CAAA;QAE1D,MAAM,MAAS,GAAA,IAAI,iBAAkB,CAAA,SAAA,CAAU,IAAA,CAAK,MAAM,CAAA,CAAA;QAE1D,6MAAA,CAAW,sBAAA,CAAuB,gBAAgB,CAAA,CAAA;QAE3C,OAAA;YAAE,MAAQ;YAAA,KAAA;YAAO,MAAO;QAAA,CAAA,CAAA;IAAA,CACnC;IAEO,OACP,GAAA;QACI,IAAA,CAAK,gBAAA,CAAiB,OAAQ,EAAA,CAAA;QAC9B,KAAA,MAAW,CAAK,IAAA,MAAA,CAAO,IAAK,CAAA,IAAA,CAAK,cAAc,CAC/C,CAAA;YACU,MAAA,GAAA,GAAM,OAAO,CAAC,CAAA,CAAA;YACd,MAAA,SAAA,GAAY,IAAK,CAAA,cAAA,CAAe,GAAG,CAAA,CAAA;YAEzC,SAAA,EAAW,OAAQ,EAAA,CAAA;QAAA,CACvB;QAEC,IAAA,CAAK,SAAqB,GAAA,IAAA,CAAA;QAC3B,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;QACZ,IAAA,CAAK,gBAAmB,GAAA,IAAA,CAAA;QACxB,IAAA,CAAK,YAAe,GAAA,IAAA,CAAA;QACpB,IAAA,CAAK,cAAiB,GAAA,IAAA,CAAA;IAAA,CAC1B;AACJ,CAAA;AAAA,YAAA,GAtTa,gBAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,+KAAc,CAAA,YAAA;KAClB;IACA,IAAM,EAAA,SAAA;AACV,CAAA"}},
    {"offset": {"line": 7213, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs","sources":["file:///C:/projects/spin-win/node_modules/pixi.js/src/rendering/renderers/gpu/WebGPURenderer.ts"],"sourcesContent":["import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { BindGroupSystem } from './BindGroupSystem';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem';\nimport { type GPU, GpuDeviceSystem } from './GpuDeviceSystem';\nimport { GpuEncoderSystem } from './GpuEncoderSystem';\nimport { GpuLimitsSystem } from './GpuLimitsSystem';\nimport { GpuStencilSystem } from './GpuStencilSystem';\nimport { GpuUboSystem } from './GpuUboSystem';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe';\nimport { PipelineSystem } from './pipeline/PipelineSystem';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem';\nimport { GpuStateSystem } from './state/GpuStateSystem';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\n\nconst DefaultWebGPUSystems = [\n    ...SharedSystems,\n    GpuUboSystem,\n    GpuEncoderSystem,\n    GpuDeviceSystem,\n    GpuLimitsSystem,\n    GpuBufferSystem,\n    GpuTextureSystem,\n    GpuRenderTargetSystem,\n    GpuShaderSystem,\n    GpuStateSystem,\n    PipelineSystem,\n    GpuColorMaskSystem,\n    GpuStencilSystem,\n    BindGroupSystem,\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\n\n/**\n * The default WebGPU systems. These are the systems that are added by default to the WebGPURenderer.\n * @category rendering\n * @standard\n * @interface\n */\nexport type WebGPUSystems = ExtractSystemTypes<typeof DefaultWebGPUSystems> &\nPixiMixins.RendererSystems &\nPixiMixins.WebGPUSystems;\n\n/**\n * The WebGPU renderer pipes. These are used to render the scene.\n * @see {@link WebGPURenderer}\n * @internal\n */\nexport type WebGPUPipes = ExtractSystemTypes<typeof DefaultWebGPUPipes> &\nPixiMixins.RendererPipes &\nPixiMixins.WebGPUPipes;\n\n/**\n * Options for WebGPURenderer.\n * @category rendering\n * @standard\n */\nexport interface WebGPUOptions extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGPUSystems>,\n    PixiMixins.WebGPUOptions{}\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>,\n    WebGPUSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGPU PixiJS Renderer. This renderer allows you to use the next-generation graphics API, WebGPU.\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGPURenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n * ```ts\n * import { autoDetectRenderer } from 'pixi.js';\n * // Create a new renderer\n * const renderer = await autoDetectRenderer();\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGPU renderer:\n *\n * | WebGPU Core Systems                      | Systems that are specific to the WebGL renderer                               |\n * | ---------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link GpuUboSystem}           | This manages WebGPU uniform buffer objects feature for shaders                |\n * | {@link GpuEncoderSystem}       | This manages the WebGPU command encoder                                       |\n * | {@link GpuDeviceSystem}        | This manages the WebGPU Device and its extensions                             |\n * | {@link GpuBufferSystem}        | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link GpuTextureSystem}       | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link GpuRenderTargetSystem}  | This manages what we render too. For example the screen, or another texture   |\n * | {@link GpuShaderSystem}        | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link GpuStateSystem}         | This manages the state of the WebGPU Pipelines. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link PipelineSystem}         | This manages the WebGPU pipelines, used for rendering                         |\n * | {@link GpuColorMaskSystem}     | This manages the color mask. Used for color masking                           |\n * | {@link GpuStencilSystem}       | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link BindGroupSystem}        | This manages the WebGPU bind groups. this is how data is bound to a shader when rendering |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @category rendering\n * @standard\n * @property {GpuUboSystem} ubo - UboSystem instance.\n * @property {GpuEncoderSystem} encoder - EncoderSystem instance.\n * @property {GpuDeviceSystem} device - DeviceSystem instance.\n * @property {GpuBufferSystem} buffer - BufferSystem instance.\n * @property {GpuTextureSystem} texture - TextureSystem instance.\n * @property {GpuRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {GpuShaderSystem} shader - ShaderSystem instance.\n * @property {GpuStateSystem} state - StateSystem instance.\n * @property {PipelineSystem} pipeline - PipelineSystem instance.\n * @property {GpuColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @property {GpuStencilSystem} stencil - StencilSystem instance.\n * @property {BindGroupSystem} bindGroup - BindGroupSystem instance.\n * @extends AbstractRenderer\n */\nexport class WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>\n    implements WebGPUSystems\n{\n    /** The WebGPU Device. */\n    public gpu: GPU;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgpu',\n            type: RendererType.WEBGPU,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,MAAM,oBAAuB,GAAA;OACtB,kNAAA;IACH,mMAAA;IACA,2MAAA;IACA,yMAAA;IACA,yMAAA;IACA,mNAAA;IACA,sNAAA;IACA,qOAAA;IACA,mNAAA;IACA,gNAAA;IACA,mNAAA;IACA,+MAAA;IACA,2MAAA;IACA,yMAAA;CACJ,CAAA;AACA,MAAM,kBAAqB,GAAA,CAAC;OAAG,sNAAA;IAAmB,iNAAmB;CAAA,CAAA;AACrE,MAAM,qBAAwB,GAAA;IAAC,uMAAiB;IAAA,8LAAA;IAAgB,0MAAkB;CAAA,CAAA;AAGlF,MAAM,UAAwD,EAAC,CAAA;AAC/D,MAAM,cAA0D,EAAC,CAAA;AACjE,MAAM,qBAAqD,EAAC,CAAA;AAE5D,4KAAW,CAAA,iBAAA,CAAkB,+KAAc,CAAA,YAAA,EAAc,OAAO,CAAA,CAAA;AAChE,4KAAW,CAAA,iBAAA,CAAkB,+KAAc,CAAA,WAAA,EAAa,WAAW,CAAA,CAAA;AACnE,4KAAW,CAAA,iBAAA,CAAkB,+KAAc,CAAA,kBAAA,EAAoB,kBAAkB,CAAA,CAAA;AAGjF,4KAAA,CAAW,GAAA,CAAI,GAAG,oBAAA,EAAsB,GAAG,kBAAA,EAAoB,GAAG,qBAAqB,CAAA,CAAA;AAiGhF,MAAM,uBACD,wNAEZ,CAAA;IAII,WACA,EAAA;QACI,MAAM,YAAe,GAAA;YACjB,IAAM,EAAA,QAAA;YACN,MAAM,qLAAa,CAAA,MAAA;YACnB,OAAA;YACA,WAAA;YACA,kBAAA;QAAA,CACJ,CAAA;QAEA,KAAA,CAAM,YAAY,CAAA,CAAA;IAAA,CACtB;AACJ"}}]
}
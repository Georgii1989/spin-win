{"version":3,"sources":["../../../../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts","../../../../node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts","../../../../node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts","../../../../node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts","../../../../node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts","../../../../node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts","../../../../node_modules/pixi.js/src/scene/text-bitmap/utils/resolveCharacters.ts","../../../../node_modules/pixi.js/src/scene/particle-container/shared/utils/createIndicesForQuads.ts","../../../../node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts","../../../../node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts","../../../../node_modules/pixi.js/src/scene/text-bitmap/utils/getBitmapTextLayout.ts","../../../../node_modules/pixi.js/src/scene/particle-container/gpu/GpuParticleContainerAdaptor.ts","../../../../node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts","../../../../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts","../../../../node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts","../../../../node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts","../../../../node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","../../../../node_modules/pixi.js/src/scene/particle-container/gl/GlParticleContainerAdaptor.ts","../../../../node_modules/pixi.js/src/scene/text-html/BatchableHTMLText.ts","../../../../node_modules/pixi.js/src/scene/particle-container/shared/utils/generateParticleUpdateFunction.ts","../../../../node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts","../../../../node_modules/pixi.js/src/filters/FilterPipe.ts","../../../../node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts","../../../../node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts","../../../../node_modules/pixi.js/src/utils/browser/isSafari.ts","../../../../node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts","../../../../node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts","../../../../node_modules/pixi.js/src/filters/init.ts","../../../../node_modules/pixi.js/src/scene/text/utils/updateTextBounds.ts","../../../../node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts","../../../../node_modules/pixi.js/src/scene/particle-container/shared/GlParticleContainerPipe.ts","../../../../node_modules/pixi.js/src/scene/particle-container/shared/GpuParticleContainerPipe.ts","../../../../node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts","../../../../node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts","../../../../node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts","../../../../node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts","../../../../node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts","../../../../node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts","../../../../node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts","../../../../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","../../../../node_modules/pixi.js/src/filters/defaults/passthrough/PassthroughFilter.ts","../../../../node_modules/pixi.js/src/scene/particle-container/shared/ParticleBuffer.ts","../../../../node_modules/pixi.js/src/filters/FilterSystem.ts","../../../../node_modules/pixi.js/src/scene/particle-container/shared/shader/ParticleShader.ts","../../../../node_modules/pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts","../../../../node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts","../../../../node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts","../../../../node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts","../../../../node_modules/pixi.js/src/app/ResizePlugin.ts","../../../../node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts","../../../../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","../../../../node_modules/pixi.js/src/scene/particle-container/shared/ParticleContainerPipe.ts","../../../../node_modules/pixi.js/src/scene/text-bitmap/AbstractBitmapFont.ts","../../../../node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts","../../../../node_modules/pixi.js/src/app/TickerPlugin.ts","../../../../node_modules/pixi.js/src/scene/text-bitmap/BitmapFontManager.ts"],"sourcesContent":["/** @internal */\nexport const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        `,\n    }\n\n};\n\n/** @internal */\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        `,\n    }\n\n};\n","/** @internal */\nexport const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\n/** @internal */\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    }\n\n};\n","import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n * @internal\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement\n{\n    public batcherName = 'default';\n\n    public _topology: Topology;\n\n    public readonly packAsQuad = false;\n    public location: number;\n\n    public renderable: ViewContainer;\n\n    public indexOffset = 0;\n    public attributeOffset = 0;\n\n    public texture: Texture;\n    public geometry: MeshGeometry;\n    public transform: Matrix;\n    public roundPixels: 0 | 1 = 0;\n\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n    public _indexStart: number;\n    public _textureId: number;\n    public _textureMatrixUpdateId: number = -1;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    get topology() { return this._topology || this.geometry.topology; }\n    set topology(value: Topology) { this._topology = value; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    /**\n     * Sets the texture for the batchable mesh.\n     * As it does so, it resets the texture matrix update ID.\n     * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n     * @param value - The texture to set.\n     */\n    public setTexture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this.texture = value;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    get uvs()\n    {\n        const geometry = this.geometry;\n\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        return transformedUvs as Float32Array;\n    }\n\n    get positions()\n    {\n        return this.geometry.positions;\n    }\n\n    get indices()\n    {\n        return this.geometry.indices;\n    }\n\n    get color()\n    {\n        return this.renderable.groupColorAlpha;\n    }\n\n    get groupTransform()\n    {\n        return this.renderable.groupTransform;\n    }\n\n    get attributeSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\n/**\n * @param array\n * @param stride\n * @param offset\n * @param matrix\n * @internal\n */\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import type { TilingSprite } from '../TilingSprite';\n\n/**\n * @param tilingSprite\n * @param positions\n * @internal\n */\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n","/**\n * Generic Mask Stack data structure\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n * @internal\n */\nexport function createIndicesForQuads(\n    size: number,\n    outBuffer: Uint16Array | Uint32Array | null = null\n): Uint16Array | Uint32Array\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    // Check if we need to use Uint32Array\n    if (totalIndices > 65535)\n    {\n        outBuffer ||= new Uint32Array(totalIndices); // Use Uint32Array if needed\n    }\n    else\n    {\n        outBuffer ||= new Uint16Array(totalIndices);\n    }\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n","import { type ImageLike } from '../../../environment/ImageLike';\n\n/**\n * This function loads an SVG image into an IImage element.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n * @internal\n */\nexport function loadSVGImage(image: ImageLike, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n * @internal\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\n/**\n * The layout data for a bitmap text.\n * This contains the width, height, scale, offsetY and lines of text.\n * Each line contains its width, character positions, characters, space width and spaces index.\n * @category text\n * @internal\n */\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\n/**\n * @param chars\n * @param style\n * @param font\n * @param trimEnd\n * @internal\n */\nexport function getBitmapTextLayout(\n    chars: string[],\n    style: TextStyle,\n    font: AbstractBitmapFont<any>,\n    trimEnd: boolean\n): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n    const adjustedLineHeight = style.lineHeight ? style.lineHeight * scale : font.lineHeight;\n\n    const breakWords = style.wordWrap && style.breakWords;\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n\n        if (trimEnd)\n        {\n            let lastChar = currentLine.chars[index];\n\n            while (lastChar === ' ')\n            {\n                currentLine.width -= font.chars[lastChar].xAdvance;\n                lastChar = currentLine.chars[--index];\n            }\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += adjustedLineHeight;\n    };\n\n    const checkIsOverflow = (lineWidth: number) =>\n        lineWidth - adjustedLetterSpacing > adjustedWordWrapWidth;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord && style.wordWrap && checkIsOverflow(currentLine.width + currentWord.width);\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                nextLine();\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            const addWordToNextLine = breakWords && checkIsOverflow(currentLine.width + currentWord.width + nextCharWidth);\n\n            if (addWordToNextLine)\n            {\n                nextWord(currentWord);\n                nextLine();\n            }\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n","import type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\n/** @internal */\nexport class GpuParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const renderer = particleContainerPipe.renderer as WebGPURenderer;\n\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n\n        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n\n        const state = particleContainerPipe.state;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        renderer.encoder.draw({\n            geometry: buffer.geometry,\n            shader: container.shader || particleContainerPipe.defaultShader,\n            state,\n            size: container.particleChildren.length * 6,\n        });\n    }\n}\n","/* eslint-disable no-restricted-globals */\nimport { DOMAdapter } from '../../environment/adapter';\nimport { type ImageLike } from '../../environment/ImageLike';\n\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\n/** @internal */\nconst nssvg = 'http://www.w3.org/2000/svg';\n/** @internal */\nconst nsxhtml = 'http://www.w3.org/1999/xhtml';\n\n/** @internal */\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image: ImageLike;\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n\n        this.image = DOMAdapter.get().createImage();\n    }\n\n    public destroy(): void\n    {\n        this.svgRoot.remove();\n        this.foreignObject.remove();\n        this.styleElement.remove();\n        this.domElement.remove();\n        this.image.src = '';\n        this.image.remove();\n\n        this.svgRoot = null;\n        this.foreignObject = null;\n        this.styleElement = null;\n        this.domElement = null;\n        this.image = null;\n        this.canvasAndContext = null;\n    }\n}\n","import { type PointData } from '../../maths/point/PointData';\nimport { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @category scene\n * @advanced\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n\n    /** The anchor point of the NineSliceSprite. */\n    anchor?: PointData\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @category scene\n * @advanced\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    /** @internal */\n    public _leftWidth: number;\n    /** @internal */\n    public _rightWidth: number;\n    /** @internal */\n    public _topHeight: number;\n    /** @internal */\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n    private _anchorX: any;\n    private _anchorY: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this._anchorX = options.anchor?.x;\n        this._anchorY = options.anchor?.y;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const p = this.positions;\n        const {\n            width,\n            height,\n            _leftWidth,\n            _rightWidth,\n            _topHeight,\n            _bottomHeight,\n            _anchorX,\n            _anchorY,\n        } = this;\n\n        const w = _leftWidth + _rightWidth;\n        const scaleW = width > w ? 1.0 : width / w;\n\n        const h = _topHeight + _bottomHeight;\n        const scaleH = height > h ? 1.0 : height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        const anchorOffsetX = _anchorX * width;\n        const anchorOffsetY = _anchorY * height;\n\n        p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n        p[2] = p[10] = p[18] = p[26] = (_leftWidth * scale) - anchorOffsetX;\n        p[4] = p[12] = p[20] = p[28] = width - (_rightWidth * scale) - anchorOffsetX;\n        p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n\n        p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n        p[9] = p[11] = p[13] = p[15] = (_topHeight * scale) - anchorOffsetY;\n        p[17] = p[19] = p[21] = p[23] = height - (_bottomHeight * scale) - anchorOffsetY;\n        p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\n/**\n * Options for the font CSS style\n * @category text\n * @internal\n */\nexport interface FontCSSStyleOptions\n{\n    /**\n     * The font family to use in the CSS\n     * @example\n     * 'Arial' or ['Arial', 'Helvetica']\n     */\n    fontFamily: string | string[]\n    /**\n     * The font weight to use in the CSS\n     * @example\n     * 'normal', 'bold', '100', '200', etc.\n     */\n    fontWeight: string\n    /**\n     * The font style to use in the CSS\n     * @example\n     * 'normal', 'italic', 'oblique'\n     */\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n * @internal\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n        src: url('${dataSrc}');\n    }`;\n}\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n * @internal\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","import { type ImageLike } from '../../../environment/ImageLike';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\nimport type { CanvasAndContext } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * Remember to return this canvas is immediately to the CanvasPool for reuse when you are done with it.\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n * @internal\n */\nexport function getTemporaryCanvasFromImage(image: ImageLike, resolution: number): CanvasAndContext\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas.\n    return canvasAndContext;\n}\n\n","import type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\n/** @internal */\nexport class GlParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const state = particleContainerPipe.state;\n        const renderer = particleContainerPipe.renderer as WebGLRenderer;\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.resources.uTexture = container.texture._source;\n        shader.resources.uniforms = particleContainerPipe.localUniforms;\n\n        const gl = renderer.gl;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        // now lets upload and render the buffers..\n        renderer.shader.bind(shader);\n        renderer.state.set(state);\n        renderer.geometry.bind(buffer.geometry, shader.glProgram);\n\n        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n    }\n}\n","import { type Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\n/**\n * The BatchableHTMLText class extends the BatchableSprite class and is used to handle HTML text rendering.\n * It includes a promise for the texture as generating the HTML texture takes some time.\n * @internal\n */\nexport class BatchableHTMLText extends BatchableSprite\n{\n    public texturePromise: Promise<Texture>;\n    public generatingTexture = false;\n    public currentKey: string = '--';\n\n    /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */\n    public destroy()\n    {\n        this.texturePromise = null;\n        this.generatingTexture = false;\n        this.currentKey = '--';\n        super.destroy();\n    }\n}\n","import {\n    getAttributeInfoFromFormat\n} from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { IParticle } from '../Particle';\nimport type { ParticleRendererProperty } from '../particleData';\n\n// TODO rename to update function\n/** @internal */\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) => void;\n\n/**\n * @param properties\n * @internal\n */\nexport function generateParticleUpdateFunction(properties: Record<string, ParticleRendererProperty>)\n{\n    return {\n        dynamicUpdate: generateUpdateFunction(properties, true),\n        staticUpdate: generateUpdateFunction(properties, false),\n    };\n}\n\nfunction generateUpdateFunction(\n    properties: Record<string, ParticleRendererProperty>,\n    dynamic: boolean\n): ParticleUpdateFunction\n{\n    const funcFragments: string[] = [];\n\n    funcFragments.push(`\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n\n    let offset = 0;\n\n    for (const i in properties)\n    {\n        const property = properties[i];\n\n        if (dynamic !== property.dynamic) continue;\n\n        funcFragments.push(`offset = index + ${offset}`);\n\n        funcFragments.push(property.code);\n\n        const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n        offset += attributeInfo.stride / 4;\n    }\n\n    funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n\n    // add to the front..\n    funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n\n    const functionSource = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('ps', 'f32v', 'u32v', functionSource) as ParticleUpdateFunction;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n/** @internal */\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { Matrix } from '../../../maths';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\n/**\n * This matrix is used for calculations of the bounds for renderables placed inside cacheAsTexture render groups.\n * @ignore\n * @internal\n */\nconst tempProjectionMatrix: Matrix = new Matrix();\n\n/**\n * @param renderables\n * @param bounds\n * @internal\n */\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const actualMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n\n        if (renderGroup?.isCachedAsTexture)\n        {\n            bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform)\n                .append(renderable.worldTransform);\n        }\n        else if (renderGroup?._parentCacheAsTextureRenderGroup)\n        {\n            bounds.matrix = tempProjectionMatrix\n                .copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform)\n                .append(renderable.groupTransform);\n        }\n        else\n        {\n            bounds.matrix = renderable.worldTransform;\n        }\n\n        bounds.addBounds(renderable.bounds);\n    }\n\n    bounds.matrix = actualMatrix;\n\n    return bounds;\n}\n","import { Cache } from '../../../assets/cache/Cache';\nimport { type FontFaceCache } from '../../../assets/loader/parsers/loadWebFont';\nimport { loadFontCSS } from './loadFontCSS';\n\n/** @internal */\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @returns - The css string\n * @internal\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { entries } = Cache.get<FontFaceCache>(`${fontFamily}-and-url`);\n                const promises: Promise<string>[] = [];\n\n                entries.forEach((entry) =>\n                {\n                    const url = entry.url;\n                    const faces = entry.faces;\n\n                    const out = faces.map((face) => ({ weight: face.weight, style: face.style }));\n\n                    // load each out font with the correct style\n                    promises.push(\n                        ...out.map((style) =>\n                            loadFontCSS(\n                                {\n                                    fontWeight: style.weight,\n                                    fontStyle: style.style,\n                                    fontFamily,\n                                },\n                                url,\n                            ),\n                        ),\n                    );\n                });\n                FontStylePromiseCache.set(\n                    fontFamily,\n                    Promise.all(promises).then((css) => css.join('\\n')),\n                );\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","import { DOMAdapter } from '../../environment/adapter';\n\n/**\n * Checks if the current browser is Safari.\n * @returns {boolean} True if the browser is Safari, false otherwise.\n * @internal\n */\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link PlaneGeometry}\n * @category scene\n * @advanced\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @category scene\n * @advanced\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","/* eslint-disable no-restricted-globals */\nimport { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n * @internal\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData ||= tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    // padding is included in the CSS calculation, so we need to remove it here\n    const doublePadding = style.padding * 2;\n\n    return {\n        width: contentBounds.width - doublePadding,\n        height: contentBounds.height - doublePadding,\n    };\n}\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","import { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { type BatchableSprite } from '../../sprite/BatchableSprite';\nimport { type AbstractText } from '../AbstractText';\nimport { type TextStyle, type TextStyleOptions } from '../TextStyle';\n\n/**\n * Updates the bounds of the given batchable sprite based on the provided text object.\n *\n * This function adjusts the bounds of the batchable sprite to match the dimensions\n * and anchor point of the text's texture. Additionally, it compensates for any padding\n * specified in the text's style to ensure the text is rendered correctly on screen.\n * @param {BatchableSprite} batchableSprite - The sprite whose bounds need to be updated.\n * @param {AbstractText} text - The text object containing the texture and style information.\n * @internal\n */\nexport function updateTextBounds(batchableSprite: BatchableSprite, text: AbstractText<TextStyle, TextStyleOptions>)\n{\n    const { texture, bounds } = batchableSprite;\n    const padding = text._style._getFinalPadding();\n\n    // When HTML text textures are created, they include the padding around the text content\n    // to prevent text clipping and provide a buffer zone. This padding is built into\n    // the texture itself. However, we don't want this padding to affect the text's\n    // actual position on screen.\n\n    // First, calculate bounds using the full padded texture\n    updateQuadBounds(bounds, text._anchor, texture);\n\n    // Then adjust by the padding amount to compensate for the buffer zone\n    // This shifts the render position back by the padding amount, ensuring the text\n    // appears exactly where intended while maintaining the buffer zone around it.\n    const paddingOffset = text._anchor._x * padding * 2;\n    const paddingOffsetY = text._anchor._y * padding * 2;\n\n    bounds.minX -= padding - paddingOffset;\n    bounds.minY -= padding - paddingOffsetY;\n    bounds.maxX -= padding - paddingOffset;\n    bounds.maxY -= padding - paddingOffsetY;\n}\n","import { type ImageLike } from '../../../environment/ImageLike';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n * @internal\n */\nexport function getPo2TextureFromSource(\n    image: ImageLike | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\n\n/**\n * WebGL renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GlParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer, new GlParticleContainerAdaptor());\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\n\n/**\n * WebGPU renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GpuParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer, new GpuParticleContainerAdaptor());\n    }\n}\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\n/** @internal */\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @category scene\n * @advanced\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. If not provided, they will be filled with 0 and match the size of the positions. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @category scene\n * @advanced\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n\n        let uvs = options.uvs;\n\n        if (!uvs)\n        {\n            if (options.positions)\n            {\n                uvs = new Float32Array(positions.length);\n            }\n            else\n            {\n                uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n            }\n        }\n\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the positions of the mesh.\n     * When setting the positions, its important that the uvs array is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The positions of the mesh.\n     */\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the UVs of the mesh.\n     * Its important that the uvs array you set is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The UVs of the mesh.\n     */\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash';\nimport { updateTextBounds } from '../utils/updateTextBounds';\nimport { BatchableText } from './BatchableText';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\n/** @internal */\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _managedTexts: GCManagedHash<Text>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.runners.resolutionChange.add(this);\n        this._managedTexts = new GCManagedHash({\n            renderer,\n            type: 'renderable',\n            onUnload: this.onTextUnload.bind(this),\n            name: 'canvasText'\n        });\n    }\n\n    protected resolutionChange()\n    {\n        for (const key in this._managedTexts.items)\n        {\n            const text = this._managedTexts.items[key];\n\n            if (text?._autoResolution) text.onViewUpdate();\n        }\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text.styleKey;\n\n        if (gpuText.currentKey !== newKey) return true;\n\n        return text._didTextUpdate;\n    }\n\n    public addRenderable(text: Text, instructionSet: InstructionSet)\n    {\n        const batchableText = this._getGpuText(text);\n\n        if (text._didTextUpdate)\n        {\n            const resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n\n            if (batchableText.currentKey !== text.styleKey || text.resolution !== resolution)\n            {\n                // If the text has changed, we need to update the GPU text\n                this._updateGpuText(text);\n            }\n\n            text._didTextUpdate = false;\n\n            updateTextBounds(batchableText, text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const batchableText = this._getGpuText(text);\n\n        batchableText._batcher.updateElement(batchableText);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const batchableText = this._getGpuText(text);\n\n        if (batchableText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(batchableText.currentKey);\n        }\n\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n\n        batchableText.texture = this._renderer.canvasText.getManagedTexture(text);\n        batchableText.currentKey = text.styleKey;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return text._gpuData[this._renderer.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const batchableText = new BatchableText();\n\n        batchableText.currentKey = '--';\n        batchableText.renderable = text;\n        batchableText.transform = text.groupTransform;\n        batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableText.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        text._gpuData[this._renderer.uid] = batchableText;\n        this._managedTexts.add(text);\n\n        return batchableText;\n    }\n\n    protected onTextUnload(text: Text)\n    {\n        const gpuData = text._gpuData[this._renderer.uid];\n\n        if (!gpuData) return;\n\n        const { canvasText } = this._renderer;\n        const refCount = canvasText.getReferenceCount(gpuData.currentKey);\n\n        if (refCount > 0)\n        {\n            canvasText.decreaseReferenceCount(gpuData.currentKey);\n        }\n        else if (gpuData.texture)\n        {\n            canvasText.returnTexture(gpuData.texture);\n        }\n    }\n\n    public destroy()\n    {\n        this._managedTexts.destroy();\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { type Filter } from '../../../filters/Filter';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { type CanvasTextOptions, type Text } from '../Text';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextGenerator } from './CanvasTextGenerator';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @category rendering\n * @advanced\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    private readonly _activeTextures: Record<string, {\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    public getTexture(options: CanvasTextOptions): Texture;\n    public getTexture(\n        options: CanvasTextOptions | string,\n        _resolution?: number,\n        _style?: TextStyle,\n        _textKey?: string\n    ): Texture\n    {\n        if (typeof options === 'string')\n        {\n            // #if _DEBUG\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n            // #endif\n\n            options = {\n                text: options,\n                style: _style,\n                resolution: _resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        if (!(options.textureStyle instanceof TextureStyle))\n        {\n            options.textureStyle = new TextureStyle(options.textureStyle);\n        }\n\n        if (typeof options.text !== 'string')\n        {\n            options.text = options.text.toString();\n        }\n\n        const { text, style, textureStyle } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({\n            text: text as string,\n            style: style as TextStyle,\n            resolution,\n        });\n\n        const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);\n\n        if (textureStyle) texture.source.style = textureStyle as TextureStyle;\n\n        if (style.trim)\n        {\n            // reapply the padding to the frame\n            frame.pad(style.padding);\n            texture.frame.copyFrom(frame);\n\n            // We initially increased the frame size by a resolution factor\n            // to achieve a crisper display. Now we need to scale down the already\n            // trimmed frame to render the texture in the expected size.\n            texture.frame.scale(1 / resolution);\n            texture.updateUvs();\n        }\n\n        if (style.filters)\n        {\n            // apply the filters to the texture if required..\n            // this returns a new texture with the filters applied\n            const filteredTexture = this._applyFilters(texture, style.filters as Filter[]);\n\n            // return the original texture to the pool so we can reuse the next frame\n            this.returnTexture(texture);\n\n            CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n            // return the new texture with the filters applied\n            return filteredTexture;\n        }\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    /**\n     * Returns a texture that was created wit the above `getTexture` function.\n     * Handy if you are done with a texture and want to return it to the pool.\n     * @param texture - The texture to be returned.\n     */\n    public returnTexture(texture: Texture)\n    {\n        const source = texture.source;\n\n        source.resource = null;\n        source.uploadMethodId = 'unknown';\n        source.alphaMode = 'no-premultiply-alpha';\n\n        TexturePool.returnTexture(texture, true);\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     * @deprecated since 8.10.0\n     */\n    public renderTextToCanvas(): void\n    {\n        // #if _DEBUG\n        deprecation(\n            '8.10.0',\n            'CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead'\n        );\n        // #endif\n    }\n\n    /**\n     * Gets or creates a managed texture for a Text object. This method handles texture reuse and reference counting.\n     * @param text - The Text object that needs a texture\n     * @returns A Texture instance that represents the rendered text\n     * @remarks\n     * This method performs the following:\n     * 1. Sets the appropriate resolution based on auto-resolution settings\n     * 2. Checks if a texture already exists for the text's style\n     * 3. Creates a new texture if needed or returns an existing one\n     * 4. Manages reference counting for texture reuse\n     */\n    public getManagedTexture(text: Text)\n    {\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        const textKey = text.styleKey;\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const texture = this.getTexture({\n            text: text.text,\n            style: text.style,\n            resolution: text._resolution,\n            textureStyle: text.textureStyle,\n        });\n\n        this._activeTextures[textKey] = {\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    /**\n     * Decreases the reference count for a texture associated with a text key.\n     * When the reference count reaches zero, the texture is returned to the pool.\n     * @param textKey - The unique key identifying the text style configuration\n     * @remarks\n     * This method is crucial for memory management, ensuring textures are properly\n     * cleaned up when they are no longer needed by any Text instances.\n     */\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            this.returnTexture(activeTexture.texture);\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    /**\n     * Gets the current reference count for a texture associated with a text key.\n     * @param textKey - The unique key identifying the text style configuration\n     * @returns The number of Text instances currently using this texture\n     */\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey]?.usageCount ?? 0;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    /**\n     * Applies the specified filters to the given texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n     * texture is set to 'premultiplied-alpha'.\n     * @param {Texture} texture - The texture to which the filters will be applied.\n     * @param {Filter[]} filters - The filters to apply to the texture.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     */\n    private _applyFilters(texture: Texture, filters: Filter[]): Texture\n    {\n        // Save the current render target so it can be restored later\n        const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n\n        // Apply the filters to the texture and get the resulting texture\n        const resultTexture = this._renderer.filter.generateFilteredTexture({\n            texture,\n            filters,\n        });\n\n        // Set the alpha mode of the resulting texture to 'premultiplied-alpha'\n\n        // Restore the previous render target\n        this._renderer.renderTarget.bind(currentRenderTarget, false);\n\n        // Return the resulting texture with the filters applied\n        return resultTexture;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        // Clean up active textures\n        for (const key in this._activeTextures)\n        {\n            if (this._activeTextures[key]) this.returnTexture(this._activeTextures[key].texture);\n        }\n        (this._activeTextures as null) = null;\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\n/**\n * The shader used by the TilingSprite.\n * @internal\n */\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { GCManagedHash } from '../../utils/data/GCManagedHash';\nimport { updateTextBounds } from '../text/utils/updateTextBounds';\nimport { BatchableHTMLText } from './BatchableHTMLText';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\n\n/**\n * The HTMLTextPipe class is responsible for rendering HTML text.\n * @internal\n */\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _managedTexts: GCManagedHash<HTMLText>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.runners.resolutionChange.add(this);\n        this._managedTexts = new GCManagedHash({\n            renderer,\n            type: 'renderable',\n            onUnload: this.onTextUnload.bind(this),\n            name: 'htmlText'\n        });\n    }\n\n    protected resolutionChange()\n    {\n        for (const key in this._managedTexts.items)\n        {\n            const text = this._managedTexts.items[key];\n\n            if (text?._autoResolution)\n            {\n                text.onViewUpdate();\n            }\n        }\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText.styleKey;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (htmlText._didTextUpdate)\n        {\n            const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n            if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution)\n            {\n                // If the text has changed, we need to update the GPU text\n                this._updateGpuText(htmlText).catch((e) =>\n                {\n                    console.error(e);\n                });\n            }\n\n            htmlText._didTextUpdate = false;\n\n            updateTextBounds(batchableHTMLText, htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        batchableHTMLText._batcher.updateElement(batchableHTMLText);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (batchableHTMLText.generatingTexture) return;\n\n        // We need to preserve the current texture and don't release it until the new texture is generated.\n        // It's necessary to ensure that the texture won't be captured by another field and overwritten with their\n        // content, while our texture is still in progress.\n        const oldTexturePromise = batchableHTMLText.texturePromise;\n\n        batchableHTMLText.texturePromise = null;\n\n        batchableHTMLText.generatingTexture = true;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n        let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n\n        if (oldTexturePromise)\n        {\n            // Release old texture after new one is generated.\n            texturePromise = texturePromise.finally(() =>\n            {\n                this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);\n                this._renderer.htmlText.returnTexturePromise(oldTexturePromise);\n            });\n        }\n\n        batchableHTMLText.texturePromise = texturePromise;\n        batchableHTMLText.currentKey = htmlText.styleKey;\n\n        batchableHTMLText.texture = await texturePromise;\n\n        // need a rerender...\n        const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            // need a rebuild of the render group\n            renderGroup.structureDidChange = true;\n        }\n\n        batchableHTMLText.generatingTexture = false;\n\n        updateTextBounds(batchableHTMLText, htmlText);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const batchableHTMLText = new BatchableHTMLText();\n\n        batchableHTMLText.renderable = htmlText;\n        batchableHTMLText.transform = htmlText.groupTransform;\n        batchableHTMLText.texture = Texture.EMPTY;\n        batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableHTMLText.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n\n        this._managedTexts.add(htmlText);\n\n        return batchableHTMLText;\n    }\n\n    protected onTextUnload(text: HTMLText)\n    {\n        const gpuData = text._gpuData[this._renderer.uid];\n\n        if (!gpuData) return;\n\n        const { htmlText } = this._renderer;\n\n        htmlText.getReferenceCount(gpuData.currentKey) === null\n            ? htmlText.returnTexturePromise(gpuData.texturePromise)\n            : htmlText.decreaseReferenceCount(gpuData.currentKey);\n    }\n\n    public destroy()\n    {\n        this._managedTexts.destroy();\n        this._renderer = null;\n    }\n}\n\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\n/**\n * @param tilingSprite\n * @param uvs\n * @internal\n */\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite.applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { type Renderer } from '../../../rendering/renderers/types';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { type GPUData } from '../../view/ViewContainer';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext } from './GraphicsContextSystem';\n\n/** @internal */\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    contextChange(renderer: Renderer): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\n\n/** @internal */\nexport class GraphicsGpuData implements GPUData\n{\n    public batches: BatchableGraphics[] = [];\n    public batched = false;\n    public destroy()\n    {\n        this.batches.forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this.batches.length = 0;\n    }\n}\n\n/** @internal */\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: Renderer;\n    public state: State = State.for2d();\n\n    private _adaptor: GraphicsAdaptor;\n    private readonly _managedGraphics: GCManagedHash<Graphics>;\n\n    constructor(renderer: Renderer, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n        this.renderer.runners.contextChange.add(this);\n        this._managedGraphics = new GCManagedHash({ renderer, type: 'renderable', priority: -1, name: 'graphics' });\n    }\n\n    public contextChange(): void\n    {\n        this._adaptor.contextChange(this.renderer);\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n        const context = graphics.context;\n\n        const wasBatched = !!graphics._gpuData;\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n        if (graphics.didViewUpdate)\n        {\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const batches = gpuData.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batch._batcher.updateElement(batch);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // free up the batches..\n        gpuData.destroy();\n\n        if (gpuContext.isBatchable)\n        {\n            this._updateBatchesForRenderable(graphics, gpuData);\n        }\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getGpuDataForRenderable(graphics).batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n    }\n\n    private _initGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        const gpuData = new GraphicsGpuData();\n\n        graphics._gpuData[this.renderer.uid] = gpuData;\n\n        this._managedGraphics.add(graphics);\n\n        return gpuData;\n    }\n\n    private _updateBatchesForRenderable(graphics: Graphics, gpuData: GraphicsGpuData)\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        gpuData.batches = gpuContext.batches.map((batch) =>\n        {\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n    }\n\n    public destroy()\n    {\n        this._managedGraphics.destroy();\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { GCManagedHash } from '../../utils/data/GCManagedHash';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { type GPUData } from '../view/ViewContainer';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\n/**\n * GPU data for NineSliceSprite.\n * @internal\n */\nexport class NineSliceSpriteGpuData extends BatchableMesh implements GPUData\n{\n    constructor()\n    {\n        super();\n        this.geometry = new NineSliceGeometry();\n    }\n\n    public destroy()\n    {\n        this.geometry.destroy();\n    }\n}\n\n/**\n * The NineSliceSpritePipe is a render pipe for rendering NineSliceSprites.\n * @internal\n */\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private readonly _managedSprites: GCManagedHash<NineSliceSprite>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._managedSprites = new GCManagedHash({ renderer, type: 'renderable', name: 'nineSliceSprite' });\n    }\n\n    public addRenderable(sprite: NineSliceSprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture\n        );\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.setTexture(sprite._texture);\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): NineSliceSpriteGpuData\n    {\n        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): NineSliceSpriteGpuData\n    {\n        const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();\n\n        const batchableMesh = gpuData;\n\n        batchableMesh.renderable = sprite;\n        batchableMesh.transform = sprite.groupTransform;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._managedSprites.add(sprite);\n\n        // if the sprite has not been updated by the view, we need to update the batchable mesh now.\n        if (!sprite.didViewUpdate)\n        {\n            this._updateBatchableSprite(sprite, batchableMesh);\n        }\n\n        return gpuData;\n    }\n\n    public destroy()\n    {\n        this._managedSprites.destroy();\n        (this._renderer as null) = null;\n    }\n}\n","import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Filter } from '../../Filter';\nimport vertex from '../defaultFilter.vert';\nimport fragment from './passthrough.frag';\nimport source from './passthrough.wgsl';\n\n/**\n * The PassthroughFilter passes the input data through without altering it.\n * It serves as a basic filter, performing no graphical alterations.\n * @category filters\n * @internal\n */\nexport class PassthroughFilter extends Filter\n{\n    constructor()\n    {\n        const gpuProgram = GpuProgram.from({\n            vertex: { source, entryPoint: 'mainVertex' },\n            fragment: { source, entryPoint: 'mainFragment' },\n            name: 'passthrough-filter'\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'passthrough-filter'\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n        });\n    }\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { type GPUData } from '../../view/ViewContainer';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\nimport type { ParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\n/**\n * Options for creating a ParticleBuffer.\n * @internal\n */\nexport interface ParticleBufferOptions\n{\n    /** The size of the particle buffer, defaults to 1000. */\n    size: number;\n    /** A record of attributes that the particle container uses. */\n    properties: Record<string, ParticleRendererProperty>;\n}\n\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer implements GPUData\n{\n    /** The buffer containing static attribute data for all elements in the batch. */\n    public staticAttributeBuffer: ViewableBuffer;\n    /** The buffer containing dynamic attribute data for all elements in the batch. */\n    public dynamicAttributeBuffer: ViewableBuffer;\n\n    private readonly _staticBuffer: Buffer;\n    private readonly _dynamicBuffer: Buffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    private readonly _dynamicStride: number;\n    private readonly _staticStride: number;\n\n    /** The geometry of the particle buffer. */\n    public readonly geometry: Geometry;\n\n    private _size = 0;\n    private readonly _dynamicUpload: ParticleUpdateFunction;\n    private readonly _staticUpload: ParticleUpdateFunction;\n    private readonly _generateParticleUpdateCache: Record<string, {\n        dynamicUpdate: ParticleUpdateFunction;\n        staticUpdate: ParticleUpdateFunction;\n    }> = {};\n\n    constructor(options: ParticleBufferOptions)\n    {\n        // size in sprites!\n        const size = this._size = options.size ?? 1000;\n\n        // TODO add the option to specify what is dynamic!\n        const properties = options.properties;\n\n        // in bytes!\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                // dynamic.\n                dynamicVertexSize += attributeInfo.stride;\n            }\n            else\n            {\n                // static.\n                staticVertexSize += attributeInfo.stride;\n            }\n        }\n\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n\n        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n\n        this.indexBuffer = createIndicesForQuads(size);\n\n        // build geometry..\n\n        const geometry = new Geometry();\n\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n\n        this._staticBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'static-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        this._dynamicBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'dynamic-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format,\n                });\n                dynamicOffset += attributeInfo.size;\n            }\n            else\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format,\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n\n        geometry.addIndex(this.indexBuffer);\n\n        const uploadFunction = this.getParticleUpdate(properties);\n\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n\n        this.geometry = geometry;\n    }\n\n    public getParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        const key = getParticleSyncKey(properties);\n\n        if (this._generateParticleUpdateCache[key])\n        {\n            return this._generateParticleUpdateCache[key];\n        }\n\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n\n        return this._generateParticleUpdateCache[key];\n    }\n\n    public generateParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        return generateParticleUpdateFunction(properties);\n    }\n\n    public update(particles: IParticle[], uploadStatic: boolean)\n    {\n        // first resize the buffers if needed!\n        // TODO resize!\n        if (particles.length > this._size)\n        {\n            uploadStatic = true;\n\n            this._size = Math.max(particles.length, (this._size * 1.5) | 0);\n\n            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n            this.indexBuffer = createIndicesForQuads(this._size);\n\n            this.geometry.indexBuffer.setDataWithSize(\n                this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n\n        this._dynamicBuffer.setDataWithSize(\n            this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n\n        if (uploadStatic)\n        {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n\n            this._staticBuffer.setDataWithSize(\n                staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n\n    public destroy()\n    {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\n\nfunction getParticleSyncKey(properties: Record<string, ParticleRendererProperty>)\n{\n    const keyGen: string[] = [];\n\n    for (const key in properties)\n    {\n        const property = properties[key];\n\n        keyGen.push(key, property.code, property.dynamic ? 'd' : 's');\n    }\n\n    return keyGen.join('_');\n}\n\n","import { ExtensionType } from '../extensions/Extensions';\nimport { PassthroughFilter } from '../filters/defaults/passthrough/PassthroughFilter';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { type Rectangle } from '../maths/shapes/Rectangle';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n * @internal\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: 'pushFilter' | 'popFilter',\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\n/**\n * Class representing the data required for applying filters.\n * This class holds various properties that are used during the filter application process.\n * @internal\n */\nclass FilterData\n{\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    public skip = false;\n\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    public inputTexture: Texture = null;\n\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    public backTexture?: Texture = null;\n\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    public filters: Filter[] = null;\n\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    public bounds = new Bounds();\n\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    public container: Container = null;\n\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    public blendRequired: boolean = false;\n\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    public outputRenderSurface: RenderSurface = null;\n\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    public globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n\n    /**\n     * Indicates whether antialiasing is enabled for the filter.\n     * @type {boolean}\n     */\n    public antialias: boolean;\n\n    /**\n     * The resolution of the filter.\n     * @type {number}\n     */\n    public resolution: number;\n\n    /** The first enabled filter index in the current filter list. */\n    public firstEnabledIndex = -1;\n\n    /** The last enabled filter index in the current filter list. */\n    public lastEnabledIndex = -1;\n}\n\n/**\n * System that manages the filter pipeline\n * @category rendering\n * @advanced\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n    private _passthroughFilter: Filter;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    /**\n     * Pushes a filter instruction onto the filter stack.\n     * @param instruction - The instruction containing the filter effect and container.\n     * @internal\n     */\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        filterData.skip = false;\n\n        filterData.filters = filters as Filter[];\n        filterData.container = instruction.container;\n        filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, or all of them disabled, we skip the pass\n        if (filters.every((filter) => !filter.enabled))\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds = filterData.bounds;\n\n        this._calculateFilterArea(instruction, bounds);\n\n        this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        const previousFilterData = this._getPreviousFilterData();\n\n        const globalResolution = this._findFilterResolution(rootResolution);\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (previousFilterData)\n        {\n            offsetX = previousFilterData.bounds.minX;\n            offsetY = previousFilterData.bounds.minY;\n        }\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        // set all the filter data\n\n        this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n    }\n\n    /**\n     * Applies filters to a texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture.\n     * @param {object} params - The parameters for applying filters.\n     * @param {Texture} params.texture - The texture to apply filters to.\n     * @param {Filter[]} params.filters - The filters to apply.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     * @example\n     *\n     * ```ts\n     * // Create a texture and a list of filters\n     * const texture = new Texture(...);\n     * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n     *\n     * // Apply the filters to the texture\n     * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n     *\n     * // Use the resulting texture\n     * sprite.texture = resultTexture;\n     * ```\n     *\n     * Key Points:\n     * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n     * 2. If all filters are disabled or skipped, the original texture is returned.\n     */\n    public generateFilteredTexture({ texture, filters }: {texture: Texture, filters: Filter[]}): Texture\n    {\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        this._activeFilterData = filterData;\n        filterData.skip = false;\n\n        filterData.filters = filters;\n\n        const colorTextureSource = texture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, or all of them disabled, we skip the pass\n        if (filters.every((filter) => !filter.enabled))\n        {\n            filterData.skip = true;\n\n            return texture;\n        }\n\n        const bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n\n        bounds.addRect(texture.frame);\n\n        this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n\n        if (filterData.skip)\n        {\n            return texture;\n        }\n\n        const globalResolution = rootResolution;\n        const offsetX = 0;\n        const offsetY = 0;\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        /// /////////\n\n        // set all the filter data\n        // get a P02 texture from our pool...\n        filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // TODO this might need looking at for padding!\n        filterData.inputTexture = texture;\n\n        /// ////////////// PART 2 POP //////////////////////\n\n        const renderer = this.renderer;\n\n        // TODO required? check with AA\n        renderer.renderTarget.finishRenderPass();\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        this._applyFiltersToTexture(filterData, true);\n\n        const outputTexture = filterData.outputRenderSurface as Texture;\n\n        outputTexture.source.alphaMode = 'premultiplied-alpha';\n\n        return outputTexture;\n    }\n\n    /** @internal */\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._popFilterData();\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        renderer.globalUniforms.pop();\n\n        renderer.renderTarget.finishRenderPass();\n\n        this._activeFilterData = filterData;\n\n        this._applyFiltersToTexture(filterData, false);\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(filterData.backTexture);\n        }\n\n        // return the texture to the pool so we can reuse the next frame\n        TexturePool.returnTexture(filterData.inputTexture);\n    }\n\n    /**\n     * Copies the last render surface to a texture.\n     * @param lastRenderSurface - The last render surface to copy from.\n     * @param bounds - The bounds of the area to copy.\n     * @param previousBounds - The previous bounds to use for offsetting the copy.\n     */\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    /**\n     * Applies a filter to a texture.\n     * @param filter - The filter to apply.\n     * @param input - The input texture.\n     * @param output - The output render surface.\n     * @param clear - Whether to clear the output surface before applying the filter.\n     */\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._activeFilterData;\n\n        const outputRenderSurface = filterData.outputRenderSurface;\n\n        const isFinalTarget = outputRenderSurface === output;\n\n        // Find the correct resolution by looking back through the filter stack\n        const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n        const resolution = this._findFilterResolution(rootResolution);\n\n        // Calculate the offset for both outputFrame and globalFrame\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (isFinalTarget)\n        {\n            const offset = this._findPreviousFilterOffset();\n\n            offsetX = offset.x;\n            offsetY = offset.y;\n        }\n\n        this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n\n        // If the filter is disabled, we still need to write something into the output surface.\n        // Render a pass-through (copy) so the pipeline remains intact.\n        const filterToApply = filter.enabled\n            ? filter\n            : this._getPassthroughFilter();\n\n        this._setupBindGroupsAndRender(filterToApply, input, renderer);\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n\n        if (renderGroup && renderGroup.cacheToLocalTransform)\n        {\n            // get the matrix relative to the render group..\n            worldTransform.prepend(renderGroup.cacheToLocalTransform);\n        }\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.orig.width,\n            1.0 / sprite.texture.orig.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy(): void\n    {\n        this._passthroughFilter?.destroy(true);\n        (this._passthroughFilter as null) = null;\n    }\n\n    private _getPassthroughFilter(): Filter\n    {\n        this._passthroughFilter ??= new PassthroughFilter();\n\n        return this._passthroughFilter;\n    }\n\n    /**\n     * Sets up the bind groups and renders the filter.\n     * @param filter - The filter to apply\n     * @param input - The input texture\n     * @param renderer - The renderer instance\n     */\n    private _setupBindGroupsAndRender(filter: Filter, input: Texture, renderer: Renderer): void\n    {\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(this._filterGlobalUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    /**\n     * Sets up the filter textures including input texture and back texture if needed.\n     * @param filterData - The filter data to update\n     * @param bounds - The bounds for the texture\n     * @param renderer - The renderer instance\n     * @param previousFilterData - The previous filter data for back texture calculation\n     */\n    private _setupFilterTextures(\n        filterData: FilterData,\n        bounds: Bounds,\n        renderer: Renderer,\n        previousFilterData: FilterData | null\n    ): void\n    {\n        // set all the filter data\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        // Very cryptic, but important(!) moment.\n        //\n        // If we try to pull texture from the pool for backTexture before inputTexture,\n        // it will be unbounded later by startRenderPass. It happens because in such a case - the current backTexture\n        // is actually inputTexture from the previous filter application (check `pop` method).\n        //\n        // So maintaining the order (inputTexture -> backTexture) helps us to prevent unwanted texture unbinding.\n        if (filterData.blendRequired)\n        {\n            renderer.renderTarget.finishRenderPass();\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n\n            filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n        }\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n\n        // set the global uniforms to take into account the bounds offset required\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    /**\n     * Calculates and sets the global frame for the filter.\n     * @param filterData - The filter data to update\n     * @param offsetX - The X offset\n     * @param offsetY - The Y offset\n     * @param globalResolution - The global resolution\n     * @param sourceWidth - The source texture width\n     * @param sourceHeight - The source texture height\n     */\n    private _calculateGlobalFrame(\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        globalResolution: number,\n        sourceWidth: number,\n        sourceHeight: number\n    ): void\n    {\n        const globalFrame = filterData.globalFrame;\n\n        globalFrame.x = offsetX * globalResolution;\n        globalFrame.y = offsetY * globalResolution;\n        globalFrame.width = sourceWidth * globalResolution;\n        globalFrame.height = sourceHeight * globalResolution;\n    }\n\n    /**\n     * Updates the filter uniforms with the current filter state.\n     * @param input - The input texture\n     * @param output - The output render surface\n     * @param filterData - The current filter data\n     * @param offsetX - The X offset for positioning\n     * @param offsetY - The Y offset for positioning\n     * @param resolution - The current resolution\n     * @param isFinalTarget - Whether this is the final render target\n     * @param clear - Whether to clear the output surface\n     */\n    private _updateFilterUniforms(\n        input: Texture,\n        output: RenderSurface,\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        resolution: number,\n        isFinalTarget: boolean,\n        clear: boolean\n    ): void\n    {\n        const uniforms = this._filterGlobalUniforms.uniforms;\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            outputFrame[0] = filterData.bounds.minX - offsetX;\n            outputFrame[1] = filterData.bounds.minY - offsetY;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offsetX * resolution;\n        globalFrame[1] = offsetY * resolution;\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // we are going to overwrite resource we can set it to null!\n        if (output instanceof Texture) output.source.resource = null;\n\n        // set the output texture - this is where we are going to render to\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        this.renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n\n        this._filterGlobalUniforms.update();\n    }\n\n    /**\n     * Finds the correct resolution by looking back through the filter stack.\n     * @param rootResolution - The fallback root resolution to use\n     * @returns The resolution from the previous filter or root resolution\n     */\n    private _findFilterResolution(rootResolution: number): number\n    {\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        return currentIndex > 0 && this._filterStack[currentIndex].inputTexture\n            ? this._filterStack[currentIndex].inputTexture.source._resolution\n            : rootResolution;\n    }\n\n    /**\n     * Finds the offset from the previous non-skipped filter in the stack.\n     * @returns The offset coordinates from the previous filter\n     */\n    private _findPreviousFilterOffset(): { x: number, y: number }\n    {\n        let offsetX = 0;\n        let offsetY = 0;\n        let lastIndex = this._filterStackIndex;\n\n        while (lastIndex > 0)\n        {\n            lastIndex--;\n            const prevFilterData = this._filterStack[lastIndex];\n\n            if (!prevFilterData.skip)\n            {\n                offsetX = prevFilterData.bounds.minX;\n                offsetY = prevFilterData.bounds.minY;\n                break;\n            }\n        }\n\n        return { x: offsetX, y: offsetY };\n    }\n\n    /**\n     * Calculates the filter area bounds based on the instruction type.\n     * @param instruction - The filter instruction\n     * @param bounds - The bounds object to populate\n     */\n    private _calculateFilterArea(instruction: FilterInstruction, bounds: Bounds): void\n    {\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            // we want to factor render layers to get the real visual bounds of this container.\n            // so the last param is true..\n            instruction.container.getFastGlobalBounds(true, bounds);\n        }\n\n        if (instruction.container)\n        {\n            // When a container is cached as a texture, its filters need to be applied relative to its\n            // cached parent's coordinate space rather than world space. This transform adjustment ensures\n            // filters are applied in the correct coordinate system.\n            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n            const filterFrameTransform = renderGroup.cacheToLocalTransform;\n\n            if (filterFrameTransform)\n            {\n                bounds.applyMatrix(filterFrameTransform);\n            }\n        }\n    }\n\n    private _applyFiltersToTexture(filterData: FilterData, clear: boolean)\n    {\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        const filters = filterData.filters;\n        const firstEnabled = filterData.firstEnabledIndex;\n        const lastEnabled = filterData.lastEnabledIndex;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n\n        if (firstEnabled === lastEnabled)\n        {\n            // render a single filter...\n            filters[firstEnabled].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            const tempTexture = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            // get another texture that we will render the next filter too\n            let flop = tempTexture;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (let i = firstEnabled; i < lastEnabled; i++)\n            {\n                const filter = filters[i];\n\n                if (!filter.enabled) continue;\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n            // apply the last enabled filter to the output\n            filters[lastEnabled].apply(this, flip, filterData.outputRenderSurface, clear);\n\n            // return those textures for later!\n            TexturePool.returnTexture(tempTexture);\n        }\n    }\n\n    private _calculateFilterBounds(\n        filterData: FilterData,\n        viewPort: Rectangle,\n        rootAntialias: boolean,\n        rootResolution: number,\n        // a multiplier padding for the bounds calculation\n        // this prop is used when applying filters to textures\n        // as the should have padding applied to them already (until we fix padding when applying them to textures)\n        // set to 0 to remove padding from the bounds calculation\n        paddingMultiplier: number\n    )\n    {\n        const renderer = this.renderer;\n\n        const bounds = filterData.bounds;\n        const filters = filterData.filters;\n\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n        // cache first/last enabled indices for later passes\n        let firstEnabledIndex = -1;\n        let lastEnabledIndex = -1;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            // Only enabled filters should influence pipeline characteristics\n            if (!filter.enabled) continue;\n\n            if (firstEnabledIndex === -1) firstEnabledIndex = i;\n            lastEnabledIndex = i;\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? rootResolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= rootAntialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = true;\n            blendRequired ||= filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        if (clipToViewport)\n        {\n            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n        }\n\n        // round the bounds to the nearest pixel\n        bounds\n            .scale(resolution)\n            .ceil()\n            .scale(1 / resolution)\n            .pad((padding | 0) * paddingMultiplier);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set the global frame to the root texture\n\n        // get previous bounds.. we must take into account skipped filters also..\n\n        // // to find the previous resolution we need to account for the skipped filters\n        // // the following will find the last non skipped filter...\n\n        // store the values that will be used to apply the filters\n        filterData.antialias = antialias;\n        filterData.resolution = resolution;\n        filterData.blendRequired = blendRequired;\n        filterData.firstEnabledIndex = firstEnabledIndex;\n        filterData.lastEnabledIndex = lastEnabledIndex;\n    }\n\n    private _popFilterData(): FilterData\n    {\n        this._filterStackIndex--;\n\n        return this._filterStack[this._filterStackIndex];\n    }\n\n    private _getPreviousFilterData(): FilterData | null\n    {\n        let previousFilterData: FilterData;\n\n        let index = this._filterStackIndex - 1;\n\n        while (index > 0)\n        {\n            index--;\n            previousFilterData = this._filterStack[index];\n\n            if (!previousFilterData.skip)\n            {\n                break;\n            }\n        }\n\n        return previousFilterData;\n    }\n\n    private _pushFilterData(): FilterData\n    {\n        let filterData = this._filterStack[this._filterStackIndex];\n\n        if (!filterData)\n        {\n            filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n        }\n\n        this._filterStackIndex++;\n\n        return filterData;\n    }\n}\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\nimport wgsl from './particles.wgsl';\n\n/** @internal */\nexport class ParticleShader extends Shader\n{\n    constructor()\n    {\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment\n        });\n\n        const gpuProgram = GpuProgram.from({\n            fragment: {\n                source: wgsl,\n                entryPoint: 'mainFragment'\n            },\n            vertex: {\n                source: wgsl,\n                entryPoint: 'mainVertex'\n            }\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                // this will be replaced with the texture from the particle container\n                uTexture: Texture.WHITE.source,\n                // this will be replaced with the texture style from the particle container\n                uSampler: new TextureStyle({}),\n                // this will be replaced with the local uniforms from the particle container\n                uniforms: {\n                    uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Color(0xFFFFFF), type: 'vec4<f32>' },\n                    uRound: { value: 1, type: 'f32' },\n                    uResolution: { value: [0, 0], type: 'vec2<f32>' },\n                }\n            }\n        });\n    }\n}\n","import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle, type TextureStyleOptions } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { TextStyle } from '../text/TextStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/** @internal */\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n    textureSize?: number\n    mipmap?: boolean\n    textureStyle?: TextureStyle | TextureStyleOptions\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @category text\n * @internal\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    public static defaultOptions: DynamicBitmapFontOptions = {\n        textureSize: 512,\n        style: new TextStyle(),\n        mipmap: true,\n    };\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 0;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentMaxCharHeight = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n    private readonly _textureSize: number;\n    private readonly _mipmap: boolean;\n    private readonly _textureStyle?: TextureStyle;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = { ...DynamicBitmapFont.defaultOptions, ...options };\n\n        this._textureSize = dynamicOptions.textureSize;\n        this._mipmap = dynamicOptions.mipmap;\n\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        this.applyFillAsTint = dynamicOptions.overrideFill;\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        if (dynamicOptions.textureStyle)\n        {\n            this._textureStyle = dynamicOptions.textureStyle instanceof TextureStyle\n                ? dynamicOptions.textureStyle\n                : new TextureStyle(dynamicOptions.textureStyle);\n        }\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = CanvasTextMetrics.graphemeSegmenter(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n        let currentMaxCharHeight = this._currentMaxCharHeight;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        let skipTexture = false;\n\n        const maxTextureWidth = canvas.width / this.resolution;\n        const maxTextureHeight = canvas.height / this.resolution;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps height\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = metrics.width * fontScale;\n            // This is ugly - but italics are given more space so they don't overlap\n            const textureGlyphWidth = Math.ceil((style.fontStyle === 'italic' ? 2 : 1) * width);\n\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = textureGlyphWidth + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                currentMaxCharHeight = Math.ceil(Math.max(paddedHeight, currentMaxCharHeight));\n            }\n\n            if (currentX + paddedWidth > maxTextureWidth)\n            {\n                currentY += currentMaxCharHeight;\n\n                // reset the line x and height..\n                currentMaxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + currentMaxCharHeight > maxTextureHeight)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentX = 0;\n                    currentY = 0;\n                    currentMaxCharHeight = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n        this._currentMaxCharHeight = currentMaxCharHeight;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n            this._textureSize,\n            this._textureSize,\n            textureResolution\n        );\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload',\n                autoGenerateMipmaps: this._mipmap,\n            }),\n\n        });\n\n        if (this._textureStyle)\n        {\n            texture.source.style = this._textureStyle;\n        }\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        let removeShadow = false;\n\n        if (style.stroke && strokeThickness)\n        {\n            removeShadow = true;\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        const { shadowBlur, shadowOffsetX, shadowOffsetY } = context;\n\n        if (style._fill)\n        {\n            if (removeShadow)\n            {\n                context.shadowBlur = 0;\n                context.shadowOffsetX = 0;\n                context.shadowOffsetY = 0;\n            }\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (removeShadow)\n        {\n            context.shadowBlur = shadowBlur;\n            context.shadowOffsetX = shadowOffsetX;\n            context.shadowOffsetY = shadowOffsetY;\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { GCManagedHash } from '../../utils/data/GCManagedHash';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { type GPUData } from '../view/ViewContainer';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { TilingSprite } from './TilingSprite';\n\nconst sharedQuad = new QuadGeometry();\n\n/** @internal */\nexport class TilingSpriteGpuData implements GPUData\n{\n    public canBatch: boolean = true;\n    public renderable: TilingSprite;\n    public batchableMesh?: BatchableMesh;\n    public geometry?: MeshGeometry;\n    public shader?: TilingSpriteShader;\n\n    constructor()\n    {\n        this.geometry = new MeshGeometry({\n            indices: sharedQuad.indices.slice(),\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n    }\n\n    public destroy()\n    {\n        this.geometry.destroy();\n        this.shader?.destroy();\n    }\n}\n\n/**\n * The TilingSpritePipe is a render pipe for rendering TilingSprites.\n * It handles the batching and rendering of TilingSprites using a shader.\n * @internal\n */\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _state: State = State.default2d;\n    private readonly _managedTilingSprites: GCManagedHash<TilingSprite>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._managedTilingSprites = new GCManagedHash({ renderer, type: 'renderable', name: 'tilingSprite' });\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                renderable.texture\n            );\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite.didViewUpdate)\n            {\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.renderable = tilingSprite;\n                batchableMesh.transform = tilingSprite.groupTransform;\n                batchableMesh.setTexture(tilingSprite._texture);\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._getTilingSpriteData(tilingSprite);\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: this._state,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh._batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite.didViewUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): TilingSpriteGpuData\n    {\n        return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): TilingSpriteGpuData\n    {\n        const gpuData = new TilingSpriteGpuData();\n\n        gpuData.renderable = tilingSprite;\n        tilingSprite._gpuData[this._renderer.uid] = gpuData;\n\n        this._managedTilingSprites.add(tilingSprite);\n\n        return gpuData;\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        this._managedTilingSprites.destroy();\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\n/** @internal */\nexport class SdfShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { type GPUData } from '../../view/ViewContainer';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\n/**\n * GPUData for Mesh\n * @internal\n */\nexport class MeshGpuData implements GPUData\n{\n    public meshData?: MeshData;\n    public batchableMesh?: BatchableMesh;\n\n    public destroy()\n    {\n        // BOOM!\n    }\n}\n\n/**\n * The data for the mesh\n * @internal\n */\ninterface MeshData\n{\n    /** if the mesh is batched or not */\n    batched: boolean;\n    /** the size of the index buffer */\n    indexSize: number;\n    /** the size of the vertex buffer */\n    vertexSize: number;\n}\n\n/** @internal */\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\n/**\n * The MeshPipe is responsible for handling the rendering of Mesh objects.\n * It manages the batching of meshes, updates their GPU data, and executes the rendering instructions.\n * It also handles the local uniforms for each mesh, such as transformation matrices and colors.\n * @category scene\n * @internal\n */\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            if (batchableMesh.texture.uid !== mesh._texture.uid)\n            {\n                batchableMesh._textureMatrixUpdateId = -1;\n            }\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                mesh._texture\n            );\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const meshData = this._getMeshData(mesh);\n\n        if (mesh.didViewUpdate)\n        {\n            meshData.indexSize = mesh._geometry.indices?.length;\n            meshData.vertexSize = mesh._geometry.positions?.length;\n        }\n\n        if (meshData.batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add(mesh);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public execute(mesh: Mesh)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        mesh._gpuData[this.renderer.uid] ||= new MeshGpuData();\n\n        return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        mesh._gpuData[this.renderer.uid].meshData = {\n            batched: mesh.batched,\n            indexSize: 0,\n            vertexSize: 0,\n        };\n\n        return mesh._gpuData[this.renderer.uid].meshData;\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        mesh._gpuData[this.renderer.uid] ||= new MeshGpuData();\n\n        return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = new BatchableMesh();\n\n        gpuMesh.renderable = mesh;\n        gpuMesh.setTexture(mesh._texture);\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link ResizePlugin}.\n * These options control how your application handles window and element resizing.\n * @example\n * ```ts\n * // Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Auto-resize to container element\n * await app.init({ resizeTo: document.querySelector('#game') });\n * ```\n * @category app\n * @standard\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @example\n     * ```ts\n     * const app = new Application();\n     * await app.init({\n     *     resizeTo: window, // Resize to the entire window\n     *     // or\n     *     resizeTo: document.querySelector('#game-container'), // Resize to a specific element\n     *     // or\n     *     resizeTo: null, // Disable auto-resize\n     * });\n     * ```\n     * @default null\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality. This plugin handles automatic\n * and manual resizing of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `resizeTo`: Set an element to automatically resize to\n * - `resize`: Manually trigger a resize\n * - `queueResize`: Queue a resize for the next animation frame\n * - `cancelResize`: Cancel a queued resize\n * @example\n * ```ts\n * import { Application, ResizePlugin } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Example 2: Auto-resize to specific element\n * const container = document.querySelector('#game-container');\n * await app.init({ resizeTo: container });\n *\n * // Example 3: Change resize target at runtime\n * app.resizeTo = window;                    // Enable auto-resize to window\n * app.resizeTo = null;                      // Disable auto-resize\n * ```\n * @category app\n * @standard\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n    /** @internal */\n    public static resizeTo: Window | HTMLElement;\n    /** @internal */\n    public static resize: () => void;\n    /** @internal */\n    public static renderer: ResizeableRenderer;\n    /** @internal */\n    public static queueResize: () => void;\n    /** @internal */\n    public static render: () => void;\n    /** @internal */\n    private static _resizeId: number;\n    /** @internal */\n    private static _resizeTo: Window | HTMLElement;\n    /** @internal */\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            {\n                configurable: true,\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { GCManagedHash } from '../../utils/data/GCManagedHash';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { type GPUData } from '../view/ViewContainer';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { BitmapText } from './BitmapText';\n\n/** @internal */\nexport class BitmapTextGraphics extends Graphics implements GPUData\n{\n    public destroy()\n    {\n        if (this.context.customShader)\n        {\n            this.context.customShader.destroy();\n        }\n\n        super.destroy();\n    }\n}\n\n/** @internal */\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _managedBitmapTexts: GCManagedHash<BitmapText>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._managedBitmapTexts = new GCManagedHash({ renderer, type: 'renderable', priority: -2, name: 'bitmapText' });\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                // TODO: Check if this is a WebGL renderer before asserting type\n                context.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);\n            }\n        }\n\n        const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        let tx = bitmapTextLayout.width;\n        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n\n        if (style._stroke)\n        {\n            tx += style._stroke.width / scale;\n            ty += style._stroke.width / scale;\n        }\n\n        context\n            .translate((-bitmapText._anchor._x * tx) - padding, (-bitmapText._anchor._y * ty) - padding)\n            .scale(scale, scale);\n\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 0xFFFFFF;\n\n        let fontSize = bitmapFont.fontMetrics.fontSize;\n        let lineHeight = bitmapFont.lineHeight;\n\n        if (style.lineHeight)\n        {\n            fontSize = style.fontSize / scale;\n            lineHeight = style.lineHeight / scale;\n        }\n\n        let linePositionYShift = (lineHeight - fontSize) / 2;\n\n        // if `currentY` is no longer starts from `baseLineOffset`\n        // the `baseLineOffset` below may also need to be removed\n        if (linePositionYShift - bitmapFont.baseLineOffset < 0)\n        {\n            linePositionYShift = 0;\n        }\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = line.chars[j];\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    const texture = charData.texture;\n\n                    context.texture(\n                        texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset + linePositionYShift),\n                        texture.orig.width,\n                        texture.orig.height,\n                    );\n                }\n            }\n\n            currentY += lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that has the same style!\n        const proxyRenderable = new BitmapTextGraphics();\n\n        bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        this._managedBitmapTexts.add(bitmapText);\n\n        return proxyRenderable;\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        this._managedBitmapTexts.destroy();\n        this._renderer = null;\n        (this._managedBitmapTexts as null) = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\n/** @internal */\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */`\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n\n    }\n};\n\n/** @internal */\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */`\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n\n    }\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport { ParticleShader } from './shader/ParticleShader';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { ParticleContainer } from './ParticleContainer';\n\n/** @internal */\nexport interface ParticleContainerAdaptor\n{\n    execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer): void;\n}\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @category scene\n * @internal\n */\nexport class ParticleContainerPipe implements RenderPipe<ParticleContainer>\n{\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public defaultShader: Shader;\n\n    /** @internal */\n    public adaptor: ParticleContainerAdaptor;\n    /** @internal */\n    public readonly state = State.for2d();\n    /** @internal */\n    public readonly renderer: Renderer;\n    private readonly _managedContainers: GCManagedHash<ParticleContainer>;\n\n    /** Local uniforms that are used for rendering particles. */\n    public readonly localUniforms = new UniformGroup({\n        uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uRound: { value: 1, type: 'f32' },\n        uResolution: { value: [0, 0], type: 'vec2<f32>' },\n    });\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     * @param adaptor\n     */\n    constructor(renderer: Renderer, adaptor: ParticleContainerAdaptor)\n    {\n        this.renderer = renderer;\n\n        this.adaptor = adaptor;\n\n        this.defaultShader = new ParticleShader();\n\n        this.state = State.for2d();\n\n        this._managedContainers = new GCManagedHash({ renderer, type: 'renderable', name: 'particleContainer' });\n    }\n\n    public validateRenderable(_renderable: ParticleContainer): boolean\n    {\n        // always fine :D\n        return false;\n    }\n\n    public addRenderable(renderable: ParticleContainer, instructionSet: InstructionSet)\n    {\n        this.renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(renderable);\n    }\n\n    public getBuffers(renderable: ParticleContainer): ParticleBuffer\n    {\n        return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);\n    }\n\n    private _initBuffer(renderable: ParticleContainer): ParticleBuffer\n    {\n        renderable._gpuData[this.renderer.uid] = new ParticleBuffer({\n            size: renderable.particleChildren.length,\n            properties: renderable._properties,\n        });\n\n        this._managedContainers.add(renderable);\n\n        return renderable._gpuData[this.renderer.uid];\n    }\n\n    public updateRenderable(_renderable: ParticleContainer)\n    {\n        // nothing to be done here!\n    }\n\n    public execute(container: ParticleContainer): void\n    {\n        const children = container.particleChildren;\n\n        if (children.length === 0)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const buffer = this.getBuffers(container);\n\n        container.texture ||= children[0].texture;\n\n        const state = this.state;\n\n        buffer.update(children, container._childrenDirty);\n        container._childrenDirty = false;\n\n        state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n\n        const uniforms = this.localUniforms.uniforms;\n\n        const transformationMatrix = uniforms.uTranslationMatrix;\n\n        container.worldTransform.copyTo(transformationMatrix);\n\n        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n\n        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n        uniforms.uRound = renderer._roundPixels | container._roundPixels;\n\n        color32BitToUniform(\n            container.groupColorAlpha,\n            uniforms.uColor,\n            0\n        );\n\n        this.adaptor.execute(this, container);\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        this._managedContainers.destroy();\n        (this.renderer as null) = null;\n        if (this.defaultShader)\n        {\n            this.defaultShader.destroy();\n            this.defaultShader = null;\n        }\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/**\n * @category text\n * @advanced\n */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @category text\n * @advanced\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @category text\n * @advanced\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @category text\n * @advanced\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    public applyFillAsTint = true;\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): NonNullable<BitmapFontData['distanceField']>['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): NonNullable<BitmapFontData['distanceField']>['type']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(destroyTextures = false): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            // texture may not exist if the char is \" \", \\n, \\r, or \\t.\n            this.chars[i].texture?.destroy();\n        }\n\n        (this.chars as null) = null;\n\n        if (destroyTextures)\n        {\n            this.pages.forEach((page) => page.texture.destroy(true));\n            (this.pages as any) = null;\n        }\n    }\n}\n","import { type ImageLike } from '../../environment/ImageLike';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { type CanvasAndContext, CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { type HTMLTextStyle } from './HTMLTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLText, HTMLTextOptions } from './HTMLText';\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @category rendering\n * @advanced\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    private readonly _activeTextures: Record<string, {\n        texture: Texture,\n        usageCount: number,\n        promise: Promise<Texture>,\n    }> = {};\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    /**\n     * @param options\n     * @deprecated Use getTexturePromise instead\n     */\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this.getTexturePromise(options);\n    }\n\n    /**\n     * Increases the reference count for a texture.\n     * @param text - The HTMLText instance associated with the texture.\n     */\n    public getManagedTexture(text: HTMLText): Promise<Texture>\n    {\n        const textKey = text.styleKey;\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    /**\n     * Gets the current reference count for a texture associated with a text key.\n     * @param textKey - The unique key identifying the text style configuration\n     * @returns The number of Text instances currently using this texture\n     */\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey]?.usageCount ?? null;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    /**\n     * Decreases the reference count for a texture.\n     * If the count reaches zero, the texture is cleaned up.\n     * @param textKey - The key associated with the HTMLText instance.\n     */\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture.texture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture.texture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    /**\n     * Returns a promise that resolves to a texture for the given HTMLText options.\n     * @param options - The options for the HTMLText.\n     * @returns A promise that resolves to a Texture.\n     */\n    public getTexturePromise(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(options);\n    }\n\n    private async _buildTexturePromise(options: HTMLTextOptions)\n    {\n        const { text, style, resolution, textureStyle } = options as {\n            text: string,\n            style: HTMLTextStyle,\n            resolution: number,\n            textureStyle?: TextureStyle,\n        };\n\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(fontFamilies);\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        // this off set will ensure we don't get any UV bleeding!\n        const uvSafeOffset = 2;\n\n        image.width = (width | 0) + uvSafeOffset;\n        image.height = (height | 0) + uvSafeOffset;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        const resource: ImageLike | HTMLCanvasElement = image;\n        let canvasAndContext: CanvasAndContext;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : resource,\n            image.width - uvSafeOffset,\n            image.height - uvSafeOffset,\n            resolution\n        );\n\n        if (textureStyle) texture.source.style = textureStyle;\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    public returnTexturePromise(texturePromise: Promise<Texture>)\n    {\n        texturePromise.then((texture) =>\n        {\n            this._cleanUp(texture);\n        }).catch(() =>\n        {\n            // #if _DEBUG\n            warn('HTMLTextSystem: Failed to clean texture');\n            // #endif\n        });\n    }\n\n    private _cleanUp(texture: Texture)\n    {\n        TexturePool.returnTexture(texture, true);\n        texture.source.resource = null;\n        texture.source.uploadMethodId = 'unknown';\n    }\n\n    public destroy()\n    {\n        // BOOM!\n        (this._renderer as null) = null;\n        for (const key in this._activeTextures)\n        {\n            if (this._activeTextures[key]) this.returnTexturePromise(this._activeTextures[key].promise);\n        }\n        (this._activeTextures as null) = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link TickerPlugin}.\n * These options control the animation loop and update cycle of your PixiJS application.\n * @example\n * ```ts\n * import { Application } from 'pixi.js';\n *\n * // Basic setup with default options\n * const app = new Application();\n * await app.init({\n *     autoStart: true,     // Start animation loop automatically\n *     sharedTicker: false  // Use dedicated ticker instance\n * });\n *\n * // Advanced setup with shared ticker\n * const app2 = new Application();\n * await app2.init({\n *     autoStart: false,    // Don't start automatically\n *     sharedTicker: true   // Use global shared ticker\n * });\n *\n * // Start animation when ready\n * app2.start();\n * ```\n * @remarks\n * The ticker is the heart of your application's animation system. It:\n * - Manages the render loop\n * - Provides accurate timing information\n * - Handles frame-based updates\n * - Supports priority-based execution order\n * @see {@link Ticker} For detailed ticker functionality\n * @see {@link UPDATE_PRIORITY} For update priority constants\n * @category app\n * @standard\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Controls whether the animation loop starts automatically after initialization.\n     * > [!IMPORTANT]\n     * > Setting this to `false` does NOT stop the shared ticker even if `sharedTicker` is `true`.\n     * > You must stop the shared ticker manually if needed.\n     * @example\n     * ```ts\n     * // Auto-start (default behavior)\n     * await app.init({ autoStart: true });\n     *\n     * // Manual start\n     * await app.init({ autoStart: false });\n     * app.start(); // Start when ready\n     * ```\n     * @default true\n     */\n    autoStart?: boolean;\n\n    /**\n     * Controls whether to use the shared global ticker or create a new instance.\n     *\n     * The shared ticker is useful when you have multiple instances that should sync their updates.\n     * However, it has some limitations regarding update order control.\n     *\n     * Update Order:\n     * 1. System ticker (always runs first)\n     * 2. Shared ticker (if enabled)\n     * 3. App ticker (if using own ticker)\n     * @example\n     * ```ts\n     * // Use shared ticker (global instance)\n     * await app.init({ sharedTicker: true });\n     *\n     * // Use dedicated ticker (default)\n     * await app.init({ sharedTicker: false });\n     *\n     * // Access ticker properties\n     * console.log(app.ticker.FPS);    // Current FPS\n     * console.log(app.ticker.deltaMS); // MS since last update\n     * ```\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link Ticker} functionality. This plugin manages the\n * animation loop and update cycle of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `ticker`: Access to the application's ticker\n * - `start`: Start the animation loop\n * - `stop`: Stop the animation loop\n * @example\n * ```ts\n * import { Application, TickerPlugin, extensions } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Basic ticker usage (default autoStart)\n * await app.init({ autoStart: true });      // Starts ticker automatically\n *\n * // Example 2: Manual ticker control\n * await app.init({ autoStart: false });     // Don't start automatically\n * app.start();                              // Start manually\n * app.stop();                               // Stop manually\n *\n * // Example 3: Add custom update logic\n * app.ticker.add((ticker) => {\n *     // Run every frame, delta is the time since last update\n *     sprite.rotation += 0.1 * ticker.deltaTime;\n * });\n *\n * // Example 4: Control update priority\n * import { UPDATE_PRIORITY } from 'pixi.js';\n *\n * app.ticker.add(\n *     (ticker) => {\n *         // Run before normal priority updates\n *     },\n *     null,\n *     UPDATE_PRIORITY.HIGH\n * );\n *\n * // Example 5: One-time update\n * app.ticker.addOnce(() => {\n *     console.log('Runs next frame only');\n * });\n * ```\n * @see {@link Ticker} For detailed ticker functionality\n * @see {@link UPDATE_PRIORITY} For priority constants\n * @category app\n * @standard\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    /** @internal */\n    public static start: () => void;\n    /** @internal */\n    public static stop: () => void;\n    /** @internal */\n    private static _ticker: Ticker;\n    /** @internal */\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                configurable: true,\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        this._ticker = null;\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n","import { lru } from 'tiny-lru';\nimport { Cache } from '../../assets/cache/Cache';\nimport { type TextureStyle, type TextureStyleOptions } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\nlet fontCount = 0;\n\n/**\n * The options for installing a new BitmapFont. Once installed, the font will be available\n * for use in BitmapText objects through the fontFamily property of TextStyle.\n * @example\n * ```ts\n * import { BitmapFont, BitmapText } from 'pixi.js';\n *\n * // Basic font installation\n * BitmapFont.install({\n *     name: 'BasicFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: '#ffffff'\n *     }\n * });\n *\n * // Advanced font installation\n * BitmapFont.install({\n *     name: 'AdvancedFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: '#ff0000',\n *         stroke: { color: '#000000', width: 2 }\n *     },\n *     // Include specific character ranges\n *     chars: [\n *         ['a', 'z'],           // lowercase letters\n *         ['A', 'Z'],           // uppercase letters\n *         ['0', '9'],           // numbers\n *         '!@#$%^&*()_+-=[]{}' // symbols\n *     ],\n *     resolution: 2,            // High-DPI support\n *     padding: 4,              // Glyph padding\n *     skipKerning: false,      // Enable kerning\n *     textureStyle: {\n *         scaleMode: 'linear',\n *     }\n * });\n *\n * // Using the installed font\n * const text = new BitmapText({\n *     text: 'Hello World',\n *     style: {\n *         fontFamily: 'AdvancedFont',\n *         fontSize: 48\n *     }\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface BitmapFontInstallOptions\n{\n    /**\n     * The name of the font. This will be used as the fontFamily in text styles to access this font.\n     * Must be unique across all installed bitmap fonts.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'MyCustomFont',\n     *     style: { fontFamily: 'Arial' }\n     * });\n     * ```\n     */\n    name?: string;\n\n    /**\n     * Characters included in the font set. You can specify individual characters or ranges.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     * @example\n     * ```ts\n     * // Different ways to specify characters\n     * BitmapFont.install({\n     *     name: 'RangeFont',\n     *     chars: [\n     *         ['a', 'z'],              // Range of characters\n     *         '0123456789',            // String of characters\n     *         [['0', '9'], ['A', 'Z']] // Multiple ranges\n     *     ]\n     * });\n     * ```\n     */\n    chars?: string | (string | string[])[];\n\n    /**\n     * Render resolution for glyphs. Higher values create sharper text at the cost of memory.\n     * Useful for supporting high-DPI displays.\n     * @default 1\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'HiDPIFont',\n     *     resolution: window.devicePixelRatio || 2\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * Padding between glyphs on texture atlas. Balances visual quality with texture space.\n     * - Lower values: More compact, but may have visual artifacts\n     * - Higher values: Better quality, but uses more texture space\n     * @default 4\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'PaddedFont',\n     *     padding: 8 // More padding for better quality\n     * });\n     * ```\n     */\n    padding?: number;\n\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * - true: Faster generation, but text may have inconsistent spacing\n     * - false: Better text appearance, but slower generation\n     * @default false\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'FastFont',\n     *     skipKerning: true // Prioritize performance\n     * });\n     * ```\n     */\n    skipKerning?: boolean;\n\n    /**\n     * Style options to render the BitmapFont with.\n     * Supports all TextStyle properties including fill, stroke, and shadow effects.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'StyledFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 32,\n     *         fill: 'white',\n     *         stroke: { color: '#000000', width: 2 },\n     *         dropShadow: {\n     *             color: '#000000',\n     *             blur: 2,\n     *             distance: 3\n     *         }\n     *     }\n     * });\n     * ```\n     */\n    style?: TextStyle | TextStyleOptions;\n\n    /**\n     * Optional texture style to use when creating the font textures.\n     * Controls how the font textures are rendered and filtered.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'CrispFont',\n     *     textureStyle: {\n     *         scaleMode: 'nearest',\n     *     }\n     * });\n     * ```\n     */\n    textureStyle?: TextureStyle | TextureStyleOptions;\n\n    /**\n     * Whether to allow overriding the fill color with a tint at runtime.\n     *\n     * When enabled, the font can be dynamically tinted using the `tint` property of BitmapText,\n     * allowing a single font to display multiple colors without creating separate font textures.\n     * This is memory efficient but requires the font to be rendered with white fill color.\n     *\n     * When disabled, the fill color is permanently baked into the font texture. This allows\n     * any fill color but prevents runtime tinting - each color variation requires a separate font.\n     * @default false (automatically determined based on style)\n     *\n     * **Requirements for tinting:**\n     * - Fill color must be white (`0xFFFFFF` or `'#ffffff'`)\n     * - No stroke effects\n     * - No drop shadows (or only black shadows)\n     * - No gradient or pattern fills\n     *\n     * **Performance considerations:**\n     * -  Enabled: One font texture, multiple colors via tinting (memory efficient)\n     * -  Disabled: Separate font texture per color (higher memory usage)\n     * @example\n     * ```ts\n     * // Correct usage - white fill with tinting enabled\n     * BitmapFont.install({\n     *     name: 'TintableFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: 0xFFFFFF  // Must be white for tinting\n     *     },\n     *     dynamicFill: true\n     * });\n     *\n     * // Use the font with different colors via tinting\n     * const redText = new BitmapText({\n     *     text: 'Red Text',\n     *     style: { fontFamily: 'TintableFont', fill: 'red }, // Red tint\n     * });\n     *\n     * const blueText = new BitmapText({\n     *     text: 'Blue Text',\n     *     style: { fontFamily: 'TintableFont', fill: 'blue' }, // Blue tint\n     * });\n     * ```\n     * @example\n     * ```ts\n     * // Incorrect usage - colored fill with tinting enabled\n     * BitmapFont.install({\n     *     name: 'BadTintFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: 0xFF0000  //  Red fill won't tint properly\n     *     },\n     *     dynamicFill: true  //  Will not work as expected\n     * });\n     * ```\n     * @example\n     * ```ts\n     * // Alternative - baked colors (no tinting)\n     * BitmapFont.install({\n     *     name: 'BakedColorFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: 0xFF0000,  // Any color works\n     *         stroke: { color: 0x000000, width: 2 }  // Strokes allowed\n     *     },\n     *     dynamicFill: false  // Color is baked in\n     * });\n     * ```\n     */\n    dynamicFill?: boolean;\n}\n\n/** @advanced */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @type {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n        textureStyle: null,\n    };\n\n    /** Cache for measured text layouts to avoid recalculating them multiple times. */\n    public readonly measureCache = lru<BitmapTextLayoutData>(1000);\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill && !style._stroke)\n        {\n            fontFamilyKey += style._fill.fill.styleKey;\n            overrideFill = false;\n        }\n        else if (style._stroke || style.dropShadow)\n        {\n            // if there is a stoke, we need to use the style key as this the font generated cannot be tinted\n            // due to the fact the font has at least two colors.\n            fontFamilyKey = `${style.styleKey}-bitmap`;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const styleCopy = Object.create(style);\n\n            // Override the lineHeight, let the BitmapFont calculate the lineHeight\n            // from the fontMetrics instead using a custom lineHeight from BitmapText parameter\n            styleCopy.lineHeight = 0;\n\n            const fnt = new DynamicBitmapFont({\n                style: styleCopy,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fontCount++;\n\n            // warn users if they have created too many dynamic fonts\n            if (fontCount > 50)\n            {\n                // eslint-disable-next-line max-len\n                warn('BitmapText', `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:\"style1\", style})\\``);\n            }\n\n            fnt.once('destroy', () =>\n            {\n                fontCount--;\n                Cache.remove(fontFamilyKey);\n            });\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public getLayout(text: string, style: TextStyle, trimEnd: boolean = true): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        const id = `${text}-${style.styleKey}-${trimEnd}`;\n\n        // Check if we have a cached layout\n        if (this.measureCache.has(id))\n        {\n            return this.measureCache.get(id);\n        }\n\n        const segments = CanvasTextMetrics.graphemeSegmenter(text);\n\n        // Generate the layout data\n        const layoutData = getBitmapTextLayout(segments, style, bitmapFont, trimEnd);\n\n        this.measureCache.set(id, layoutData);\n\n        return layoutData;\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public measureText(\n        text: string,\n        style: TextStyle,\n        trimEnd: boolean = true\n    ): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style, trimEnd);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = options.dynamicFill ?? this._canUseTintForStyle(style);\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false,\n            textureStyle: options.textureStyle,\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            font.destroy();\n        }\n    }\n\n    /**\n     * Determines if a style can use tinting instead of baking colors into the bitmap.\n     * Tinting is more efficient as it allows reusing the same bitmap with different colors.\n     * @param style - The text style to evaluate\n     * @returns true if the style can use tinting, false if colors must be baked in\n     * @private\n     */\n    private _canUseTintForStyle(style: TextStyle): boolean\n    {\n        // Exclude strokes, non black shadows and ensure\n        // we have a non gradient or pattern fill,\n        // and the fill color is white\n        return !style._stroke\n            && (!style.dropShadow || style.dropShadow.color === 0x000000)\n            && !style._fill.fill\n            && style._fill.color === 0xFFFFFF;\n    }\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @category text\n * @advanced\n * @class\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nexport const BitmapFontManager = new BitmapFontManagerClass();\n"],"names":["resolve","i","pageData"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56]}
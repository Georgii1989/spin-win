{"version":3,"sources":["../../../../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlType.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/mapType.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/texture/const.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/buffer/GlBuffer.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/defaultValue.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/compileShader.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/createUboElementsSTD40.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/pixiToGlMaps.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/logProgramError.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/buffer/const.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/applyStyleParams.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.ts","../../../../node_modules/pixi.js/src/rendering/batcher/gl/GlBatchAdaptor.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/texture/GlTexture.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/GlColorMaskSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/GlEncoderSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/createUboSyncSTD40.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/GenerateShaderSyncCode.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getUboData.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/GlUboSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getUniformData.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadImageResource.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/GlRenderTarget.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlShaderSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgramData.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/GlLimitsSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/generateProgram.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/GlStencilSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/state/GlStateSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/buffer/GlBufferSystem.ts","../../../../node_modules/pixi.js/src/scene/mesh/gl/GlMeshAdaptor.ts","../../../../node_modules/pixi.js/src/scene/graphics/gl/GlGraphicsAdaptor.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateUniformsSync.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/texture/GlTextureSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/geometry/GlGeometrySystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/GlBackBufferSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlUniformGroupSystem.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/WebGLRenderer.ts","../../../../node_modules/pixi.js/src/rendering/renderers/gl/context/GlContextSystem.ts"],"sourcesContent":["import type { GlRenderingContext } from '../../context/GlRenderingContext';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param {WebGLRenderingContext} gl - The rendering context.\n * @returns Lookup table.\n */\nexport function mapFormatToGlType(gl: GlRenderingContext): Record<string, number>\n{\n    return {\n        // 8-bit formats\n        r8unorm: gl.UNSIGNED_BYTE,\n        r8snorm: gl.BYTE,\n        r8uint: gl.UNSIGNED_BYTE,\n        r8sint: gl.BYTE,\n\n        // 16-bit formats\n        r16uint: gl.UNSIGNED_SHORT,\n        r16sint: gl.SHORT,\n        r16float: gl.HALF_FLOAT,\n        rg8unorm: gl.UNSIGNED_BYTE,\n        rg8snorm: gl.BYTE,\n        rg8uint: gl.UNSIGNED_BYTE,\n        rg8sint: gl.BYTE,\n\n        // 32-bit formats\n        r32uint: gl.UNSIGNED_INT,\n        r32sint: gl.INT,\n        r32float: gl.FLOAT,\n        rg16uint: gl.UNSIGNED_SHORT,\n        rg16sint: gl.SHORT,\n        rg16float: gl.HALF_FLOAT,\n        rgba8unorm: gl.UNSIGNED_BYTE,\n        'rgba8unorm-srgb': gl.UNSIGNED_BYTE,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.BYTE,\n        rgba8uint: gl.UNSIGNED_BYTE,\n        rgba8sint: gl.BYTE,\n        bgra8unorm: gl.UNSIGNED_BYTE,\n        'bgra8unorm-srgb': gl.UNSIGNED_BYTE,\n        rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,\n        rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,\n        rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,\n\n        // 64-bit formats\n        rg32uint: gl.UNSIGNED_INT,\n        rg32sint: gl.INT,\n        rg32float: gl.FLOAT,\n        rgba16uint: gl.UNSIGNED_SHORT,\n        rgba16sint: gl.SHORT,\n        rgba16float: gl.HALF_FLOAT,\n\n        // 128-bit formats\n        rgba32uint: gl.UNSIGNED_INT,\n        rgba32sint: gl.INT,\n        rgba32float: gl.FLOAT,\n\n        // Depth/stencil formats\n        stencil8: gl.UNSIGNED_BYTE,\n        depth16unorm: gl.UNSIGNED_SHORT,\n        depth24plus: gl.UNSIGNED_INT,\n        'depth24plus-stencil8': gl.UNSIGNED_INT_24_8,\n        depth32float: gl.FLOAT,\n        'depth32float-stencil8': gl.FLOAT_32_UNSIGNED_INT_24_8_REV,\n\n    };\n}\n","import type { Dict } from '../../../../../utils/types';\nimport type { VertexFormat } from '../../../shared/geometry/const';\n\nlet GL_TABLE: Dict<string> = null;\n\nconst GL_TO_GLSL_TYPES: Dict<string> = {\n    FLOAT:       'float',\n    FLOAT_VEC2:  'vec2',\n    FLOAT_VEC3:  'vec3',\n    FLOAT_VEC4:  'vec4',\n\n    INT:         'int',\n    INT_VEC2:    'ivec2',\n    INT_VEC3:    'ivec3',\n    INT_VEC4:    'ivec4',\n\n    UNSIGNED_INT:         'uint',\n    UNSIGNED_INT_VEC2:    'uvec2',\n    UNSIGNED_INT_VEC3:    'uvec3',\n    UNSIGNED_INT_VEC4:    'uvec4',\n\n    BOOL:        'bool',\n    BOOL_VEC2:   'bvec2',\n    BOOL_VEC3:   'bvec3',\n    BOOL_VEC4:   'bvec4',\n\n    FLOAT_MAT2:  'mat2',\n    FLOAT_MAT3:  'mat3',\n    FLOAT_MAT4:  'mat4',\n\n    SAMPLER_2D:              'sampler2D',\n    INT_SAMPLER_2D:          'sampler2D',\n    UNSIGNED_INT_SAMPLER_2D: 'sampler2D',\n    SAMPLER_CUBE:              'samplerCube',\n    INT_SAMPLER_CUBE:          'samplerCube',\n    UNSIGNED_INT_SAMPLER_CUBE: 'samplerCube',\n    SAMPLER_2D_ARRAY:              'sampler2DArray',\n    INT_SAMPLER_2D_ARRAY:          'sampler2DArray',\n    UNSIGNED_INT_SAMPLER_2D_ARRAY: 'sampler2DArray',\n};\n\nconst GLSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    float: 'float32',\n    vec2: 'float32x2',\n    vec3: 'float32x3',\n    vec4: 'float32x4',\n\n    int: 'sint32',\n    ivec2: 'sint32x2',\n    ivec3: 'sint32x3',\n    ivec4: 'sint32x4',\n\n    uint: 'uint32',\n    uvec2: 'uint32x2',\n    uvec3: 'uint32x3',\n    uvec4: 'uint32x4',\n\n    bool: 'uint32',\n    bvec2: 'uint32x2',\n    bvec3: 'uint32x3',\n    bvec4: 'uint32x4',\n};\n\n/**\n * @param gl\n * @param type\n * @internal\n */\nexport function mapType(gl: any, type: number): string\n{\n    if (!GL_TABLE)\n    {\n        const typeNames = Object.keys(GL_TO_GLSL_TYPES);\n\n        GL_TABLE = {};\n\n        for (let i = 0; i < typeNames.length; ++i)\n        {\n            const tn = typeNames[i];\n\n            GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];\n        }\n    }\n\n    return GL_TABLE[type];\n}\n\n/**\n * @param gl\n * @param type\n * @internal\n */\nexport function mapGlToVertexFormat(gl: any, type: number): VertexFormat\n{\n    const typeValue = mapType(gl, type);\n\n    return GLSL_TO_VERTEX_TYPES[typeValue] || 'float32';\n}\n","/**\n * Various GL texture/resources formats.\n * @category rendering\n * @advanced\n */\nexport enum GL_FORMATS\n{\n    RGBA = 6408,\n    RGB = 6407,\n    RG = 33319,\n    RED = 6403,\n    RGBA_INTEGER = 36249,\n    RGB_INTEGER = 36248,\n    RG_INTEGER = 33320,\n    RED_INTEGER = 36244,\n    ALPHA = 6406,\n    LUMINANCE = 6409,\n    LUMINANCE_ALPHA = 6410,\n    DEPTH_COMPONENT = 6402,\n    DEPTH_STENCIL = 34041,\n}\n\n/**\n * Various GL target types.\n * @category rendering\n * @advanced\n */\nexport enum GL_TARGETS\n{\n    TEXTURE_2D = 3553,\n    TEXTURE_CUBE_MAP = 34067,\n    TEXTURE_2D_ARRAY = 35866,\n    TEXTURE_CUBE_MAP_POSITIVE_X = 34069,\n    TEXTURE_CUBE_MAP_NEGATIVE_X = 34070,\n    TEXTURE_CUBE_MAP_POSITIVE_Y = 34071,\n    TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072,\n    TEXTURE_CUBE_MAP_POSITIVE_Z = 34073,\n    TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074,\n}\n\n/**\n * The wrap modes that are supported by pixi.\n *\n * The {@link WRAP_MODE} wrap mode affects the default wrapping mode of future operations.\n * It can be re-assigned to either CLAMP or REPEAT, depending upon suitability.\n * If the texture is non power of two then clamp will be used regardless as WebGL can\n * only use REPEAT if the texture is po2.\n *\n * This property only affects WebGL.\n * @category rendering\n * @advanced\n */\nexport enum GL_WRAP_MODES\n{\n    /**\n     * The textures uvs are clamped\n     * @default 33071\n     */\n    CLAMP = 33071,\n    /**\n     * The texture uvs tile and repeat\n     * @default 10497\n     */\n    REPEAT = 10497,\n    /**\n     * The texture uvs tile and repeat with mirroring\n     * @default 33648\n     */\n    MIRRORED_REPEAT = 33648,\n}\n\n/** @internal */\nexport enum GL_TYPES\n{\n    /**\n     * 8 bits per channel for gl.RGBA\n     * @default 5121\n     */\n    UNSIGNED_BYTE = 5121,\n    /** @default 5123 */\n    UNSIGNED_SHORT = 5123,\n    /**\n     * 5 red bits, 6 green bits, 5 blue bits.\n     * @default 33635\n     */\n    UNSIGNED_SHORT_5_6_5 = 33635,\n    /**\n     * 4 red bits, 4 green bits, 4 blue bits, 4 alpha bits.\n     * @default 32819\n     */\n    UNSIGNED_SHORT_4_4_4_4 = 32819,\n    /**\n     * 5 red bits, 5 green bits, 5 blue bits, 1 alpha bit.\n     * @default 32820\n     */\n    UNSIGNED_SHORT_5_5_5_1 = 32820,\n    /** @default 5125 */\n    UNSIGNED_INT = 5125,\n    /** @default 35899 */\n    UNSIGNED_INT_10F_11F_11F_REV = 35899,\n    /** @default 33640 */\n    UNSIGNED_INT_2_10_10_10_REV = 33640,\n    /** @default 34042 */\n    UNSIGNED_INT_24_8 = 34042,\n    /** @default 35902 */\n    UNSIGNED_INT_5_9_9_9_REV = 35902,\n    /** @default 5120 */\n    BYTE = 5120,\n    /** @default 5122 */\n    SHORT = 5122,\n    /** @default 5124 */\n    INT = 5124,\n    /** @default 5126 */\n    FLOAT = 5126,\n    /** @default 36269 */\n    FLOAT_32_UNSIGNED_INT_24_8_REV = 36269,\n    /** @default 36193 */\n    HALF_FLOAT = 36193,\n}\n\n","import { type GPUData } from '../../../../scene/view/ViewContainer';\n\nimport type { BUFFER_TYPE } from './const';\n\n/** @internal */\nexport class GlBuffer implements GPUData\n{\n    public buffer: WebGLBuffer;\n    public updateID: number;\n    public byteLength: number;\n    public type: number;\n    public _lastBindBaseLocation: number = -1;\n    public _lastBindCallId: number = -1;\n\n    constructor(buffer: WebGLBuffer, type: BUFFER_TYPE)\n    {\n        this.buffer = buffer || null;\n        this.updateID = -1;\n        this.byteLength = -1;\n        this.type = type;\n    }\n\n    public destroy()\n    {\n        this.buffer = null;\n        this.updateID = -1;\n        this.byteLength = -1;\n        this.type = -1;\n        this._lastBindBaseLocation = -1;\n        this._lastBindCallId = -1;\n    }\n}\n","function booleanArray(size: number): Array<boolean>\n{\n    const array = new Array(size);\n\n    for (let i = 0; i < array.length; i++)\n    {\n        array[i] = false;\n    }\n\n    return array;\n}\n\n/**\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function defaultValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'float':\n            return 0;\n\n        case 'vec2':\n            return new Float32Array(2 * size);\n\n        case 'vec3':\n            return new Float32Array(3 * size);\n\n        case 'vec4':\n            return new Float32Array(4 * size);\n\n        case 'int':\n        case 'uint':\n        case 'sampler2D':\n        case 'sampler2DArray':\n            return 0;\n\n        case 'ivec2':\n            return new Int32Array(2 * size);\n\n        case 'ivec3':\n            return new Int32Array(3 * size);\n\n        case 'ivec4':\n            return new Int32Array(4 * size);\n\n        case 'uvec2':\n            return new Uint32Array(2 * size);\n\n        case 'uvec3':\n            return new Uint32Array(3 * size);\n\n        case 'uvec4':\n            return new Uint32Array(4 * size);\n\n        case 'bool':\n            return false;\n\n        case 'bvec2':\n\n            return booleanArray(2 * size);\n\n        case 'bvec3':\n            return booleanArray(3 * size);\n\n        case 'bvec4':\n            return booleanArray(4 * size);\n\n        case 'mat2':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n","/**\n * @private\n * @param {WebGLRenderingContext} gl - The current WebGL context {WebGLProgram}\n * @param {number} type - the type, can be either VERTEX_SHADER or FRAGMENT_SHADER\n * @param {string} src - The vertex shader source as an array of strings.\n * @returns {WebGLShader} the shader\n */\nexport function compileShader(gl: WebGLRenderingContextBase, type: number, src: string): WebGLShader\n{\n    const shader = gl.createShader(type);\n\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n\n    return shader;\n}\n","import type { UboElement, UboLayout, UniformData } from '../../../shared/shader/types';\n\n/** @internal */\nexport const WGSL_TO_STD40_SIZE: Record<string, number> = {\n    f32: 4,\n    i32: 4,\n    'vec2<f32>': 8,\n    'vec3<f32>': 12,\n    'vec4<f32>': 16,\n\n    'vec2<i32>': 8,\n    'vec3<i32>': 12,\n    'vec4<i32>': 16,\n\n    'mat2x2<f32>': 16 * 2,\n    'mat3x3<f32>': 16 * 3,\n    'mat4x4<f32>': 16 * 4,\n\n    // TODO - not essential for now but support these in the future\n    // int:      4,\n    // ivec2:    8,\n    // ivec3:    12,\n    // ivec4:    16,\n\n    // uint:     4,\n    // uvec2:    8,\n    // uvec3:    12,\n    // uvec4:    16,\n\n    // bool:     4,\n    // bvec2:    8,\n    // bvec3:    12,\n    // bvec4:    16,\n\n    // mat2:     16 * 2,\n    // mat3:     16 * 3,\n    // mat4:     16 * 4,\n};\n\n/**\n * @param uniformData\n * @internal\n */\nexport function createUboElementsSTD40(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    const chunkSize = 16;\n\n    let size = 0;\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        size = WGSL_TO_STD40_SIZE[uboElement.data.type];\n\n        if (!size)\n        {\n            throw new Error(`Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, chunkSize) * uboElement.data.size;\n        }\n\n        const boundary = size === 12 ? 16 : size;\n\n        uboElement.size = size;\n\n        const curOffset = offset % chunkSize;\n\n        if (curOffset > 0 && chunkSize - curOffset < boundary)\n        {\n            offset += (chunkSize - curOffset) % 16;\n        }\n        else\n        {\n            offset += (size - (curOffset % size)) % size;\n        }\n\n        uboElement.offset = offset;\n        offset += size;\n    }\n\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n","/** @internal */\nexport const scaleModeToGlFilter = {\n    linear: 9729,\n    nearest: 9728,\n};\n\n/** @internal */\nexport const mipmapScaleModeToGlFilter = {\n    linear: {\n        linear: 9987,\n        nearest: 9985,\n    },\n    nearest: {\n        linear: 9986,\n        nearest: 9984,\n    }\n};\n\n/** @internal */\nexport const wrapModeToGlAddress = {\n    'clamp-to-edge': 33071,\n    repeat: 10497,\n    'mirror-repeat': 33648,\n};\n\n/** @internal */\nexport const compareModeToGlCompare = {\n    never: 512,\n    less: 513,\n    equal: 514,\n    'less-equal': 515,\n    greater: 516,\n    'not-equal': 517,\n    'greater-equal': 518,\n    always: 519,\n};\n\n","/**\n * will log a shader error highlighting the lines with the error\n * also will add numbers along the side.\n * @param gl - the WebGLContext\n * @param shader - the shader to log errors for\n */\nfunction logPrettyShaderError(gl: WebGLRenderingContext, shader: WebGLShader): void\n{\n    const shaderSrc = gl.getShaderSource(shader)\n        .split('\\n')\n        .map((line, index) => `${index}: ${line}`);\n\n    const shaderLog = gl.getShaderInfoLog(shader);\n    const splitShader = shaderLog.split('\\n');\n\n    const dedupe: Record<number, boolean> = {};\n\n    const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, '$1')))\n        .filter((n) =>\n        {\n            if (n && !dedupe[n])\n            {\n                dedupe[n] = true;\n\n                return true;\n            }\n\n            return false;\n        });\n\n    const logArgs = [''];\n\n    lineNumbers.forEach((number) =>\n    {\n        shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;\n        logArgs.push('background: #FF0000; color:#FFFFFF; font-size: 10px', 'font-size: 10px');\n    });\n\n    const fragmentSourceToLog = shaderSrc\n        .join('\\n');\n\n    logArgs[0] = fragmentSourceToLog;\n\n    console.error(shaderLog);\n\n    // eslint-disable-next-line no-console\n    console.groupCollapsed('click to view full shader code');\n    console.warn(...logArgs);\n    // eslint-disable-next-line no-console\n    console.groupEnd();\n}\n\n/**\n *\n * logs out any program errors\n * @param gl - The current WebGL context\n * @param program - the WebGL program to display errors for\n * @param vertexShader  - the fragment WebGL shader program\n * @param fragmentShader - the vertex WebGL shader program\n * @private\n */\nexport function logProgramError(\n    gl: WebGLRenderingContext,\n    program: WebGLProgram,\n    vertexShader: WebGLShader,\n    fragmentShader: WebGLShader\n): void\n{\n    // if linking fails, then log and cleanup\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n    {\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))\n        {\n            logPrettyShaderError(gl, vertexShader);\n        }\n\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS))\n        {\n            logPrettyShaderError(gl, fragmentShader);\n        }\n\n        console.error('PixiJS Error: Could not initialize shader.');\n\n        // if there is a program info log, log it\n        if (gl.getProgramInfoLog(program) !== '')\n        {\n            console.warn('PixiJS Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));\n        }\n    }\n}\n","/**\n * Constants for various buffer types in Pixi\n * @category rendering\n * @advanced\n */\nexport enum BUFFER_TYPE\n{\n    /** buffer type for using as an index buffer */\n    ELEMENT_ARRAY_BUFFER = 34963,\n    /** buffer type for using attribute data */\n    ARRAY_BUFFER = 34962,\n    /** the buffer type is for uniform buffer objects */\n    UNIFORM_BUFFER = 35345,\n}\n\n","import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nconst compressedFormatMap: Record<string, boolean> = {\n    'bc1-rgba-unorm': true,\n    'bc1-rgba-unorm-srgb': true,\n    'bc2-rgba-unorm': true,\n    'bc2-rgba-unorm-srgb': true,\n    'bc3-rgba-unorm': true,\n    'bc3-rgba-unorm-srgb': true,\n    'bc4-r-unorm': true,\n    'bc4-r-snorm': true,\n    'bc5-rg-unorm': true,\n    'bc5-rg-snorm': true,\n    'bc6h-rgb-ufloat': true,\n    'bc6h-rgb-float': true,\n    'bc7-rgba-unorm': true,\n    'bc7-rgba-unorm-srgb': true,\n\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'etc2-rgb8unorm': true,\n    'etc2-rgb8unorm-srgb': true,\n    'etc2-rgb8a1unorm': true,\n    'etc2-rgb8a1unorm-srgb': true,\n    'etc2-rgba8unorm': true,\n    'etc2-rgba8unorm-srgb': true,\n    'eac-r11unorm': true,\n    'eac-r11snorm': true,\n    'eac-rg11unorm': true,\n    'eac-rg11snorm': true,\n\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'astc-4x4-unorm': true,\n    'astc-4x4-unorm-srgb': true,\n    'astc-5x4-unorm': true,\n    'astc-5x4-unorm-srgb': true,\n    'astc-5x5-unorm': true,\n    'astc-5x5-unorm-srgb': true,\n    'astc-6x5-unorm': true,\n    'astc-6x5-unorm-srgb': true,\n    'astc-6x6-unorm': true,\n    'astc-6x6-unorm-srgb': true,\n    'astc-8x5-unorm': true,\n    'astc-8x5-unorm-srgb': true,\n    'astc-8x6-unorm': true,\n    'astc-8x6-unorm-srgb': true,\n    'astc-8x8-unorm': true,\n    'astc-8x8-unorm-srgb': true,\n    'astc-10x5-unorm': true,\n    'astc-10x5-unorm-srgb': true,\n    'astc-10x6-unorm': true,\n    'astc-10x6-unorm-srgb': true,\n    'astc-10x8-unorm': true,\n    'astc-10x8-unorm-srgb': true,\n    'astc-10x10-unorm': true,\n    'astc-10x10-unorm-srgb': true,\n    'astc-12x10-unorm': true,\n    'astc-12x10-unorm-srgb': true,\n    'astc-12x12-unorm': true,\n    'astc-12x12-unorm-srgb': true,\n};\n\n/** @internal */\nexport const glUploadCompressedTextureResource = {\n\n    id: 'compressed',\n\n    upload(source: CompressedSource, glTexture: GlTexture, gl: GlRenderingContext)\n    {\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const compressed = !!compressedFormatMap[source.format];\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            if (compressed)\n            {\n                gl.compressedTexImage2D(\n                    gl.TEXTURE_2D, i, glTexture.internalFormat,\n                    mipWidth, mipHeight, 0,\n                    levelBuffer\n                );\n            }\n            else\n            {\n                gl.texImage2D(\n                    gl.TEXTURE_2D, i, glTexture.internalFormat,\n                    mipWidth, mipHeight, 0,\n                    glTexture.format, glTexture.type,\n                    levelBuffer);\n            }\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GLTextureUploader;\n\n","import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { WebGLExtensions } from '../../context/WebGLExtensions';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param gl - The rendering context.\n * @param extensions - The WebGL extensions.\n * @returns Lookup table.\n */\nexport function mapFormatToGlInternalFormat(\n    gl: GlRenderingContext,\n    extensions: WebGLExtensions,\n): Record<string, number>\n{\n    let srgb = {};\n    let bgra8unorm: number = gl.RGBA;\n\n    if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext()))\n    {\n        srgb = {\n            'rgba8unorm-srgb': gl.SRGB8_ALPHA8,\n            'bgra8unorm-srgb': gl.SRGB8_ALPHA8,\n        };\n\n        bgra8unorm = gl.RGBA8;\n    }\n    else if (extensions.srgb)\n    {\n        srgb = {\n            'rgba8unorm-srgb': extensions.srgb.SRGB8_ALPHA8_EXT,\n            'bgra8unorm-srgb': extensions.srgb.SRGB8_ALPHA8_EXT,\n        };\n    }\n\n    return {\n        // 8-bit formats\n        r8unorm: gl.R8,\n        r8snorm: gl.R8_SNORM,\n        r8uint: gl.R8UI,\n        r8sint: gl.R8I,\n\n        // 16-bit formats\n        r16uint: gl.R16UI,\n        r16sint: gl.R16I,\n        r16float: gl.R16F,\n        rg8unorm: gl.RG8,\n        rg8snorm: gl.RG8_SNORM,\n        rg8uint: gl.RG8UI,\n        rg8sint: gl.RG8I,\n\n        // 32-bit formats\n        r32uint: gl.R32UI,\n        r32sint: gl.R32I,\n        r32float: gl.R32F,\n        rg16uint: gl.RG16UI,\n        rg16sint: gl.RG16I,\n        rg16float: gl.RG16F,\n        rgba8unorm: gl.RGBA,\n\n        ...srgb,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.RGBA8_SNORM,\n        rgba8uint: gl.RGBA8UI,\n        rgba8sint: gl.RGBA8I,\n        bgra8unorm,\n        rgb9e5ufloat: gl.RGB9_E5,\n        rgb10a2unorm: gl.RGB10_A2,\n        rg11b10ufloat: gl.R11F_G11F_B10F,\n\n        // 64-bit formats\n        rg32uint: gl.RG32UI,\n        rg32sint: gl.RG32I,\n        rg32float: gl.RG32F,\n        rgba16uint: gl.RGBA16UI,\n        rgba16sint: gl.RGBA16I,\n        rgba16float: gl.RGBA16F,\n\n        // 128-bit formats\n        rgba32uint: gl.RGBA32UI,\n        rgba32sint: gl.RGBA32I,\n        rgba32float: gl.RGBA32F,\n\n        // Depth/stencil formats\n        stencil8: gl.STENCIL_INDEX8,\n        depth16unorm: gl.DEPTH_COMPONENT16,\n        depth24plus: gl.DEPTH_COMPONENT24,\n        'depth24plus-stencil8': gl.DEPTH24_STENCIL8,\n        depth32float: gl.DEPTH_COMPONENT32F,\n        'depth32float-stencil8': gl.DEPTH32F_STENCIL8,\n\n        // Compressed formats\n        ...extensions.s3tc ? {\n            'bc1-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n            'bc2-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n            'bc3-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n        } : {},\n        ...extensions.s3tc_sRGB ? {\n            'bc1-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n            'bc2-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n            'bc3-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,\n        } : {},\n        ...extensions.rgtc ? {\n            'bc4-r-unorm': extensions.rgtc.COMPRESSED_RED_RGTC1_EXT,\n            'bc4-r-snorm': extensions.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,\n            'bc5-rg-unorm': extensions.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,\n            'bc5-rg-snorm': extensions.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,\n        } : {},\n        ...extensions.bptc ? {\n            'bc6h-rgb-float': extensions.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,\n            'bc6h-rgb-ufloat': extensions.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,\n            'bc7-rgba-unorm': extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,\n            'bc7-rgba-unorm-srgb': extensions.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT,\n        } : {},\n        ...extensions.etc ? {\n            'etc2-rgb8unorm': extensions.etc.COMPRESSED_RGB8_ETC2,\n            'etc2-rgb8unorm-srgb': extensions.etc.COMPRESSED_SRGB8_ETC2,\n            'etc2-rgb8a1unorm': extensions.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n            'etc2-rgb8a1unorm-srgb': extensions.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n            'etc2-rgba8unorm': extensions.etc.COMPRESSED_RGBA8_ETC2_EAC,\n            'etc2-rgba8unorm-srgb': extensions.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,\n            'eac-r11unorm': extensions.etc.COMPRESSED_R11_EAC,\n            // 'eac-r11snorm'\n            'eac-rg11unorm': extensions.etc.COMPRESSED_SIGNED_RG11_EAC,\n            // 'eac-rg11snorm'\n        } : {},\n        ...extensions.astc ? {\n            'astc-4x4-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,\n            'astc-4x4-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,\n            'astc-5x4-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,\n            'astc-5x4-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,\n            'astc-5x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,\n            'astc-5x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,\n            'astc-6x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,\n            'astc-6x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,\n            'astc-6x6-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,\n            'astc-6x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,\n            'astc-8x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,\n            'astc-8x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,\n            'astc-8x6-unorm':   extensions.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,\n            'astc-8x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,\n            'astc-8x8-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,\n            'astc-8x8-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,\n            'astc-10x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,\n            'astc-10x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,\n            'astc-10x6-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,\n            'astc-10x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,\n            'astc-10x8-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,\n            'astc-10x8-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,\n            'astc-10x10-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,\n            'astc-10x10-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,\n            'astc-12x10-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,\n            'astc-12x10-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,\n            'astc-12x12-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,\n            'astc-12x12-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,\n        } : {},\n    };\n}\n","import {\n    compareModeToGlCompare,\n    mipmapScaleModeToGlFilter,\n    scaleModeToGlFilter,\n    wrapModeToGlAddress\n} from './pixiToGlMaps';\n\nimport type { TextureStyle } from '../../../shared/texture/TextureStyle';\n\n/**\n * @param style\n * @param gl\n * @param mipmaps\n * @param anisotropicExt\n * @param glFunctionName\n * @param firstParam\n * @param forceClamp\n * @param firstCreation\n * @internal\n */\nexport function applyStyleParams(\n    style: TextureStyle,\n    gl: WebGL2RenderingContext,\n    mipmaps: boolean,\n    // eslint-disable-next-line camelcase\n    anisotropicExt: EXT_texture_filter_anisotropic,\n    glFunctionName: 'samplerParameteri' | 'texParameteri',\n    firstParam: 3553 | WebGLSampler,\n    forceClamp: boolean,\n    /** if true we can skip setting certain values if the values is the same as the default gl values */\n    firstCreation: boolean\n)\n{\n    const castParam = firstParam as 3553;\n\n    if (!firstCreation\n        || style.addressModeU !== 'repeat'\n        || style.addressModeV !== 'repeat'\n        || style.addressModeW !== 'repeat'\n    )\n    {\n        // 1. set the wrapping mode\n        const wrapModeS = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeU];\n        const wrapModeT = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeV];\n        const wrapModeR = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeW];\n\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);\n\n        // does not exist in webGL1\n        if (gl.TEXTURE_WRAP_R) gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);\n    }\n\n    if (!firstCreation || style.magFilter !== 'linear')\n    {\n        // 2. set the filtering mode\n        gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);\n    }\n\n    // assuming the currently bound texture is the one we want to set the filter for\n    // the only smelly part of this code, WebGPU is much better here :P\n    if (mipmaps)\n    {\n        if (!firstCreation || style.mipmapFilter !== 'linear')\n        {\n            const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];\n\n            gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);\n        }\n    }\n\n    else\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);\n    }\n\n    // 3. set the anisotropy\n    if (anisotropicExt && style.maxAnisotropy > 1)\n    {\n        const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n\n        gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n    }\n\n    // 4. set the compare mode\n    if (style.compare)\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\n\n/**\n * Maps gl blend combinations to WebGL.\n * @param gl\n * @returns {object} Map of gl blend combinations to WebGL.\n * @internal\n */\nexport function mapWebGLBlendModesToPixi(gl: GlRenderingContext): Record<BLEND_MODES, number[]>\n{\n    const blendMap: Partial<Record<BLEND_MODES, number[]>> = {};\n\n    // TODO - premultiply alpha would be different.\n    // add a boolean for that!\n    blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.add = [gl.ONE, gl.ONE];\n    blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.none = [0, 0];\n\n    // not-premultiplied blend modes\n    blendMap['normal-npm'] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap['add-npm'] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];\n    blendMap['screen-npm'] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n\n    blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n\n    const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());\n\n    if (isWebGl2)\n    {\n        blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];\n        blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];\n    }\n    else\n    {\n        const ext = gl.getExtension('EXT_blend_minmax');\n\n        if (ext)\n        {\n            blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];\n            blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];\n        }\n    }\n\n    // TODO - implement if requested!\n    // composite operations\n    // array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];\n    // array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];\n    // array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n    // array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];\n    // array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];\n    // array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n    // array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];\n    // array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n    // SUBTRACT from flash\n    // array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];\n\n    return blendMap as Record<BLEND_MODES, number[]>;\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\n\nimport type { WebGLRenderer } from '../../renderers/gl/WebGLRenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\n/**\n * A BatcherAdaptor that uses WebGL to render batches.\n * @category rendering\n * @ignore\n */\nexport class GlBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private readonly _tempState = State.for2d();\n\n    /**\n     * We only want to sync the a batched shaders uniforms once on first use\n     * this is a hash of shader uids to a boolean value.  When the shader is first bound\n     * we set the value to true.  When the shader is bound again we check the value and\n     * if it is true we know that the uniforms have already been synced and we skip it.\n     */\n    private _didUploadHash: Record<string, boolean> = {};\n    public init(batcherPipe: BatcherPipe): void\n    {\n        batcherPipe.renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._didUploadHash = {};\n    }\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    {\n        const renderer = batchPipe.renderer as WebGLRenderer;\n\n        const didUpload = this._didUploadHash[shader.uid];\n\n        // only want to sync the shade ron its first bind!\n        renderer.shader.bind(shader, didUpload);\n\n        if (!didUpload)\n        {\n            this._didUploadHash[shader.uid] = true;\n        }\n\n        renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);\n\n        renderer.geometry.bind(geometry, shader.glProgram);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const renderer = batchPipe.renderer as WebGLRenderer;\n\n        this._tempState.blendMode = batch.blendMode;\n\n        renderer.state.set(this._tempState);\n\n        const textures = batch.textures.textures;\n\n        for (let i = 0; i < batch.textures.count; i++)\n        {\n            renderer.texture.bind(textures[i], i);\n        }\n\n        renderer.geometry.draw(batch.topology, batch.size, batch.start);\n    }\n}\n","import { type GPUData } from '../../../../scene/view/ViewContainer';\nimport { GL_FORMATS, GL_TARGETS, GL_TYPES } from './const';\n\n/**\n * Internal texture for WebGL context\n * @category rendering\n * @ignore\n */\nexport class GlTexture implements GPUData\n{\n    public target: GL_TARGETS = GL_TARGETS.TEXTURE_2D;\n\n    /** The WebGL texture. */\n    public texture: WebGLTexture;\n\n    /** Width of texture that was used in texImage2D. */\n    public width: number;\n\n    /** Height of texture that was used in texImage2D. */\n    public height: number;\n\n    /** Whether mip levels has to be generated. */\n    public mipmap: boolean;\n\n    /** Type copied from texture source. */\n    public type: number;\n\n    /** Type copied from texture source. */\n    public internalFormat: number;\n\n    /** Type of sampler corresponding to this texture. See {@link SAMPLER_TYPES} */\n    public samplerType: number;\n\n    public format: GL_FORMATS;\n\n    constructor(texture: WebGLTexture)\n    {\n        this.texture = texture;\n        this.width = -1;\n        this.height = -1;\n        this.type = GL_TYPES.UNSIGNED_BYTE;\n        this.internalFormat = GL_FORMATS.RGBA;\n        this.format = GL_FORMATS.RGBA;\n        this.samplerType = 0;\n    }\n\n    public destroy(): void\n    {\n        // BOOM\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * The system that handles color masking for the WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGLRenderer;\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.gl.colorMask(\n            !!(colorMask & 0b1000),\n            !!(colorMask & 0b0100),\n            !!(colorMask & 0b0010),\n            !!(colorMask & 0b0001)\n        );\n    }\n\n    public destroy?: () => void;\n}\n","import { WGSL_TO_STD40_SIZE } from './createUboElementsSTD40';\n\nimport type { UboElement } from '../../../shared/shader/types';\n\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the std140 layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n * @internal\n */\nexport function generateArraySyncSTD40(uboElement: UboElement, offsetToAdd: number): string\n{\n    const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n    const elementSize = (uboElement.data.value as Array<number>).length / uboElement.data.size;// size / rowSize;\n\n    const remainder = (4 - (elementSize % 4)) % 4;\n    const data = uboElement.data.type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';\n\n    return `\n        v = uv.${uboElement.data.name};\n        offset += ${offsetToAdd};\n\n        arrayOffset = offset;\n\n        t = 0;\n\n        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n        {\n            for(var j = 0; j < ${elementSize}; j++)\n            {\n                ${data}[arrayOffset++] = v[t++];\n            }\n            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ''}\n        }\n    `;\n}\n","import { GL_TYPES } from '../../texture/const';\n\nimport type { VertexFormat } from '../../../shared/geometry/const';\n\nconst infoMap = {\n    uint8x2: GL_TYPES.UNSIGNED_BYTE,\n    uint8x4: GL_TYPES.UNSIGNED_BYTE,\n    sint8x2: GL_TYPES.BYTE,\n    sint8x4: GL_TYPES.BYTE,\n    unorm8x2: GL_TYPES.UNSIGNED_BYTE,\n    unorm8x4: GL_TYPES.UNSIGNED_BYTE,\n    snorm8x2: GL_TYPES.BYTE,\n    snorm8x4: GL_TYPES.BYTE,\n    uint16x2: GL_TYPES.UNSIGNED_SHORT,\n    uint16x4: GL_TYPES.UNSIGNED_SHORT,\n    sint16x2: GL_TYPES.SHORT,\n    sint16x4: GL_TYPES.SHORT,\n    unorm16x2: GL_TYPES.UNSIGNED_SHORT,\n    unorm16x4: GL_TYPES.UNSIGNED_SHORT,\n    snorm16x2: GL_TYPES.SHORT,\n    snorm16x4: GL_TYPES.SHORT,\n    float16x2: GL_TYPES.HALF_FLOAT,\n    float16x4: GL_TYPES.HALF_FLOAT,\n    float32: GL_TYPES.FLOAT,\n    float32x2: GL_TYPES.FLOAT,\n    float32x3: GL_TYPES.FLOAT,\n    float32x4: GL_TYPES.FLOAT,\n    uint32: GL_TYPES.UNSIGNED_INT,\n    uint32x2: GL_TYPES.UNSIGNED_INT,\n    uint32x3: GL_TYPES.UNSIGNED_INT,\n    uint32x4: GL_TYPES.UNSIGNED_INT,\n    sint32: GL_TYPES.INT,\n    sint32x2: GL_TYPES.INT,\n    sint32x3: GL_TYPES.INT,\n    sint32x4: GL_TYPES.INT\n};\n\n/**\n * @param format\n * @internal\n */\nexport function getGlTypeFromFormat(format: VertexFormat): number\n{\n    return infoMap[format] ?? infoMap.float32;\n}\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\nimport { mapGlToVertexFormat } from './mapType';\n\nimport type { Attribute } from '../../../shared/geometry/Geometry';\n\n/**\n * This interface represents the extracted attribute data from a WebGL program.\n * It extends the `Attribute` interface but omits the `buffer` property.\n * It includes an optional `location` property that indicates where the shader location is for this attribute.\n * @category rendering\n * @advanced\n */\nexport interface ExtractedAttributeData extends Omit<Attribute, 'buffer'>\n{\n    /** set where the shader location is for this attribute */\n    location?: number;\n}\n\n/**\n * returns the attribute data from the program\n * @private\n * @param {WebGLProgram} [program] - the WebGL program\n * @param {WebGLRenderingContext} [gl] - the WebGL context\n * @param sortAttributes\n * @returns {object} the attribute data for this program\n */\nexport function extractAttributesFromGlProgram(\n    program: WebGLProgram,\n    gl: WebGLRenderingContextBase,\n    sortAttributes = false\n): Record<string, ExtractedAttributeData>\n{\n    const attributes: {[key: string]: ExtractedAttributeData} = {};\n\n    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n    for (let i = 0; i < totalAttributes; i++)\n    {\n        const attribData = gl.getActiveAttrib(program, i);\n\n        // ignore the default ones!\n        if (attribData.name.startsWith('gl_'))\n        {\n            continue;\n        }\n\n        const format = mapGlToVertexFormat(gl, attribData.type);\n\n        attributes[attribData.name] = {\n            location: 0, // set further down..\n            format,\n            stride: getAttributeInfoFromFormat(format).stride,\n            offset: 0,\n            instance: false,\n            start: 0,\n        };\n    }\n\n    const keys = Object.keys(attributes);\n\n    if (sortAttributes)\n    {\n        keys.sort((a, b) => (a > b) ? 1 : -1); // eslint-disable-line no-confusing-arrow\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            attributes[keys[i]].location = i;\n\n            gl.bindAttribLocation(program, i, keys[i]);\n        }\n\n        gl.linkProgram(program);\n    }\n    else\n    {\n        for (let i = 0; i < keys.length; i++)\n        {\n            attributes[keys[i]].location = gl.getAttribLocation(program, keys[i]);\n        }\n    }\n\n    return attributes;\n}\n","import type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\n/** @internal */\nexport const glUploadBufferImageResource = {\n\n    id: 'buffer',\n\n    upload(source: TextureSource, glTexture: GlTexture, gl: GlRenderingContext)\n    {\n        if (glTexture.width === source.width || glTexture.height === source.height)\n        {\n            gl.texSubImage2D(\n                gl.TEXTURE_2D,\n                0,\n                0,\n                0,\n                source.width,\n                source.height,\n                glTexture.format,\n                glTexture.type,\n                source.resource\n            );\n        }\n        else\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                source.width,\n                source.height,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource\n            );\n        }\n\n        glTexture.width = source.width;\n        glTexture.height = source.height;\n    }\n} as GLTextureUploader;\n\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * The system that handles encoding commands for the WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'encoder',\n    } as const;\n\n    public readonly commandFinished = Promise.resolve();\n    private readonly _renderer: WebGLRenderer;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setGeometry(geometry: Geometry, shader?: Shader)\n    {\n        this._renderer.geometry.bind(geometry, shader.glProgram);\n    }\n\n    public finishRenderPass()\n    {\n        // noop\n    }\n\n    public draw(options: {\n        geometry: Geometry,\n        shader: Shader,\n        state?: State,\n        topology?: Topology,\n        size?: number,\n        start?: number,\n        instanceCount?: number\n        skipSync?: boolean,\n    })\n    {\n        const renderer = this._renderer;\n        const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;\n\n        renderer.shader.bind(shader, skipSync);\n\n        renderer.geometry.bind(geometry, renderer.shader._activeProgram);\n\n        if (state)\n        {\n            renderer.state.set(state);\n        }\n\n        renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n","import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction';\nimport { uboSyncFunctionsSTD40 } from '../../../shared/shader/utils/uboSyncFunctions';\nimport { generateArraySyncSTD40 } from './generateArraySyncSTD40';\n\nimport type { UboElement, UniformsSyncCallback } from '../../../shared/shader/types';\n\n/**\n * @param uboElements\n * @internal\n */\nexport function createUboSyncFunctionSTD40(\n    uboElements: UboElement[],\n): UniformsSyncCallback\n{\n    return createUboSyncFunction(\n        uboElements,\n        'uboStd40',\n        generateArraySyncSTD40,\n        uboSyncFunctionsSTD40,\n    );\n}\n","import { BufferResource } from '../../shared/buffer/BufferResource';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\n\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { GlShaderSystem, ShaderSyncFunction } from './GlShaderSystem';\n\n/**\n * Generates the a function that will efficiently sync shader resources with the GPU.\n * @param shader - The shader to generate the code for\n * @param shaderSystem - An instance of the shader system\n * @internal\n */\nexport function generateShaderSyncCode(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n{\n    const funcFragments: string[] = [];\n\n    /**\n     * rS = renderer.shader\n     * sS = shaderSystem\n     * sD = shaderData\n     * g = shader.groups\n     * s = shader\n     * r = renderer\n     * ugS = renderer.uniformGroupSystem\n     */\n    const headerFragments: string[] = [`\n        var g = s.groups;\n        var sS = r.shader;\n        var p = s.glProgram;\n        var ugS = r.uniformGroup;\n        var resources;\n    `];\n\n    let addedTextreSystem = false;\n    let textureCount = 0;\n\n    const programData = shaderSystem._getProgramData(shader.glProgram);\n\n    for (const i in shader.groups)\n    {\n        const group = shader.groups[i];\n\n        funcFragments.push(`\n            resources = g[${i}].resources;\n        `);\n\n        for (const j in group.resources)\n        {\n            const resource = group.resources[j];\n\n            if (resource instanceof UniformGroup)\n            {\n                if (resource.ubo)\n                {\n                    const resName = shader._uniformBindMap[i][Number(j)];\n\n                    funcFragments.push(`\n                        sS.bindUniformBlock(\n                            resources[${j}],\n                            '${resName}',\n                            ${shader.glProgram._uniformBlockData[resName].index}\n                        );\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        ugS.updateUniformGroup(resources[${j}], p, sD);\n                    `);\n                }\n            }\n            else if (resource instanceof BufferResource)\n            {\n                const resName = shader._uniformBindMap[i][Number(j)];\n\n                funcFragments.push(`\n                    sS.bindUniformBlock(\n                        resources[${j}],\n                        '${resName}',\n                        ${shader.glProgram._uniformBlockData[resName].index}\n                    );\n                `);\n            }\n            else if (resource instanceof TextureSource)\n            {\n                const uniformName = shader._uniformBindMap[i as unknown as number][j as unknown as number];\n\n                const uniformData = programData.uniformData[uniformName];\n\n                if (uniformData)\n                {\n                    if (!addedTextreSystem)\n                    {\n                        addedTextreSystem = true;\n                        headerFragments.push(`\n                        var tS = r.texture;\n                        `);\n                    }\n\n                    shaderSystem._gl.uniform1i(uniformData.location, textureCount);\n\n                    funcFragments.push(`\n                        tS.bind(resources[${j}], ${textureCount});\n                    `);\n\n                    textureCount++;\n                }\n            }\n        }\n    }\n\n    const functionSource = [...headerFragments, ...funcFragments].join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('r', 's', 'sD', functionSource) as ShaderSyncFunction;\n}\n","import type { GlUniformBlockData } from '../GlProgram';\n\n/**\n * returns the uniform block data from the program\n * @private\n * @param program - the webgl program\n * @param gl - the WebGL context\n * @returns {object} the uniform data for this program\n */\nexport function getUboData(program: WebGLProgram, gl: WebGL2RenderingContext): Record<string, GlUniformBlockData>\n{\n    // if uniform buffer data is not supported, early out\n    if (!gl.ACTIVE_UNIFORM_BLOCKS) return {};\n\n    const uniformBlocks: Record<string, GlUniformBlockData> = {};\n\n    // const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n    const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n\n    for (let i = 0; i < totalUniformsBlocks; i++)\n    {\n        const name = gl.getActiveUniformBlockName(program, i);\n        const uniformBlockIndex = gl.getUniformBlockIndex(program, name);\n\n        const size = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE);\n\n        uniformBlocks[name] = {\n            name,\n            index: uniformBlockIndex,\n            size,\n        };\n    }\n\n    return uniformBlocks;\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsSTD40 } from './shader/utils/createUboElementsSTD40';\nimport { createUboSyncFunctionSTD40 } from './shader/utils/createUboSyncSTD40';\n\n/**\n * System plugin to the renderer to manage uniform buffers. But with an WGSL adaptor.\n * @category rendering\n * @advanced\n */\nexport class GlUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGLSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsSTD40,\n            generateUboSync: createUboSyncFunctionSTD40,\n        });\n    }\n}\n","import { defaultValue } from './defaultValue';\nimport { mapType } from './mapType';\n\nimport type { GlUniformData } from '../GlProgram';\n\n/**\n * returns the uniform data from the program\n * @private\n * @param program - the webgl program\n * @param gl - the WebGL context\n * @returns {object} the uniform data for this program\n */\nexport function getUniformData(program: WebGLProgram, gl: WebGLRenderingContextBase): {[key: string]: GlUniformData}\n{\n    const uniforms: {[key: string]: GlUniformData} = {};\n\n    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n    for (let i = 0; i < totalUniforms; i++)\n    {\n        const uniformData = gl.getActiveUniform(program, i);\n        const name = uniformData.name.replace(/\\[.*?\\]$/, '');\n\n        const isArray = !!(uniformData.name.match(/\\[.*?\\]$/));\n\n        const type = mapType(gl, uniformData.type);\n\n        uniforms[name] = {\n            name,\n            index: i,\n            type,\n            size: uniformData.size,\n            isArray,\n            value: defaultValue(type, uniformData.size),\n        };\n    }\n\n    return uniforms;\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GlRenderTargetAdaptor } from './GlRenderTargetAdaptor';\n\nimport type { GlRenderTarget } from '../GlRenderTarget';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @category rendering\n * @advanced\n */\nexport class GlRenderTargetSystem extends RenderTargetSystem<GlRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGLSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GlRenderTargetAdaptor();\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n","import type { CanvasSource } from '../../../shared/texture/sources/CanvasSource';\nimport type { ImageSource } from '../../../shared/texture/sources/ImageSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\n/** @internal */\nexport const glUploadImageResource = {\n\n    id: 'image',\n\n    upload(source: ImageSource | CanvasSource, glTexture: GlTexture, gl: GlRenderingContext, webGLVersion: number)\n    {\n        const glWidth = glTexture.width;\n        const glHeight = glTexture.height;\n\n        const textureWidth = source.pixelWidth;\n        const textureHeight = source.pixelHeight;\n\n        const resourceWidth = source.resourceWidth;\n        const resourceHeight = source.resourceHeight;\n\n        if (resourceWidth < textureWidth || resourceHeight < textureHeight)\n        {\n            if (glWidth !== textureWidth || glHeight !== textureHeight)\n            {\n                gl.texImage2D(\n                    glTexture.target,\n                    0,\n                    glTexture.internalFormat,\n                    textureWidth,\n                    textureHeight,\n                    0,\n                    glTexture.format,\n                    glTexture.type,\n                    null\n                );\n            }\n\n            if (webGLVersion === 2)\n            {\n                gl.texSubImage2D(\n                    gl.TEXTURE_2D,\n                    0,\n                    0,\n                    0,\n                    resourceWidth,\n                    resourceHeight,\n                    glTexture.format,\n                    glTexture.type,\n                    source.resource as TexImageSource\n                );\n            }\n            else\n            {\n                gl.texSubImage2D(\n                    gl.TEXTURE_2D,\n                    0,\n                    0,\n                    0,\n                    glTexture.format,\n                    glTexture.type,\n                    source.resource as TexImageSource\n                );\n            }\n        }\n        else if (glWidth === textureWidth && glHeight === textureHeight)\n        {\n            gl.texSubImage2D(\n                gl.TEXTURE_2D,\n                0,\n                0,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n        else if (webGLVersion === 2)\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                textureWidth,\n                textureHeight,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n        else\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n\n        glTexture.width = textureWidth;\n        glTexture.height = textureHeight;\n    }\n} as GLTextureUploader;\n\n","/**\n * Represents a render target.\n * @category rendering\n * @ignore\n */\nexport class GlRenderTarget\n{\n    public width = -1;\n    public height = -1;\n    public msaa = false;\n    public framebuffer: WebGLFramebuffer;\n    public resolveTargetFramebuffer: WebGLFramebuffer;\n    public msaaRenderBuffer: WebGLRenderbuffer[] = [];\n    public depthStencilRenderBuffer: WebGLRenderbuffer;\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { generateShaderSyncCode } from './GenerateShaderSyncCode';\nimport { generateProgram } from './program/generateProgram';\n\nimport type { BufferResource } from '../../shared/buffer/BufferResource';\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { UniformGroup } from '../../shared/shader/UniformGroup';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GlProgram } from './GlProgram';\nimport type { GlProgramData } from './GlProgramData';\n\n/** @internal */\nexport interface ShaderSyncData\n{\n    textureCount: number;\n    blockIndex: number;\n}\n\n/** @internal */\nexport type ShaderSyncFunction = (renderer: WebGLRenderer, shader: Shader, syncData: ShaderSyncData) => void;\n\n// default sync data so we don't create a new one each time!\nconst defaultSyncData: ShaderSyncData = {\n    textureCount: 0,\n    blockIndex: 0,\n};\n\n/**\n * System plugin to the renderer to manage the shaders for WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    /** @internal */\n    public _activeProgram: GlProgram = null;\n\n    private _programDataHash: Record<string, GlProgramData> = Object.create(null);\n    private readonly _renderer: WebGLRenderer;\n    /** @internal */\n    public _gl: WebGL2RenderingContext;\n    private _shaderSyncFunctions: Record<string, ShaderSyncFunction> = Object.create(null);\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        this._programDataHash = Object.create(null);\n        /**\n         * these need to also be cleared as internally some uniforms are set as an optimisation as the sync\n         * function is generated. Specifically the texture ints.\n         */\n        this._shaderSyncFunctions = Object.create(null);\n        this._activeProgram = null;\n    }\n\n    /**\n     * Changes the current shader to the one given in parameter.\n     * @param shader - the new shader\n     * @param skipSync - false if the shader should automatically sync its uniforms.\n     * @returns the glProgram that belongs to the shader.\n     */\n    public bind(shader: Shader, skipSync?: boolean): void\n    {\n        this._setProgram(shader.glProgram);\n\n        if (skipSync) return;\n\n        defaultSyncData.textureCount = 0;\n        defaultSyncData.blockIndex = 0;\n\n        let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];\n\n        if (!syncFunction)\n        {\n            syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);\n        }\n\n        // TODO: take into account number of TF buffers. Currently works only with interleaved\n        this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);\n        syncFunction(this._renderer, shader, defaultSyncData);\n    }\n\n    /**\n     * Updates the uniform group.\n     * @param uniformGroup - the uniform group to update\n     */\n    public updateUniformGroup(uniformGroup: UniformGroup): void\n    {\n        this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);\n    }\n\n    /**\n     * Binds a uniform block to the shader.\n     * @param uniformGroup - the uniform group to bind\n     * @param name - the name of the uniform block\n     * @param index - the index of the uniform block\n     */\n    public bindUniformBlock(uniformGroup: UniformGroup | BufferResource, name: string, index = 0): void\n    {\n        const bufferSystem = this._renderer.buffer;\n        const programData = this._getProgramData(this._activeProgram);\n\n        const isBufferResource = (uniformGroup as BufferResource)._bufferResource;\n\n        if (!isBufferResource)\n        {\n            this._renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n        }\n\n        const buffer = uniformGroup.buffer;\n\n        const glBuffer = bufferSystem.updateBuffer(buffer);\n\n        const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);\n\n        if (isBufferResource)\n        {\n            const { offset, size } = (uniformGroup as BufferResource);\n\n            // trivial case of buffer resource, can be cached\n            if (offset === 0 && size === buffer.data.byteLength)\n            {\n                bufferSystem.bindBufferBase(glBuffer, boundLocation);\n            }\n            else\n            {\n                bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);\n            }\n        }\n        else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation)\n        {\n            // confirmation that buffer isn't there yet\n            bufferSystem.bindBufferBase(glBuffer, boundLocation);\n        }\n\n        const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;\n\n        if (programData.uniformBlockBindings[index] === boundLocation) return;\n        programData.uniformBlockBindings[index] = boundLocation;\n\n        this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);\n    }\n\n    private _setProgram(program: GlProgram)\n    {\n        if (this._activeProgram === program) return;\n\n        this._activeProgram = program;\n\n        const programData = this._getProgramData(program);\n\n        this._gl.useProgram(programData.program);\n    }\n\n    /**\n     * @param program - the program to get the data for\n     * @internal\n     */\n    public _getProgramData(program: GlProgram): GlProgramData\n    {\n        return this._programDataHash[program._key] || this._createProgramData(program);\n    }\n\n    private _createProgramData(program: GlProgram): GlProgramData\n    {\n        const key = program._key;\n\n        this._programDataHash[key] = generateProgram(this._gl, program);\n\n        return this._programDataHash[key];\n    }\n\n    public destroy(): void\n    {\n        for (const key of Object.keys(this._programDataHash))\n        {\n            this._programDataHash[key].destroy();\n        }\n\n        this._programDataHash = null;\n        this._shaderSyncFunctions = null;\n        this._activeProgram = null;\n        (this._renderer as null) = null;\n        this._gl = null;\n    }\n\n    /**\n     * Creates a function that can be executed that will sync the shader as efficiently as possible.\n     * Overridden by the unsafe eval package if you don't want eval used in your project.\n     * @param shader - the shader to generate the sync function for\n     * @param shaderSystem - the shader system to use\n     * @returns - the generated sync function\n     * @ignore\n     */\n    public _generateShaderSync(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n    {\n        return generateShaderSyncCode(shader, shaderSystem);\n    }\n\n    public resetState(): void\n    {\n        this._activeProgram = null;\n    }\n}\n","/** @private */\nexport class IGLUniformData\n{\n    public location: WebGLUniformLocation;\n    public value: number | boolean | Float32Array | Int32Array | Uint32Array | boolean[];\n}\n\n/**\n * Helper class to create a WebGL Program\n * @private\n */\nexport class GlProgramData\n{\n    /** The shader program. */\n    public program: WebGLProgram;\n\n    /**\n     * Holds the uniform data which contains uniform locations\n     * and current uniform values used for caching and preventing unneeded GPU commands.\n     */\n    public uniformData: Record<string, any>;\n\n    /**\n     * UniformGroups holds the various upload functions for the shader. Each uniform group\n     * and program have a unique upload function generated.\n     */\n    public uniformGroups: Record<string, any>;\n\n    /** A hash that stores where UBOs are bound to on the program. */\n    public uniformBlockBindings: Record<string, any>;\n\n    /** A hash for lazily-generated uniform uploading functions. */\n    public uniformSync: Record<string, any>;\n\n    /**\n     * A place where dirty ticks are stored for groups\n     * If a tick here does not match with the Higher level Programs tick, it means\n     * we should re upload the data.\n     */\n    public uniformDirtyGroups: Record<string, any>;\n\n    /**\n     * Makes a new Pixi program.\n     * @param program - webgl program\n     * @param uniformData - uniforms\n     */\n    constructor(program: WebGLProgram, uniformData: {[key: string]: IGLUniformData})\n    {\n        this.program = program;\n        this.uniformData = uniformData;\n        this.uniformGroups = {};\n        this.uniformDirtyGroups = {};\n        this.uniformBlockBindings = {};\n    }\n\n    /** Destroys this program. */\n    public destroy(): void\n    {\n        this.uniformData = null;\n        this.uniformGroups = null;\n        this.uniformDirtyGroups = null;\n        this.uniformBlockBindings = null;\n        this.program = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { checkMaxIfStatementsInShader } from '../../batcher/gl/utils/checkMaxIfStatementsInShader';\nimport { type System } from '../shared/system/System';\n\nimport type { WebGLRenderer } from './WebGLRenderer';\n/**\n * The GpuLimitsSystem provides information about the capabilities and limitations of the underlying GPU.\n * These limits, such as the maximum number of textures that can be used in a shader\n * (`maxTextures`) or the maximum number of textures that can be batched together (`maxBatchableTextures`),\n * are determined by the specific graphics hardware and driver.\n *\n * The values for these limits are not available immediately upon instantiation of the class.\n * They are populated when the GL rendering context is successfully initialized and ready,\n * which occurs after the `renderer.init()` method has completed.\n * Attempting to access these properties before the context is ready will result in undefined or default values.\n *\n * This system allows the renderer to adapt its behavior and resource allocation strategies\n * to stay within the supported boundaries of the GPU, ensuring optimal performance and stability.\n * @example\n * ```ts\n * const renderer = new WebGlRenderer();\n * await renderer.init();\n *\n * console.log(renderer.limits.maxTextures);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GlLimitsSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'limits',\n    } as const;\n\n    /** The maximum number of textures that can be used by a shader */\n    public maxTextures: number;\n    /** The maximum number of batchable textures */\n    public maxBatchableTextures: number;\n\n    /** The maximum number of uniform bindings */\n    public maxUniformBindings: number;\n\n    private readonly _renderer: WebGLRenderer;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public contextChange(): void\n    {\n        const gl = this._renderer.gl;\n\n        // step 1: first check max textures the GPU can handle.\n        this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n        // step 2: check the maximum number of if statements the shader can have too..\n        this.maxBatchableTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);\n\n        // step 3: check the limit of uniform buffer bindings.\n        // UBs are available only in WebGL2 context, requesting within WebGL1 produces a warning.\n        const isWebGl2 = this._renderer.context.webGLVersion === 2;\n\n        this.maxUniformBindings = isWebGl2\n            ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS)\n            : 0;\n    }\n\n    public destroy(): void\n    {\n        // boom!\n    }\n}\n","import { warn } from '../../../../../utils/logging/warn';\nimport { GlProgramData } from '../GlProgramData';\nimport { compileShader } from './compileShader';\nimport { defaultValue } from './defaultValue';\nimport { extractAttributesFromGlProgram } from './extractAttributesFromGlProgram';\nimport { getUboData } from './getUboData';\nimport { getUniformData } from './getUniformData';\nimport { logProgramError } from './logProgramError';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlProgram } from '../GlProgram';\nimport type { IGLUniformData } from '../GlProgramData';\n\n/**\n * generates a WebGL Program object from a high level Pixi Program.\n * @param gl - a rendering context on which to generate the program\n * @param program - the high level Pixi Program.\n * @private\n */\nexport function generateProgram(gl: GlRenderingContext, program: GlProgram): GlProgramData\n{\n    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);\n    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);\n\n    const webGLProgram = gl.createProgram();\n\n    gl.attachShader(webGLProgram, glVertShader);\n    gl.attachShader(webGLProgram, glFragShader);\n\n    const transformFeedbackVaryings = program.transformFeedbackVaryings;\n\n    if (transformFeedbackVaryings)\n    {\n        if (typeof gl.transformFeedbackVaryings !== 'function')\n        {\n            // #if _DEBUG\n            warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);\n            // #endif\n        }\n        else\n        {\n            gl.transformFeedbackVaryings(\n                webGLProgram,\n                transformFeedbackVaryings.names,\n                transformFeedbackVaryings.bufferMode === 'separate'\n                    ? gl.SEPARATE_ATTRIBS\n                    : gl.INTERLEAVED_ATTRIBS\n            );\n        }\n    }\n\n    gl.linkProgram(webGLProgram);\n\n    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS))\n    {\n        logProgramError(gl, webGLProgram, glVertShader, glFragShader);\n    }\n\n    // GLSL 1.00: bind attributes sorted by name in ascending order\n    // GLSL 3.00: don't change the attribute locations that where chosen by the compiler\n    //            or assigned by the layout specifier in the shader source code\n    program._attributeData = extractAttributesFromGlProgram(\n        webGLProgram,\n        gl,\n        !(/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m).test(program.vertex)\n    );\n\n    program._uniformData = getUniformData(webGLProgram, gl);\n    program._uniformBlockData = getUboData(webGLProgram, gl);\n\n    gl.deleteShader(glVertShader);\n    gl.deleteShader(glFragShader);\n\n    const uniformData: {[key: string]: IGLUniformData} = {};\n\n    for (const i in program._uniformData)\n    {\n        const data = program._uniformData[i];\n\n        uniformData[i] = {\n            location: gl.getUniformLocation(webGLProgram, i),\n            value: defaultValue(data.type, data.size),\n        };\n    }\n\n    const glProgram = new GlProgramData(webGLProgram, uniformData);\n\n    return glProgram;\n}\n","import { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { warn } from '../../../../utils/logging/warn';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { CLEAR } from '../const';\nimport { GlRenderTarget } from '../GlRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { CLEAR_OR_BOOL } from '../const';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGL renderer\n * @category rendering\n * @ignore\n */\nexport class GlRenderTargetAdaptor implements RenderTargetAdaptor<GlRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GlRenderTarget>;\n    private _renderer: WebGLRenderer<HTMLCanvasElement>;\n    private _clearColorCache: RgbaArray = [0, 0, 0, 0];\n    private _viewPortCache: Rectangle = new Rectangle();\n    /** Pre-computed draw buffers arrays for MRT, indexed by color attachment count */\n    private _drawBuffersCache: number[][];\n\n    public init(renderer: WebGLRenderer, renderTargetSystem: RenderTargetSystem<GlRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n\n        renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._clearColorCache = [0, 0, 0, 0];\n        this._viewPortCache = new Rectangle();\n\n        // Pre-compute draw buffers arrays for all possible MRT configurations\n        const gl = this._renderer.gl;\n\n        this._drawBuffersCache = [];\n\n        for (let i = 1; i <= 16; i++)\n        {\n            this._drawBuffersCache[i] = Array.from({ length: i }, (_, j) => gl.COLOR_ATTACHMENT0 + j);\n        }\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const renderer = this._renderer;\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n        const gl = renderer.gl;\n\n        this.finishRenderPass(sourceRenderSurfaceTexture);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n\n        renderer.texture.bind(destinationTexture, 0);\n\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0,\n            originDest.x, originDest.y,\n            originSrc.x,\n            originSrc.y,\n            size.width,\n            size.height\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const source = renderTarget.colorTexture;\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        let viewPortY = viewport.y;\n\n        if (renderTarget.isRoot)\n        {\n            // /TODO this is the same logic?\n            viewPortY = source.pixelHeight - viewport.height - viewport.y;\n        }\n\n        // unbind the current render texture..\n        renderTarget.colorTextures.forEach((texture) =>\n        {\n            this._renderer.texture.unbind(texture);\n        });\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);\n\n        // Set draw buffers for multiple render targets (MRT)\n        if (renderTarget.colorTextures.length > 1)\n        {\n            this._setDrawBuffers(renderTarget, gl);\n        }\n\n        const viewPortCache = this._viewPortCache;\n\n        if (viewPortCache.x !== viewport.x\n            || viewPortCache.y !== viewPortY\n            || viewPortCache.width !== viewport.width\n            || viewPortCache.height !== viewport.height)\n        {\n            viewPortCache.x = viewport.x;\n            viewPortCache.y = viewPortY;\n            viewPortCache.width = viewport.width;\n            viewPortCache.height = viewport.height;\n\n            gl.viewport(\n                viewport.x,\n                viewPortY,\n                viewport.width,\n                viewport.height,\n            );\n        }\n\n        // if the stencil buffer has been requested, we need to create a stencil buffer\n        if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth))\n        {\n            this._initStencil(gpuRenderTarget);\n        }\n\n        this.clear(renderTarget, clear, clearColor);\n    }\n\n    public finishRenderPass(renderTarget?: RenderTarget)\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (!glRenderTarget.msaa) return;\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        gl.blitFramebuffer(\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            gl.COLOR_BUFFER_BIT, gl.NEAREST,\n        );\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        // dont think we need this anymore? keeping around just in case the wheels fall off\n        // gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GlRenderTarget\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n\n        // do single...\n\n        const glRenderTarget = new GlRenderTarget();\n\n        // we are rendering to the main canvas..\n        const colorTexture = renderTarget.colorTexture;\n\n        if (colorTexture instanceof CanvasSource)\n        {\n            this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);\n\n            glRenderTarget.framebuffer = null;\n\n            return glRenderTarget;\n        }\n\n        this._initColor(renderTarget, glRenderTarget);\n\n        // set up a depth texture..\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return glRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        if (gpuRenderTarget.framebuffer)\n        {\n            gl.deleteFramebuffer(gpuRenderTarget.framebuffer);\n            gpuRenderTarget.framebuffer = null;\n        }\n\n        if (gpuRenderTarget.resolveTargetFramebuffer)\n        {\n            gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);\n            gpuRenderTarget.resolveTargetFramebuffer = null;\n        }\n\n        if (gpuRenderTarget.depthStencilRenderBuffer)\n        {\n            gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);\n            gpuRenderTarget.depthStencilRenderBuffer = null;\n        }\n\n        gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) =>\n        {\n            gl.deleteRenderbuffer(renderBuffer);\n        });\n\n        gpuRenderTarget.msaaRenderBuffer = null;\n    }\n\n    public clear(_renderTarget: RenderTarget, clear: CLEAR_OR_BOOL, clearColor?: RgbaArray)\n    {\n        if (!clear) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        // if clear is boolean..\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const gl = this._renderer.gl;\n\n        if (clear & CLEAR.COLOR)\n        {\n            clearColor ??= renderTargetSystem.defaultClearColor;\n\n            const clearColorCache = this._clearColorCache;\n            const clearColorArray = clearColor as number[];\n\n            if (clearColorCache[0] !== clearColorArray[0]\n                || clearColorCache[1] !== clearColorArray[1]\n                || clearColorCache[2] !== clearColorArray[2]\n                || clearColorCache[3] !== clearColorArray[3])\n            {\n                clearColorCache[0] = clearColorArray[0];\n                clearColorCache[1] = clearColorArray[1];\n                clearColorCache[2] = clearColorArray[2];\n                clearColorCache[3] = clearColorArray[3];\n\n                gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);\n            }\n        }\n\n        gl.clear(clear);\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        if (renderTarget.isRoot) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        this._resizeColor(renderTarget, glRenderTarget);\n\n        if (renderTarget.stencil || renderTarget.depth)\n        {\n            this._resizeStencil(glRenderTarget);\n        }\n    }\n\n    private _initColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n        // deal with our outputs..\n        const resolveTargetFramebuffer = gl.createFramebuffer();\n\n        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;\n\n        // set up the texture..\n        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);\n\n        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;\n        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;\n\n        const colorTextures = renderTarget.colorTextures;\n\n        colorTextures.forEach((colorTexture, i) =>\n        {\n            const source = colorTexture.source;\n\n            if (source.antialias)\n            {\n                if (renderer.context.supports.msaa)\n                {\n                    glRenderTarget.msaa = true;\n                }\n                else\n                {\n                    warn('[RenderTexture] Antialiasing on textures is not supported in WebGL1');\n                }\n            }\n\n            // TODO bindSource could return the glTexture\n            renderer.texture.bindSource(source, 0);\n            const glSource = renderer.texture.getGlSource(source);\n\n            const glTexture = glSource.texture;\n\n            gl.framebufferTexture2D(gl.FRAMEBUFFER,\n                gl.COLOR_ATTACHMENT0 + i,\n                3553, // texture.target,\n                glTexture,\n                0);// mipLevel);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const viewFramebuffer = gl.createFramebuffer();\n\n            glRenderTarget.framebuffer = viewFramebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((_, i) =>\n            {\n                const msaaRenderBuffer = gl.createRenderbuffer();\n\n                glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;\n            });\n        }\n        else\n        {\n            glRenderTarget.framebuffer = resolveTargetFramebuffer;\n        }\n\n        this._resizeColor(renderTarget, glRenderTarget);\n    }\n\n    private _resizeColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const source = renderTarget.colorTexture.source;\n\n        glRenderTarget.width = source.pixelWidth;\n        glRenderTarget.height = source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            // nno need to resize the first texture..\n            if (i === 0) return;\n\n            colorTexture.source.resize(source.width, source.height, source._resolution);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const renderer = this._renderer;\n            const gl = renderer.gl;\n\n            const viewFramebuffer = glRenderTarget.framebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const source = colorTexture.source;\n\n                renderer.texture.bindSource(source, 0);\n                const glSource = renderer.texture.getGlSource(source);\n\n                const glInternalFormat = glSource.internalFormat;\n\n                const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];\n\n                gl.bindRenderbuffer(\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n\n                gl.renderbufferStorageMultisample(\n                    gl.RENDERBUFFER,\n                    4,\n                    glInternalFormat,\n                    source.pixelWidth,\n                    source.pixelHeight\n                );\n\n                gl.framebufferRenderbuffer(\n                    gl.FRAMEBUFFER,\n                    gl.COLOR_ATTACHMENT0 + i,\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n            });\n        }\n    }\n\n    private _initStencil(glRenderTarget: GlRenderTarget)\n    {\n        // this already exists on the default screen\n        if (glRenderTarget.framebuffer === null) return;\n\n        const gl = this._renderer.gl;\n\n        const depthStencilRenderBuffer = gl.createRenderbuffer();\n\n        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            gl.DEPTH_STENCIL_ATTACHMENT,\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        // TDO DO>>\n        this._resizeStencil(glRenderTarget);\n    }\n\n    private _resizeStencil(glRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            glRenderTarget.depthStencilRenderBuffer\n        );\n\n        if (glRenderTarget.msaa)\n        {\n            gl.renderbufferStorageMultisample(\n                gl.RENDERBUFFER,\n                4,\n                gl.DEPTH24_STENCIL8,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n        else\n        {\n            gl.renderbufferStorage(\n                gl.RENDERBUFFER,\n                this._renderer.context.webGLVersion === 2\n                    ? gl.DEPTH24_STENCIL8\n                    : gl.DEPTH_STENCIL,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n    }\n\n    public prerender(renderTarget: RenderTarget)\n    {\n        const resource = renderTarget.colorTexture.resource;\n\n        // if the render target is a canvas, ensure its size matches the source\n        if (this._renderer.context.multiView && CanvasSource.test(resource))\n        {\n            this._renderer.context.ensureCanvasSize(resource);\n        }\n    }\n\n    public postrender(renderTarget: RenderTarget)\n    {\n        // if multiView is not enabled, we don't need to do anything\n        if (!this._renderer.context.multiView) return;\n\n        // if the render target is a canvas, we need to copy the pixels from the gl canvas\n        // to the canvas target\n        if (CanvasSource.test(renderTarget.colorTexture.resource))\n        {\n            const contextCanvas = this._renderer.context.canvas;\n            const canvasSource = renderTarget.colorTexture as unknown as CanvasSource;\n\n            canvasSource.context2D.drawImage(\n                contextCanvas as CanvasImageSource,\n                0, canvasSource.pixelHeight - contextCanvas.height\n            );\n        }\n    }\n\n    private _setDrawBuffers(renderTarget: RenderTarget, gl: GlRenderingContext): void\n    {\n        const count = renderTarget.colorTextures.length;\n        const bufferArray = this._drawBuffersCache[count];\n\n        if (this._renderer.context.webGLVersion === 1)\n        {\n            const ext = this._renderer.context.extensions.drawBuffers;\n\n            if (!ext)\n            {\n                warn('[RenderTexture] This WebGL1 context does not support rendering to multiple targets');\n            }\n            else\n            {\n                ext.drawBuffersWEBGL(bufferArray);\n            }\n        }\n        else\n        {\n            // WebGL2 has built in support\n            gl.drawBuffers(bufferArray);\n        }\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuStencilModesToPixi } from '../gpu/state/GpuStencilModesToPixi';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @category rendering\n * @advanced\n */\nexport class GlStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private _gl: WebGLRenderingContext;\n\n    private readonly _stencilCache = {\n        enabled: false,\n        stencilReference: 0,\n        stencilMode: STENCIL_MODES.NONE,\n    };\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _stencilOpsMapping: {\n        keep: number;\n        zero: number;\n        replace: number;\n        invert: number;\n        'increment-clamp': number;\n        'decrement-clamp': number;\n        'increment-wrap': number;\n        'decrement-wrap': number;\n    };\n\n    private _comparisonFuncMapping: {\n        always: number;\n        never: number;\n        equal: number;\n        'not-equal': number;\n        less: number;\n        'less-equal': number;\n        greater: number;\n        'greater-equal': number;\n    };\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected contextChange(gl: WebGLRenderingContext)\n    {\n        // TODO - this could be declared in a gl const\n        // we know the numbers don't tend to change!\n        this._gl = gl;\n\n        this._comparisonFuncMapping = {\n            always: gl.ALWAYS,\n            never: gl.NEVER,\n            equal: gl.EQUAL,\n            'not-equal': gl.NOTEQUAL,\n            less: gl.LESS,\n            'less-equal': gl.LEQUAL,\n            greater: gl.GREATER,\n            'greater-equal': gl.GEQUAL,\n        };\n\n        this._stencilOpsMapping = {\n            keep: gl.KEEP,\n            zero: gl.ZERO,\n            replace: gl.REPLACE,\n            invert: gl.INVERT,\n            'increment-clamp': gl.INCR,\n            'decrement-clamp': gl.DECR,\n            'increment-wrap': gl.INCR_WRAP,\n            'decrement-wrap': gl.DECR_WRAP,\n        };\n\n        this.resetState();\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        if (this._activeRenderTarget === renderTarget) return;\n\n        this._activeRenderTarget = renderTarget;\n\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        // restore the current render targets stencil state..\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public resetState()\n    {\n        // reset stencil cache\n        this._stencilCache.enabled = false;\n        this._stencilCache.stencilMode = STENCIL_MODES.NONE;\n        this._stencilCache.stencilReference = 0;\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        const gl = this._gl;\n        const mode = GpuStencilModesToPixi[stencilMode];\n\n        const _stencilCache = this._stencilCache;\n\n        // store the stencil state for restoration later, if a render target changes\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        if (stencilMode === STENCIL_MODES.DISABLED)\n        {\n            if (this._stencilCache.enabled)\n            {\n                this._stencilCache.enabled = false;\n\n                gl.disable(gl.STENCIL_TEST);\n            }\n\n            return;\n        }\n\n        if (!this._stencilCache.enabled)\n        {\n            this._stencilCache.enabled = true;\n            gl.enable(gl.STENCIL_TEST);\n        }\n\n        if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference)\n        {\n            _stencilCache.stencilMode = stencilMode;\n            _stencilCache.stencilReference = stencilReference;\n\n            // this is pretty simple mapping.\n            // will work for pixi's simple mask cases.\n            // although a true mapping of the GPU state to webGL state should be done\n            gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 0xFF);\n            gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);\n        }\n    }\n\n    public destroy?: () => void;\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { type RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport { State } from '../../shared/state/State';\nimport { type WebGLRenderer } from '../WebGLRenderer';\nimport { mapWebGLBlendModesToPixi } from './mapWebGLBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\n\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * System plugin to the renderer to manage WebGL state machines\n * @category rendering\n * @advanced\n */\nexport class GlStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'state',\n    } as const;\n\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @type {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gl: GlRenderingContext;\n\n    protected blendModesMap: Record<BLEND_MODES, number[]>;\n\n    /**\n     * Collection of calls\n     * @type {Function[]}\n     */\n    protected readonly map: ((value: boolean) => void)[];\n\n    /**\n     * Collection of check calls\n     * @type {Function[]}\n     */\n    protected readonly checks: ((system: this, state: State) => void)[];\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    /**\n     * Whether to invert the front face when rendering\n     * This is used for render textures where the Y-coordinate is flipped\n     * @default false\n     */\n    private _invertFrontFace: boolean = false;\n    private _glFrontFace: boolean;\n    private _cullFace: boolean;\n    private _frontFaceDirty: boolean;\n    private _frontFace: boolean;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this.gl = null;\n\n        this.stateId = 0;\n        this.polygonOffset = 0;\n        this.blendMode = 'none';\n\n        this._blendEq = false;\n\n        // map functions for when we set state..\n        this.map = [];\n        this.map[BLEND] = this.setBlend;\n        this.map[OFFSET] = this.setOffset;\n        this.map[CULLING] = this.setCullFace;\n        this.map[DEPTH_TEST] = this.setDepthTest;\n        this.map[WINDING] = this.setFrontFace;\n        this.map[DEPTH_MASK] = this.setDepthMask;\n\n        this.checks = [];\n\n        this.defaultState = State.for2d();\n\n        // listen for when the renderTarget changes\n        // as rendering to textures means we need to invert the front face\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        this._invertFrontFace = !renderTarget.isRoot;\n\n        // mini optimization to avoid setting the front face if culling is disabled\n        if (this._cullFace)\n        {\n            // need to set the front face to the requested value as it matters because of the culling is active!\n            this.setFrontFace(this._frontFace);\n        }\n        else\n        {\n            // if culling is disabled, we need to set the front face dirty\n            this._frontFaceDirty = true;\n        }\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this.gl = gl;\n\n        this.blendModesMap = mapWebGLBlendModesToPixi(gl);\n\n        // Reset face culling variables\n\n        this.resetState();\n    }\n\n    /**\n     * Sets the current state\n     * @param {*} state - The state to set.\n     */\n    public set(state: State): void\n    {\n        state ||= this.defaultState;\n\n        // TODO maybe to an object check? ( this.state === state )?\n        if (this.stateId !== state.data)\n        {\n            let diff = this.stateId ^ state.data;\n            let i = 0;\n\n            // order from least to most common\n            while (diff)\n            {\n                if (diff & 1)\n                {\n                    // state change!\n                    this.map[i].call(this, !!(state.data & (1 << i)));\n                }\n\n                diff >>= 1;\n                i++;\n            }\n\n            this.stateId = state.data;\n        }\n\n        // based on the above settings we check for specific modes..\n        // for example if blend is active we check and set the blend modes\n        // or of polygon offset is active we check the poly depth.\n        for (let i = 0; i < this.checks.length; i++)\n        {\n            this.checks[i](this, state);\n        }\n    }\n\n    /**\n     * Sets the state, when previous state is unknown.\n     * @param {*} state - The state to set\n     */\n    public forceState(state: State): void\n    {\n        state ||= this.defaultState;\n        for (let i = 0; i < this.map.length; i++)\n        {\n            this.map[i].call(this, !!(state.data & (1 << i)));\n        }\n        for (let i = 0; i < this.checks.length; i++)\n        {\n            this.checks[i](this, state);\n        }\n\n        this.stateId = state.data;\n    }\n\n    /**\n     * Sets whether to enable or disable blending.\n     * @param value - Turn on or off WebGl blending.\n     */\n    public setBlend(value: boolean): void\n    {\n        this._updateCheck(GlStateSystem._checkBlendMode, value);\n\n        this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);\n    }\n\n    /**\n     * Sets whether to enable or disable polygon offset fill.\n     * @param value - Turn on or off webgl polygon offset testing.\n     */\n    public setOffset(value: boolean): void\n    {\n        this._updateCheck(GlStateSystem._checkPolygonOffset, value);\n\n        this.gl[value ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);\n    }\n\n    /**\n     * Sets whether to enable or disable depth test.\n     * @param value - Turn on or off webgl depth testing.\n     */\n    public setDepthTest(value: boolean): void\n    {\n        this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);\n    }\n\n    /**\n     * Sets whether to enable or disable depth mask.\n     * @param value - Turn on or off webgl depth mask.\n     */\n    public setDepthMask(value: boolean): void\n    {\n        this.gl.depthMask(value);\n    }\n\n    /**\n     * Sets whether to enable or disable cull face.\n     * @param {boolean} value - Turn on or off webgl cull face.\n     */\n    public setCullFace(value: boolean): void\n    {\n        this._cullFace = value;\n        this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);\n\n        if (this._cullFace && this._frontFaceDirty)\n        {\n            // need to set the front face to the requested value as it matters because of the culling is active!\n            this.setFrontFace(this._frontFace);\n        }\n    }\n\n    /**\n     * Sets the gl front face.\n     * @param {boolean} value - true is clockwise and false is counter-clockwise\n     */\n    public setFrontFace(value: boolean): void\n    {\n        this._frontFace = value;\n        this._frontFaceDirty = false;\n        // If invertFrontFace is true, we invert the face direction\n        const faceMode = this._invertFrontFace ? !value : value;\n\n        if (this._glFrontFace !== faceMode)\n        {\n            this._glFrontFace = faceMode;\n            this.gl.frontFace(this.gl[faceMode ? 'CW' : 'CCW']);\n        }\n    }\n\n    /**\n     * Sets the blend mode.\n     * @param {number} value - The blend mode to set to.\n     */\n    public setBlendMode(value: BLEND_MODES): void\n    {\n        if (!this.blendModesMap[value])\n        {\n            value = 'normal';\n        }\n\n        if (value === this.blendMode)\n        {\n            return;\n        }\n\n        this.blendMode = value;\n\n        const mode = this.blendModesMap[value];\n        const gl = this.gl;\n\n        if (mode.length === 2)\n        {\n            gl.blendFunc(mode[0], mode[1]);\n        }\n        else\n        {\n            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n        }\n\n        if (mode.length === 6)\n        {\n            this._blendEq = true;\n            gl.blendEquationSeparate(mode[4], mode[5]);\n        }\n        else if (this._blendEq)\n        {\n            this._blendEq = false;\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n        }\n    }\n\n    /**\n     * Sets the polygon offset.\n     * @param {number} value - the polygon offset\n     * @param {number} scale - the polygon offset scale\n     */\n    public setPolygonOffset(value: number, scale: number): void\n    {\n        this.gl.polygonOffset(value, scale);\n    }\n\n    /** Resets all the logic and disables the VAOs. */\n    public resetState(): void\n    {\n        this._glFrontFace = false;\n        this._frontFace = false;\n        this._cullFace = false;\n        this._frontFaceDirty = false;\n        this._invertFrontFace = false;\n\n        this.gl.frontFace(this.gl.CCW);\n        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n\n        this.forceState(this.defaultState);\n\n        this._blendEq = true;\n        // setting to '' means the blend mode will be set as soon as we set the first blend mode when rendering!\n        this.blendMode = '' as BLEND_MODES;\n        this.setBlendMode('normal');\n    }\n\n    /**\n     * Checks to see which updates should be checked based on which settings have been activated.\n     *\n     * For example, if blend is enabled then we should check the blend modes each time the state is changed\n     * or if polygon fill is activated then we need to check if the polygon offset changes.\n     * The idea is that we only check what we have too.\n     * @param func - the checking function to add or remove\n     * @param value - should the check function be added or removed.\n     */\n    private _updateCheck(func: (system: this, state: State) => void, value: boolean): void\n    {\n        const index = this.checks.indexOf(func);\n\n        if (value && index === -1)\n        {\n            this.checks.push(func);\n        }\n        else if (!value && index !== -1)\n        {\n            this.checks.splice(index, 1);\n        }\n    }\n\n    /**\n     * A private little wrapper function that we call to check the blend mode.\n     * @param system - the System to perform the state check on\n     * @param state - the state that the blendMode will pulled from\n     */\n    private static _checkBlendMode(system: GlStateSystem, state: State): void\n    {\n        system.setBlendMode(state.blendMode);\n    }\n\n    /**\n     * A private little wrapper function that we call to check the polygon offset.\n     * @param system - the System to perform the state check on\n     * @param state - the state that the blendMode will pulled from\n     */\n    private static _checkPolygonOffset(system: GlStateSystem, state: State): void\n    {\n        system.setPolygonOffset(1, state.polygonOffset);\n    }\n\n    /** @ignore */\n    public destroy(): void\n    {\n        this.gl = null;\n        this.checks.length = 0;\n    }\n}\n","import type { GlRenderingContext } from '../../context/GlRenderingContext';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param {WebGLRenderingContext} gl - The rendering context.\n * @returns Lookup table.\n */\nexport function mapFormatToGlFormat(gl: GlRenderingContext): Record<string, number>\n{\n    return {\n        // 8-bit formats\n        r8unorm: gl.RED,\n        r8snorm: gl.RED,\n        r8uint: gl.RED,\n        r8sint: gl.RED,\n\n        // 16-bit formats\n        r16uint: gl.RED,\n        r16sint:    gl.RED,\n        r16float: gl.RED,\n        rg8unorm:  gl.RG,\n        rg8snorm:   gl.RG,\n        rg8uint:  gl.RG,\n        rg8sint:  gl.RG,\n\n        // 32-bit formats\n        r32uint: gl.RED,\n        r32sint: gl.RED,\n        r32float: gl.RED,\n        rg16uint:   gl.RG,\n        rg16sint:  gl.RG,\n        rg16float:  gl.RG,\n        rgba8unorm: gl.RGBA,\n        'rgba8unorm-srgb': gl.RGBA,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.RGBA,\n        rgba8uint: gl.RGBA,\n        rgba8sint: gl.RGBA,\n        bgra8unorm: gl.RGBA,\n        'bgra8unorm-srgb': gl.RGBA,\n        rgb9e5ufloat: gl.RGB,\n        rgb10a2unorm: gl.RGBA,\n        rg11b10ufloat: gl.RGB,\n\n        // 64-bit formats\n        rg32uint: gl.RG,\n        rg32sint: gl.RG,\n        rg32float:  gl.RG,\n        rgba16uint: gl.RGBA,\n        rgba16sint: gl.RGBA,\n        rgba16float: gl.RGBA,\n\n        // 128-bit formats\n        rgba32uint: gl.RGBA,\n        rgba32sint: gl.RGBA,\n        rgba32float: gl.RGBA,\n\n        // Depth/stencil formats\n        stencil8: gl.STENCIL_INDEX8,\n        depth16unorm: gl.DEPTH_COMPONENT,\n        depth24plus: gl.DEPTH_COMPONENT,\n        'depth24plus-stencil8': gl.DEPTH_STENCIL,\n        depth32float: gl.DEPTH_COMPONENT,\n        'depth32float-stencil8': gl.DEPTH_STENCIL,\n\n    };\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash';\nimport { BufferUsage } from '../../shared/buffer/const';\nimport { BUFFER_TYPE } from './const';\nimport { GlBuffer } from './GlBuffer';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * System plugin to the renderer to manage buffers.\n *\n * WebGL uses Buffers as a way to store objects to the GPU.\n * This system makes working with them a lot easier.\n *\n * Buffers are used in three main places in WebGL\n * - geometry information\n * - Uniform information (via uniform buffer objects - a WebGL 2 only feature)\n * - Transform feedback information. (WebGL 2 only feature)\n *\n * This system will handle the binding of buffers to the GPU as well as uploading\n * them. With this system, you never need to work directly with GPU buffers, but instead work with\n * the Buffer class.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GlBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    /** @internal */\n    public _gl: GlRenderingContext;\n    protected _managedBuffers: GCManagedHash<Buffer>;\n\n    /** Cache keeping track of the base bound buffer bases */\n    private _boundBufferBases: {[key: number]: GlBuffer} = Object.create(null);\n\n    private _renderer: WebGLRenderer;\n\n    private _minBaseLocation = 0;\n    private _maxBindings: number;\n    private _nextBindBaseIndex = this._minBaseLocation;\n    private _bindCallId = 0;\n\n    /**\n     * @param {Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._managedBuffers = new GCManagedHash({\n            renderer,\n            type: 'resource',\n            onUnload: this.onBufferUnload.bind(this),\n            name: 'glBuffer'\n        });\n    }\n\n    /** @ignore */\n    public destroy(): void\n    {\n        this._managedBuffers.destroy();\n        this._renderer = null;\n        this._gl = null;\n        this._boundBufferBases = {};\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this._gl = this._renderer.gl;\n\n        this.destroyAll(true);\n        this._maxBindings = this._renderer.limits.maxUniformBindings;\n    }\n\n    public getGlBuffer(buffer: Buffer): GlBuffer\n    {\n        buffer._gcLastUsed = this._renderer.gc.now;\n\n        return (buffer._gpuData[this._renderer.uid] as GlBuffer) || this.createGLBuffer(buffer);\n    }\n\n    /**\n     * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n     * @param buffer - the buffer to bind to the renderer\n     */\n    public bind(buffer: Buffer): void\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n    }\n\n    /**\n     * Binds an uniform buffer to at the given index.\n     *\n     * A cache is used so a buffer will not be bound again if already bound.\n     * @param glBuffer - the buffer to bind\n     * @param index - the base index to bind it to.\n     */\n    public bindBufferBase(glBuffer: GlBuffer, index: number): void\n    {\n        const { _gl: gl } = this;\n\n        if (this._boundBufferBases[index] !== glBuffer)\n        {\n            this._boundBufferBases[index] = glBuffer;\n            glBuffer._lastBindBaseLocation = index;\n\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n        }\n    }\n\n    public nextBindBase(hasTransformFeedback: boolean)\n    {\n        this._bindCallId++;\n        this._minBaseLocation = 0;\n        if (hasTransformFeedback)\n        {\n            this._boundBufferBases[0] = null;\n            this._minBaseLocation = 1;\n            if (this._nextBindBaseIndex < 1)\n            {\n                this._nextBindBaseIndex = 1;\n            }\n        }\n    }\n\n    public freeLocationForBufferBase(glBuffer: GlBuffer): number\n    {\n        let freeIndex = this.getLastBindBaseLocation(glBuffer);\n\n        // check if it is already bound..\n        if (freeIndex >= this._minBaseLocation)\n        {\n            glBuffer._lastBindCallId = this._bindCallId;\n\n            return freeIndex;\n        }\n\n        let loop = 0;\n        let nextIndex = this._nextBindBaseIndex;\n\n        while (loop < 2)\n        {\n            if (nextIndex >= this._maxBindings)\n            {\n                nextIndex = this._minBaseLocation;\n                loop++;\n            }\n\n            const curBuf = this._boundBufferBases[nextIndex];\n\n            if (curBuf && curBuf._lastBindCallId === this._bindCallId)\n            {\n                nextIndex++;\n                continue;\n            }\n            break;\n        }\n\n        freeIndex = nextIndex;\n        this._nextBindBaseIndex = nextIndex + 1;\n\n        if (loop >= 2)\n        {\n            // TODO: error\n            return -1;\n        }\n\n        glBuffer._lastBindCallId = this._bindCallId;\n        this._boundBufferBases[freeIndex] = null;\n\n        return freeIndex;\n    }\n\n    public getLastBindBaseLocation(glBuffer: GlBuffer): number\n    {\n        const index = glBuffer._lastBindBaseLocation;\n\n        if (this._boundBufferBases[index] === glBuffer)\n        {\n            return index;\n        }\n\n        return -1;\n    }\n\n    /**\n     * Binds a buffer whilst also binding its range.\n     * This will make the buffer start from the offset supplied rather than 0 when it is read.\n     * @param glBuffer - the buffer to bind\n     * @param index - the base index to bind at, defaults to 0\n     * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n     * @param size - the size to bind at (this is blocks of 256).\n     */\n    public bindBufferRange(glBuffer: GlBuffer, index?: number, offset?: number, size?: number): void\n    {\n        const { _gl: gl } = this;\n\n        offset ||= 0;\n        index ||= 0;\n\n        this._boundBufferBases[index] = null;\n\n        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);\n    }\n\n    /**\n     * Will ensure the data in the buffer is uploaded to the GPU.\n     * @param {Buffer} buffer - the buffer to update\n     */\n    public updateBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        if (buffer._updateID === glBuffer.updateID)\n        {\n            return glBuffer;\n        }\n\n        glBuffer.updateID = buffer._updateID;\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n\n        const data = buffer.data;\n\n        const drawType = (buffer.descriptor.usage & BufferUsage.STATIC) ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n\n        if (data)\n        {\n            if (glBuffer.byteLength >= data.byteLength)\n            {\n                // assuming our buffers are aligned to 4 bits...\n                // offset is always zero for now!\n                gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);\n            }\n            else\n            {\n                glBuffer.byteLength = data.byteLength;\n                // assuming our buffers are aligned to 4 bits...\n                gl.bufferData(glBuffer.type, data, drawType);\n            }\n        }\n        else\n        {\n            glBuffer.byteLength = buffer.descriptor.size;\n            gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);\n        }\n\n        return glBuffer;\n    }\n\n    /**\n     * dispose all WebGL resources of all managed buffers\n     * @param contextLost\n     */\n    public destroyAll(contextLost: boolean = false): void\n    {\n        this._managedBuffers.removeAll(contextLost);\n    }\n\n    protected onBufferUnload(buffer: Buffer, contextLost: boolean = false): void\n    {\n        const glBuffer = buffer._gpuData[this._renderer.uid] as GlBuffer;\n\n        if (!glBuffer) return;\n        if (!contextLost) this._gl.deleteBuffer(glBuffer.buffer);\n    }\n\n    /**\n     * creates and attaches a GLBuffer object tied to the current context.\n     * @param buffer\n     * @protected\n     */\n    protected createGLBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        let type = BUFFER_TYPE.ARRAY_BUFFER;\n\n        if ((buffer.descriptor.usage & BufferUsage.INDEX))\n        {\n            type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n        }\n        else if ((buffer.descriptor.usage & BufferUsage.UNIFORM))\n        {\n            type = BUFFER_TYPE.UNIFORM_BUFFER;\n        }\n\n        const glBuffer = new GlBuffer(gl.createBuffer(), type);\n\n        buffer._gpuData[this._renderer.uid] = glBuffer;\n        this._managedBuffers.add(buffer);\n\n        return glBuffer;\n    }\n\n    public resetState(): void\n    {\n        this._boundBufferBases = Object.create(null);\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBitGl } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * A MeshAdaptor that uses the WebGL to render meshes.\n * @category rendering\n * @ignore\n */\nexport class GlMeshAdaptor implements MeshAdaptor\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBitGl,\n                textureBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        this._shader = new Shader({\n            glProgram,\n            resources: {\n                uTexture: Texture.EMPTY.source,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh): void\n    {\n        const renderer = meshPipe.renderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            const texture = mesh.texture;\n            const source = texture.source;\n\n            shader.resources.uTexture = source;\n            shader.resources.uSampler = source.style;\n            shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;\n        }\n        else if (!shader.glProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no glProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        // setting the groups to be high to be compatible and not\n        // overlap any other groups\n        shader.groups[100] = renderer.globalUniforms.bindGroup;\n        shader.groups[101] = meshPipe.localUniformsBindGroup;\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state,\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { type Renderer } from '../../../rendering/renderers/types';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses WebGL to render graphics.\n * @category rendering\n * @ignore\n */\nexport class GlGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    public contextChange(renderer: Renderer): void\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const maxTextures = renderer.limits.maxBatchableTextures;\n\n        const glProgram = compileHighShaderGlProgram({\n            name: 'graphics',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        this.shader = new Shader({\n            glProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGLRenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            batcher, instructions,\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGL specific..\n        shader.groups[0] = renderer.globalUniforms.bindGroup;\n\n        renderer.state.set(graphicsPipe.state);\n\n        renderer.shader.bind(shader);\n\n        renderer.geometry.bind(batcher.geometry, shader.glProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            if (batch.size)\n            {\n                for (let j = 0; j < batch.textures.count; j++)\n                {\n                    renderer.texture.bind(batch.textures.textures[j], j);\n                }\n\n                renderer.geometry.draw(batch.topology, batch.size, batch.start);\n            }\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n","// cu = Cached value's uniform data field\n// cv = Cached value\n// v = value to upload\n// ud = uniformData\n// uv = uniformValue\n\nimport { BufferResource } from '../../../shared/buffer/BufferResource';\nimport { UniformGroup } from '../../../shared/shader/UniformGroup';\nimport { uniformParsers } from '../../../shared/shader/utils/uniformParsers';\nimport { UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS } from './generateUniformsSyncTypes';\n\nimport type { UniformsSyncCallback } from '../../../shared/shader/types';\n\n/**\n * @param group\n * @param uniformData\n * @internal\n */\nexport function generateUniformsSync(group: UniformGroup, uniformData: Record<string, any>): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    `];\n\n    for (const i in group.uniforms)\n    {\n        if (!uniformData[i])\n        {\n            if (group.uniforms[i] instanceof UniformGroup)\n            {\n                if ((group.uniforms[i] as UniformGroup).ubo)\n                {\n                    funcFragments.push(`\n                        renderer.shader.bindUniformBlock(uv.${i}, \"${i}\");\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        renderer.shader.updateUniformGroup(uv.${i});\n                    `);\n                }\n            }\n            else if (group.uniforms[i] instanceof BufferResource)\n            {\n                funcFragments.push(`\n                        renderer.shader.bindBufferResource(uv.${i}, \"${i}\");\n                    `);\n            }\n\n            continue;\n        }\n\n        const uniform = group.uniformStructures[i];\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const parser = uniformParsers[j];\n\n            if (uniform.type === parser.type && parser.test(uniform))\n            {\n                funcFragments.push(`name = \"${i}\";`, uniformParsers[j].uniform);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;\n\n            const template = templateType[uniform.type].replace('location', `ud[\"${i}\"].location`);\n\n            funcFragments.push(`\n            cu = ud[\"${i}\"];\n            cv = cu.value;\n            v = uv[\"${i}\"];\n            ${template};`);\n        }\n    }\n\n    /*\n     * the introduction of syncData is to solve an issue where textures in uniform groups are not set correctly\n     * the texture count was always starting from 0 in each group. This needs to increment each time a texture is used\n     * no matter which group is being used\n     *\n     */\n    // eslint-disable-next-line no-new-func\n    return new Function('ud', 'uv', 'renderer', 'syncData', funcFragments.join('\\n')) as UniformsSyncCallback;\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash';\nimport { Texture } from '../../shared/texture/Texture';\nimport { GlTexture } from './GlTexture';\nimport { glUploadBufferImageResource } from './uploaders/glUploadBufferImageResource';\nimport { glUploadCompressedTextureResource } from './uploaders/glUploadCompressedTextureResource';\nimport { glUploadImageResource } from './uploaders/glUploadImageResource';\nimport { glUploadVideoResource } from './uploaders/glUploadVideoResource';\nimport { applyStyleParams } from './utils/applyStyleParams';\nimport { mapFormatToGlFormat } from './utils/mapFormatToGlFormat';\nimport { mapFormatToGlInternalFormat } from './utils/mapFormatToGlInternalFormat';\nimport { mapFormatToGlType } from './utils/mapFormatToGlType';\nimport { unpremultiplyAlpha } from './utils/unpremultiplyAlpha';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GLTextureUploader } from './uploaders/GLTextureUploader';\n\nconst BYTES_PER_PIXEL = 4;\n\n/**\n * The system for managing textures in WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    private readonly _renderer: WebGLRenderer;\n    private readonly _managedTextures: GCManagedHash<TextureSource>;\n    /**\n     * @deprecated since 8.15.0\n     */\n    public get managedTextures(): Readonly<TextureSource[]> { return Object.values(this._managedTextures.items); }\n\n    private _glSamplers: Record<string, WebGLSampler> = Object.create(null);\n\n    private _boundTextures: TextureSource[] = [];\n    private _activeTextureLocation = -1;\n\n    private _boundSamplers: Record<number, WebGLSampler> = Object.create(null);\n\n    private readonly _uploads: Record<string, GLTextureUploader> = {\n        image: glUploadImageResource,\n        buffer: glUploadBufferImageResource,\n        video: glUploadVideoResource,\n        compressed: glUploadCompressedTextureResource,\n    };\n\n    private _gl: GlRenderingContext;\n    private _mapFormatToInternalFormat: Record<string, number>;\n    private _mapFormatToType: Record<string, number>;\n    private _mapFormatToFormat: Record<string, number>;\n\n    private _premultiplyAlpha = false;\n\n    // TODO - separate samplers will be a cool thing to add, but not right now!\n    private readonly _useSeparateSamplers = false;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._managedTextures = new GCManagedHash({\n            renderer,\n            type: 'resource',\n            onUnload: this.onSourceUnload.bind(this),\n            name: 'glTexture'\n        });\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        if (!this._mapFormatToInternalFormat)\n        {\n            this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);\n\n            this._mapFormatToType = mapFormatToGlType(gl);\n            this._mapFormatToFormat = mapFormatToGlFormat(gl);\n        }\n\n        this._managedTextures.removeAll(true);\n\n        this._glSamplers = Object.create(null);\n        this._boundSamplers = Object.create(null);\n        this._premultiplyAlpha = false;\n\n        for (let i = 0; i < 16; i++)\n        {\n            this.bind(Texture.EMPTY, i);\n        }\n    }\n\n    /**\n     * Initializes a texture source, if it has already been initialized nothing will happen.\n     * @param source - The texture source to initialize.\n     * @returns The initialized texture source.\n     */\n    public initSource(source: TextureSource)\n    {\n        this.bind(source);\n    }\n\n    public bind(texture: BindableTexture, location = 0)\n    {\n        const source = texture.source;\n\n        if (texture)\n        {\n            this.bindSource(source, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(source.style, location);\n            }\n        }\n        else\n        {\n            this.bindSource(null, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(null, location);\n            }\n        }\n    }\n\n    public bindSource(source: TextureSource, location = 0): void\n    {\n        const gl = this._gl;\n\n        source._gcLastUsed = this._renderer.gc.now;\n\n        if (this._boundTextures[location] !== source)\n        {\n            this._boundTextures[location] = source;\n            this._activateLocation(location);\n\n            source ||= Texture.EMPTY.source;\n\n            // bind texture and source!\n            const glTexture = this.getGlSource(source);\n\n            gl.bindTexture(glTexture.target, glTexture.texture);\n        }\n    }\n\n    private _bindSampler(style: TextureStyle, location = 0): void\n    {\n        const gl = this._gl;\n\n        if (!style)\n        {\n            this._boundSamplers[location] = null;\n            gl.bindSampler(location, null);\n\n            return;\n        }\n\n        const sampler = this._getGlSampler(style);\n\n        if (this._boundSamplers[location] !== sampler)\n        {\n            this._boundSamplers[location] = sampler;\n            gl.bindSampler(location, sampler);\n        }\n    }\n\n    public unbind(texture: BindableTexture): void\n    {\n        const source = texture.source;\n        const boundTextures = this._boundTextures;\n        const gl = this._gl;\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            if (boundTextures[i] === source)\n            {\n                this._activateLocation(i);\n\n                const glTexture = this.getGlSource(source);\n\n                gl.bindTexture(glTexture.target, null);\n                boundTextures[i] = null;\n            }\n        }\n    }\n\n    private _activateLocation(location: number): void\n    {\n        if (this._activeTextureLocation !== location)\n        {\n            this._activeTextureLocation = location;\n            this._gl.activeTexture(this._gl.TEXTURE0 + location);\n        }\n    }\n\n    private _initSource(source: TextureSource): GlTexture\n    {\n        const gl = this._gl;\n\n        const glTexture = new GlTexture(gl.createTexture());\n\n        glTexture.type = this._mapFormatToType[source.format];\n        glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];\n        glTexture.format = this._mapFormatToFormat[source.format];\n\n        if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo))\n        {\n            const biggestDimension = Math.max(source.width, source.height);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        source._gpuData[this._renderer.uid] = glTexture;\n\n        const added = this._managedTextures.add(source);\n\n        if (added)\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceUpdate, this);\n            source.on('styleChange', this.onStyleChange, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n        }\n\n        this.onSourceUpdate(source);\n        this.updateStyle(source, false);\n\n        return glTexture;\n    }\n\n    protected onStyleChange(source: TextureSource): void\n    {\n        this.updateStyle(source, false);\n    }\n\n    protected updateStyle(source: TextureSource, firstCreation: boolean): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        applyStyleParams(\n            source.style,\n            gl,\n            source.mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'texParameteri',\n            gl.TEXTURE_2D,\n            // will force a clamp to edge if the texture is not a power of two\n            !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo,\n            firstCreation,\n        );\n    }\n\n    protected onSourceUnload(source: TextureSource, contextLost = false): void\n    {\n        const glTexture = source._gpuData[this._renderer.uid] as GlTexture;\n\n        if (!glTexture) return;\n\n        if (!contextLost)\n        {\n            this.unbind(source);\n            this._gl.deleteTexture(glTexture.texture);\n        }\n        source.off('update', this.onSourceUpdate, this);\n        source.off('resize', this.onSourceUpdate, this);\n        source.off('styleChange', this.onStyleChange, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        if (this._premultiplyAlpha !== premultipliedAlpha)\n        {\n            this._premultiplyAlpha = premultipliedAlpha;\n            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);\n        }\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);\n        }\n        else\n        {\n            gl.texImage2D(\n                gl.TEXTURE_2D,\n                0,\n                glTexture.internalFormat,\n                source.pixelWidth,\n                source.pixelHeight,\n                0,\n                glTexture.format,\n                glTexture.type,\n                null,\n            );\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source, false);\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource, bind = true): void\n    {\n        if (bind) this.bindSource(source, 0);\n\n        const glTexture = this.getGlSource(source);\n\n        this._gl.generateMipmap(glTexture.target);\n    }\n\n    private _initSampler(style: TextureStyle): WebGLSampler\n    {\n        const gl = this._gl;\n\n        const glSampler = this._gl.createSampler();\n\n        this._glSamplers[style._resourceId] = glSampler;\n\n        applyStyleParams(\n            style,\n            gl,\n            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'samplerParameteri',\n            glSampler,\n            false,\n            true,\n        );\n\n        return this._glSamplers[style._resourceId];\n    }\n\n    private _getGlSampler(sampler: TextureStyle): WebGLSampler\n    {\n        return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGlSource(source: TextureSource): GlTexture\n    {\n        source._gcLastUsed = this._renderer.gc.now;\n\n        return source._gpuData[this._renderer.uid] as GlTexture || this._initSource(source);\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const { pixels, width, height } = this.getPixels(texture);\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = width;\n        canvas.height = height;\n\n        const ctx = canvas.getContext('2d');\n\n        if (ctx)\n        {\n            const imageData = ctx.createImageData(width, height);\n\n            imageData.data.set(pixels);\n            ctx.putImageData(imageData, 0, 0);\n        }\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const resolution = texture.source.resolution;\n        const frame = texture.frame;\n\n        const width = Math.max(Math.round(frame.width * resolution), 1);\n        const height = Math.max(Math.round(frame.height * resolution), 1);\n        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        const renderer = this._renderer;\n\n        const renderTarget = renderer.renderTarget.getRenderTarget(texture);\n        const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);\n\n        const gl = renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);\n\n        gl.readPixels(\n            Math.round(frame.x * resolution),\n            Math.round(frame.y * resolution),\n            width,\n            height,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            pixels\n        );\n\n        // if (texture.source.premultiplyAlpha > 0)\n        // TODO - premultiplied alpha does not exist right now, need to add that back in!\n        // eslint-disable-next-line no-constant-condition\n        if (false)\n        {\n            unpremultiplyAlpha(pixels);\n        }\n\n        return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the array with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this._managedTextures.destroy();\n        this._glSamplers = null;\n        this._boundTextures = null;\n        this._boundSamplers = null;\n        this._mapFormatToInternalFormat = null;\n        this._mapFormatToType = null;\n        this._mapFormatToFormat = null;\n        (this._uploads as null) = null;\n        (this._renderer as null) = null;\n    }\n\n    public resetState(): void\n    {\n        this._activeTextureLocation = -1;\n        this._boundTextures.fill(Texture.EMPTY.source);\n        this._boundSamplers = Object.create(null);\n\n        const gl = this._gl;\n\n        this._premultiplyAlpha = false;\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);\n    }\n}\n\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { type GPUData } from '../../../../scene/view/ViewContainer';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash';\nimport { getAttributeInfoFromFormat } from '../../shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ensureAttributes } from '../shader/program/ensureAttributes';\nimport { getGlTypeFromFormat } from './utils/getGlTypeFromFormat';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { GlProgram } from '../shader/GlProgram';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\nconst topologyToGlMap = {\n    'point-list': 0x0000,\n    'line-list': 0x0001,\n    'line-strip': 0x0003,\n    'triangle-list': 0x0004,\n    'triangle-strip': 0x0005\n};\n\n/**\n * Stores GPU-specific data for a Geometry instance in WebGL context.\n *\n * This class manages Vertex Array Object (VAO) caching for geometries,\n * allowing efficient reuse of VAOs across different shader programs.\n * Each geometry can have multiple VAOs cached, one for each unique\n * shader program signature it's used with.\n * @internal\n */\nexport class GlGeometryGpuData implements GPUData\n{\n    public vaoCache: Record<string, WebGLVertexArrayObject>;\n\n    constructor()\n    {\n        this.vaoCache = Object.create(null);\n    }\n\n    public destroy(): void\n    {\n        this.vaoCache = Object.create(null);\n    }\n}\n\n/**\n * System plugin to the renderer to manage geometry.\n * @category rendering\n * @advanced\n */\nexport class GlGeometrySystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'geometry',\n    } as const;\n\n    /**\n     * `true` if we has `*_vertex_array_object` extension.\n     * @readonly\n     */\n    public hasVao: boolean;\n\n    /**\n     * `true` if has `ANGLE_instanced_arrays` extension.\n     * @readonly\n     */\n    public hasInstance: boolean;\n\n    protected gl: GlRenderingContext;\n    protected _activeGeometry: Geometry;\n    /** @internal */\n    public _activeVao: WebGLVertexArrayObject;\n    /** @internal */\n    public _managedGeometries: GCManagedHash<Geometry>;\n\n    /** Renderer that owns this {@link GeometrySystem}. */\n    private _renderer: WebGLRenderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n\n        this._managedGeometries = new GCManagedHash({\n            renderer,\n            type: 'resource',\n            onUnload: this.onGeometryUnload.bind(this),\n            name: 'glGeometry'\n        });\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        const gl = this.gl = this._renderer.gl;\n\n        if (!this._renderer.context.supports.vertexArrayObject)\n        {\n            throw new Error('[PixiJS] Vertex Array Objects are not supported on this device');\n        }\n\n        this.destroyAll(true);\n        const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;\n\n        if (nativeVaoExtension)\n        {\n            gl.createVertexArray = (): WebGLVertexArrayObject =>\n                nativeVaoExtension.createVertexArrayOES();\n\n            gl.bindVertexArray = (vao): void =>\n                nativeVaoExtension.bindVertexArrayOES(vao);\n\n            gl.deleteVertexArray = (vao): void =>\n                nativeVaoExtension.deleteVertexArrayOES(vao);\n        }\n\n        const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;\n\n        if (nativeInstancedExtension)\n        {\n            gl.drawArraysInstanced = (a, b, c, d): void =>\n            {\n                nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);\n            };\n\n            gl.drawElementsInstanced = (a, b, c, d, e): void =>\n            {\n                nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);\n            };\n\n            gl.vertexAttribDivisor = (a, b): void =>\n                nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);\n        }\n\n        this._activeGeometry = null;\n        this._activeVao = null;\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @param geometry - Instance of geometry to bind.\n     * @param program - Instance of program to use vao for.\n     */\n    public bind(geometry?: Geometry, program?: GlProgram): void\n    {\n        // shader ||= this.renderer.shader.shader;\n\n        const gl = this.gl;\n\n        this._activeGeometry = geometry;\n\n        const vao = this.getVao(geometry, program);\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            gl.bindVertexArray(vao);\n        }\n\n        this.updateBuffers();\n    }\n\n    /** Reset and unbind any active VAO and geometry. */\n    public resetState(): void\n    {\n        this.unbind();\n    }\n\n    /** Update buffers of the currently bound geometry. */\n    public updateBuffers(): void\n    {\n        const geometry = this._activeGeometry;\n\n        const bufferSystem = this._renderer.buffer;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            bufferSystem.updateBuffer(buffer);\n        }\n\n        geometry._gcLastUsed = this._renderer.gc.now;\n    }\n\n    /**\n     * Check compatibility between a geometry and a program\n     * @param geometry - Geometry instance.\n     * @param program - Program instance.\n     */\n    protected checkCompatibility(geometry: Geometry, program: GlProgram): void\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Takes a geometry and program and generates a unique signature for them.\n     * @param geometry - To get signature from.\n     * @param program - To test geometry against.\n     * @returns - Unique signature of the geometry and program\n     */\n    protected getSignature(geometry: Geometry, program: GlProgram): string\n    {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        const strings = ['g', geometry.uid];\n\n        for (const i in attribs)\n        {\n            if (shaderAttributes[i])\n            {\n                strings.push(i, shaderAttributes[i].location);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    protected getVao(geometry: Geometry, program: GlProgram): WebGLVertexArrayObject\n    {\n        return geometry._gpuData[this._renderer.uid]?.vaoCache[program._key] || this.initGeometryVao(geometry, program);\n    }\n\n    /**\n     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n     * attribute locations.\n     * @param geometry - Instance of geometry to to generate Vao for.\n     * @param program\n     * @param _incRefCount - Increment refCount of all geometry buffers.\n     */\n    protected initGeometryVao(geometry: Geometry, program: GlProgram, _incRefCount = true): WebGLVertexArrayObject\n    {\n        const gl = this._renderer.gl;\n        // const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this._renderer.buffer;\n\n        this._renderer.shader._getProgramData(program);\n\n        this.checkCompatibility(geometry, program);\n\n        const signature = this.getSignature(geometry, program);\n\n        const gpuData = new GlGeometryGpuData();\n\n        geometry._gpuData[this._renderer.uid] = gpuData;\n        this._managedGeometries.add(geometry);\n\n        const vaoObjectHash = gpuData.vaoCache;\n        let vao = vaoObjectHash[signature];\n\n        if (vao)\n        {\n            // this will give us easy access to the vao\n            vaoObjectHash[program._key] = vao;\n\n            return vao;\n        }\n\n        ensureAttributes(geometry, program._attributeData);\n\n        const buffers = geometry.buffers;\n\n        // @TODO: We don't know if VAO is supported.\n        vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            bufferSystem.bind(buffer);\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n\n        this.activateVao(geometry, program);\n\n        // add it to the cache!\n        vaoObjectHash[program._key] = vao;\n        vaoObjectHash[signature] = vao;\n\n        gl.bindVertexArray(null);\n\n        return vao;\n    }\n\n    protected onGeometryUnload(geometry: Geometry, contextLost = false): void\n    {\n        const gpuData = geometry._gpuData[this._renderer.uid];\n\n        if (!gpuData) return;\n\n        const vaoCache = gpuData.vaoCache;\n\n        if (!contextLost)\n        {\n            for (const i in vaoCache)\n            {\n                if (this._activeVao !== vaoCache[i])\n                {\n                    this.resetState();\n                }\n                this.gl.deleteVertexArray(vaoCache[i]);\n            }\n        }\n    }\n\n    /**\n     * Dispose all WebGL resources of all managed geometries.\n     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    public destroyAll(contextLost = false): void\n    {\n        this._managedGeometries.removeAll(contextLost);\n    }\n\n    /**\n     * Activate vertex array object.\n     * @param geometry - Geometry instance.\n     * @param program - Shader program instance.\n     */\n    protected activateVao(geometry: Geometry, program: GlProgram): void\n    {\n        const gl = this._renderer.gl;\n\n        const bufferSystem = this._renderer.buffer;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            bufferSystem.bind(geometry.indexBuffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = attribute.buffer;\n            const glBuffer = bufferSystem.getGlBuffer(buffer);\n            const programAttrib = program._attributeData[j];\n\n            if (programAttrib)\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    bufferSystem.bind(buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = programAttrib.location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                const attributeInfo = getAttributeInfoFromFormat(attribute.format);\n\n                const type = getGlTypeFromFormat(attribute.format);\n\n                if (programAttrib.format?.substring(1, 4) === 'int')\n                {\n                    gl.vertexAttribIPointer(location,\n                        attributeInfo.size,\n                        type,\n                        attribute.stride,\n                        attribute.offset);\n                }\n                else\n                {\n                    gl.vertexAttribPointer(location,\n                        attributeInfo.size,\n                        type,\n                        attributeInfo.normalised,\n                        attribute.stride,\n                        attribute.offset);\n                }\n\n                if (attribute.instance)\n                {\n                    // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        // Can't use truthiness check to determine if divisor is set,\n                        // since 0 is a valid value for divisor\n                        const divisor = attribute.divisor ?? 1;\n\n                        gl.vertexAttribDivisor(location, divisor);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the currently bound geometry.\n     * @param topology - The type primitive to render.\n     * @param size - The number of elements to be rendered. If not specified, all vertices after the\n     *  starting vertex will be drawn.\n     * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n     *  all instances will be drawn.\n     * @returns This instance of the geometry system.\n     */\n    public draw(topology?: Topology, size?: number, start?: number, instanceCount?: number): this\n    {\n        const { gl } = this._renderer;\n        const geometry = this._activeGeometry;\n\n        const glTopology = topologyToGlMap[topology || geometry.topology];\n\n        instanceCount ??= geometry.instanceCount;\n\n        if (geometry.indexBuffer)\n        {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n            if (instanceCount !== 1)\n            {\n                /* eslint-disable max-len */\n                gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);\n                /* eslint-enable max-len */\n            }\n            else\n            {\n                gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n            }\n        }\n        else if (instanceCount !== 1)\n        {\n            // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);\n        }\n        else\n        {\n            gl.drawArrays(glTopology, start || 0, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    /** Unbind/reset everything. */\n    protected unbind(): void\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n\n    public destroy(): void\n    {\n        this._managedGeometries.destroy();\n        this._renderer = null;\n        this.gl = null;\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n}\n","import { glUploadImageResource } from './glUploadImageResource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\n/** @internal */\nexport const glUploadVideoResource = {\n\n    id: 'video',\n\n    upload(source: VideoSource, glTexture: GlTexture, gl: GlRenderingContext, webGLVersion: number)\n    {\n        if (!source.isValid)\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                1,\n                1,\n                0,\n                glTexture.format,\n                glTexture.type,\n                null\n            );\n\n            return;\n        }\n\n        glUploadImageResource.upload(source, glTexture, gl, webGLVersion);\n    }\n} as GLTextureUploader;\n\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { warn } from '../../../utils/logging/warn';\nimport { Geometry } from '../shared/geometry/Geometry';\nimport { Shader } from '../shared/shader/Shader';\nimport { State } from '../shared/state/State';\nimport { TextureSource } from '../shared/texture/sources/TextureSource';\nimport { Texture } from '../shared/texture/Texture';\nimport { GlProgram } from './shader/GlProgram';\n\nimport type { RenderOptions } from '../shared/system/AbstractRenderer';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\nconst bigTriangleGeometry = new Geometry({\n    attributes: {\n        aPosition: [\n            -1.0, -1.0, // Bottom left corner\n            3.0, -1.0, // Bottom right corner, extending beyond right edge\n            -1.0, 3.0 // Top left corner, extending beyond top edge\n        ],\n    },\n});\n\n/**\n * The options for the back buffer system.\n * @category rendering\n * @property {boolean} [useBackBuffer=false] - if true will use the back buffer where required\n * @property {boolean} [antialias=false] - if true will ensure the texture is antialiased\n * @advanced\n */\nexport interface GlBackBufferOptions\n{\n    /**\n     * if true will use the back buffer where required\n     * @default false\n     */\n    useBackBuffer?: boolean;\n    /** if true will ensure the texture is antialiased */\n    antialias?: boolean;\n}\n\n/**\n * For blend modes you need to know what pixels you are actually drawing to. For this to be possible in WebGL\n * we need to render to a texture and then present that texture to the screen. This system manages that process.\n *\n * As the main scene is rendered to a texture, it means we can sample it and copy its pixels,\n * something not possible on the main canvas.\n *\n * If antialiasing is set to to true and useBackBuffer is set to true, then the back buffer will be antialiased.\n * and the main gl context will not.\n *\n * You only need to activate this back buffer if you are using a blend mode that requires it.\n *\n * to activate is simple, you pass `useBackBuffer:true` to your render options\n * @category rendering\n * @advanced\n */\nexport class GlBackBufferSystem implements System<GlBackBufferOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'backBuffer',\n        priority: 1\n    } as const;\n\n    /** default options for the back buffer system */\n    public static defaultOptions: GlBackBufferOptions = {\n        /** if true will use the back buffer where required */\n        useBackBuffer: false,\n    };\n\n    /** if true, the back buffer is used */\n    public useBackBuffer = false;\n\n    private _backBufferTexture: Texture;\n    private readonly _renderer: WebGLRenderer;\n    private _targetTexture: TextureSource;\n    private _useBackBufferThisRender = false;\n    private _antialias: boolean;\n    private _state: State;\n    private _bigTriangleShader: Shader;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public init(options: GlBackBufferOptions = {})\n    {\n        const { useBackBuffer, antialias } = { ...GlBackBufferSystem.defaultOptions, ...options };\n\n        this.useBackBuffer = useBackBuffer;\n\n        this._antialias = antialias;\n\n        if (!this._renderer.context.supports.msaa)\n        {\n            warn('antialiasing, is not supported on when using the back buffer');\n\n            this._antialias = false;\n        }\n\n        this._state = State.for2d();\n\n        const bigTriangleProgram = new GlProgram({\n            vertex: `\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }`,\n            fragment: `\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }`,\n            name: 'big-triangle',\n        });\n\n        this._bigTriangleShader = new Shader({\n            glProgram: bigTriangleProgram,\n            resources: {\n                uTexture: Texture.WHITE.source,\n            },\n        });\n    }\n\n    /**\n     * This is called before the RenderTargetSystem is started. This is where\n     * we replace the target with the back buffer if required.\n     * @param options - The options for this render.\n     */\n    protected renderStart(options: RenderOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n\n        this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;\n\n        if (this._useBackBufferThisRender)\n        {\n            const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n\n            this._targetTexture = renderTarget.colorTexture;\n\n            options.target = this._getBackBufferTexture(renderTarget.colorTexture);\n        }\n    }\n\n    protected renderEnd()\n    {\n        this._presentBackBuffer();\n    }\n\n    private _presentBackBuffer()\n    {\n        const renderer = this._renderer;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (!this._useBackBufferThisRender) return;\n\n        renderer.renderTarget.bind(this._targetTexture, false);\n\n        this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;\n\n        renderer.encoder.draw({\n            geometry: bigTriangleGeometry,\n            shader: this._bigTriangleShader,\n            state: this._state,\n        });\n    }\n\n    private _getBackBufferTexture(targetSourceTexture: TextureSource)\n    {\n        this._backBufferTexture = this._backBufferTexture || new Texture({\n            source: new TextureSource({\n                width: targetSourceTexture.width,\n                height: targetSourceTexture.height,\n                resolution: targetSourceTexture._resolution,\n                antialias: this._antialias,\n            }),\n        });\n\n        // this will not resize if its the same size already! No extra check required\n        this._backBufferTexture.source.resize(\n            targetSourceTexture.width,\n            targetSourceTexture.height,\n            targetSourceTexture._resolution,\n        );\n\n        return this._backBufferTexture;\n    }\n\n    /** destroys the back buffer */\n    public destroy()\n    {\n        if (this._backBufferTexture)\n        {\n            this._backBufferTexture.destroy();\n            this._backBufferTexture = null;\n        }\n    }\n}\n","// cu = Cached value's uniform data field\n// cv = Cached value\n// v = value to upload\n// ud = uniformData\n// uv = uniformValue\n\nimport type { UNIFORM_TYPES } from '../../../shared/shader/types';\n\n/** @internal */\nexport const UNIFORM_TO_SINGLE_SETTERS: Record<UNIFORM_TYPES | string, string> = {\n    f32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1f(location, v);\n        }`,\n    'vec2<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2f(location, v[0], v[1]);\n        }`,\n    'vec3<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3f(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        }`,\n    i32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n    'vec2<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n    'vec3<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n    u32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1ui(location, v);\n        }`,\n    'vec2<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2ui(location, v[0], v[1]);\n        }`,\n    'vec3<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3ui(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n        }`,\n    bool: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n    'vec2<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n    'vec3<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n    'mat2x2<f32>': `gl.uniformMatrix2fv(location, false, v);`,\n    'mat3x3<f32>': `gl.uniformMatrix3fv(location, false, v);`,\n    'mat4x4<f32>': `gl.uniformMatrix4fv(location, false, v);`,\n};\n\n/** @internal */\nexport const UNIFORM_TO_ARRAY_SETTERS: Record<UNIFORM_TYPES | string, string> = {\n    f32: `gl.uniform1fv(location, v);`,\n    'vec2<f32>': `gl.uniform2fv(location, v);`,\n    'vec3<f32>': `gl.uniform3fv(location, v);`,\n    'vec4<f32>': `gl.uniform4fv(location, v);`,\n    'mat2x2<f32>': `gl.uniformMatrix2fv(location, false, v);`,\n    'mat3x3<f32>': `gl.uniformMatrix3fv(location, false, v);`,\n    'mat4x4<f32>': `gl.uniformMatrix4fv(location, false, v);`,\n    i32: `gl.uniform1iv(location, v);`,\n    'vec2<i32>': `gl.uniform2iv(location, v);`,\n    'vec3<i32>': `gl.uniform3iv(location, v);`,\n    'vec4<i32>': `gl.uniform4iv(location, v);`,\n    u32: `gl.uniform1iv(location, v);`,\n    'vec2<u32>': `gl.uniform2iv(location, v);`,\n    'vec3<u32>': `gl.uniform3iv(location, v);`,\n    'vec4<u32>': `gl.uniform4iv(location, v);`,\n    bool: `gl.uniform1iv(location, v);`,\n    'vec2<bool>': `gl.uniform2iv(location, v);`,\n    'vec3<bool>': `gl.uniform3iv(location, v);`,\n    'vec4<bool>': `gl.uniform4iv(location, v);`,\n};\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { generateUniformsSync } from './utils/generateUniformsSync';\n\nimport type { UniformsSyncCallback } from '../../shared/shader/types';\nimport type { UniformGroup } from '../../shared/shader/UniformGroup';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GlProgram, GlUniformData } from './GlProgram';\n\n/**\n * System plugin to the renderer to manage shaders.\n * @category rendering\n * @advanced\n */\nexport class GlUniformGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'uniformGroup',\n    } as const;\n\n    /**\n     * The current WebGL rendering context.\n     * @type {WebGLRenderingContext}\n     */\n    protected gl: GlRenderingContext;\n\n    /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */\n    private _cache: Record<string, UniformsSyncCallback> = {};\n    private _renderer: WebGLRenderer;\n\n    private _uniformGroupSyncHash: Record<string, Record<string, UniformsSyncCallback>> = {};\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this.gl = null;\n        this._cache = {};\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this.gl = gl;\n    }\n\n    /**\n     * Uploads the uniforms values to the currently bound shader.\n     * @param group - the uniforms values that be applied to the current shader\n     * @param program\n     * @param syncData\n     * @param syncData.textureCount\n     */\n    public updateUniformGroup(group: UniformGroup, program: GlProgram, syncData: { textureCount: number }): void\n    {\n        const programData = this._renderer.shader._getProgramData(program);\n\n        if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid])\n        {\n            programData.uniformDirtyGroups[group.uid] = group._dirtyId;\n\n            const syncFunc = this._getUniformSyncFunction(group, program);\n\n            syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);\n        }\n    }\n\n    /**\n     * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.\n     * @param group\n     * @param program\n     */\n    private _getUniformSyncFunction(group: UniformGroup, program: GlProgram): UniformsSyncCallback\n    {\n        return this._uniformGroupSyncHash[group._signature]?.[program._key]\n            || this._createUniformSyncFunction(group, program);\n    }\n\n    private _createUniformSyncFunction(group: UniformGroup, program: GlProgram): UniformsSyncCallback\n    {\n        const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature]\n            || (this._uniformGroupSyncHash[group._signature] = {});\n\n        const id = this._getSignature(group, program._uniformData, 'u');\n\n        if (!this._cache[id])\n        {\n            this._cache[id] = this._generateUniformsSync(group, program._uniformData);\n        }\n\n        uniformGroupSyncHash[program._key] = this._cache[id];\n\n        return uniformGroupSyncHash[program._key];\n    }\n\n    private _generateUniformsSync(group: UniformGroup, uniformData: Record<string, GlUniformData>): UniformsSyncCallback\n    {\n        return generateUniformsSync(group, uniformData);\n    }\n\n    /**\n     * Takes a uniform group and data and generates a unique signature for them.\n     * @param group - The uniform group to get signature of\n     * @param group.uniforms\n     * @param uniformData - Uniform information generated by the shader\n     * @param preFix\n     * @returns Unique signature of the uniform group\n     */\n    private _getSignature(group: UniformGroup, uniformData: Record<string, any>, preFix: string): string\n    {\n        const uniforms = group.uniforms;\n\n        const strings = [`${preFix}-`];\n\n        for (const i in uniforms)\n        {\n            strings.push(i);\n\n            if (uniformData[i])\n            {\n                strings.push(uniformData[i].type);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    /** Destroys this System and removes all its textures. */\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._cache = null;\n    }\n}\n","import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GlGraphicsAdaptor } from '../../../scene/graphics/gl/GlGraphicsAdaptor';\nimport { GlMeshAdaptor } from '../../../scene/mesh/gl/GlMeshAdaptor';\nimport { GlBatchAdaptor } from '../../batcher/gl/GlBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { GlBufferSystem } from './buffer/GlBufferSystem';\nimport { GlContextSystem } from './context/GlContextSystem';\nimport { GlGeometrySystem } from './geometry/GlGeometrySystem';\nimport { GlBackBufferSystem } from './GlBackBufferSystem';\nimport { GlColorMaskSystem } from './GlColorMaskSystem';\nimport { GlEncoderSystem } from './GlEncoderSystem';\nimport { GlLimitsSystem } from './GlLimitsSystem';\nimport { GlStencilSystem } from './GlStencilSystem';\nimport { GlUboSystem } from './GlUboSystem';\nimport { GlRenderTargetSystem } from './renderTarget/GlRenderTargetSystem';\nimport { GlShaderSystem } from './shader/GlShaderSystem';\nimport { GlUniformGroupSystem } from './shader/GlUniformGroupSystem';\nimport { GlStateSystem } from './state/GlStateSystem';\nimport { GlTextureSystem } from './texture/GlTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\nimport type { GlRenderingContext } from './context/GlRenderingContext';\n\nconst DefaultWebGLSystems = [\n    ...SharedSystems,\n    GlUboSystem,\n    GlBackBufferSystem,\n    GlContextSystem,\n    GlLimitsSystem,\n    GlBufferSystem,\n    GlTextureSystem,\n    GlRenderTargetSystem,\n    GlGeometrySystem,\n    GlUniformGroupSystem,\n    GlShaderSystem,\n    GlEncoderSystem,\n    GlStateSystem,\n    GlStencilSystem,\n    GlColorMaskSystem,\n];\nconst DefaultWebGLPipes = [...SharedRenderPipes];\nconst DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGLSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);\n\n/**\n * The default WebGL renderer, uses WebGL2 contexts.\n * @category rendering\n * @standard\n * @interface\n */\nexport type WebGLSystems = ExtractSystemTypes<typeof DefaultWebGLSystems>\n& PixiMixins.RendererSystems & PixiMixins.WebGLSystems;\n\n/**\n * The default WebGL renderer, uses WebGL2 contexts.\n * @internal\n */\nexport type WebGLPipes = ExtractSystemTypes<typeof DefaultWebGLPipes> & PixiMixins.RendererPipes & PixiMixins.WebGLPipes;\n\n/**\n * Options for WebGLRenderer.\n * @category rendering\n * @standard\n */\nexport interface WebGLOptions\n    extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGLSystems>,\n    PixiMixins.WebGLOptions {}\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface WebGLRenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGLPipes, WebGLOptions, T>,\n    WebGLSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGL PixiJS Renderer. This renderer allows you to use the most common graphics API, WebGL (and WebGL2).\n *\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGLRenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n *\n *\n * ```ts\n * // Create a new renderer\n * const renderer = await rendering.autoDetectRenderer({\n *    preference:'webgl',\n * });\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGL renderer:\n *\n * | WebGL Core Systems                          | Systems that are specific to the WebGL renderer                               |\n * | ------------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link GlUboSystem}               | This manages WebGL2 uniform buffer objects feature for shaders                |\n * | {@link GlBackBufferSystem}        | manages the back buffer, used so that we can pixi can pixels from the screen  |\n * | {@link GlContextSystem}           | This manages the WebGL context and its extensions                             |\n * | {@link GlBufferSystem}            | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link GlTextureSystem}           | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link GlRenderTargetSystem}      | This manages what we render too. For example the screen, or another texture   |\n * | {@link GlGeometrySystem}          | This manages geometry, used for drawing meshes via the GPU                    |\n * | {@link GlUniformGroupSystem}      | This manages uniform groups. Syncing shader properties with the GPU           |\n * | {@link GlShaderSystem}            | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link GlEncoderSystem}           | This manages encoders, a WebGPU Paradigm, use it to draw a mesh + shader      |\n * | {@link GlStateSystem}             | This manages the state of the WebGL context. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link GlStencilSystem}           | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link GlColorMaskSystem}         | This manages the color mask. Used for color masking                           |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @category rendering\n * @property {GlUboSystem} ubo - UboSystem instance.\n * @property {GlBackBufferSystem} backBuffer - BackBufferSystem instance.\n * @property {GlContextSystem} context - ContextSystem instance.\n * @property {GlBufferSystem} buffer - BufferSystem instance.\n * @property {GlTextureSystem} texture - TextureSystem instance.\n * @property {GlRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {GlGeometrySystem} geometry - GeometrySystem instance.\n * @property {GlUniformGroupSystem} uniformGroup - UniformGroupSystem instance.\n * @property {GlShaderSystem} shader - ShaderSystem instance.\n * @property {GlEncoderSystem} encoder - EncoderSystem instance.\n * @property {GlStateSystem} state - StateSystem instance.\n * @property {GlStencilSystem} stencil - StencilSystem instance.\n * @property {GlColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @extends AbstractRenderer\n * @standard\n */\nexport class WebGLRenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGLPipes, WebGLOptions, T>\n    implements WebGLSystems\n{\n    public gl: GlRenderingContext;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgl',\n            type: RendererType.WEBGL,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { type GpuPowerPreference } from '../../types';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { WebGLExtensions } from './WebGLExtensions';\n\n/**\n * Options for the context system.\n * @category rendering\n * @advanced\n * @property {WebGL2RenderingContext | null} [context=null] - User-provided WebGL rendering context object.\n * @property {GpuPowerPreference} [powerPreference='default'] - An optional hint indicating what configuration\n * of GPU is suitable for the WebGL context, can be `'high-performance'` or `'low-power'`. Setting to `'high-performance'`\n * will prioritize rendering performance over power consumption, while setting to `'low-power'` will prioritize power saving\n * over rendering performance.\n * @property {boolean} [premultipliedAlpha=true] - Whether the compositor will assume the drawing buffer contains\n * colors with premultiplied alpha.\n * @property {boolean} [preserveDrawingBuffer=false] - Whether to enable drawing buffer preservation.\n * If enabled, the drawing buffer will preserve\n * its value until cleared or overwritten. Enable this if you need to call `toDataUrl` on the WebGL context.\n * @property {boolean} [antialias] - Whether to enable antialiasing.\n * @property {1 | 2} [preferWebGLVersion=2] - The preferred WebGL version to use.\n */\nexport interface ContextSystemOptions\n{\n    /**\n     * User-provided WebGL rendering context object.\n     * @default null\n     */\n    context: WebGL2RenderingContext | null;\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGL context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @default undefined\n     */\n    powerPreference?: GpuPowerPreference;\n\n    /**\n     * Whether the compositor will assume the drawing buffer contains colors with premultiplied alpha.\n     * @default true\n     */\n    premultipliedAlpha: boolean;\n    /**\n     * Whether to enable drawing buffer preservation. If enabled, the drawing buffer will preserve\n     * its value until cleared or overwritten. Enable this if you need to call `toDataUrl` on the WebGL context.\n     * @default false\n     */\n    preserveDrawingBuffer: boolean;\n\n    antialias?: boolean;\n\n    /**\n     * The preferred WebGL version to use.\n     * @default 2\n     */\n    preferWebGLVersion?: 1 | 2;\n\n    /**\n     * Whether to enable multi-view rendering. Set to true when rendering to multiple\n     * canvases on the dom.\n     * @default false\n     */\n    multiView: boolean;\n}\n\n/**\n * System plugin to the renderer to manage the context\n * @category rendering\n * @advanced\n */\nexport class GlContextSystem implements System<ContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'context',\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: ContextSystemOptions = {\n        /**\n         * {@link WebGLOptions.context}\n         * @default null\n         */\n        context: null,\n        /**\n         * {@link WebGLOptions.premultipliedAlpha}\n         * @default true\n         */\n        premultipliedAlpha: true,\n        /**\n         * {@link WebGLOptions.preserveDrawingBuffer}\n         * @default false\n         */\n        preserveDrawingBuffer: false,\n        /**\n         * {@link WebGLOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * {@link WebGLOptions.webGLVersion}\n         * @default 2\n         */\n        preferWebGLVersion: 2,\n        /**\n         * {@link WebGLOptions.multiView}\n         * @default false\n         */\n        multiView: false\n    };\n\n    protected CONTEXT_UID: number;\n    protected gl: WebGL2RenderingContext;\n\n    /**\n     * Features supported by current renderer.\n     * @type {object}\n     * @readonly\n     */\n    public supports = {\n        /** Support for 32-bit indices buffer. */\n        uint32Indices: true,\n        /** Support for UniformBufferObjects */\n        uniformBufferObject: true,\n        /** Support for VertexArrayObjects */\n        vertexArrayObject: true,\n        /** Support for SRGB texture format */\n        srgbTextures: true,\n        /** Support for wrapping modes if a texture is non-power of two */\n        nonPowOf2wrapping: true,\n        /** Support for MSAA (antialiasing of dynamic textures) */\n        msaa: true,\n        /** Support for mipmaps if a texture is non-power of two */\n        nonPowOf2mipmaps: true,\n    };\n\n    /**\n     * Extensions available.\n     * @type {object}\n     * @readonly\n     * @property {WEBGL_draw_buffers} drawBuffers - WebGL v1 extension\n     * @property {WEBGL_depth_texture} depthTexture - WebGL v1 extension\n     * @property {OES_texture_float} floatTexture - WebGL v1 extension\n     * @property {WEBGL_lose_context} loseContext - WebGL v1 extension\n     * @property {OES_vertex_array_object} vertexArrayObject - WebGL v1 extension\n     * @property {EXT_texture_filter_anisotropic} anisotropicFiltering - WebGL v1 and v2 extension\n     */\n    public extensions: WebGLExtensions;\n\n    public webGLVersion: 1 | 2;\n\n    /**\n     * Whether to enable multi-view rendering. Set to true when rendering to multiple\n     * canvases on the dom.\n     * @default false\n     */\n    public multiView: boolean;\n\n    /**\n     * The canvas that the WebGL Context is rendering to.\n     * This will be the view canvas. But if multiView is enabled, this canvas will not be attached to the DOM.\n     * It will be rendered to and then copied to the target canvas.\n     * @readonly\n     */\n    public canvas: ICanvas;\n\n    private _renderer: WebGLRenderer;\n    private _contextLossForced: boolean;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this.extensions = Object.create(null);\n\n        // Bind functions\n        this.handleContextLost = this.handleContextLost.bind(this);\n        this.handleContextRestored = this.handleContextRestored.bind(this);\n    }\n\n    /**\n     * `true` if the context is lost\n     * @readonly\n     */\n    get isLost(): boolean\n    {\n        return (!this.gl || this.gl.isContextLost());\n    }\n\n    /**\n     * Handles the context change event.\n     * @param {WebGLRenderingContext} gl - New WebGL context.\n     */\n    protected contextChange(gl: WebGL2RenderingContext): void\n    {\n        this.gl = gl;\n        this._renderer.gl = gl;\n    }\n\n    public init(options: ContextSystemOptions): void\n    {\n        options = { ...GlContextSystem.defaultOptions, ...options };\n\n        // TODO add to options\n        let multiView = this.multiView = options.multiView;\n\n        if (options.context && multiView)\n        {\n            // eslint-disable-next-line max-len\n            warn('Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.');\n\n            multiView = false;\n        }\n\n        if (multiView)\n        {\n            this.canvas = DOMAdapter.get()\n                .createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);\n        }\n        else\n        {\n            this.canvas = this._renderer.view.canvas;\n        }\n        /*\n         * The options passed in to create a new WebGL context.\n         */\n        if (options.context)\n        {\n            this.initFromContext(options.context);\n        }\n        else\n        {\n            const alpha = this._renderer.background.alpha < 1;\n            const premultipliedAlpha = options.premultipliedAlpha ?? true;\n            const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;\n\n            this.createContext(options.preferWebGLVersion, {\n                alpha,\n                premultipliedAlpha,\n                antialias,\n                stencil: true,\n                preserveDrawingBuffer: options.preserveDrawingBuffer,\n                powerPreference: options.powerPreference ?? 'default',\n            });\n        }\n    }\n\n    public ensureCanvasSize(targetCanvas: ICanvas): void\n    {\n        if (!this.multiView)\n        {\n            if (targetCanvas !== this.canvas)\n            {\n                warn('multiView is disabled, but targetCanvas is not the main canvas');\n            }\n\n            return;\n        }\n\n        const { canvas } = this;\n\n        if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height)\n        {\n            canvas.width = Math.max(targetCanvas.width, targetCanvas.width);\n            canvas.height = Math.max(targetCanvas.height, targetCanvas.height);\n        }\n    }\n\n    /**\n     * Initializes the context.\n     * @protected\n     * @param {WebGLRenderingContext} gl - WebGL context\n     */\n    protected initFromContext(gl: WebGL2RenderingContext): void\n    {\n        this.gl = gl;\n\n        this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;\n\n        this.getExtensions();\n\n        this.validateContext(gl);\n\n        this._renderer.runners.contextChange.emit(gl);\n\n        const element = this._renderer.view.canvas;\n\n        (element as any).addEventListener('webglcontextlost', this.handleContextLost, false);\n        element.addEventListener('webglcontextrestored', this.handleContextRestored, false);\n    }\n\n    /**\n     * Initialize from context options\n     * @protected\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n     * @param preferWebGLVersion\n     * @param {object} options - context attributes\n     */\n    protected createContext(preferWebGLVersion: 1 | 2, options: WebGLContextAttributes): void\n    {\n        let gl: WebGL2RenderingContext | WebGLRenderingContext;\n\n        const canvas = this.canvas;\n\n        if (preferWebGLVersion === 2)\n        {\n            gl = canvas.getContext('webgl2', options);\n        }\n\n        if (!gl)\n        {\n            gl = canvas.getContext('webgl', options);\n\n            if (!gl)\n            {\n                // fail, not able to get a context\n                throw new Error('This browser does not support WebGL. Try using the canvas renderer');\n            }\n        }\n\n        this.gl = gl as WebGL2RenderingContext;\n\n        this.initFromContext(this.gl);\n    }\n\n    /** Auto-populate the {@link GlContextSystem.extensions extensions}. */\n    protected getExtensions(): void\n    {\n        // time to set up default extensions that Pixi uses.\n        const { gl } = this;\n\n        const common = {\n            anisotropicFiltering: gl.getExtension('EXT_texture_filter_anisotropic'),\n            floatTextureLinear: gl.getExtension('OES_texture_float_linear'),\n\n            s3tc: gl.getExtension('WEBGL_compressed_texture_s3tc'),\n            s3tc_sRGB: gl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), // eslint-disable-line camelcase\n            etc: gl.getExtension('WEBGL_compressed_texture_etc'),\n            etc1: gl.getExtension('WEBGL_compressed_texture_etc1'),\n            pvrtc: gl.getExtension('WEBGL_compressed_texture_pvrtc')\n                || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n            atc: gl.getExtension('WEBGL_compressed_texture_atc'),\n            astc: gl.getExtension('WEBGL_compressed_texture_astc'),\n            bptc: gl.getExtension('EXT_texture_compression_bptc'),\n            rgtc: gl.getExtension('EXT_texture_compression_rgtc'),\n            loseContext: gl.getExtension('WEBGL_lose_context'),\n        };\n\n        if (this.webGLVersion === 1)\n        {\n            this.extensions = {\n                ...common,\n\n                drawBuffers: gl.getExtension('WEBGL_draw_buffers'),\n                depthTexture: gl.getExtension('WEBGL_depth_texture'),\n                vertexArrayObject: gl.getExtension('OES_vertex_array_object')\n                    || gl.getExtension('MOZ_OES_vertex_array_object')\n                    || gl.getExtension('WEBKIT_OES_vertex_array_object'),\n                uint32ElementIndex: gl.getExtension('OES_element_index_uint'),\n                // Floats and half-floats\n                floatTexture: gl.getExtension('OES_texture_float'),\n                floatTextureLinear: gl.getExtension('OES_texture_float_linear'),\n                textureHalfFloat: gl.getExtension('OES_texture_half_float'),\n                textureHalfFloatLinear: gl.getExtension('OES_texture_half_float_linear'),\n                vertexAttribDivisorANGLE: gl.getExtension('ANGLE_instanced_arrays'),\n                srgb: gl.getExtension('EXT_sRGB'),\n            };\n        }\n        else\n        {\n            this.extensions = {\n                ...common,\n                colorBufferFloat: gl.getExtension('EXT_color_buffer_float'),\n            };\n\n            const provokeExt = gl.getExtension('WEBGL_provoking_vertex');\n\n            if (provokeExt)\n            {\n                provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);\n            }\n        }\n    }\n\n    /**\n     * Handles a lost webgl context\n     * @param {WebGLContextEvent} event - The context lost event.\n     */\n    protected handleContextLost(event: WebGLContextEvent): void\n    {\n        event.preventDefault();\n\n        // only restore if we purposefully nuked it\n        if (this._contextLossForced)\n        {\n            this._contextLossForced = false;\n            // Restore the context after this event has exited\n            setTimeout(() =>\n            {\n                if (this.gl.isContextLost())\n                {\n                    this.extensions.loseContext?.restoreContext();\n                }\n            }, 0);\n        }\n    }\n\n    /** Handles a restored webgl context. */\n    protected handleContextRestored(): void\n    {\n        this.getExtensions(); // restore extensions state\n        this._renderer.runners.contextChange.emit(this.gl);\n    }\n\n    public destroy(): void\n    {\n        const element = this._renderer.view.canvas;\n\n        this._renderer = null;\n\n        // remove listeners\n        (element as any).removeEventListener('webglcontextlost', this.handleContextLost);\n        element.removeEventListener('webglcontextrestored', this.handleContextRestored);\n\n        this.gl.useProgram(null);\n\n        this.extensions.loseContext?.loseContext();\n    }\n\n    /**\n     * this function can be called to force a webGL context loss\n     * this will release all resources on the GPU.\n     * Useful if you need to put Pixi to sleep, and save some GPU memory\n     *\n     * As soon as render is called - all resources will be created again.\n     */\n    public forceContextLoss(): void\n    {\n        this.extensions.loseContext?.loseContext();\n        this._contextLossForced = true;\n    }\n    /**\n     * Validate context.\n     * @param {WebGLRenderingContext} gl - Render context.\n     */\n    protected validateContext(gl: WebGL2RenderingContext): void\n    {\n        const attributes = gl.getContextAttributes();\n\n        // this is going to be fairly simple for now.. but at least we have room to grow!\n        if (attributes && !attributes.stencil)\n        {\n            // #if _DEBUG\n            warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');\n            // #endif\n        }\n\n        // support\n        const supports = this.supports;\n\n        const isWebGl2 = this.webGLVersion === 2;\n        const extensions = this.extensions;\n\n        supports.uint32Indices = isWebGl2 || !!extensions.uint32ElementIndex;\n        supports.uniformBufferObject = isWebGl2;\n        supports.vertexArrayObject = isWebGl2 || !!extensions.vertexArrayObject;\n        supports.srgbTextures = isWebGl2 || !!extensions.srgb;\n        supports.nonPowOf2wrapping = isWebGl2;\n        supports.nonPowOf2mipmaps = isWebGl2;\n        supports.msaa = isWebGl2;\n\n        if (!supports.uint32Indices)\n        {\n            // #if _DEBUG\n            warn('Provided WebGL context does not support 32 index buffer, large scenes may not render correctly');\n            // #endif\n        }\n    }\n}\n"],"names":["GL_FORMATS","BUFFER_TYPE","GL_TARGETS","GL_WRAP_MODES","GL_TYPES","renderTarget","source"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49]}
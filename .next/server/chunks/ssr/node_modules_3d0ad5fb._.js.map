{"version":3,"sources":["../../../../node_modules/pixi.js/src/utils/browser/detectVideoAlphaMode.ts","../../../../node_modules/pixi.js/src/rendering/mask/color/ColorMask.ts","../../../../node_modules/pixi.js/src/rendering/mask/utils/addMaskBounds.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/ImageSource.ts","../../../../node_modules/pixi.js/src/rendering/mask/utils/addMaskLocalBounds.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/VideoSource.ts","../../../../node_modules/pixi.js/src/rendering/mask/alpha/AlphaMask.ts","../../../../node_modules/pixi.js/src/rendering/mask/stencil/StencilMask.ts","../../../../node_modules/pixi.js/src/assets/utils/convertToList.ts","../../../../node_modules/pixi.js/src/assets/cache/Cache.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/textureFrom.ts","../../../../node_modules/pixi.js/src/rendering/init.ts","../../../../node_modules/pixi.js/src/assets/loader/parsers/LoaderParser.ts","../../../../node_modules/pixi.js/src/utils/path.ts","../../../../node_modules/pixi.js/src/assets/utils/copySearchParams.ts","../../../../node_modules/pixi.js/src/assets/utils/createStringVariations.ts","../../../../node_modules/pixi.js/src/assets/utils/isSingleItem.ts","../../../../node_modules/pixi.js/src/spritesheet/init.ts","../../../../node_modules/pixi.js/src/spritesheet/Spritesheet.ts","../../../../node_modules/pixi.js/src/assets/resolver/Resolver.ts","../../../../node_modules/pixi.js/src/spritesheet/spritesheetAsset.ts","../../../../node_modules/parse-svg-path/index.js","../../../../node_modules/pixi.js/src/maths/misc/squaredDistanceToLineSegment.ts","../../../../node_modules/pixi.js/src/maths/shapes/RoundedRectangle.ts","../../../../node_modules/pixi.js/src/maths/shapes/Ellipse.ts","../../../../node_modules/pixi.js/src/maths/shapes/Circle.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/svg/parseSVGPath.ts","../../../../node_modules/pixi.js/src/maths/shapes/Polygon.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/const.ts","../../../../node_modules/earcut/src/earcut.js","../../../../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/buildUvs.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/utils/getOrientationOfPoints.ts","../../../../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/transformVertices.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildTriangle.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/utils/triangulateWithHoles.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildCircle.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildRectangle.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildPixelLine.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildPolygon.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/BatchableGraphics.ts","../../../../node_modules/pixi.js/src/utils/utils.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildLine.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/utils/generateTextureFillMatrix.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/GraphicsContextSystem.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/fill/FillGradient.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/utils/buildContextBatches.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/svg/utils/fillOperations.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArc.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/path/roundShape.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/svg/utils/extractSvgUrlId.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/svg/parseSVGFloatAttribute.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/svg/utils/pathOperations.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcToSvg.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveBezier.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcTo.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/svg/parseSVGStyle.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/path/GraphicsPath.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/svg/parseSVGDefinitions.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/svg/SVGParser.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/path/ShapePath.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/fill/FillPattern.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/utils/convertFillInputToFillStyle.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/GraphicsContext.ts","../../../../node_modules/pixi.js/src/scene/graphics/shared/Graphics.ts","../../../../node_modules/tiny-lru/dist/tiny-lru.js","../../../../node_modules/pixi.js/src/scene/text/canvas/utils/fontStringFromTextStyle.ts","../../../../node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts","../../../../node_modules/pixi.js/src/scene/text/canvas/CanvasTextMetrics.ts","../../../../node_modules/pixi.js/src/scene/text/canvas/utils/getCanvasFillStyle.ts","../../../../node_modules/pixi.js/src/scene/text/canvas/CanvasTextGenerator.ts","../../../../node_modules/pixi.js/src/scene/text/TextStyle.ts"],"sourcesContent":["/* eslint-disable no-restricted-globals */\nimport { DOMAdapter } from '../../environment/adapter';\n\nimport type { ALPHA_MODES } from '../../rendering/renderers/shared/texture/const';\n\nlet promise: Promise<ALPHA_MODES> | undefined;\n\n/**\n * Helper for detecting the correct alpha mode for video textures.\n * For some reason, some browsers/devices/WebGL implementations premultiply the alpha\n * of a video before and then a second time if `UNPACK_PREMULTIPLY_ALPHA_WEBGL`\n * is true. So the video is premultiplied twice if the alpha mode is `UNPACK`.\n * In this case we need the alpha mode to be `PMA`. This function detects\n * the upload behavior by uploading a white 2x2 webm with 50% alpha\n * without `UNPACK_PREMULTIPLY_ALPHA_WEBGL` and then checking whether\n * the uploaded pixels are premultiplied.\n * @category utils\n * @internal\n * @returns {Promise<ALPHA_MODES>} The correct alpha mode for video textures.\n */\nexport async function detectVideoAlphaMode(): Promise<ALPHA_MODES>\n{\n    promise ??= (async () =>\n    {\n        const canvas = DOMAdapter.get().createCanvas(1, 1);\n        const gl = canvas.getContext('webgl');\n\n        if (!gl)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const video = await new Promise<HTMLVideoElement | null>((resolve) =>\n        {\n            const video = document.createElement('video');\n\n            video.onloadeddata = () => resolve(video);\n            video.onerror = () => resolve(null);\n            video.autoplay = false;\n            video.crossOrigin = 'anonymous';\n            video.preload = 'auto';\n            // eslint-disable-next-line max-len\n            video.src = 'data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=';\n            video.load();\n        });\n\n        if (!video)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const texture = gl.createTexture();\n\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        const framebuffer = gl.createFramebuffer();\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.COLOR_ATTACHMENT0,\n            gl.TEXTURE_2D,\n            texture,\n            0\n        );\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n\n        const pixel = new Uint8Array(4);\n\n        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n\n        gl.deleteFramebuffer(framebuffer);\n        gl.deleteTexture(texture);\n        gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n        return pixel[0] <= pixel[3] ? 'premultiplied-alpha' : 'premultiply-alpha-on-upload';\n    })();\n\n    return promise;\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * The ColorMask effect allows you to apply a color mask to the rendering process.\n * This can be useful for selectively rendering certain colors or for creating\n * effects based on color values.\n * @category rendering\n * @advanced\n */\nexport class ColorMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: number;\n    public pipe = 'colorMask';\n\n    constructor(options: {mask: number})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: number): void\n    {\n        this.mask = mask;\n    }\n\n    public destroy(): void\n    {\n        // nothing to destroy\n    }\n\n    public static test(mask: any): boolean\n    {\n        return typeof mask === 'number';\n    }\n}\n","import { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\n\nimport type { Container } from '../../../scene/container/Container';\n\nconst tempBounds = new Bounds();\n\n/**\n * @param mask\n * @param bounds\n * @param skipUpdateTransform\n * @internal\n */\nexport function addMaskBounds(mask: Container, bounds: Bounds, skipUpdateTransform: boolean): void\n{\n    const boundsToMask = tempBounds;\n\n    mask.measurable = true;\n\n    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n\n    bounds.addBoundsMask(boundsToMask);\n\n    mask.measurable = false;\n}\n\n","import { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * The type of image-like resource that can be used as a texture source.\n *\n * - `ImageBitmap` is used for bitmap images.\n * - `HTMLCanvasElement` and `OffscreenCanvas` are used for canvas elements.\n * - `ICanvas` is an interface for canvas-like objects.\n * - `VideoFrame` is used for video frames.\n * - `HTMLImageElement` is used for HTML image elements.\n * - `HTMLVideoElement` is used for HTML video elements.\n * @category rendering\n * @advanced\n */\nexport type ImageResource =\nImageBitmap\n| HTMLCanvasElement\n| OffscreenCanvas\n| ICanvas\n| VideoFrame\n| HTMLImageElement\n| HTMLVideoElement;\n\n/**\n * A texture source that uses an image-like resource as its resource.\n * It can handle HTMLImageElement, ImageBitmap, VideoFrame, and HTMLVideoElement.\n * It is used for textures that can be uploaded to the GPU.\n * @category rendering\n * @advanced\n */\nexport class ImageSource extends TextureSource<ImageResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n    public uploadMethodId = 'image';\n\n    constructor(options: TextureSourceOptions<ImageResource>)\n    {\n        super(options);\n\n        this.autoGarbageCollect = true;\n    }\n\n    public static test(resource: any): resource is ImageResource\n    {\n        return (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        || (typeof ImageBitmap !== 'undefined' && resource instanceof ImageBitmap)\n        || (globalThis.VideoFrame && resource instanceof VideoFrame);\n    }\n}\n","import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\n\n/**\n * @param mask\n * @param bounds\n * @param localRoot\n * @internal\n */\nexport function addMaskLocalBounds(mask: Container, bounds: Bounds, localRoot: Container): void\n{\n    const boundsToMask = boundsPool.get();\n\n    mask.measurable = true;\n\n    const tempMatrix = matrixPool.get().identity();\n\n    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n\n    getLocalBounds(mask, boundsToMask, relativeMask);\n\n    mask.measurable = false;\n\n    bounds.addBoundsMask(boundsToMask);\n\n    matrixPool.return(tempMatrix);\n    boundsPool.return(boundsToMask);\n}\n\nfunction getMatrixRelativeToParent(target: Container, root: Container, matrix: Matrix): Matrix\n{\n    if (!target)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Mask bounds, renderable is not inside the root container');\n        // #endif\n\n        return matrix;\n    }\n\n    if (target !== root)\n    {\n        getMatrixRelativeToParent(target.parent, root, matrix);\n\n        target.updateLocalTransform();\n\n        matrix.append(target.localTransform);\n    }\n\n    return matrix;\n}\n","// VideoSource.ts\n\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { Ticker } from '../../../../../ticker/Ticker';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { Dict } from '../../../../../utils/types';\nimport type { ALPHA_MODES } from '../const';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * The type of resource used for video textures.\n * This is typically an HTMLVideoElement.\n * @category rendering\n * @advanced\n */\nexport type VideoResource = HTMLVideoElement;\n\n/**\n * Options for video sources.\n * @category rendering\n * @advanced\n */\nexport interface VideoSourceOptions extends TextureSourceOptions<VideoResource>\n{\n    /** If true, the video will start loading immediately. */\n    autoLoad?: boolean;\n    /** If true, the video will start playing as soon as it is loaded. */\n    autoPlay?: boolean;\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n    updateFPS?: number;\n    /** If true, the video will be loaded with the `crossorigin` attribute. */\n    crossorigin?: boolean | string;\n    /** If true, the video will loop when it ends. */\n    loop?: boolean;\n    /** If true, the video will be muted. */\n    muted?: boolean;\n    /** If true, the video will play inline. */\n    playsinline?: boolean;\n    /** If true, the video will be preloaded. */\n    preload?: boolean;\n    /** The time in milliseconds to wait for the video to preload before timing out. */\n    preloadTimeoutMs?: number;\n    /** The alpha mode of the video. */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * A texture source that uses a video as its resource.\n * It automatically resizes the texture based on the video dimensions.\n * It also provides methods to control playback and handle video events.\n * This class supports automatic loading, playback, and frame updates.\n * It can also handle cross-origin videos and provides options for looping, muting, and inline playback.\n * @category rendering\n * @advanced\n */\nexport class VideoSource extends TextureSource<VideoResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    /** The default options for video sources. */\n    public static defaultOptions: VideoSourceOptions = {\n        ...TextureSource.defaultOptions,\n        /** If true, the video will start loading immediately. */\n        autoLoad: true,\n        /** If true, the video will start playing as soon as it is loaded. */\n        autoPlay: true,\n        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n        updateFPS: 0,\n        /** If true, the video will be loaded with the `crossorigin` attribute. */\n        crossorigin: true,\n        /** If true, the video will loop when it ends. */\n        loop: false,\n        /** If true, the video will be muted. */\n        muted: true,\n        /** If true, the video will play inline. */\n        playsinline: true,\n        /** If true, the video will be preloaded. */\n        preload: false,\n    };\n\n    // Public\n    /** Whether or not the video is ready to play. */\n    public isReady = false;\n    /** The upload method for this texture. */\n    public uploadMethodId = 'video';\n\n    // Protected\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     * @default true\n     */\n    protected autoPlay: boolean;\n\n    // Private\n    /**\n     * `true` to use Ticker.shared to auto update the base texture.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update the base texture.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    private _msToNextUpdate: number;\n    private _preloadTimeout: number;\n\n    /** Callback when completed with load. */\n    private _resolve: (value?: this | PromiseLike<this>) => void;\n    private _reject: (error: ErrorEvent) => void;\n\n    private _updateFPS: number;\n    private _videoFrameRequestCallbackHandle: number | null;\n\n    constructor(\n        options: VideoSourceOptions\n    )\n    {\n        super(options);\n\n        // Merge provided options with default ones\n        options = {\n            ...VideoSource.defaultOptions,\n            ...options\n        };\n\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? 'premultiply-alpha-on-upload';\n\n        // Binding for frame updates\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n\n        // Bind for listeners\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n\n        if (options.autoLoad !== false)\n        {\n            void this.load();\n        }\n    }\n\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */\n    protected updateFrame(): void\n    {\n        if (this.destroyed)\n        {\n            return;\n        }\n\n        if (this._updateFPS)\n        {\n            // Account for if video has had its playbackRate changed\n            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n\n        if (!this._updateFPS || this._msToNextUpdate <= 0)\n        {\n            this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;\n        }\n\n        if (this.isValid)\n        {\n            this.update();\n        }\n    }\n\n    /** Callback to update the video frame and potentially request the next frame update. */\n    private _videoFrameRequestCallback(): void\n    {\n        this.updateFrame();\n\n        if (this.destroyed)\n        {\n            this._videoFrameRequestCallbackHandle = null;\n        }\n        else\n        {\n            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                this._videoFrameRequestCallback\n            );\n        }\n    }\n\n    /**\n     * Checks if the resource has valid dimensions.\n     * @returns {boolean} True if width and height are set, otherwise false.\n     */\n    public get isValid(): boolean\n    {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n\n    /**\n     * Start preloading the video resource.\n     * @returns {Promise<this>} Handle the validate event\n     */\n    public async load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const source = this.resource;\n        const options = this.options as VideoSourceOptions;\n\n        // Check if source data is enough and set it to complete if needed\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            (source as any).complete = true;\n        }\n\n        // Add event listeners related to playback and seeking\n        source.addEventListener('play', this._onPlayStart);\n        source.addEventListener('pause', this._onPlayStop);\n        source.addEventListener('seeked', this._onSeeked);\n\n        // Add or handle source readiness event listeners\n        if (!this._isSourceReady())\n        {\n            if (!options.preload)\n            {\n                // since this event fires early, only bind if not waiting for a preload event\n                source.addEventListener('canplay', this._onCanPlay);\n            }\n            source.addEventListener('canplaythrough', this._onCanPlayThrough);\n            source.addEventListener('error', this._onError, true);\n        }\n        else\n        {\n            // Source is already ready, so handle it immediately\n            this._mediaReady();\n        }\n\n        this.alphaMode = await detectVideoAlphaMode();\n\n        // Create and return the loading promise\n        this._load = new Promise((resolve, reject): void =>\n        {\n            if (this.isValid)\n            {\n                resolve(this);\n            }\n            else\n            {\n                this._resolve = resolve;\n                this._reject = reject;\n\n                if (options.preloadTimeoutMs !== undefined)\n                {\n                    this._preloadTimeout = setTimeout(() =>\n                    {\n                        this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                    }) as unknown as number;\n                }\n                source.load();\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Handle video error events.\n     * @param event - The error event\n     */\n    private _onError(event: ErrorEvent): void\n    {\n        this.resource.removeEventListener('error', this._onError, true);\n        this.emit('error', event);\n\n        if (this._reject)\n        {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n\n    /**\n     * Checks if the underlying source is playing.\n     * @returns True if playing.\n     */\n    private _isSourcePlaying(): boolean\n    {\n        const source = this.resource;\n\n        return (!source.paused && !source.ended);\n    }\n\n    /**\n     * Checks if the underlying source is ready for playing.\n     * @returns True if ready.\n     */\n    private _isSourceReady(): boolean\n    {\n        const source = this.resource;\n\n        return source.readyState > 2;\n    }\n\n    /** Runs the update loop when the video is ready to play. */\n    private _onPlayStart(): void\n    {\n        // Handle edge case where video might not have received its \"can play\" event yet\n        if (!this.isValid)\n        {\n            this._mediaReady();\n        }\n\n        this._configureAutoUpdate();\n    }\n\n    /** Stops the update loop when a pause event is triggered. */\n    private _onPlayStop(): void\n    {\n        this._configureAutoUpdate();\n    }\n\n    /** Handles behavior when the video completes seeking to the current playback position. */\n    private _onSeeked(): void\n    {\n        if (this._autoUpdate && !this._isSourcePlaying())\n        {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n\n    private _onCanPlay(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplay', this._onCanPlay);\n\n        this._mediaReady();\n    }\n\n    private _onCanPlayThrough(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        if (this._preloadTimeout)\n        {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = undefined;\n        }\n\n        this._mediaReady();\n    }\n\n    /** Fired when the video is loaded and ready to play. */\n    private _mediaReady(): void\n    {\n        const source = this.resource;\n\n        if (this.isValid)\n        {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n\n        // Reset update timers and perform a frame update\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n\n        // Resolve the loading promise if it exists\n        if (this._resolve)\n        {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n\n        // Handle play behavior based on current source status\n        if (this._isSourcePlaying())\n        {\n            this._onPlayStart();\n        }\n        else if (this.autoPlay)\n        {\n            void this.resource.play();\n        }\n    }\n\n    /** Cleans up resources and event listeners associated with this texture. */\n    public destroy()\n    {\n        this._configureAutoUpdate();\n\n        const source = this.resource;\n\n        if (source)\n        {\n            // Remove event listeners\n            source.removeEventListener('play', this._onPlayStart);\n            source.removeEventListener('pause', this._onPlayStop);\n            source.removeEventListener('seeked', this._onSeeked);\n            source.removeEventListener('canplay', this._onCanPlay);\n            source.removeEventListener('canplaythrough', this._onCanPlayThrough);\n            source.removeEventListener('error', this._onError, true);\n\n            // Clear the video source and pause\n            source.pause();\n            source.src = '';\n            source.load();\n        }\n\n        super.destroy();\n    }\n\n    /** Should the base texture automatically update itself, set to true by default. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * How many times a second to update the texture from the video.\n     * Leave at 0 to update at every render.\n     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n     */\n    get updateFPS(): number\n    {\n        return this._updateFPS;\n    }\n\n    set updateFPS(value: number)\n    {\n        if (value !== this._updateFPS)\n        {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * Configures the updating mechanism based on the current state and settings.\n     *\n     * This method decides between using the browser's native video frame callback or a custom ticker\n     * for updating the video frame. It ensures optimal performance and responsiveness\n     * based on the video's state, playback status, and the desired frames-per-second setting.\n     *\n     * - If `_autoUpdate` is enabled and the video source is playing:\n     *   - It will prefer the native video frame callback if available and no specific FPS is set.\n     *   - Otherwise, it will use a custom ticker for manual updates.\n     * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n     */\n    private _configureAutoUpdate(): void\n    {\n        // Check if automatic updating is enabled and if the source is currently playing\n        if (this._autoUpdate && this._isSourcePlaying())\n        {\n            // Determine if we should use the browser's native video frame callback (generally for better performance)\n            if (!this._updateFPS && this.resource.requestVideoFrameCallback)\n            {\n                // If connected to a custom ticker, remove the update frame function from it\n                if (this._isConnectedToTicker)\n                {\n                    Ticker.shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n\n                // Check if we haven't already requested a video frame callback, and if not, request one\n                if (this._videoFrameRequestCallbackHandle === null)\n                {\n                    this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                        this._videoFrameRequestCallback\n                    );\n                }\n            }\n            else\n            {\n                // If a video frame request callback exists, cancel it, as we are switching to manual ticker-based updates\n                if (this._videoFrameRequestCallbackHandle !== null)\n                {\n                    this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n\n                // If not connected to the custom ticker, add the update frame function to it\n                if (!this._isConnectedToTicker)\n                {\n                    Ticker.shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n            }\n        }\n        else\n        {\n            // If automatic updating is disabled or the source isn't playing, perform cleanup\n\n            // Cancel any existing video frame callback request\n            if (this._videoFrameRequestCallbackHandle !== null)\n            {\n                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n\n            // Remove the update frame function from the custom ticker\n            if (this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                // Reset the time until the next update\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n\n    /**\n     * Map of video MIME types that can't be directly derived from file extensions.\n     * @readonly\n     */\n    public static MIME_TYPES: Dict<string>\n        = {\n            ogv: 'video/ogg',\n            mov: 'video/quicktime',\n            m4v: 'video/mp4',\n        };\n\n    public static test(resource: any): resource is VideoResource\n    {\n        return (globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement);\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * AlphaMask is an effect that applies a mask to a container using the alpha channel of a sprite.\n * It can be used to create complex masking effects by using a sprite as the mask.\n * The mask can be inverted, and it can render the mask to a texture if the mask is not a sprite.\n * @category rendering\n * @advanced\n */\nexport class AlphaMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public inverse: boolean = false;\n    public pipe = 'alphaMask';\n    public renderMaskToTexture: boolean;\n\n    constructor(options?: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n\n        // TODO - might want to change this to adjust on the fly\n        // user may add children to the sprite..\n        this.renderMaskToTexture = !(mask instanceof Sprite);\n\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        if (this.mask === null) return;\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform?: boolean): void\n    {\n        if (!this.inverse)\n        {\n            addMaskBounds(this.mask, bounds, skipUpdateTransform);\n        }\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Sprite;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Container } from '../../../scene/container/Container';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * A mask that uses the stencil buffer to clip the rendering of a container.\n * This is useful for complex masks that cannot be achieved with simple shapes.\n * It is more performant than using a `Graphics` mask, but requires WebGL support.\n * It is also useful for masking with `Container` objects that have complex shapes.\n * @category rendering\n * @advanced\n */\nexport class StencilMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'stencilMask';\n\n    constructor(options: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n        this.mask.includeInBuild = false;\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        if (this.mask === null) return;\n        this.mask.measurable = true;\n        this.mask.includeInBuild = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Container;\n    }\n}\n","/**\n * @param input\n * @param transform\n * @param forceTransform\n * @internal\n */\nexport const convertToList = <T>(\n    input: string | T | (string | T)[],\n    transform?: (input: string) => T,\n    forceTransform = false\n): T[] =>\n{\n    if (!Array.isArray(input))\n    {\n        input = [input as T];\n    }\n\n    if (!transform)\n    {\n        return input as T[];\n    }\n\n    return (input as (string | T)[]).map((item): T =>\n    {\n        if (typeof item === 'string' || forceTransform)\n        {\n            return transform(item as string);\n        }\n\n        return item as T;\n    });\n};\n","import { warn } from '../../utils/logging/warn';\nimport { convertToList } from '../utils/convertToList';\n\nimport type { CacheParser } from './CacheParser';\n\n/** @internal */\nclass CacheClass\n{\n    private readonly _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<any, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: any): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: any): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set<T = any>(key: any | any[], value: T): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        // convert cacheable assets to a map of key-value pairs\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n\n        if (!cacheableAssets)\n        {\n            keys.forEach((key) =>\n            {\n                cacheableMap.set(key, value);\n            });\n        }\n\n        const cacheKeys = [...cacheableMap.keys()];\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets as any);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            const val = cacheableAssets ? cacheableAssets[key] : value;\n\n            if (this._cache.has(key) && this._cache.get(key) !== val)\n            {\n                // #if _DEBUG\n                warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableMap.get(key));\n        });\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: any): void\n    {\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /**\n     * All loader parsers registered\n     * @advanced\n     */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\n/**\n * A global cache for all assets in your PixiJS application. The cache system provides fast\n * access to loaded assets and prevents duplicate loading.\n *\n * Key Features:\n * - Automatic caching of loaded assets\n * - Support for custom cache parsers\n * - Automatic parsing of complex assets (e.g., spritesheets)\n * - Memory management utilities\n * > [!IMPORTANT] You typically do not need to use this class directly.\n * > Use the main {@link Assets} class for high-level asset management.\n * > `Assets.get(key)` will automatically use the cache.\n * @example\n * ```ts\n * import { Cache } from 'pixi.js';\n *\n * // Store an asset in the cache\n * Cache.set('myTexture', texture);\n *\n * // Retrieve an asset\n * const texture = Cache.get('myTexture');\n *\n * // Check if an asset exists\n * if (Cache.has('myTexture')) {\n *     // Use the cached asset\n *     const sprite = new Sprite(Cache.get('myTexture'));\n * }\n *\n * // Remove an asset from cache\n * Cache.remove('myTexture');\n *\n * // Clear all cached assets\n * Cache.reset();\n * ```\n * @remarks\n * The Cache is a core component of PixiJS' asset management system:\n * - Used internally by the {@link Assets} class\n * - Supports automatic parsing via {@link CacheParser}\n * - Handles complex asset types like spritesheets\n * - Manages memory through asset removal\n *\n * > [!IMPORTANT]\n * > This is a singleton class and should not be instantiated directly.\n * > Use the exported `Cache` instance instead.\n * @see {@link Assets} For high-level asset management\n * @see {@link CacheParser} For custom cache parsing\n * @category assets\n * @class\n * @advanced\n */\nexport const Cache = new CacheClass();\n","import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferImageSource';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer | ICanvas): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\n/**\n * The type of resource or options that can be used to create a texture source.\n * This includes ImageResource, TextureSourceOptions, BufferSourceOptions, and CanvasSourceOptions.\n * @category rendering\n * @advanced\n */\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions\n  | CanvasSourceOptions;\n\n/**\n * @param options\n * @deprecated since v8.2.0\n * @see TextureSource.from\n * @category rendering\n * @internal\n */\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    return textureSourceFrom(options);\n}\n\n/**\n * Creates a texture source from the options provided\n * @param options - The options to create the texture source from. This can be\n */\nfunction textureSourceFrom(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\n/**\n * @param options\n * @param skipCache\n * @internal\n */\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: textureSourceFrom(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n * @category utils\n * @internal\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\nTextureSource.from = textureSourceFrom;\n","import { extensions } from '../extensions/Extensions';\nimport { AlphaMask } from './mask/alpha/AlphaMask';\nimport { ColorMask } from './mask/color/ColorMask';\nimport { StencilMask } from './mask/stencil/StencilMask';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferImageSource';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource';\nimport './renderers/shared/texture/utils/textureFrom';\nimport './mask/MaskEffectManager';\n\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n\n","import type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { ResolvedAsset } from '../../types';\nimport type { Loader } from '../Loader';\n\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension test.\n * The higher priority parsers will be checked first.\n * @category assets\n * @advanced\n */\nexport enum LoaderParserPriority\n{\n    /** Generic parsers: txt, json, webfonts */\n    Low = 0,\n    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n    Normal = 1,\n    /** Specific texture types: svg, png, ktx, dds, basis */\n    High = 2,\n}\n\n/**\n * A more verbose version of the LoaderParser, allowing you to set the loaded, parsed, and unloaded asset separately\n * @category assets\n * @advanced\n */\nexport interface LoaderParserAdvanced<\n    ASSET = any,\n    PARSED_ASSET = ASSET,\n    UNLOAD_ASSET = ASSET,\n    META_DATA = any,\n    CONFIG = Record<string, any>\n>\n{\n    /** Should be ExtensionType.LoaderParser */\n    extension?: ExtensionMetadata;\n\n    /** A config to adjust the parser */\n    config?: CONFIG;\n\n    /**\n     * @deprecated Use `id` instead.\n     */\n    name?: string;\n    /** The name of the parser (this can be used when specifying parser in a ResolvedAsset) */\n    id: string;\n\n    /**\n     * Each URL to load will be tested here,\n     * if the test is passed the assets are loaded using the load function below.\n     * Good place to test for things like file extensions!\n     * @param url - The URL to test\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    test?: (url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => boolean;\n\n    /**\n     * This is the promise that loads the URL provided\n     * resolves with a loaded asset if returned by the parser.\n     * @param url - The URL to load\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    load?: <T>(url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<ASSET | T>;\n\n    /**\n     * This function is used to test if the parse function should be run on the asset\n     * If this returns true then parse is called with the asset\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    testParse?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\n    /**\n     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    parse?: <T>(asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<PARSED_ASSET | T>;\n\n    /**\n     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n     * @param asset - The asset to unload/destroy\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    unload?: (asset: UNLOAD_ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<void> | void;\n}\n\n/**\n * The interface to define a loader parser *(all functions are optional)*.\n *\n * When you create a `parser` object, the flow for every asset loaded is:\n *\n * 1. `parser.test()` - Each URL to load will be tested here, if the test is passed the assets are\n * loaded using the load function below. Good place to test for things like file extensions!\n * 2. `parser.load()` - This is the promise that loads the URL provided resolves with a loaded asset\n * if returned by the parser.\n * 3. `parser.testParse()` - This function is used to test if the parse function should be run on the\n *  asset If this returns true then parse is called with the asset\n * 4. `parse.parse()` - Gets called on the asset it testParse passes. Useful to convert a raw asset\n *  into something more useful\n *\n * <br/>\n * Some loaders may only be used for parsing, some only for loading, and some for both!\n * @category assets\n * @advanced\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface LoaderParser<ASSET = any, META_DATA = any, CONFIG = Record<string, any>>\n    extends LoaderParserAdvanced<ASSET, ASSET, ASSET, META_DATA, CONFIG> {}\n","import { DOMAdapter } from '../environment/adapter';\n\nfunction assertPath(path: string)\n{\n    if (typeof path !== 'string')\n    {\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\n    }\n}\n\nfunction removeUrlParams(url: string): string\n{\n    const re = url.split('?')[0];\n\n    return re.split('#')[0];\n}\n\nfunction escapeRegExp(string: string)\n{\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction replaceAll(str: string, find: string, replace: string)\n{\n    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean)\n{\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n\n    for (let i = 0; i <= path.length; ++i)\n    {\n        if (i < path.length)\n        {\n            code = path.charCodeAt(i);\n        }\n        else if (code === 47)\n        {\n            break;\n        }\n        else\n        {\n            code = 47;\n        }\n        if (code === 47)\n        {\n            if (lastSlash === i - 1 || dots === 1)\n            {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2)\n            {\n                if (\n                    res.length < 2\n                    || lastSegmentLength !== 2\n                    || res.charCodeAt(res.length - 1) !== 46\n                    || res.charCodeAt(res.length - 2) !== 46\n                )\n                {\n                    if (res.length > 2)\n                    {\n                        const lastSlashIndex = res.lastIndexOf('/');\n\n                        if (lastSlashIndex !== res.length - 1)\n                        {\n                            if (lastSlashIndex === -1)\n                            {\n                                res = '';\n                                lastSegmentLength = 0;\n                            }\n                            else\n                            {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1)\n                    {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot)\n                {\n                    if (res.length > 0)\n                    { res += '/..'; }\n                    else\n                    { res = '..'; }\n                    lastSegmentLength = 2;\n                }\n            }\n            else\n            {\n                if (res.length > 0)\n                {\n                    res += `/${path.slice(lastSlash + 1, i)}`;\n                }\n                else\n                {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === 46 && dots !== -1)\n        {\n            ++dots;\n        }\n        else\n        {\n            dots = -1;\n        }\n    }\n\n    return res;\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @category utils\n * @advanced\n */\nexport interface Path\n{\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix: (path: string) => string;\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl: (path: string) => boolean;\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol: (path: string) => boolean;\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol: (path: string) => string;\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param baseUrl - The base URL to use\n     * @param rootUrl - The root URL to use\n     */\n    toAbsolute: (url: string, baseUrl?: string, rootUrl?: string) => string;\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize: (path: string) => string;\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute: (path: string) => boolean;\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param paths - The segments of the path to join\n     */\n    join: (...paths: string[]) => string;\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname: (path: string) => string;\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname: (path: string) => string;\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename: (path: string, ext?: string) => string;\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname: (path: string) => string;\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse: (path: string) => { root?: string, dir?: string, base?: string, ext?: string, name?: string };\n    sep: string,\n    delimiter: string,\n    joinExtensions: string[],\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * @example\n * ```ts\n * import { path } from 'pixi.js';\n *\n * // Basic path normalization\n * path.normalize('http://www.example.com/foo/bar/../baz');\n * // -> 'http://www.example.com/foo/baz'\n *\n * // Working with file paths\n * path.join('assets', 'images', 'sprite.png');\n * // -> 'assets/images/sprite.png'\n *\n * // URL handling\n * path.toAbsolute('images/texture.png', 'http://example.com/assets/');\n * // -> 'http://example.com/assets/images/texture.png'\n * ```\n * @remarks\n * - Normalizes to POSIX separators (forward slashes)\n * - Handles URLs, data URLs, and file paths\n * - Supports path composition and decomposition\n * - Common in asset loading and URL management\n * @category utils\n * @standard\n * @see {@link Path} For full API reference\n * @see {@link DOMAdapter} For platform-specific path handling\n */\nexport const path: Path = {\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     * @example\n     * ```ts\n     * // Convert a Windows path to POSIX format\n     * path.toPosix('C:\\\\Users\\\\User\\\\Documents\\\\file.txt');\n     * // -> 'C:/Users/User/Documents/file.txt'\n     * ```\n     */\n    toPosix(path: string) { return replaceAll(path, '\\\\', '/'); },\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a URL\n     * path.isUrl('http://www.example.com');\n     * // -> true\n     * path.isUrl('C:/Users/User/Documents/file.txt');\n     * // -> false\n     * ```\n     */\n    isUrl(path: string) { return (/^https?:/).test(this.toPosix(path)); },\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a data URL\n     * path.isDataUrl('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...');\n     * // -> true\n     * ```\n     */\n    isDataUrl(path: string)\n    {\n        // eslint-disable-next-line max-len\n        return (/^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i)\n            .test(path);\n    },\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a blob URL\n     * path.isBlobUrl('blob:http://www.example.com/12345678-1234-1234-1234-123456789012');\n     * // -> true\n     * ```\n     */\n    isBlobUrl(path: string)\n    {\n        // Not necessary to have an exact regex to match the blob URLs\n        return path.startsWith('blob:');\n    },\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path has a protocol\n     * path.hasProtocol('http://www.example.com');\n     * // -> true\n     * path.hasProtocol('C:/Users/User/Documents/file.txt');\n     * // -> true\n     * ```\n     */\n    hasProtocol(path: string) { return (/^[^/:]+:/).test(this.toPosix(path)); },\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     * @example\n     * ```ts\n     * // Get the protocol from a URL\n     * path.getProtocol('http://www.example.com/path/to/resource');\n     * // -> 'http://'\n     * // Get the protocol from a file path\n     * path.getProtocol('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/'\n     * ```\n     */\n    getProtocol(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        const matchFile = (/^file:\\/\\/\\//).exec(path);\n\n        if (matchFile)\n        {\n            return matchFile[0];\n        }\n\n        const matchProtocol = (/^[^/:]+:\\/{0,2}/).exec(path);\n\n        if (matchProtocol)\n        {\n            return matchProtocol[0];\n        }\n\n        return '';\n    },\n\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     * @example\n     * ```ts\n     * // Convert a relative URL to an absolute path\n     * path.toAbsolute('images/texture.png', 'http://example.com/assets/');\n     * // -> 'http://example.com/assets/images/texture.png'\n     * ```\n     */\n    toAbsolute(url: string, customBaseUrl?: string, customRootUrl?: string)\n    {\n        assertPath(url);\n\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n\n        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n\n        url = this.toPosix(url);\n\n        // root relative url\n        if (url.startsWith('/'))\n        {\n            return path.join(rootUrl, url.slice(1));\n        }\n\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n\n        return absolutePath;\n    },\n\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     * @example\n     * ```ts\n     * // Normalize a path with relative segments\n     * path.normalize('http://www.example.com/foo/bar/../baz');\n     * // -> 'http://www.example.com/foo/baz'\n     * // Normalize a file path with relative segments\n     * path.normalize('C:\\\\Users\\\\User\\\\Documents\\\\..\\\\file.txt');\n     * // -> 'C:/Users/User/file.txt'\n     * ```\n     */\n    normalize(path: string)\n    {\n        assertPath(path);\n\n        if (path.length === 0) return '.';\n        if (this.isDataUrl(path) || this.isBlobUrl(path)) return path;\n\n        path = this.toPosix(path);\n\n        let protocol = '';\n        const isAbsolute = path.startsWith('/');\n\n        if (this.hasProtocol(path))\n        {\n            protocol = this.rootname(path);\n            path = path.slice(protocol.length);\n        }\n\n        const trailingSeparator = path.endsWith('/');\n\n        // Normalize the path\n        path = normalizeStringPosix(path, false);\n\n        if (path.length > 0 && trailingSeparator) path += '/';\n        if (isAbsolute) return `/${path}`;\n\n        return protocol + path;\n    },\n\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     * @example\n     * ```ts\n     * // Check if a path is absolute\n     * path.isAbsolute('http://www.example.com/foo/bar');\n     * // -> true\n     * path.isAbsolute('C:/Users/User/Documents/file.txt');\n     * // -> true\n     * ```\n     */\n    isAbsolute(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        if (this.hasProtocol(path)) return true;\n\n        return path.startsWith('/');\n    },\n\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     * @example\n     * ```ts\n     * // Join multiple path segments\n     * path.join('assets', 'images', 'sprite.png');\n     * // -> 'assets/images/sprite.png'\n     * // Join with relative segments\n     * path.join('assets', 'images', '../textures', 'sprite.png');\n     * // -> 'assets/textures/sprite.png'\n     * ```\n     */\n    join(...segments: string[])\n    {\n        if (segments.length === 0)\n        { return '.'; }\n        let joined;\n\n        for (let i = 0; i < segments.length; ++i)\n        {\n            const arg = segments[i];\n\n            assertPath(arg);\n            if (arg.length > 0)\n            {\n                if (joined === undefined) joined = arg;\n                else\n                {\n                    const prevArg = segments[i - 1] ?? '';\n\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase()))\n                    {\n                        joined += `/../${arg}`;\n                    }\n                    else\n                    {\n                        joined += `/${arg}`;\n                    }\n                }\n            }\n        }\n        if (joined === undefined) { return '.'; }\n\n        return this.normalize(joined);\n    },\n\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the directory name of a path\n     * path.dirname('http://www.example.com/foo/bar/baz.png');\n     * // -> 'http://www.example.com/foo/bar'\n     * // Get the directory name of a file path\n     * path.dirname('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/Users/User/Documents'\n     * ```\n     */\n    dirname(path: string)\n    {\n        assertPath(path);\n        if (path.length === 0) return '.';\n        path = this.toPosix(path);\n        let code = path.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n\n        const proto = this.getProtocol(path);\n        const origpath = path;\n\n        path = path.slice(proto.length);\n\n        for (let i = path.length - 1; i >= 1; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                if (!matchedSlash)\n                {\n                    end = i;\n                    break;\n                }\n            }\n            else\n            {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n\n        // if end is -1 and its a url then we need to add the path back\n        // eslint-disable-next-line no-nested-ternary\n        if (end === -1) return hasRoot ? '/' : this.isUrl(origpath) ? proto + path : proto;\n        if (hasRoot && end === 1) return '//';\n\n        return proto + path.slice(0, end);\n    },\n\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the root of a URL\n     * path.rootname('http://www.example.com/foo/bar/baz.png');\n     * // -> 'http://www.example.com/'\n     * // Get the root of a file path\n     * path.rootname('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/'\n     * ```\n     */\n    rootname(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let root = '';\n\n        if (path.startsWith('/')) root = '/';\n        else\n        {\n            root = this.getProtocol(path);\n        }\n\n        if (this.isUrl(path))\n        {\n            // need to find the first path separator\n            const index = path.indexOf('/', root.length);\n\n            if (index !== -1)\n            {\n                root = path.slice(0, index);\n            }\n            else root = path;\n\n            if (!root.endsWith('/')) root += '/';\n        }\n\n        return root;\n    },\n\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     * @example\n     * ```ts\n     * // Get the basename of a URL\n     * path.basename('http://www.example.com/foo/bar/baz.png');\n     * // -> 'baz.png'\n     * // Get the basename of a file path\n     * path.basename('C:/Users/User/Documents/file.txt');\n     * // -> 'file.txt'\n     * ```\n     */\n    basename(path: string, ext?: string)\n    {\n        assertPath(path);\n        if (ext) assertPath(ext);\n\n        path = removeUrlParams(this.toPosix(path));\n\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i: number;\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length)\n        {\n            if (ext.length === path.length && ext === path) return '';\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n\n            for (i = path.length - 1; i >= 0; --i)\n            {\n                const code = path.charCodeAt(i);\n\n                if (code === 47)\n                {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash)\n                    {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else\n                {\n                    if (firstNonSlashEnd === -1)\n                    {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0)\n                    {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx))\n                        {\n                            if (--extIdx === -1)\n                            {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else\n                        {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length;\n\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i)\n        {\n            if (path.charCodeAt(i) === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n\n        if (end === -1) return '';\n\n        return path.slice(start, end);\n    },\n\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the extension of a URL\n     * path.extname('http://www.example.com/foo/bar/baz.png');\n     * // -> '.png'\n     * // Get the extension of a file path\n     * path.extname('C:/Users/User/Documents/file.txt');\n     * // -> '.txt'\n     * ```\n     */\n    extname(path: string)\n    {\n        assertPath(path);\n        path = removeUrlParams(this.toPosix(path));\n\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        for (let i = path.length - 1; i >= 0; --i)\n        {\n            const code = path.charCodeAt(i);\n\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            return '';\n        }\n\n        return path.slice(startDot, end);\n    },\n\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Parse a URL\n     * const parsed = path.parse('http://www.example.com/foo/bar/baz.png');\n     * // -> {\n     * //   root: 'http://www.example.com/',\n     * //   dir: 'http://www.example.com/foo/bar',\n     * //   base: 'baz.png',\n     * //   ext: '.png',\n     * //   name: 'baz'\n     * // }\n     * // Parse a file path\n     * const parsedFile = path.parse('C:/Users/User/Documents/file.txt');\n     * // -> {\n     * //   root: 'C:/',\n     * //   dir: 'C:/Users/User/Documents',\n     * //   base: 'file.txt',\n     * //   ext: '.txt',\n     * //   name: 'file'\n     * // }\n     * ```\n     */\n    parse(path: string)\n    {\n        assertPath(path);\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n        if (path.length === 0) return ret;\n        path = removeUrlParams(this.toPosix(path));\n\n        let code = path.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path);\n        let start: number;\n        const protocol = '';\n\n        ret.root = this.rootname(path);\n\n        if (isAbsolute || this.hasProtocol(path))\n        {\n            start = 1;\n        }\n        else\n        {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        // Get non-dir info\n        for (; i >= start; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            if (end !== -1)\n            {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);\n                else ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        else\n        {\n            if (startPart === 0 && isAbsolute)\n            {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            }\n            else\n            {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n\n        ret.dir = this.dirname(path);\n        if (protocol) ret.dir = protocol + ret.dir;\n\n        return ret;\n    },\n\n    sep: '/',\n    delimiter: ':',\n    joinExtensions: ['.html'],\n} as Path;\n","/**\n * Copies the search params from one url to another\n * @param targetUrl - the url to copy the search params to\n * @param sourceUrl - the url container the search params we want to copy\n * @returns the url with the search params copied\n * @internal\n */\nexport const copySearchParams = (targetUrl: string, sourceUrl: string) =>\n{\n    const searchParams = sourceUrl.split('?')[1];\n\n    if (searchParams)\n    {\n        targetUrl += `?${searchParams}`;\n    }\n\n    return targetUrl;\n};\n","function processX(base: string, ids: string[][], depth: number, result: string[], tags: string[])\n{\n    const id = ids[depth];\n\n    for (let i = 0; i < id.length; i++)\n    {\n        const value = id[i];\n\n        if (depth < ids.length - 1)\n        {\n            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        }\n        else\n        {\n            tags.push(base.replace(result[depth], value));\n        }\n    }\n}\n\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n * @internal\n */\nexport function createStringVariations(string: string): string[]\n{\n    const regex = /\\{(.*?)\\}/g;\n\n    const result = string.match(regex);\n\n    const tags: string[] = [];\n\n    if (result)\n    {\n        const ids: string[][] = [];\n\n        result.forEach((vars) =>\n        {\n            // first remove the brackets...\n            const split = vars.substring(1, vars.length - 1).split(',');\n\n            ids.push(split);\n        });\n\n        processX(string, ids, 0, result, tags);\n    }\n    else\n    {\n        tags.push(string);\n    }\n\n    return tags;\n}\n","/**\n * Checks if the given value is an array.\n * @param item - The item to test\n * @internal\n */\nexport const isSingleItem = (item: unknown): boolean => (!Array.isArray(item));\n","import { extensions } from '../extensions/Extensions';\nimport { spritesheetAsset } from './spritesheetAsset';\n\nextensions.add(spritesheetAsset);\n","import { Rectangle } from '../maths/shapes/Rectangle';\nimport { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { BindableTexture, TextureBorders } from '../rendering/renderers/shared/texture/Texture';\nimport type { Dict } from '../utils/types';\n\n/**\n * Represents the JSON data for a spritesheet atlas.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetFrameData\n{\n    /** The frame rectangle of the texture. */\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    /** Whether the texture is trimmed. */\n    trimmed?: boolean;\n    /** Whether the texture is rotated. */\n    rotated?: boolean;\n    /** The source size of the texture. */\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    /** The sprite source size. */\n    spriteSourceSize?: {\n        h?: number;\n        w?: number;\n        x: number;\n        y: number;\n    };\n    /** The anchor point of the texture. */\n    anchor?: PointData;\n    /** The 9-slice borders of the texture. */\n    borders?: TextureBorders\n}\n\n/**\n * Atlas format.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetData\n{\n    /** The frames of the atlas. */\n    frames: Dict<SpritesheetFrameData>;\n    /** The animations of the atlas. */\n    animations?: Dict<string[]>;\n    /** The meta data of the atlas. */\n    meta: {\n        app?: string;\n        format?: string;\n        frameTags?: {\n            from: number;\n            name: string;\n            to: number;\n            direction: string;\n        }[];\n        image?: string;\n        layers?: {\n            blendMode: string;\n            name: string;\n            opacity: number;\n        }[];\n        scale: number | string;\n        size?: {\n            h: number;\n            w: number;\n        };\n        slices?: {\n            color: string;\n            name: string;\n            keys: {\n                frame: number,\n                bounds: {\n                    x: number;\n                    y: number;\n                    w: number;\n                    h: number;\n                };\n            }[];\n        }[];\n        related_multi_packs?: string[];\n        version?: string;\n    };\n}\n\n/**\n * Options for loading a spritesheet from an atlas.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetOptions<S extends SpritesheetData = SpritesheetData>\n{\n    /** Reference to Texture */\n    texture: BindableTexture;\n    /** JSON data for the atlas. */\n    data: S;\n    /** The filename to consider when determining the resolution of the spritesheet. */\n    resolutionFilename?: string;\n    /**\n     * Prefix to add to texture names when adding to global TextureCache,\n     * using this option can be helpful if you have multiple texture atlases\n     * that share texture names and you need to disambiguate them.\n     */\n    cachePrefix?: string;\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * ```js\n * import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Here's an example of a sprite sheet JSON data file:\n * ```json\n * {\n *     \"frames\": {\n *         \"enemy1.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":1,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":0.5,\"y\":0.5}\n *         },\n *         \"enemy2.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":35,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":0.5,\"y\":0.5}\n *         },\n *         \"button.png\":\n *         {\n *             \"frame\": {\"x\":1,\"y\":1,\"w\":100,\"h\":100},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":100,\"h\":100},\n *             \"sourceSize\": {\"w\":100,\"h\":100},\n *             \"anchor\": {\"x\":0,\"y\":0},\n *             \"borders\": {\"left\":35,\"top\":35,\"right\":35,\"bottom\":35}\n *         }\n *     },\n *\n *     \"animations\": {\n *         \"enemy\": [\"enemy1.png\",\"enemy2.png\"]\n *     },\n *\n *     \"meta\": {\n *         \"image\": \"sheet.png\",\n *         \"format\": \"RGBA8888\",\n *         \"size\": {\"w\":136,\"h\":102},\n *         \"scale\": \"1\"\n *     }\n * }\n * ```\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link Texture#defaultAnchor}), default 9-slice borders\n * (see {@link Texture#defaultBorders}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * Alternative ways for loading spritesheet image if you need more control:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheetTexture = await Assets.load('images/spritesheet.png');\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {texture: sheetTexture} // using of preloaded texture\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n *\n * or:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {imageFilename: 'my-spritesheet.2x.avif'} // using of custom filename located in \"images/my-spritesheet.2x.avif\"\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n * @category assets\n * @standard\n */\nexport class Spritesheet<S extends SpritesheetData = SpritesheetData>\n{\n    /**\n     * The maximum number of Textures to build per process.\n     * @advanced\n     */\n    public static readonly BATCH_SIZE = 1000;\n\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    public linkedSheets: Spritesheet<S>[] = [];\n\n    /** Reference to the source texture. */\n    public textureSource: TextureSource;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link Sprite}:\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * new Sprite(sheet.textures['image.png']);\n     */\n    public textures: Record<keyof S['frames'], Texture>;\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link AnimatedSprite}:\n     * @example\n     * import { AnimatedSprite } from 'pixi.js';\n     *\n     * new AnimatedSprite(sheet.animations['anim_name']);\n     */\n    public animations: Record<keyof NonNullable<S['animations']>, Texture[]>;\n\n    /**\n     * Reference to the original JSON data.\n     * @type {object}\n     */\n    public data: S;\n\n    /** The resolution of the spritesheet. */\n    public resolution: number;\n\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     */\n    private _texture: Texture;\n\n    /**\n     * Map of spritesheet frames.\n     * @type {object}\n     */\n    private _frames: S['frames'];\n\n    /** Collection of frame names. */\n    private _frameKeys: (keyof S['frames'])[];\n\n    /** Current batch index being processed. */\n    private _batchIndex: number;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     */\n    private _callback: (textures: Dict<Texture>) => void;\n\n    /** Prefix string to add to global cache */\n    public readonly cachePrefix: string;\n\n    /**\n     * @class\n     * @param options - Options to use when constructing a new Spritesheet.\n     */\n    constructor(options: SpritesheetOptions<S>);\n\n    /**\n     * @param texture - Reference to the source BaseTexture object.\n     * @param {object} data - Spritesheet image data.\n     */\n    constructor(texture: BindableTexture, data: S);\n\n    constructor(optionsOrTexture: SpritesheetOptions<S> | BindableTexture, arg1?: S)\n    {\n        let options = optionsOrTexture as SpritesheetOptions<S>;\n\n        if ((optionsOrTexture as BindableTexture)?.source instanceof TextureSource)\n        {\n            options = {\n                texture: optionsOrTexture as BindableTexture,\n                data: arg1,\n            };\n        }\n        const { texture, data, cachePrefix = '' } = options;\n\n        this.cachePrefix = cachePrefix;\n        this._texture = texture instanceof Texture ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {} as Record<keyof S['frames'], Texture>;\n        this.animations = {} as Record<keyof NonNullable<S['animations']>, Texture[]>;\n        this.data = data;\n\n        const metaResolution = parseFloat(data.meta.scale as string);\n\n        if (metaResolution)\n        {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        }\n        else\n        {\n            this.resolution = texture.source._resolution;\n        }\n\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     */\n    public parse(): Promise<Record<string, Texture>>\n    {\n        return new Promise((resolve) =>\n        {\n            this._callback = resolve;\n            this._batchIndex = 0;\n\n            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n            {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            }\n            else\n            {\n                this._nextBatch();\n            }\n        });\n    }\n\n    /**\n     * Process a batch of frames\n     * @param initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture({\n                    source: this.textureSource,\n\n                    frame,\n                    orig,\n                    trim,\n                    rotate: data.rotated ? 2 : 0,\n                    defaultAnchor: data.anchor,\n                    defaultBorders: data.borders,\n\n                    label: i.toString(),\n                });\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /** Parse animations config. */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName as keyof S['animations']] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /** The parse has completed. */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /** Begin the next batch of textures. */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n}\n","import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type {\n    ArrayOr,\n    AssetsBundle,\n    AssetsManifest,\n    AssetSrc,\n    ResolvedAsset,\n    ResolvedSrc,\n    UnresolvedAsset,\n} from '../types';\nimport type { PreferOrder, ResolveURLParser } from './types';\n\n/**\n * Options for how the resolver deals with generating bundle ids\n * @category assets\n * @advanced\n */\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @category assets\n * @advanced\n */\nexport class Resolver\n{\n    /**\n     * The prefix that denotes a URL is for a retina asset.\n     * @default /@([0-9\\.]+)x/\n     * @example `@2x`\n     */\n    public static RETINA_PREFIX = /@([0-9\\.]+)x/;\n\n    private readonly _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolvedAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private readonly _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolvedAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: AssetsManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Returns the aliases for a given asset\n     * @param asset - the asset to get the aliases for\n     */\n    public getAlias(asset: UnresolvedAsset): string[]\n    {\n        const { alias, src } = asset;\n        const aliasesToUse = convertToList<ArrayOr<string | AssetSrc>>(\n            alias || src, (value: string | AssetSrc) =>\n            {\n                if (typeof value === 'string') return value;\n\n                if (Array.isArray(value)) return value.map((v) => (v as ResolvedSrc)?.src ?? v);\n\n                if (value?.src) return value.src;\n\n                return value;\n            }, true) as string[];\n\n        return aliasesToUse;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: AssetsManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n        let convertedAssets: UnresolvedAsset[] = assets as UnresolvedAsset[];\n\n        if (!Array.isArray(assets))\n        {\n            // convert to array...\n            convertedAssets = Object.entries(assets).map(([alias, src]) =>\n            {\n                if (typeof src === 'string' || Array.isArray(src))\n                {\n                    return { alias, src };\n                }\n\n                return { alias, ...src };\n            });\n        }\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n\n        convertedAssets.forEach((asset) =>\n        {\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids: string[];\n\n            if (typeof aliases === 'string')\n            {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n\n                assetNames.push(bundleAssetId);\n                ids = [aliases, bundleAssetId];\n            }\n            else\n            {\n                const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n\n                assetNames.push(...bundleIds);\n                ids = [...aliases, ...bundleIds];\n            }\n\n            this.add({\n                ...asset,\n                ...{\n                    alias: ids,\n                    src: srcs,\n                }\n            });\n        });\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add({alias: 'foo', src: 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n     */\n    public add(\n        aliases: ArrayOr<UnresolvedAsset>,\n    ): void\n    {\n        const assets: UnresolvedAsset[] = [];\n\n        if (Array.isArray(aliases))\n        {\n            assets.push(...(aliases as UnresolvedAsset[]));\n        }\n        else\n        {\n            assets.push(aliases as UnresolvedAsset);\n        }\n\n        let keyCheck: (key: string) => void;\n\n        // #if _DEBUG\n        // eslint-disable-next-line prefer-const\n        keyCheck = (key: string) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        };\n        // #endif\n\n        const assetArray = convertToList(assets);\n\n        // loop through all the assets and generate a resolve asset for each src\n        assetArray.forEach((asset) =>\n        {\n            const { src } = asset;\n            let {\n                data,\n                format,\n                loadParser: userDefinedLoadParser,\n                parser: userDefinedParser,\n            } = asset;\n\n            // src can contain an unresolved asset itself\n            // so we need to merge that data with the current asset\n            // we dont need to create string variations for the src if it is a ResolvedAsset\n            const srcsToUse: (string | ResolvedSrc)[][] = convertToList<AssetSrc>(src).map((src) =>\n            {\n                if (typeof src === 'string')\n                { return createStringVariations(src); }\n\n                return Array.isArray(src) ? src : [src];\n            });\n\n            const aliasesToUse = this.getAlias(asset);\n\n            // #if _DEBUG\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            // #endif\n\n            // loop through all the srcs and generate a resolve asset for each src\n            const resolvedAssets: ResolvedAsset[] = [];\n\n            // Helper function to parse a URL string using registered parsers\n            const parseUrl = (url: string): ResolvedAsset =>\n            {\n                const parser = this._parsers.find((p) => p.test(url));\n\n                return {\n                    ...parser?.parse(url),\n                    src: url,\n                };\n            };\n\n            srcsToUse.forEach((srcs) =>\n            {\n                srcs.forEach((src) =>\n                {\n                    let formattedAsset = {} as ResolvedAsset;\n\n                    if (typeof src !== 'object')\n                    {\n                        // first see if it contains any {} tags...\n                        formattedAsset = parseUrl(src);\n                    }\n                    else\n                    {\n                        data = src.data ?? data;\n                        format = src.format ?? format;\n                        if (src.loadParser || src.parser)\n                        {\n                            userDefinedLoadParser = src.loadParser ?? userDefinedLoadParser;\n                            userDefinedParser = src.parser ?? userDefinedParser;\n                        }\n\n                        formattedAsset = {\n                            ...parseUrl(src.src),\n                            ...src,\n                        };\n                    }\n\n                    // check if aliases is undefined\n                    if (!aliasesToUse)\n                    {\n                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    }\n\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data,\n                        format,\n                        loadParser: userDefinedLoadParser,\n                        parser: userDefinedParser,\n                        progressSize: asset.progressSize,\n                    });\n\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n\n            aliasesToUse.forEach((alias) =>\n            {\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n\n    // TODO: this needs an overload like load did in Assets\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: ArrayOr<string>):\n    Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolvedAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolvedAsset>;\n\n                const assets: Record<string, ResolvedAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: ArrayOr<string>): string | Record<string, string>\n    {\n        const result = this.resolve(key as string) as ResolvedAsset | Record<string, ResolvedAsset>;\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolvedAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolvedAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string): ResolvedAsset;\n    public resolve(keys: string[]): Record<string, ResolvedAsset>;\n    public resolve(keys: ArrayOr<string>): ResolvedAsset | Record<string, ResolvedAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolvedAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey as keyof ResolvedAsset])\n                                {\n                                    return asset[priorityKey as keyof ResolvedAsset] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = assets[0];\n                }\n                else\n                {\n                    this._resolverHash[key] = this._buildResolvedAsset({\n                        alias: [key],\n                        src: key,\n                    }, {});\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolvedAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[i];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n\n    private _buildResolvedAsset(formattedAsset: ResolvedAsset, data?: {\n        aliases?: string[],\n        data?: Record<string, unknown>\n        loadParser?: string,\n        parser?: string,\n        format?: string,\n        progressSize?: number,\n    }): ResolvedAsset\n    {\n        const { aliases, data: assetData, loadParser, parser, format, progressSize } = data;\n\n        if (this._basePath || this._rootPath)\n        {\n            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        }\n\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.parser = parser ?? formattedAsset.parser;\n        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n        if (progressSize !== undefined)\n        {\n            formattedAsset.progressSize = progressSize;\n        }\n\n        return formattedAsset;\n    }\n}\n\n/**\n * @param url\n * @internal\n */\nexport function getUrlExtension(url: string)\n{\n    return url.split('.').pop().split('?').shift()\n        .split('#')\n        .shift();\n}\n","import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser';\nimport { Resolver } from '../assets/resolver/Resolver';\nimport { copySearchParams } from '../assets/utils/copySearchParams';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { path } from '../utils/path';\nimport { Spritesheet } from './Spritesheet';\n\nimport type { AssetExtensionAdvanced } from '../assets/AssetExtension';\nimport type { Loader } from '../assets/loader/Loader';\nimport type { ResolvedAsset } from '../assets/types';\nimport type { TextureSourceOptions } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { SpritesheetData } from './Spritesheet';\n\n/**\n * Interface for the JSON data structure of a spritesheet.\n * This is used to define the structure of the JSON file that describes a spritesheet.\n * It includes metadata about the spritesheet and the frames it contains.\n * @see {@link Spritesheet}\n * @see {@link SpritesheetData}\n * @category assets\n * @advanced\n */\nexport interface SpriteSheetJson extends SpritesheetData\n{\n    meta: {\n        image: string;\n        scale: string;\n        related_multi_packs?: string[];\n    };\n}\n\nconst validImages = ['jpg', 'png', 'jpeg', 'avif', 'webp',\n    'basis', 'etc2', 'bc7', 'bc6h', 'bc5', 'bc4', 'bc3', 'bc2', 'bc1', 'eac', 'astc'];\n\nfunction getCacheableAssets(keys: string[], asset: Spritesheet, ignoreMultiPack: boolean)\n{\n    const out: Record<string, any> = {};\n\n    keys.forEach((key: string) =>\n    {\n        out[key] = asset;\n    });\n\n    Object.keys(asset.textures).forEach((key) =>\n    {\n        out[`${asset.cachePrefix}${key}`] = asset.textures[key];\n    });\n\n    if (!ignoreMultiPack)\n    {\n        const basePath = path.dirname(keys[0]);\n\n        asset.linkedSheets.forEach((item: Spritesheet, i) =>\n        {\n            const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n\n            Object.assign(out, out2);\n        });\n    }\n\n    return out;\n}\n\n/**\n * Asset extension for loading spritesheets\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *     alias: 'spritesheet',\n *     src: 'path/to/spritesheet.json',\n *     data: {\n *         ignoreMultiPack: true,\n *         textureOptions: {\n *             scaleMode: \"nearest\"\n *         }\n *     }\n * })\n * @type {AssetExtension}\n * @category assets\n * @advanced\n */\nexport const spritesheetAsset = {\n    extension: ExtensionType.Asset,\n    /** Handle the caching of the related Spritesheet Textures */\n    cache: {\n        test: (asset: Spritesheet) => asset instanceof Spritesheet,\n        getCacheableAssets: (keys: string[], asset: Spritesheet) => getCacheableAssets(keys, asset, false),\n    },\n    /** Resolve the resolution of the asset. */\n    resolver: {\n        extension: {\n            type: ExtensionType.ResolveParser,\n            name: 'resolveSpritesheet',\n        },\n        test: (value: string): boolean =>\n        {\n            const tempURL = value.split('?')[0];\n            const split = tempURL.split('.');\n            const extension = split.pop();\n            const format = split.pop();\n\n            return extension === 'json' && validImages.includes(format);\n        },\n        parse: (value: string) =>\n        {\n            const split = value.split('.');\n\n            return {\n                resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n                format: split[split.length - 2],\n                src: value,\n            };\n        },\n    },\n    /**\n     * Loader plugin that parses sprite sheets!\n     * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n     * If it is, we load the spritesheets image and parse the data into Spritesheet\n     * All textures in the sprite sheet are then added to the cache\n     */\n    loader: {\n        /** used for deprecation purposes */\n        name: 'spritesheetLoader',\n        id: 'spritesheet',\n\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n            name: 'spritesheetLoader',\n        },\n\n        async testParse(asset: SpriteSheetJson, options: ResolvedAsset): Promise<boolean>\n        {\n            return (path.extname(options.src).toLowerCase() === '.json' && !!asset.frames);\n        },\n\n        async parse(\n            asset: SpriteSheetJson,\n            options: ResolvedAsset<{\n                texture?: Texture,\n                imageFilename?: string,\n                ignoreMultiPack?: boolean,\n                textureOptions?: TextureSourceOptions,\n                cachePrefix?: string,\n            }>,\n            loader?: Loader\n        ): Promise<Spritesheet>\n        {\n            const {\n                texture: imageTexture, // if user need to use preloaded texture\n                imageFilename, // if user need to use custom filename (not from jsonFile.meta.image)\n                textureOptions, // if user need to set texture options on texture\n                cachePrefix, // if user need to use custom cache prefix\n            } = options?.data ?? {};\n\n            let basePath = path.dirname(options.src);\n\n            if (basePath && basePath.lastIndexOf('/') !== (basePath.length - 1))\n            {\n                basePath += '/';\n            }\n\n            let texture: Texture;\n\n            if (imageTexture instanceof Texture)\n            {\n                texture = imageTexture;\n            }\n            else\n            {\n                const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n\n                const assets = await loader.load<Texture>([{ src: imagePath, data: textureOptions }]);\n\n                texture = assets[imagePath];\n            }\n\n            const spritesheet = new Spritesheet({\n                texture: texture.source,\n                data: asset,\n                cachePrefix\n            });\n\n            await spritesheet.parse();\n\n            // Check and add the multi atlas\n            // Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n            const multiPacks = asset?.meta?.related_multi_packs;\n\n            if (Array.isArray(multiPacks))\n            {\n                const promises: Promise<Spritesheet<SpriteSheetJson>>[] = [];\n\n                for (const item of multiPacks)\n                {\n                    if (typeof item !== 'string')\n                    {\n                        continue;\n                    }\n\n                    let itemUrl = basePath + item;\n\n                    // Check if the file wasn't already added as multipack\n                    if (options.data?.ignoreMultiPack)\n                    {\n                        continue;\n                    }\n\n                    itemUrl = copySearchParams(itemUrl, options.src);\n\n                    promises.push(loader.load<Spritesheet<SpriteSheetJson>>({\n                        src: itemUrl,\n                        data: {\n                            textureOptions,\n                            ignoreMultiPack: true,\n                        }\n                    }));\n                }\n\n                const res = await Promise.all(promises);\n\n                spritesheet.linkedSheets = res;\n                res.forEach((item) =>\n                {\n                    item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => (sp !== item)));\n                });\n            }\n\n            return spritesheet;\n        },\n\n        async unload(spritesheet: Spritesheet, _resolvedAsset, loader)\n        {\n            await loader.unload(spritesheet.textureSource._sourceOrigin);\n\n            spritesheet.destroy(false);\n        },\n    }\n} satisfies AssetExtensionAdvanced<SpriteSheetJson, Spritesheet, Spritesheet, Spritesheet>;\n","\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n","/**\n * Calculates the squared distance from a point to a line segment defined by two endpoints.\n * @param x - x coordinate of the point\n * @param y - y coordinate of the point\n * @param x1 - x coordinate of the first endpoint of the line segment\n * @param y1 - y coordinate of the first endpoint of the line segment\n * @param x2 - x coordinate of the second endpoint of the line segment\n * @param y2 - y coordinate of the second endpoint of the line segment\n * @returns The squared distance from the point to the line segment\n * @category maths\n * @internal\n */\nexport function squaredDistanceToLineSegment(\n    x: number, y: number,\n    x1: number, y1: number,\n    x2: number, y2: number\n): number\n{\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n\n    const dot = (a * c) + (b * d);\n    const lenSq = (c * c) + (d * d);\n    let param = -1;\n\n    if (lenSq !== 0)\n    {\n        param = dot / lenSq;\n    }\n\n    let xx; let\n        yy;\n\n    if (param < 0)\n    {\n        xx = x1;\n        yy = y1;\n    }\n    else if (param > 1)\n    {\n        xx = x2;\n        yy = y2;\n    }\n\n    else\n    {\n        xx = x1 + (param * c);\n        yy = y1 + (param * d);\n    }\n\n    const dx = x - xx;\n    const dy = y - yy;\n\n    return (dx * dx) + (dy * dy);\n}\n","import { type SHAPE_PRIMITIVE } from '../misc/const';\nimport { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst isCornerWithinStroke = (\n    pX: number,\n    pY: number,\n    cornerX: number,\n    cornerY: number,\n    radius: number,\n    strokeWidthInner: number,\n    strokeWidthOuter: number\n) =>\n{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n    return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;\n};\n\n/**\n * The `RoundedRectangle` object represents a rectangle with rounded corners.\n * Defined by position, dimensions and corner radius.\n * @example\n * ```ts\n * // Basic rectangle creation\n * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n * // Use as container hit area\n * container.hitArea = new RoundedRectangle(0, 0, 100, 100, 10);\n * // Check point containment\n * const isInside = rect.contains(mouseX, mouseY);\n * // Get bounds\n * const bounds = rect.getBounds();\n * ```\n * @remarks\n * - Position defined by top-left corner\n * - Radius clamped to half smallest dimension\n * - Common in UI elements\n * @see {@link Rectangle} For non-rounded rectangles\n * @category maths\n * @standard\n */\nexport class RoundedRectangle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the upper-left corner of the rounded rectangle\n     * @example\n     * ```ts\n     * // Basic x position\n     * const rect = new RoundedRectangle();\n     * rect.x = 100;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rounded rectangle\n     * @example\n     * ```ts\n     * // Basic y position\n     * const rect = new RoundedRectangle();\n     * rect.y = 100;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rounded rectangle\n     * @example\n     * ```ts\n     * // Basic width setting\n     * const rect = new RoundedRectangle();\n     * rect.width = 200; // Total width will be 200\n     * ```\n     * @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rounded rectangle\n     * @example\n     * ```ts\n     * // Basic height setting\n     * const rect = new RoundedRectangle();\n     * rect.height = 150; // Total height will be 150\n     * ```\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * Controls the radius of the rounded corners\n     * @example\n     * ```ts\n     * // Basic radius setting\n     * const rect = new RoundedRectangle(0, 0, 200, 150);\n     * rect.radius = 20;\n     *\n     * // Clamp to maximum safe radius\n     * rect.radius = Math.min(rect.width, rect.height) / 2;\n     *\n     * // Create pill shape\n     * rect.radius = rect.height / 2;\n     * ```\n     * @remarks\n     * - Automatically clamped to half of smallest dimension\n     * - Common values: 0-20 for UI elements\n     * - Higher values create more rounded corners\n     * @default 20\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new RoundedRectangle(0, 0, 100, 100, 20);\n     * console.log(shape.type); // 'roundedRectangle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'roundedRectangle') {\n     *     console.log(shape.radius);\n     * }\n     * ```\n     * @readonly\n     * @default 'roundedRectangle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'roundedRectangle';\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n     * @param width - The overall width of this rounded rectangle\n     * @param height - The overall height of this rounded rectangle\n     * @param radius - Controls the radius of the rounded corners\n     */\n    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20)\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n\n    /**\n     * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const bounds = rect.getBounds();\n     * // bounds: x=100, y=100, width=200, height=150\n     *\n     * // Reuse existing rectangle\n     * const out = new Rectangle();\n     * rect.getBounds(out);\n     * ```\n     * @remarks\n     * - Rectangle matches outer dimensions\n     * - Ignores corner radius\n     * @param out - Optional rectangle to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link RoundedRectangle.contains} For checking if a point is inside\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n\n        return out;\n    }\n\n    /**\n     * Creates a clone of this Rounded Rectangle.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.radius = 30;\n     * modified.width *= 2;\n     *\n     * // Verify independence\n     * console.log(original.radius);  // 20\n     * console.log(modified.radius);  // 30\n     * ```\n     * @returns A copy of the rounded rectangle\n     * @see {@link RoundedRectangle.copyFrom} For copying into existing rectangle\n     * @see {@link RoundedRectangle.copyTo} For copying to another rectangle\n     */\n    public clone(): RoundedRectangle\n    {\n        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const target = new RoundedRectangle();\n     * target.copyFrom(source);\n     *\n     * // Chain with other operations\n     * const rect = new RoundedRectangle()\n     *     .copyFrom(source)\n     *     .getBounds(rect);\n     * ```\n     * @param rectangle - The rectangle to copy from\n     * @returns Returns itself\n     * @see {@link RoundedRectangle.copyTo} For copying to another rectangle\n     * @see {@link RoundedRectangle.clone} For creating new rectangle copy\n     */\n    public copyFrom(rectangle: RoundedRectangle): this\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const target = new RoundedRectangle();\n     * source.copyTo(target);\n     *\n     * // Chain with other operations\n     * const result = source\n     *     .copyTo(new RoundedRectangle())\n     *     .getBounds();\n     * ```\n     * @param rectangle - The rectangle to copy to\n     * @returns Returns given parameter\n     * @see {@link RoundedRectangle.copyFrom} For copying from another rectangle\n     * @see {@link RoundedRectangle.clone} For creating new rectangle copy\n     */\n    public copyTo(rectangle: RoundedRectangle): RoundedRectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const isInside = rect.contains(150, 125); // true\n     * // Check corner radius\n     * const corner = rect.contains(100, 100); // false if within corner curve\n     * ```\n     * @remarks\n     * - Returns false if width/height is 0 or negative\n     * - Handles rounded corners with radius check\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Rounded Rectangle\n     * @see {@link RoundedRectangle.strokeContains} For checking stroke intersection\n     * @see {@link RoundedRectangle.getBounds} For getting containing rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n        if (x >= this.x && x <= this.x + this.width)\n        {\n            if (y >= this.y && y <= this.y + this.height)\n            {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n\n                if ((y >= this.y + radius && y <= this.y + this.height - radius)\n                    || (x >= this.x + radius && x <= this.x + this.width - radius))\n                {\n                    return true;\n                }\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + this.width - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dy = y - (this.y + this.height - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside\n     * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered\n     * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside\n     * ```\n     * @param pX - The X coordinate of the point to test\n     * @param pY - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coordinates are within this rectangle's stroke\n     * @see {@link RoundedRectangle.contains} For checking fill containment\n     * @see {@link RoundedRectangle.getBounds} For getting stroke bounds\n     */\n    public strokeContains(pX: number, pY: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { x, y, width, height, radius } = this;\n\n        const strokeWidthOuter = strokeWidth * (1 - alignment);\n        const strokeWidthInner = strokeWidth - strokeWidthOuter;\n\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - (radius * 2);\n        const innerHeight = height - (radius * 2);\n        const rightBound = x + width;\n        const bottomBound = y + height;\n\n        // Check if point is within the vertical edges (excluding corners)\n        if (((pX >= x - strokeWidthOuter && pX <= x + strokeWidthInner)\n            || (pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter))\n            && pY >= innerY && pY <= innerY + innerHeight)\n        {\n            return true;\n        }\n\n        // Check if point is within the horizontal edges (excluding corners)\n        if (((pY >= y - strokeWidthOuter && pY <= y + strokeWidthInner)\n            || (pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter))\n            && pX >= innerX && pX <= innerX + innerWidth)\n        {\n            return true;\n        }\n\n        // Top-left, top-right, bottom-right, bottom-left corners\n        return (\n            // Top-left\n            (pX < innerX && pY < innerY\n                && isCornerWithinStroke(pX, pY, innerX, innerY,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            //  top-right\n            || (pX > rightBound - radius && pY < innerY\n                && isCornerWithinStroke(pX, pY, rightBound - radius, innerY,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            // bottom-right\n            || (pX > rightBound - radius && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            // bottom-left\n            || (pX < innerX && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius,\n                    radius, strokeWidthInner, strokeWidthOuter)));\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}`\n            + `width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n    // #endif\n}\n","import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for containers.\n * @example\n * ```ts\n * // Basic ellipse creation\n * const ellipse = new Ellipse(100, 100, 20, 10);\n *\n * // Use as a hit area\n * container.hitArea = new Ellipse(0, 0, 50, 25);\n *\n * // Check point containment\n * const isInside = ellipse.contains(mouseX, mouseY);\n *\n * // Get bounding box\n * const bounds = ellipse.getBounds();\n * ```\n * @remarks\n * - Defined by center (x,y) and half dimensions\n * - Total width = halfWidth * 2\n * - Total height = halfHeight * 2\n * @see {@link Rectangle} For rectangular shapes\n * @see {@link Circle} For circular shapes\n * @category maths\n * @standard\n */\nexport class Ellipse implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this ellipse\n     * @example\n     * ```ts\n     * // Basic x position\n     * const ellipse = new Ellipse();\n     * ellipse.x = 100;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this ellipse\n     * @example\n     * ```ts\n     * // Basic y position\n     * const ellipse = new Ellipse();\n     * ellipse.y = 200;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The half width of this ellipse\n     * @example\n     * ```ts\n     * // Set half width\n     * const ellipse = new Ellipse(100, 100);\n     * ellipse.halfWidth = 50; // Total width will be 100\n     * ```\n     * @default 0\n     */\n    public halfWidth: number;\n\n    /**\n     * The half height of this ellipse\n     * @example\n     * ```ts\n     * // Set half height\n     * const ellipse = new Ellipse(100, 100);\n     * ellipse.halfHeight = 25; // Total height will be 50\n     * ```\n     * @default 0\n     */\n    public halfHeight: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Ellipse(0, 0, 50, 25);\n     * console.log(shape.type); // 'ellipse'\n     *\n     * // Use in type guards\n     * if (shape.type === 'ellipse') {\n     *     console.log(shape.halfWidth, shape.halfHeight);\n     * }\n     * ```\n     * @readonly\n     * @default 'ellipse'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type = 'ellipse';\n\n    /**\n     * @param x - The X coordinate of the center of this ellipse\n     * @param y - The Y coordinate of the center of this ellipse\n     * @param halfWidth - The half width of this ellipse\n     * @param halfHeight - The half height of this ellipse\n     */\n    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n\n    /**\n     * Creates a clone of this Ellipse instance.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new Ellipse(100, 100, 50, 25);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.halfWidth *= 2;\n     * modified.halfHeight *= 2;\n     *\n     * // Verify independence\n     * console.log(original.halfWidth);  // 50\n     * console.log(modified.halfWidth);  // 100\n     * ```\n     * @returns A copy of the ellipse\n     * @see {@link Ellipse.copyFrom} For copying into existing ellipse\n     * @see {@link Ellipse.copyTo} For copying to another ellipse\n     */\n    public clone(): Ellipse\n    {\n        return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse.\n     * Uses normalized coordinates and the ellipse equation to determine containment.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const ellipse = new Ellipse(100, 100, 50, 25);\n     * const isInside = ellipse.contains(120, 110);\n     * ```\n     * @remarks\n     * - Uses ellipse equation (x/a + y/b  1)\n     * - Returns false if dimensions are 0 or negative\n     * - Normalized to center (0,0) for calculation\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coords are within this ellipse\n     * @see {@link Ellipse.strokeContains} For checking stroke intersection\n     * @see {@link Ellipse.getBounds} For getting containing rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0)\n        {\n            return false;\n        }\n\n        // normalize the coords to an ellipse with center 0,0\n        let normx = ((x - this.x) / this.halfWidth);\n        let normy = ((y - this.y) / this.halfHeight);\n\n        normx *= normx;\n        normy *= normy;\n\n        return (normx + normy <= 1);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse including stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const ellipse = new Ellipse(100, 100, 50, 25);\n     * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Inside\n     * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered\n     * const outerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Outside\n     * ```\n     * @remarks\n     * - Uses normalized ellipse equations\n     * - Considers stroke alignment\n     * - Returns false if dimensions are 0\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coords are within this ellipse's stroke\n     * @see {@link Ellipse.contains} For checking fill containment\n     * @see {@link Ellipse.getBounds} For getting stroke bounds\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { halfWidth, halfHeight } = this;\n\n        if (halfWidth <= 0 || halfHeight <= 0)\n        {\n            return false;\n        }\n\n        const strokeOuterWidth = strokeWidth * (1 - alignment);\n        const strokeInnerWidth = strokeWidth - strokeOuterWidth;\n\n        const innerHorizontal = halfWidth - strokeInnerWidth;\n        const innerVertical = halfHeight - strokeInnerWidth;\n\n        const outerHorizontal = halfWidth + strokeOuterWidth;\n        const outerVertical = halfHeight + strokeOuterWidth;\n\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n\n        const innerEllipse = ((normalizedX * normalizedX) / (innerHorizontal * innerHorizontal))\n            + ((normalizedY * normalizedY) / (innerVertical * innerVertical));\n\n        const outerEllipse = ((normalizedX * normalizedX) / (outerHorizontal * outerHorizontal))\n            + ((normalizedY * normalizedY) / (outerVertical * outerVertical));\n\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n\n    /**\n     * Returns the framing rectangle of the ellipse as a Rectangle object.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const ellipse = new Ellipse(100, 100, 50, 25);\n     * const bounds = ellipse.getBounds();\n     * // bounds: x=50, y=75, width=100, height=50\n     *\n     * // Reuse existing rectangle\n     * const rect = new Rectangle();\n     * ellipse.getBounds(rect);\n     * ```\n     * @remarks\n     * - Creates Rectangle if none provided\n     * - Top-left is (x-halfWidth, y-halfHeight)\n     * - Width is halfWidth * 2\n     * - Height is halfHeight * 2\n     * @param out - Optional Rectangle object to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link Ellipse.contains} For checking if a point is inside\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x - this.halfWidth;\n        out.y = this.y - this.halfHeight;\n        out.width = this.halfWidth * 2;\n        out.height = this.halfHeight * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another ellipse to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Ellipse(100, 100, 50, 25);\n     * const target = new Ellipse();\n     * target.copyFrom(source);\n     * ```\n     * @param ellipse - The ellipse to copy from\n     * @returns Returns itself\n     * @see {@link Ellipse.copyTo} For copying to another ellipse\n     * @see {@link Ellipse.clone} For creating new ellipse copy\n     */\n    public copyFrom(ellipse: Ellipse): this\n    {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n\n        return this;\n    }\n\n    /**\n     * Copies this ellipse to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Ellipse(100, 100, 50, 25);\n     * const target = new Ellipse();\n     * source.copyTo(target);\n     * ```\n     * @param ellipse - The ellipse to copy to\n     * @returns Returns given parameter\n     * @see {@link Ellipse.copyFrom} For copying from another ellipse\n     * @see {@link Ellipse.clone} For creating new ellipse copy\n     */\n    public copyTo(ellipse: Ellipse): Ellipse\n    {\n        ellipse.copyFrom(this);\n\n        return ellipse;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n    // #endif\n}\n","import { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Circle object represents a circle shape in a two-dimensional coordinate system.\n * Used for drawing graphics and specifying hit areas for containers.\n * @example\n * ```ts\n * // Basic circle creation\n * const circle = new Circle(100, 100, 50);\n *\n * // Use as hit area\n * container.hitArea = new Circle(0, 0, 100);\n *\n * // Check point containment\n * const isInside = circle.contains(mouseX, mouseY);\n *\n * // Get bounding box\n * const bounds = circle.getBounds();\n * ```\n * @remarks\n * - Defined by center (x,y) and radius\n * - Supports point containment tests\n * - Can check stroke intersections\n * @see {@link Rectangle} For rectangular shapes\n * @category maths\n * @standard\n */\nexport class Circle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this circle\n     * @example\n     * ```ts\n     * // Basic x position\n     * const circle = new Circle();\n     * circle.x = 100;\n     *\n     * // Center circle on point\n     * circle.x = point.x;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this circle\n     * @example\n     * ```ts\n     * // Basic y position\n     * const circle = new Circle();\n     * circle.y = 200;\n     *\n     * // Center circle on point\n     * circle.y = point.y;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The radius of the circle\n     * @example\n     * ```ts\n     * // Basic radius setting\n     * const circle = new Circle(100, 100);\n     * circle.radius = 50;\n     *\n     * // Calculate area\n     * const area = Math.PI * circle.radius * circle.radius;\n     * ```\n     * @default 0\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks.\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Circle(0, 0, 50);\n     * console.log(shape.type); // 'circle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'circle') {\n     *     console.log(shape.radius);\n     * }\n     * ```\n     * @remarks\n     * - Used for shape type checking\n     * - More efficient than instanceof\n     * - Read-only property\n     * @readonly\n     * @default 'circle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     * @see {@link ShapePrimitive} For shape interface\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'circle';\n\n    /**\n     * @param x - The X coordinate of the center of this circle\n     * @param y - The Y coordinate of the center of this circle\n     * @param radius - The radius of the circle\n     */\n    constructor(x = 0, y = 0, radius = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n\n    /**\n     * Creates a clone of this Circle instance.\n     * @example\n     * ```ts\n     * // Basic circle cloning\n     * const original = new Circle(100, 100, 50);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.radius = 75;\n     *\n     * // Verify independence\n     * console.log(original.radius); // 50\n     * console.log(modified.radius); // 75\n     * ```\n     * @returns A copy of the Circle\n     * @see {@link Circle.copyFrom} For copying into existing circle\n     * @see {@link Circle.copyTo} For copying to another circle\n     */\n    public clone(): Circle\n    {\n        return new Circle(this.x, this.y, this.radius);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle.\n     *\n     * Uses the distance formula to determine if a point is inside the circle's radius.\n     *\n     * Commonly used for hit testing in PixiJS events and graphics.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const circle = new Circle(100, 100, 50);\n     * const isInside = circle.contains(120, 120);\n     *\n     * // Check mouse position\n     * const circle = new Circle(0, 0, 100);\n     * container.hitArea = circle;\n     * container.on('pointermove', (e) => {\n     *     // only called if pointer is within circle\n     * });\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Circle\n     * @see {@link Circle.strokeContains} For checking stroke intersection\n     * @see {@link Circle.getBounds} For getting bounding box\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.radius <= 0) return false;\n\n        const r2 = this.radius * this.radius;\n        let dx = (this.x - x);\n        let dy = (this.y - y);\n\n        dx *= dx;\n        dy *= dy;\n\n        return (dx + dy <= r2);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const circle = new Circle(100, 100, 50);\n     * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = circle.strokeContains(150, 100, 4, 1);   // Inside\n     * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered\n     * const outerStroke = circle.strokeContains(150, 100, 4, 0);   // Outside\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width - The width of the line to check\n     * @param alignment - The alignment of the stroke, 0.5 by default\n     * @returns Whether the x/y coordinates are within this Circle's stroke\n     * @see {@link Circle.contains} For checking fill containment\n     * @see {@link Circle.getBounds} For getting stroke bounds\n     */\n    public strokeContains(x: number, y: number, width: number, alignment: number = 0.5): boolean\n    {\n        if (this.radius === 0) return false;\n\n        const dx = (this.x - x);\n        const dy = (this.y - y);\n        const radius = this.radius;\n        const outerWidth = (1 - alignment) * width;\n        const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n        return (distance <= radius + outerWidth && distance > radius - (width - outerWidth));\n    }\n\n    /**\n     * Returns the framing rectangle of the circle as a Rectangle object.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const circle = new Circle(100, 100, 50);\n     * const bounds = circle.getBounds();\n     * // bounds: x=50, y=50, width=100, height=100\n     *\n     * // Reuse existing rectangle\n     * const rect = new Rectangle();\n     * circle.getBounds(rect);\n     * ```\n     * @param out - Optional Rectangle object to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link Circle.contains} For point containment\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another circle to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Circle(100, 100, 50);\n     * const target = new Circle();\n     * target.copyFrom(source);\n     * ```\n     * @param circle - The circle to copy from\n     * @returns Returns itself\n     * @see {@link Circle.copyTo} For copying to another circle\n     * @see {@link Circle.clone} For creating new circle copy\n     */\n    public copyFrom(circle: Circle): this\n    {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n\n        return this;\n    }\n\n    /**\n     * Copies this circle to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Circle(100, 100, 50);\n     * const target = new Circle();\n     * source.copyTo(target);\n     * ```\n     * @param circle - The circle to copy to\n     * @returns Returns given parameter\n     * @see {@link Circle.copyFrom} For copying from another circle\n     * @see {@link Circle.clone} For creating new circle copy\n     */\n    public copyTo(circle: Circle): Circle\n    {\n        circle.copyFrom(this);\n\n        return circle;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n    // #endif\n}\n","import parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { GraphicsPath } from '../path/GraphicsPath';\n\ninterface SubPath\n{\n    startX: number;\n    startY: number;\n}\n\n/**\n * Parses an SVG path data string and builds a GraphicsPath object from the commands.\n * This function handles all standard SVG path commands including moves, lines, curves and arcs.\n * It maintains state for the current position and subpaths to properly handle relative commands\n * and path closures.\n *\n * Supported SVG commands:\n * - M/m: Move to absolute/relative\n * - L/l: Line to absolute/relative\n * - H/h: Horizontal line absolute/relative\n * - V/v: Vertical line absolute/relative\n * - C/c: Cubic bezier curve absolute/relative\n * - S/s: Smooth cubic bezier curve absolute/relative\n * - Q/q: Quadratic bezier curve absolute/relative\n * - T/t: Smooth quadratic bezier curve absolute/relative\n * - A/a: Arc absolute/relative\n * - Z/z: Close path\n * @param svgPath - The SVG path data string to parse (e.g. \"M0,0 L100,100\")\n * @param path - The GraphicsPath object to build the path into\n * @returns The input path object with the SVG commands applied\n * @internal\n */\nexport function parseSVGPath(svgPath: string, path: GraphicsPath): GraphicsPath\n{\n    // Parse the SVG path string into an array of commands\n    const commands = parse(svgPath);\n\n    // Track subpaths for proper path closure handling\n    const subpaths: SubPath[] = [];\n    let currentSubPath: SubPath | null = null;\n\n    // Track current position for relative commands\n    let lastX = 0;\n    let lastY = 0;\n\n    // Process each command in sequence\n    for (let i = 0; i < commands.length; i++)\n    {\n        const command = commands[i];\n        const type = command[0]; // The command letter\n        const data = command; // The command parameters, 1-based indexed\n\n        switch (type)\n        {\n            case 'M': // Move To (absolute)\n                lastX = data[1];\n                lastY = data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'm': // Move To (relative)\n                lastX += data[1];\n                lastY += data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'H': // Horizontal Line To (absolute)\n                lastX = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'h': // Horizontal Line To (relative)\n                lastX += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'V': // Vertical Line To (absolute)\n                lastY = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'v': // Vertical Line To (relative)\n                lastY += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'L': // Line To (absolute)\n                lastX = data[1];\n                lastY = data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'l': // Line To (relative)\n                lastX += data[1];\n                lastY += data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'C': // Cubic Bezier Curve (absolute)\n                lastX = data[5];\n                lastY = data[6];\n\n                path.bezierCurveTo(\n                    data[1], data[2], // First control point\n                    data[3], data[4], // Second control point\n                    lastX, lastY // End point\n                );\n                break;\n            case 'c': // Cubic Bezier Curve (relative)\n                path.bezierCurveTo(\n                    lastX + data[1], lastY + data[2], // First control point\n                    lastX + data[3], lastY + data[4], // Second control point\n                    lastX + data[5], lastY + data[6] // End point\n                );\n\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case 'S': // Smooth Cubic Bezier Curve (absolute)\n                lastX = data[3];\n                lastY = data[4];\n\n                path.bezierCurveToShort(\n                    data[1], data[2], // Control point\n                    lastX, lastY // End point\n                );\n                break;\n            case 's': // Smooth Cubic Bezier Curve (relative)\n                path.bezierCurveToShort(\n                    lastX + data[1], lastY + data[2], // Control point\n                    lastX + data[3], lastY + data[4], // End point\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'Q': // Quadratic Bezier Curve (absolute)\n                lastX = data[3];\n                lastY = data[4];\n\n                path.quadraticCurveTo(\n                    data[1], data[2], // Control point\n                    lastX, lastY // End point\n                );\n                break;\n            case 'q': // Quadratic Bezier Curve (relative)\n                path.quadraticCurveTo(\n                    lastX + data[1], lastY + data[2], // Control point\n                    lastX + data[3], lastY + data[4] // End point\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'T': // Smooth Quadratic Bezier Curve (absolute)\n                lastX = data[1];\n                lastY = data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY // End point\n                );\n                break;\n            case 't': // Smooth Quadratic Bezier Curve (relative)\n                lastX += data[1];\n                lastY += data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY // End point\n                );\n                break;\n            case 'A': // Arc (absolute)\n                lastX = data[6];\n                lastY = data[7];\n\n                path.arcToSvg(\n                    data[1], // rx\n                    data[2], // ry\n                    data[3], // x-axis-rotation\n                    data[4], // large-arc-flag\n                    data[5], // sweep-flag\n                    lastX, lastY // End point\n                );\n                break;\n            case 'a': // Arc (relative)\n                lastX += data[6];\n                lastY += data[7];\n\n                path.arcToSvg(\n                    data[1], // rx\n                    data[2], // ry\n                    data[3], // x-axis-rotation\n                    data[4], // large-arc-flag\n                    data[5], // sweep-flag\n                    lastX, lastY // End point\n                );\n                break;\n            case 'Z': // Close Path\n            case 'z':\n                path.closePath();\n                if (subpaths.length > 0)\n                {\n                    // Return to the start of the current subpath\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath)\n                    {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    }\n                    else\n                    {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                // #if _DEBUG\n                warn(`Unknown SVG path command: ${type}`);\n                // #endif\n        }\n\n        // Track subpath starts for path closure\n        if (type !== 'Z' && type !== 'z')\n        {\n            if (currentSubPath === null)\n            {\n                currentSubPath = { startX: lastX, startY: lastY };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n\n    return path;\n}\n","import { deprecation } from '../../utils/logging/deprecation';\nimport { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment';\nimport { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { PointData } from '../point/PointData';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nlet tempRect: Rectangle;\nlet tempRect2: Rectangle;\n\n/**\n * A class to define a shape via user defined coordinates.\n * Used for creating complex shapes and hit areas with custom points.\n * @example\n * ```ts\n * // Create polygon from array of points\n * const polygon1 = new Polygon([\n *     new Point(0, 0),\n *     new Point(0, 100),\n *     new Point(100, 100)\n * ]);\n *\n * // Create from array of coordinates\n * const polygon2 = new Polygon([0, 0, 0, 100, 100, 100]);\n *\n * // Create from sequence of points\n * const polygon3 = new Polygon(\n *     new Point(0, 0),\n *     new Point(0, 100),\n *     new Point(100, 100)\n * );\n *\n * // Create from sequence of coordinates\n * const polygon4 = new Polygon(0, 0, 0, 100, 100, 100);\n *\n * // Use as container hit area\n * container.hitArea = new Polygon([0, 0, 100, 0, 50, 100]);\n * ```\n * @see {@link Point} For point objects used in construction\n * @category maths\n * @standard\n */\nexport class Polygon implements ShapePrimitive\n{\n    /**\n     * An array of the points of this polygon stored as a flat array of numbers.\n     * @example\n     * ```ts\n     * // Access points directly\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * console.log(polygon.points); // [0, 0, 100, 0, 50, 100]\n     *\n     * // Modify points\n     * polygon.points[0] = 10; // Move first x coordinate\n     * polygon.points[1] = 10; // Move first y coordinate\n     * ```\n     * @remarks\n     * - Stored as [x1, y1, x2, y2, ...]\n     * - Each pair represents a vertex\n     * - Length is always even\n     * - Can be modified directly\n     */\n    public points: number[];\n\n    /**\n     * Indicates if the polygon path is closed.\n     * @example\n     * ```ts\n     * // Create open polygon\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * polygon.closePath = false;\n     *\n     * // Check path state\n     * if (polygon.closePath) {\n     *     // Last point connects to first\n     * }\n     * ```\n     * @remarks\n     * - True by default\n     * - False after moveTo\n     * - True after closePath\n     * @default true\n     */\n    public closePath: boolean;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Polygon([0, 0, 100, 0, 50, 100]);\n     * console.log(shape.type); // 'polygon'\n     *\n     * // Use in type guards\n     * if (shape.type === 'polygon') {\n     *     // TypeScript knows this is a Polygon\n     *     console.log(shape.points.length);\n     * }\n     * ```\n     * @readonly\n     * @default 'polygon'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'polygon';\n\n    constructor(points: PointData[] | number[]);\n    constructor(...points: PointData[] | number[]);\n    /**\n     * @param points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    constructor(...points: (PointData[] | number[])[] | PointData[] | number[])\n    {\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n\n        // if this is an array of points, convert it to a flat array of numbers\n        if (typeof flat[0] !== 'number')\n        {\n            const p: number[] = [];\n\n            for (let i = 0, il = flat.length; i < il; i++)\n            {\n                p.push((flat[i] as PointData).x, (flat[i] as PointData).y);\n            }\n\n            flat = p;\n        }\n\n        this.points = flat as number[];\n\n        this.closePath = true;\n    }\n\n    /**\n     * Determines whether the polygon's points are arranged in a clockwise direction.\n     * Uses the shoelace formula (surveyor's formula) to calculate the signed area.\n     *\n     * A positive area indicates clockwise winding, while negative indicates counter-clockwise.\n     *\n     * The formula sums up the cross products of adjacent vertices:\n     * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)\n     * The final sum divided by 2 gives the signed area - positive for clockwise.\n     * @example\n     * ```ts\n     * // Check polygon winding\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * console.log(polygon.isClockwise()); // Check direction\n     *\n     * // Use in path construction\n     * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);\n     * if (hole.isClockwise() === shape.isClockwise()) {\n     *     hole.points.reverse(); // Reverse for proper hole winding\n     * }\n     * ```\n     * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise\n     */\n    public isClockwise(): boolean\n    {\n        let area = 0;\n        const points = this.points;\n        const length = points.length;\n\n        for (let i = 0; i < length; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % length];\n            const y2 = points[(i + 3) % length];\n\n            area += (x2 - x1) * (y2 + y1);\n        }\n\n        return area < 0;\n    }\n\n    /**\n     * Checks if this polygon completely contains another polygon.\n     * Used for detecting holes in shapes, like when parsing SVG paths.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square\n     * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside\n     *\n     * outerSquare.containsPolygon(innerSquare); // Returns true\n     * innerSquare.containsPolygon(outerSquare); // Returns false\n     * ```\n     * @remarks\n     * - Uses bounds check for quick rejection\n     * - Tests all points for containment\n     * @param polygon - The polygon to test for containment\n     * @returns True if this polygon completely contains the other polygon\n     * @see {@link Polygon.contains} For single point testing\n     * @see {@link Polygon.getBounds} For bounds calculation\n     */\n    public containsPolygon(polygon: Polygon): boolean\n    {\n    // Quick early-out: bounds check\n        const thisBounds = this.getBounds(tempRect);\n        const otherBounds = polygon.getBounds(tempRect2);\n\n        if (!thisBounds.containsRect(otherBounds))\n        {\n            return false; // If bounds aren't contained, the polygon cannot be a hole\n        }\n\n        // Full point containment check\n        const points = polygon.points;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            // Combine bounds and polygon checks for efficiency\n            if (!this.contains(x, y))\n            {\n                return false;\n            }\n        }\n\n        return true; // All points are contained within bounds and polygon\n    }\n\n    /**\n     * Creates a clone of this polygon.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.points[0] = 10; // Modify first x coordinate\n     * ```\n     * @returns A copy of the polygon\n     * @see {@link Polygon.copyFrom} For copying into existing polygon\n     * @see {@link Polygon.copyTo} For copying to another polygon\n     */\n    public clone(): Polygon\n    {\n        const points = this.points.slice();\n        const polygon = new Polygon(points);\n\n        polygon.closePath = this.closePath;\n\n        return polygon;\n    }\n\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n     * Uses raycasting algorithm for point-in-polygon testing.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const isInside = polygon.contains(25, 25); // true\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this polygon\n     * @see {@link Polygon.strokeContains} For checking stroke intersection\n     * @see {@link Polygon.containsPolygon} For polygon-in-polygon testing\n     */\n    public contains(x: number, y: number): boolean\n    {\n        let inside = false;\n\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        const length = this.points.length / 2;\n\n        for (let i = 0, j = length - 1; i < length; j = i++)\n        {\n            const xi = this.points[i * 2];\n            const yi = this.points[(i * 2) + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[(j * 2) + 1];\n            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = polygon.strokeContains(25, 25, 4, 1);   // Inside\n     * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered\n     * const outerStroke = polygon.strokeContains(25, 25, 4, 0);   // Outside\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coordinates are within this polygon's stroke\n     * @see {@link Polygon.contains} For checking fill containment\n     * @see {@link Polygon.getBounds} For getting stroke bounds\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment = 0.5): boolean\n    {\n        const strokeWidthSquared = strokeWidth * strokeWidth;\n        const rightWidthSquared = strokeWidthSquared * (1 - alignment);\n        const leftWidthSquared = strokeWidthSquared - rightWidthSquared;\n\n        const { points } = this;\n        const iterationLength = points.length - (this.closePath ? 0 : 2);\n\n        for (let i = 0; i < iterationLength; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n\n            const distanceSquared = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n\n            const sign = Math.sign(((x2 - x1) * (y - y1)) - ((y2 - y1) * (x - x1)));\n\n            if (distanceSquared <= (sign < 0 ? leftWidthSquared : rightWidthSquared))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the framing rectangle of the polygon as a Rectangle object.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const bounds = polygon.getBounds();\n     * // bounds: x=0, y=0, width=100, height=100\n     *\n     * // Reuse existing rectangle\n     * const rect = new Rectangle();\n     * polygon.getBounds(rect);\n     * ```\n     * @param out - Optional rectangle to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link Polygon.contains} For checking if a point is inside\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        const points = this.points;\n\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0, n = points.length; i < n; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        out.x = minX;\n        out.width = maxX - minX;\n\n        out.y = minY;\n        out.height = maxY - minY;\n\n        return out;\n    }\n\n    /**\n     * Copies another polygon to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const target = new Polygon();\n     * target.copyFrom(source);\n     * ```\n     * @param polygon - The polygon to copy from\n     * @returns Returns itself\n     * @see {@link Polygon.copyTo} For copying to another polygon\n     * @see {@link Polygon.clone} For creating new polygon copy\n     */\n    public copyFrom(polygon: Polygon): this\n    {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n\n        return this;\n    }\n\n    /**\n     * Copies this polygon to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const target = new Polygon();\n     * source.copyTo(target);\n     * ```\n     * @param polygon - The polygon to copy to\n     * @returns Returns given parameter\n     * @see {@link Polygon.copyFrom} For copying from another polygon\n     * @see {@link Polygon.clone} For creating new polygon copy\n     */\n    public copyTo(polygon: Polygon): Polygon\n    {\n        polygon.copyFrom(this);\n\n        return polygon;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Polygon`\n            + `closeStroke=${this.closePath}`\n            + `points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, '')}]`;\n    }\n    // #endif\n\n    /**\n     * Get the last X coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.lastX); // 300\n     * ```\n     * @readonly\n     * @returns The x-coordinate of the last vertex\n     * @see {@link Polygon.lastY} For last Y coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get lastX(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.lastY); // 400\n     * ```\n     * @readonly\n     * @returns The y-coordinate of the last vertex\n     * @see {@link Polygon.lastX} For last X coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get lastY(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n\n    /**\n     * Get the last X coordinate of the polygon.\n     * @readonly\n     * @deprecated since 8.11.0, use {@link Polygon.lastX} instead.\n     */\n    get x(): number\n    {\n        // #if _DEBUG\n        deprecation('8.11.0', 'Polygon.lastX is deprecated, please use Polygon.lastX instead.');\n        // #endif\n\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon.\n     * @readonly\n     * @deprecated since 8.11.0, use {@link Polygon.lastY} instead.\n     */\n    get y(): number\n    {\n        // #if _DEBUG\n        deprecation('8.11.0', 'Polygon.y is deprecated, please use Polygon.lastY instead.');\n        // #endif\n\n        return this.points[this.points.length - 1];\n    }\n    /**\n     * Get the first X coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.x); // 0\n     * ```\n     * @readonly\n     * @returns The x-coordinate of the first vertex\n     * @see {@link Polygon.startY} For first Y coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get startX(): number\n    {\n        return this.points[0];\n    }\n\n    /**\n     * Get the first Y coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.y); // 0\n     * ```\n     * @readonly\n     * @returns The y-coordinate of the first vertex\n     * @see {@link Polygon.startX} For first X coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get startY(): number\n    {\n        return this.points[1];\n    }\n}\n\n","/**\n * The line cap styles for strokes.\n *\n * It can be:\n * - `butt`: The ends of the stroke are squared off at the endpoints.\n * - `round`: The ends of the stroke are rounded.\n * @category scene\n * @standard\n */\nexport type LineCap = 'butt' | 'round' | 'square';\n/**\n * The line join styles for strokes.\n *\n * It can be:\n * - `round`: The corners of the stroke are rounded.\n * - `bevel`: The corners of the stroke are squared off.\n * - `miter`: The corners of the stroke are extended to meet at a point.\n * @category scene\n * @standard\n */\nexport type LineJoin = 'round' | 'bevel' | 'miter';\n\n/** @internal */\nexport const closePointEps = 1e-4;\n/** @internal */\nexport const curveEps = 0.0001;\n","\nexport default function earcut(data, holeIndices, dim = 2) {\n\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let outerNode = linkedList(data, 0, outerLen, dim, true);\n    const triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    let minX, minY, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = data[0];\n        minY = data[1];\n        let maxX = minX;\n        let maxY = minY;\n\n        for (let i = dim; i < outerLen; i += dim) {\n            const x = data[i];\n            const y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    let last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (let i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    } else {\n        for (let i = end - dim; i >= start; i -= dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    let p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    let stop = ear;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        const prev = ear.prev;\n        const next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            triangles.push(prev.i, ear.i, next.i); // cut off the triangle\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    const a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx),\n        y0 = Math.min(ay, by, cy),\n        x1 = Math.max(ax, bx, cx),\n        y1 = Math.max(ay, by, cy);\n\n    let p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    const a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx),\n        y0 = Math.min(ay, by, cy),\n        x1 = Math.max(ax, bx, cx),\n        y1 = Math.max(ay, by, cy);\n\n    // z-order range for the current triangle bbox;\n    const minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    let p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles) {\n    let p = start;\n    do {\n        const a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i, p.i, b.i);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    let a = start;\n    do {\n        let b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                let c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    const queue = [];\n\n    for (let i = 0, len = holeIndices.length; i < len; i++) {\n        const start = holeIndices[i] * dim;\n        const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        const list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareXYSlope);\n\n    // process holes from left to right\n    for (let i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareXYSlope(a, b) {\n    let result = a.x - b.x;\n    // when the left-most point of 2 holes meet at a vertex, sort the holes counterclockwise so that when we find\n    // the bridge to the outer shell is always the point that they meet at.\n    if (result === 0) {\n        result = a.y - b.y;\n        if (result === 0) {\n            const aSlope = (a.next.y - a.y) / (a.next.x - a.x);\n            const bSlope = (b.next.y - b.y) / (b.next.x - b.x);\n            result = aSlope - bSlope;\n        }\n    }\n    return result;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole(hole, outerNode) {\n    const bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    const bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    let p = outerNode;\n    const hx = hole.x;\n    const hy = hole.y;\n    let qx = -Infinity;\n    let m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    // unless they intersect at a vertex, then choose the vertex\n    if (equals(hole, p)) return p;\n    do {\n        if (equals(hole, p.next)) return p.next;\n        else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    const stop = m;\n    const mx = m.x;\n    const my = m.y;\n    let tanMin = Infinity;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            const tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    let p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    let numMerges;\n    let inSize = 1;\n\n    do {\n        let p = list;\n        let e;\n        list = null;\n        let tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            let q = p;\n            let pSize = 0;\n            for (let i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            let qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    let p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a point lies within a convex triangle but false if its equal to the first point of the triangle\nfunction pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {\n    return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // doesn't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    const o1 = sign(area(p1, q1, p2));\n    const o2 = sign(area(p1, q1, q2));\n    const o3 = sign(area(p2, q2, p1));\n    const o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    let p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    let p = a;\n    let inside = false;\n    const px = (a.x + b.x) / 2;\n    const py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    const a2 = createNode(a.i, a.x, a.y),\n        b2 = createNode(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    const p = createNode(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction createNode(i, x, y) {\n    return {\n        i, // vertex index in coordinates array\n        x, y, // vertex coordinates\n        prev: null, // previous and next vertex nodes in a polygon ring\n        next: null,\n        z: 0, // z-order curve value\n        prevZ: null, // previous and next nodes in z-order\n        nextZ: null,\n        steiner: false // indicates whether this is a steiner point\n    };\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nexport function deviation(data, holeIndices, dim, triangles) {\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    let polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (let i = 0, len = holeIndices.length; i < len; i++) {\n            const start = holeIndices[i] * dim;\n            const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    let trianglesArea = 0;\n    for (let i = 0; i < triangles.length; i += 3) {\n        const a = triangles[i] * dim;\n        const b = triangles[i + 1] * dim;\n        const c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n}\n\nfunction signedArea(data, start, end, dim) {\n    let sum = 0;\n    for (let i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nexport function flatten(data) {\n    const vertices = [];\n    const holes = [];\n    const dimensions = data[0][0].length;\n    let holeIndex = 0;\n    let prevLen = 0;\n\n    for (const ring of data) {\n        for (const p of ring) {\n            for (let d = 0; d < dimensions; d++) vertices.push(p[d]);\n        }\n        if (prevLen) {\n            holeIndex += prevLen;\n            holes.push(holeIndex);\n        }\n        prevLen = ring.length;\n    }\n    return {vertices, holes, dimensions};\n}\n","import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Takes a vertices array and a matrix and transforms the vertices based on the matrix.\n * this out put is written to the uvs array\n * @param vertices - the vertices to calculate uvs from\n * @param verticesStride - the stride of the vertice\n * @param verticesOffset - the offset of the vertices\n * @param uvs - the uvs to fill\n * @param uvsOffset - the offset of the uvs\n * @param uvsStride - the stride of the uvs\n * @param size - the size of the vertices\n * @param matrix - the matrix to apply to the uvs\n * @internal\n */\nexport function buildUvs(\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n\n    size: number,\n    matrix: Matrix = null\n): void\n{\n    let index = 0;\n\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    while (index < size)\n    {\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n\n        uvs[uvsOffset] = (a * x) + (c * y) + tx;\n        uvs[uvsOffset + 1] = (b * x) + (d * y) + ty;\n\n        uvsOffset += uvsStride;\n\n        verticesOffset += verticesStride;\n\n        index++;\n    }\n}\n/**\n * @param uvs\n * @param uvsOffset\n * @param uvsStride\n * @param size\n * @internal\n */\nexport function buildSimpleUvs(\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n    size: number,\n)\n{\n    let index = 0;\n\n    uvsOffset *= uvsStride;\n\n    while (index < size)\n    {\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n\n        uvsOffset += uvsStride;\n\n        index++;\n    }\n}\n","/**\n * @param points\n * @internal\n */\nexport function getOrientationOfPoints(points: number[]): number\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return 1;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if (area < 0)\n    {\n        return -1;\n    }\n\n    return 1;\n}\n","import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Transforms the vertices in an array with the given matrix.\n * @param vertices - the vertices to transform\n * @param m - the matrix to apply to the vertices\n * @param offset - the offset of the vertices (defaults to 0)\n * @param stride - the stride of the vertices (defaults to 2)\n * @param size - the size of the vertices (defaults to vertices.length / stride - offset)\n * @category rendering\n * @internal\n */\nexport function transformVertices(vertices: number[], m: Matrix, offset?: number, stride?: number, size?: number)\n{\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n\n    offset ||= 0;\n    stride ||= 2;\n    size ||= (vertices.length / stride) - offset;\n\n    let index = offset * stride;\n\n    for (let i = 0; i < size; i++)\n    {\n        const x = vertices[index];\n        const y = vertices[index + 1];\n\n        vertices[index] = (a * x) + (c * y) + tx;\n        vertices[index + 1] = (b * x) + (d * y) + ty;\n\n        index += stride;\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Triangle } from '../../../../maths/shapes/Triangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a triangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildTriangle: ShapeBuildCommand<Triangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'triangle',\n    },\n\n    build(shape: Triangle, points: number[]): boolean\n    {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n\n        return true;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n","import { earcut } from '../../../../utils/utils';\n\n/**\n * @param points\n * @param holes\n * @param vertices\n * @param verticesStride\n * @param verticesOffset\n * @param indices\n * @param indicesOffset\n * @internal\n */\nexport function triangulateWithHoles(\n    points: number[],\n    holes: number[],\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    indices: number[],\n    indicesOffset: number\n)\n{\n    const triangles = earcut(points, holes, 2);\n\n    if (!triangles)\n    {\n        return;\n    }\n\n    for (let i = 0; i < triangles.length; i += 3)\n    {\n        indices[indicesOffset++] = (triangles[i] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 1] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 2] + verticesOffset);\n    }\n\n    let index = verticesOffset * verticesStride;\n\n    for (let i = 0; i < points.length; i += 2)\n    {\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n\n        index += verticesStride;\n    }\n}\n\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Circle } from '../../../../maths/shapes/Circle';\nimport type { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport type { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/** @internal */\ntype RoundedShape = Circle | Ellipse | RoundedRectangle;\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @internal\n */\nexport const buildCircle: ShapeBuildCommand<RoundedShape> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'circle',\n    },\n\n    build(shape: RoundedShape, points: number[]): boolean\n    {\n        let x;\n        let y;\n        let dx;\n        let dy;\n\n        let rx;\n        let ry;\n\n        if (shape.type === 'circle')\n        {\n            const circle = shape as Circle;\n\n            rx = ry = circle.radius;\n            if (rx <= 0)\n            {\n                return false;\n            }\n            x = circle.x;\n            y = circle.y;\n            dx = dy = 0;\n        }\n\n        else if (shape.type === 'ellipse')\n        {\n            const ellipse = shape as Ellipse;\n\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            if (rx <= 0 || ry <= 0)\n            { // skip zero ellipse\n                return false;\n            }\n            x = ellipse.x;\n            y = ellipse.y;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (dx < 0 || dy < 0)\n        {\n            return false;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        if (m === 0)\n        {\n            return false;\n        }\n\n        if (n === 0)\n        {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return true;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n\n        if (dy)\n        {\n            const y2 = y - y0;\n\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n\n        if (dx)\n        {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n\n        return true;\n    },\n\n    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset)\n    {\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        // Compute center (average of all points)\n        let centerX = 0; let\n            centerY = 0;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= (points.length / 2);\n        centerY /= (points.length / 2);\n\n        // Set center vertex\n        let count = verticesOffset;\n\n        vertices[count * verticesStride] = centerX;\n        vertices[(count * verticesStride) + 1] = centerY;\n        const centerIndex = count++;\n\n        // Set edge vertices and indices\n        for (let i = 0; i < points.length; i += 2)\n        {\n            vertices[count * verticesStride] = points[i];\n            vertices[(count * verticesStride) + 1] = points[i + 1];\n\n            if (i > 0)\n            { // Skip first point for indices\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n\n        // Connect last point to the first edge point\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n\n};\n\n/** @internal */\nexport const buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: 'ellipse' } };\n/** @internal */\nexport const buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: 'roundedRectangle' } };\n","import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildRectangle: ShapeBuildCommand<Rectangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'rectangle',\n    },\n\n    build(shape: Rectangle, points: number[]): boolean\n    {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        if (!(width > 0 && height > 0))\n        {\n            return false;\n        }\n\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n\n        return true;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        count += verticesStride;\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n\n        // triangle 2\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n","import { closePointEps } from '../const';\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param closed\n * @param vertices\n * @param indices\n * @internal\n */\nexport function buildPixelLine(\n    points: number[],\n    closed: boolean,\n    vertices: number[],\n    indices: number[],\n): void\n{\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    // get first and last point.. figure out the middle!\n\n    const fx = points[0];\n    const fy = points[1];\n\n    const lx = points[points.length - 2];\n\n    const ly = points[points.length - 1];\n\n    const closePath = closed || (Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps);\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    const indexStart = verts.length / 2;\n\n    for (let i = 0; i < length; i++)\n    {\n        verts.push(points[(i * 2)]);\n        verts.push(points[(i * 2) + 1]);\n    }\n\n    for (let i = 0; i < length - 1; i++)\n    {\n        indices.push(indexStart + i, indexStart + i + 1);\n    }\n\n    if (closePath)\n    {\n        indices.push(indexStart + length - 1, indexStart);\n    }\n}\n\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { triangulateWithHoles } from '../utils/triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\nconst emptyArray: number[] = [];\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildPolygon: ShapeBuildCommand<Polygon> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'polygon',\n    },\n\n    build(shape: Polygon, points: number[]): boolean\n    {\n        for (let i = 0; i < shape.points.length; i++)\n        {\n            points[i] = shape.points[i];\n        }\n\n        return true;\n    },\n\n    triangulate(\n        points: number[],\n        //  holes: number[],\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    },\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { multiplyHexColors } from '../../container/utils/multiplyHexColors';\n\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Graphics } from './Graphics';\n\nconst identityMatrix = new Matrix();\n\n/**\n * A batchable graphics object.\n * @ignore\n */\nexport class BatchableGraphics implements DefaultBatchableMeshElement\n{\n    public readonly packAsQuad = false;\n    public batcherName = 'default';\n\n    public texture: Texture;\n\n    public topology: Topology = 'triangle-list';\n    public renderable: Graphics;\n    public indexOffset: number;\n    public indexSize: number;\n    public attributeOffset: number;\n    public attributeSize: number;\n    public baseColor: number;\n    public alpha: number;\n    public applyTransform = true;\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    public geometryData: { vertices: number[]; uvs: number[]; indices: number[]; };\n\n    get uvs()\n    {\n        return this.geometryData.uvs;\n    }\n\n    get positions()\n    {\n        return this.geometryData.vertices;\n    }\n\n    get indices()\n    {\n        return this.geometryData.indices;\n    }\n\n    get blendMode()\n    {\n        if (this.renderable && this.applyTransform)\n        {\n            return this.renderable.groupBlendMode;\n        }\n\n        return 'normal';\n    }\n\n    get color()\n    {\n        const rgb = this.baseColor;\n        const bgr = (rgb >> 16) | (rgb & 0xff00) | ((rgb & 0xff) << 16);\n        const renderable = this.renderable;\n\n        if (renderable)\n        {\n            return multiplyHexColors(bgr, renderable.groupColor)\n            + ((this.alpha * renderable.groupAlpha * 255) << 24);\n        }\n\n        return bgr + ((this.alpha * 255) << 24);\n    }\n\n    get transform()\n    {\n        return this.renderable?.groupTransform || identityMatrix;\n    }\n\n    public copyTo(gpuBuffer: BatchableGraphics)\n    {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n\n        gpuBuffer.attributeOffset = this.attributeOffset;\n        gpuBuffer.attributeSize = this.attributeSize;\n\n        gpuBuffer.baseColor = this.baseColor;\n        gpuBuffer.alpha = this.alpha;\n\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n\n        gpuBuffer.topology = this.topology;\n    }\n\n    public reset()\n    {\n        this.applyTransform = true;\n        this.renderable = null;\n        this.topology = 'triangle-list';\n    }\n\n    public destroy()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this.geometryData = null;\n        this._batcher = null;\n        this._batch = null;\n    }\n}\n","import earcutModule from 'earcut';\n\n/**\n * A high performance event emitter\n * @see {@link https://github.com/primus/eventemitter3}\n * @class EventEmitter\n * @category utils\n */\nexport { default as EventEmitter } from 'eventemitter3';\n\n/**\n * A polygon triangulation library\n * @see {@link https://github.com/mapbox/earcut}\n * @param {number[]} vertices - A flat array of vertex coordinates\n * @param {number[]} [holes] - An array of hole indices\n * @param {number} [dimensions=2] - The number of coordinates per vertex in the input array\n * @returns {number[]} Triangulated polygon\n * @category utils\n * @advanced\n */\nexport const earcut = ((earcutModule as any).default || earcutModule) as typeof earcutModule;\n","import { Point } from '../../../../maths/point/Point';\nimport { closePointEps, curveEps } from '../const';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints';\n\nimport type { StrokeAttributes } from '../FillTypes';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array[]} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: number[],\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param lineStyle\n * @param flipAlignment\n * @param closed\n * @param vertices\n * @param indices\n * @internal\n */\nexport function buildLine(\n    points: number[],\n    lineStyle: StrokeAttributes,\n    flipAlignment: boolean,\n    closed: boolean,\n    vertices: number[],\n    indices: number[],\n): void\n{\n    // const shape = graphicsData.shape as Polygon;\n    //   let points = graphicsData.points || shape.points.slice();\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    const style = lineStyle;\n\n    let alignment = style.alignment;\n\n    if (lineStyle.alignment !== 0.5)\n    {\n        // rotate the points!\n        let orientation = getOrientationOfPoints(points);\n\n        if (flipAlignment)orientation *= -1;\n\n        alignment = ((alignment - 0.5) * orientation) + 0.5;\n    }\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    const ratio = alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x0 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpX * innerWeight),\n                y0 - (perpY * innerWeight),\n                x0 + (perpX * outerWeight),\n                y0 + (perpY * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpX * innerWeight),\n        y0 - (perpY * innerWeight));\n    verts.push(\n        x0 + (perpX * outerWeight),\n        y0 + (perpY * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n\n        dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight));\n            verts.push(\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === 'round')\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pDist is the distance between miter point and p1. */\n        const c1 = ((-perpX + x0) * (-perpY + y1)) - ((-perpX + x1) * (-perpY + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pDist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === 'bevel' || pDist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n            if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === 'miter' && pDist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n\n    dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x1 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight),\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    // const indices = graphicsGeometry.indices;\n    const eps2 = curveEps * curveEps;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { FillGradient } from '../fill/FillGradient';\n\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { FillStyle, StrokeStyle } from '../FillTypes';\n\n/**\n * Temporary matrix used for matrix calculations\n * @internal\n */\nconst tempTextureMatrix = new Matrix();\n\n/**\n * Temporary rectangle used for bounds calculations\n * @internal\n */\nconst tempRect = new Rectangle();\n\n/**\n * Generates a texture matrix for mapping textures onto shapes.\n * This function handles both local and global texture space mapping.\n *\n * In local space, the texture is mapped to fit exactly within the bounds of the shape.\n * In global space, the texture is mapped using its own dimensions and position.\n * @param out - The matrix to store the result in\n * @param style - The fill style containing texture and mapping properties\n * @param shape - The shape to map the texture onto\n * @param matrix - Optional transform matrix to apply\n * @returns The generated texture matrix for UV mapping\n * @example\n * ```ts\n * const matrix = new Matrix();\n * const textureMatrix = generateTextureMatrix(matrix, fillStyle, shape);\n * // textureMatrix now contains the proper UV mapping for the texture\n * ```\n * @internal\n */\nexport function generateTextureMatrix(out: Matrix, style: FillStyle | StrokeStyle, shape: ShapePrimitive, matrix?: Matrix)\n{\n    // Start with either the style's matrix inverted, or identity matrix\n    const textureMatrix = style.matrix\n        ? out.copyFrom(style.matrix).invert()\n        : out.identity();\n\n    if (style.textureSpace === 'local')\n    {\n        // For local space, map texture to shape's bounds\n        const bounds = shape.getBounds(tempRect);\n\n        if ((style as StrokeStyle).width)\n        {\n            bounds.pad((style as StrokeStyle).width);\n        }\n\n        const { x: tx, y: ty } = bounds;\n        const sx = 1 / bounds.width;\n        const sy = 1 / bounds.height;\n\n        const mTx = -tx * sx;\n        const mTy = -ty * sy;\n\n        const a1 = textureMatrix.a;\n        const b1 = textureMatrix.b;\n        const c1 = textureMatrix.c;\n        const d1 = textureMatrix.d;\n\n        textureMatrix.a *= sx;\n        textureMatrix.b *= sx;\n        textureMatrix.c *= sy;\n        textureMatrix.d *= sy;\n\n        textureMatrix.tx = (mTx * a1) + (mTy * c1) + textureMatrix.tx;\n        textureMatrix.ty = (mTx * b1) + (mTy * d1) + textureMatrix.ty;\n    }\n    else\n    {\n        // For global space, use texture's own dimensions\n        textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);\n        textureMatrix.scale(1 / (style.texture.source.width), 1 / (style.texture.source.height));\n    }\n\n    const sourceStyle = style.texture.source.style;\n\n    // we don't want to set the address mode if the fill is a gradient as this handles its own address mode\n    if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === 'clamp-to-edge')\n    {\n        sourceStyle.addressMode = 'repeat';\n        sourceStyle.update();\n    }\n\n    // Apply any additional transform matrix\n    if (matrix)\n    {\n        textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());\n    }\n\n    return textureMatrix;\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { type BatcherOptions } from '../../../rendering/batcher/shared/Batcher';\nimport { DefaultBatcher } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash';\nimport { deprecation, v8_3_4 } from '../../../utils/logging/deprecation';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { type GPUData } from '../../view/ViewContainer';\nimport { buildContextBatches } from './utils/buildContextBatches';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { BatchableGraphics } from './BatchableGraphics';\nimport type { GraphicsContext } from './GraphicsContext';\n\ninterface GeometryData\n{\n    vertices: number[];\n    uvs: number[];\n    indices: number[];\n}\n\n/**\n * A class that holds batchable graphics data for a GraphicsContext.\n * @category rendering\n * @ignore\n */\nexport class GpuGraphicsContext implements GPUData\n{\n    public isBatchable: boolean;\n    public context: GraphicsContext;\n\n    public batches: BatchableGraphics[] = [];\n    public geometryData: GeometryData = {\n        vertices: [],\n        uvs: [],\n        indices: [],\n    };\n    public graphicsData: GraphicsContextRenderData;\n\n    public reset()\n    {\n        if (this.batches)\n        {\n            this.batches.forEach((batch) =>\n            {\n                BigPool.return(batch);\n            });\n        }\n        if (this.graphicsData)\n        {\n            BigPool.return(this.graphicsData);\n        }\n\n        this.isBatchable = false;\n        this.context = null;\n\n        this.batches.length = 0;\n        this.geometryData.indices.length = 0;\n        this.geometryData.vertices.length = 0;\n        this.geometryData.uvs.length = 0;\n\n        this.graphicsData = null;\n    }\n\n    public destroy()\n    {\n        this.reset();\n        this.batches = null;\n        this.geometryData = null;\n    }\n}\n\n/**\n * A class that holds the render data for a GraphicsContext.\n * @category rendering\n * @ignore\n */\nexport class GraphicsContextRenderData\n{\n    public batcher: DefaultBatcher;\n    public instructions = new InstructionSet();\n\n    public init(options: BatcherOptions)\n    {\n        const maxTextures = options.maxTextures;\n\n        this.batcher ? this.batcher._updateMaxTextures(maxTextures) : this.batcher = new DefaultBatcher({ maxTextures });\n        this.instructions.reset();\n    }\n\n    /**\n     * @deprecated since version 8.0.0\n     * Use `batcher.geometry` instead.\n     * @see {Batcher#geometry}\n     */\n    get geometry()\n    {\n        // #if _DEBUG\n        deprecation(v8_3_4, 'GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.');\n        // #endif\n\n        return this.batcher.geometry;\n    }\n\n    public destroy()\n    {\n        this.batcher.destroy();\n        this.instructions.destroy();\n\n        this.batcher = null;\n        this.instructions = null;\n    }\n}\n\n/**\n * Options for the GraphicsContextSystem.\n * @category rendering\n * @advanced\n */\nexport interface GraphicsContextSystemOptions\n{\n    /** A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother) */\n    bezierSmoothness?: number;\n}\n\n/**\n * A system that manages the rendering of GraphicsContexts.\n * @category rendering\n * @advanced\n */\nexport class GraphicsContextSystem implements System<GraphicsContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'graphicsContext'\n    } as const;\n\n    /** The default options for the GraphicsContextSystem. */\n    public static readonly defaultOptions: GraphicsContextSystemOptions = {\n        /**\n         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n         * @default 0.5\n         */\n        bezierSmoothness: 0.5,\n    };\n\n    private readonly _renderer: Renderer;\n    private readonly _managedContexts: GCManagedHash<GraphicsContext>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._managedContexts = new GCManagedHash({ renderer, type: 'resource', name: 'graphicsContext' });\n    }\n\n    /**\n     * Runner init called, update the default options\n     * @ignore\n     */\n    public init(options?: GraphicsContextSystemOptions)\n    {\n        GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness\n            ?? GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n\n    /**\n     * Returns the render data for a given GraphicsContext.\n     * @param context - The GraphicsContext to get the render data for.\n     * @internal\n     */\n    public getContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        return context._gpuData[this._renderer.uid].graphicsData || this._initContextRenderData(context);\n    }\n\n    /**\n     * Updates the GPU context for a given GraphicsContext.\n     * If the context is dirty, it will rebuild the batches and geometry data.\n     * @param context - The GraphicsContext to update.\n     * @returns The updated GpuGraphicsContext.\n     * @internal\n     */\n    public updateGpuContext(context: GraphicsContext)\n    {\n        const hasContext = !!context._gpuData[this._renderer.uid];\n        const gpuContext: GpuGraphicsContext = context._gpuData[this._renderer.uid] || this._initContext(context);\n\n        if (context.dirty || !hasContext)\n        {\n            if (hasContext)\n            {\n                gpuContext.reset();\n            }\n\n            buildContextBatches(context, gpuContext);\n\n            const batchMode = context.batchMode;\n\n            if (context.customShader || batchMode === 'no-batch')\n            {\n                gpuContext.isBatchable = false;\n            }\n            else if (batchMode === 'auto')\n            {\n                gpuContext.isBatchable = (gpuContext.geometryData.vertices.length < 400);\n            }\n            else\n            {\n                gpuContext.isBatchable = true;\n            }\n\n            context.dirty = false;\n        }\n\n        return gpuContext;\n    }\n\n    /**\n     * Returns the GpuGraphicsContext for a given GraphicsContext.\n     * If it does not exist, it will initialize a new one.\n     * @param context - The GraphicsContext to get the GpuGraphicsContext for.\n     * @returns The GpuGraphicsContext for the given GraphicsContext.\n     * @internal\n     */\n    public getGpuContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        return context._gpuData[this._renderer.uid] || this._initContext(context);\n    }\n\n    private _initContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        const graphicsData: GraphicsContextRenderData = BigPool.get(GraphicsContextRenderData, {\n            maxTextures: this._renderer.limits.maxBatchableTextures,\n        });\n\n        const gpuContext = context._gpuData[this._renderer.uid];\n        const { batches, geometryData } = gpuContext;\n\n        gpuContext.graphicsData = graphicsData;\n\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            batches[i].applyTransform = false;\n        }\n\n        const batcher = graphicsData.batcher;\n\n        // TODO we can pool buffers here eventually..\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n\n        batcher.begin();\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batcher.add(batch);\n        }\n\n        batcher.finish(graphicsData.instructions);\n\n        const geometry = batcher.geometry;\n\n        // not to self - this works as we are assigning the batchers array buffer\n        // once its up loaded - this buffer is then put back in the pool to be reused.\n        // this mean we don't have to creating new Batchers for each graphics items\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n\n        const drawBatches = batcher.batches;\n\n        for (let i = 0; i < drawBatches.length; i++)\n        {\n            const batch = drawBatches[i];\n\n            batch.bindGroup = getTextureBatchBindGroup(\n                batch.textures.textures,\n                batch.textures.count,\n                this._renderer.limits.maxBatchableTextures\n            );\n        }\n\n        return graphicsData;\n    }\n\n    private _initContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        const gpuContext = new GpuGraphicsContext();\n\n        gpuContext.context = context;\n\n        context._gpuData[this._renderer.uid] = gpuContext;\n\n        this._managedContexts.add(context);\n\n        return gpuContext;\n    }\n\n    public destroy()\n    {\n        this._managedContexts.destroy();\n        (this._renderer as null) = null;\n    }\n}\n","import { Color } from '../../../../color/Color';\nimport { DOMAdapter } from '../../../../environment/adapter';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { type WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation } from '../../../../utils/logging/deprecation';\nimport { definedProps } from '../../../container/utils/definedProps';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { CanvasAndContext } from '../../../../rendering/renderers/shared/texture/CanvasPool';\nimport type { TextureSpace } from '../FillTypes';\n\n/**\n * Defines the type of gradient to create.\n *\n * It can be:\n * - 'linear': A linear gradient that transitions colors along a straight line.\n * - 'radial': A radial gradient that transitions colors in a circular pattern from an inner circle to an outer circle.\n * @category scene\n * @standard\n */\nexport type GradientType = 'linear' | 'radial';\n\n/**\n * Represents the style options for a linear gradient fill.\n * @category scene\n * @standard\n */\nexport interface BaseGradientOptions\n{\n    /** The type of gradient */\n    type?: GradientType;\n    /** Array of colors stops to use in the gradient */\n    colorStops?: { offset: number, color: ColorSource }[];\n    /** Whether coordinates are 'global' or 'local' */\n    textureSpace?: TextureSpace;\n    /**\n     * The size of the texture to use for the gradient - this is for advanced usage.\n     * The texture size does not need to match the size of the object being drawn.\n     * Due to GPU interpolation, gradient textures can be relatively small!\n     * Consider using a larger texture size if your gradient has a lot of very tight color steps\n     */\n    textureSize?: number;\n    /**\n     * The wrap mode of the gradient.\n     * This can be 'clamp-to-edge' or 'repeat'.\n     * @default 'clamp-to-edge'\n     */\n    wrapMode?: WRAP_MODE\n}\n\n/**\n * Options specific to linear gradients.\n * A linear gradient creates a smooth transition between colors along a straight line defined by start and end points.\n * @category scene\n * @standard\n */\nexport interface LinearGradientOptions extends BaseGradientOptions\n{\n    /** The type of gradient. Must be 'linear' for linear gradients. */\n    type?: 'linear';\n\n    /**\n     * The start point of the gradient.\n     * This point defines where the gradient begins.\n     * It is represented as a PointData object containing x and y coordinates.\n     * The coordinates are in local space by default (0-1), but can be in global space if specified.\n     */\n    start?: PointData;\n\n    /**\n     * The end point of the gradient.\n     * This point defines where the gradient ends.\n     * It is represented as a PointData object containing x and y coordinates.\n     * The coordinates are in local space by default (0-1), but can be in global space if specified.\n     */\n    end?: PointData;\n}\n\n/**\n * Options specific to radial gradients.\n * A radial gradient creates a smooth transition between colors that radiates outward in a circular pattern.\n * The gradient is defined by inner and outer circles, each with their own radius.\n * @category scene\n * @standard\n */\nexport interface RadialGradientOptions extends BaseGradientOptions\n{\n    /** The type of gradient. Must be 'radial' for radial gradients. */\n    type?: 'radial';\n    /** The center point of the inner circle where the gradient begins. In local coordinates by default (0-1). */\n    center?: PointData;\n    /** The radius of the inner circle where the gradient begins. */\n    innerRadius?: number;\n    /** The center point of the outer circle where the gradient ends. In local coordinates by default (0-1). */\n    outerCenter?: PointData;\n    /** The radius of the outer circle where the gradient ends. */\n    outerRadius?: number;\n    /**\n     * The y scale of the gradient, use this to make the gradient elliptical.\n     * NOTE: Only applied to radial gradients used with Graphics.\n     */\n    scale?: number;\n    /**\n     * The rotation of the gradient in radians, useful for making the gradient elliptical.\n     * NOTE: Only applied to radial gradients used with Graphics.\n     */\n    rotation?: number;\n}\n\n/**\n * Options for creating a gradient fill.\n * @category scene\n * @standard\n */\nexport type GradientOptions = LinearGradientOptions | RadialGradientOptions;\n\n/**\n * If no color stops are provided, we use a default gradient of white to black - this is to avoid a blank gradient if a dev\n * forgets to set them.\n */\nconst emptyColorStops: { offset: number, color: string }[] = [{ offset: 0, color: 'white' }, { offset: 1, color: 'black' }];\n\n/**\n * Class representing a gradient fill that can be used to fill shapes and text.\n * Supports both linear and radial gradients with multiple color stops.\n *\n * For linear gradients, color stops define colors and positions (0 to 1) along a line from start point (x0,y0)\n * to end point (x1,y1).\n *\n * For radial gradients, color stops define colors between two circles - an inner circle centered at (x0,y0) with radius r0,\n * and an outer circle centered at (x1,y1) with radius r1.\n * @example\n * ```ts\n * // Create a vertical linear gradient from red to blue\n * const linearGradient = new FillGradient({\n *     type: 'linear',\n *     start: { x: 0, y: 0 },  // Start at top\n *     end: { x: 0, y: 1 },    // End at bottom\n *     colorStops: [\n *         { offset: 0, color: 'red' },   // Red at start\n *         { offset: 1, color: 'blue' }   // Blue at end\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n *\n * // Create a radial gradient from yellow center to green edge\n * const radialGradient = new FillGradient({\n *     type: 'radial',\n *     center: { x: 0.5, y: 0.5 },\n *     innerRadius: 0,\n *     outerCenter: { x: 0.5, y: 0.5 },\n *     outerRadius: 0.5,\n *     colorStops: [\n *         { offset: 0, color: 'yellow' }, // Center color\n *         { offset: 1, color: 'green' }   // Edge color\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n *\n * // Create a rainbow linear gradient in global coordinates\n * const globalGradient = new FillGradient({\n *     type: 'linear',\n *     start: { x: 0, y: 0 },\n *     end: { x: 100, y: 0 },\n *     colorStops: [\n *         { offset: 0, color: 0xff0000 },    // Red\n *         { offset: 0.33, color: 0x00ff00 }, // Green\n *         { offset: 0.66, color: 0x0000ff }, // Blue\n *         { offset: 1, color: 0xff00ff }     // Purple\n *     ],\n *     textureSpace: 'global'  // Use world coordinates\n * });\n *\n * // Create an offset radial gradient\n * const offsetRadial = new FillGradient({\n *     type: 'radial',\n *     center: { x: 0.3, y: 0.3 },\n *     innerRadius: 0.1,\n *     outerCenter: { x: 0.5, y: 0.5 },\n *     outerRadius: 0.5,\n *     colorStops: [\n *         { offset: 0, color: 'white' },\n *         { offset: 1, color: 'black' }\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n * ```\n *\n * Internally this creates a  texture of the gradient then applies a\n * transform to it to give it the correct size and angle.\n *\n * This means that it's important to destroy a gradient when it is no longer needed\n * to avoid memory leaks.\n *\n * If you want to animate a gradient then it's best to modify and update an existing one\n * rather than creating a whole new one each time. That or use a custom shader.\n * @category scene\n * @standard\n */\nexport class FillGradient implements CanvasGradient\n{\n    /** Default options for creating a gradient fill */\n    public static readonly defaultLinearOptions: LinearGradientOptions = {\n        start: { x: 0, y: 0 },\n        end: { x: 0, y: 1 },\n        colorStops: [],\n        textureSpace: 'local',\n        type: 'linear',\n        textureSize: 256,\n        wrapMode: 'clamp-to-edge'\n    };\n\n    /** Default options for creating a radial gradient fill */\n    public static readonly defaultRadialOptions: RadialGradientOptions = {\n        center: { x: 0.5, y: 0.5 },\n        innerRadius: 0,\n        outerRadius: 0.5,\n        colorStops: [],\n        scale: 1,\n        textureSpace: 'local',\n        type: 'radial',\n        textureSize: 256,\n        wrapMode: 'clamp-to-edge'\n    };\n\n    /**\n     * Unique identifier for this gradient instance\n     * @internal\n     */\n    public readonly uid: number = uid('fillGradient');\n    /**\n     * Internal tick counter to track changes in the gradient.\n     * This is used to invalidate the gradient when the texture changes.\n     * @internal\n     */\n    public _tick: number = 0;\n    /** Type of gradient - currently only supports 'linear' */\n    public readonly type: GradientType = 'linear';\n\n    /** Internal texture used to render the gradient */\n    public texture: Texture;\n    /** Transform matrix for positioning the gradient */\n    public transform: Matrix;\n    /** Array of color stops defining the gradient */\n    public colorStops: Array<{ offset: number, color: string }> = [];\n\n    /** Whether gradient coordinates are in local or global space */\n    public textureSpace: TextureSpace;\n    private readonly _textureSize: number;\n\n    /** The start point of the linear gradient */\n    public start: PointData;\n    /** The end point of the linear gradient */\n    public end: PointData;\n    /** The wrap mode of the gradient texture */\n    private readonly _wrapMode: WRAP_MODE;\n\n    /** The center point of the inner circle of the radial gradient */\n    public center: PointData;\n    /** The center point of the outer circle of the radial gradient */\n    public outerCenter: PointData;\n    /** The radius of the inner circle of the radial gradient */\n    public innerRadius: number;\n    /** The radius of the outer circle of the radial gradient */\n    public outerRadius: number;\n    /** The scale of the radial gradient */\n    public scale: number;\n    /** The rotation of the radial gradient */\n    public rotation: number;\n\n    /**\n     * Creates a new gradient fill. The constructor behavior changes based on the gradient type.\n     * @param {GradientOptions} options - The options for the gradient\n     * @see {@link LinearGradientOptions}\n     * @see {@link RadialGradientOptions}\n     */\n    constructor(options: GradientOptions);\n    /**\n     * Deprecated: Use the options object instead.\n     * @deprecated since 8.5.2\n     * @ignore\n     */\n    constructor(\n        x0?: number,\n        y0?: number,\n        x1?: number,\n        y1?: number,\n        textureSpace?: TextureSpace,\n        textureSize?: number\n    );\n    constructor(...args: [GradientOptions] | [number?, number?, number?, number?, TextureSpace?, number?])\n    {\n        let options = ensureGradientOptions(args);\n\n        const defaults = options.type === 'radial' ? FillGradient.defaultRadialOptions : FillGradient.defaultLinearOptions;\n\n        options = { ...defaults, ...definedProps(options) };\n\n        this._textureSize = options.textureSize;\n        this._wrapMode = options.wrapMode;\n\n        if (options.type === 'radial')\n        {\n            this.center = options.center;\n            this.outerCenter = options.outerCenter ?? this.center;\n            this.innerRadius = options.innerRadius;\n            this.outerRadius = options.outerRadius;\n            this.scale = options.scale;\n            this.rotation = options.rotation;\n        }\n        else\n        {\n            this.start = options.start;\n            this.end = options.end;\n        }\n\n        this.textureSpace = options.textureSpace;\n\n        this.type = options.type;\n        options.colorStops.forEach((stop) =>\n        {\n            this.addColorStop(stop.offset, stop.color);\n        });\n    }\n\n    /**\n     * Adds a color stop to the gradient\n     * @param offset - Position of the stop (0-1)\n     * @param color - Color of the stop\n     * @returns This gradient instance for chaining\n     */\n    public addColorStop(offset: number, color: ColorSource): this\n    {\n        this.colorStops.push({ offset, color: Color.shared.setValue(color).toHexa() });\n\n        return this;\n    }\n\n    /**\n     * Builds the internal texture and transform for the gradient.\n     * Called automatically when the gradient is first used.\n     * @internal\n     */\n    public buildLinearGradient(): void\n    {\n        if (this.texture) return;\n\n        let { x: x0, y: y0 } = this.start;\n        let { x: x1, y: y1 } = this.end;\n\n        let dx = x1 - x0;\n        let dy = y1 - y0;\n\n        // Determine flip based on original dx/dy and swap coordinates if necessary\n        const flip = dx < 0 || dy < 0;\n\n        if (this._wrapMode === 'clamp-to-edge')\n        {\n            if (dx < 0)\n            {\n                const temp = x0;\n\n                x0 = x1;\n                x1 = temp;\n                dx *= -1;\n            }\n            if (dy < 0)\n            {\n                const temp = y0;\n\n                y0 = y1;\n                y1 = temp;\n                dy *= -1;\n            }\n        }\n\n        const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;\n\n        const defaultSize = this._textureSize;\n\n        const { canvas, context } = getCanvas(defaultSize, 1);\n\n        const gradient = !flip\n            ? context.createLinearGradient(0, 0, this._textureSize, 0)\n            : context.createLinearGradient(this._textureSize, 0, 0, 0);\n\n        addColorStops(gradient, colorStops);\n\n        context.fillStyle = gradient;\n        context.fillRect(0, 0, defaultSize, 1);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressMode: this._wrapMode,\n            }),\n        });\n\n        // generate some UVS based on the gradient direction sent\n\n        const dist = Math.sqrt((dx * dx) + (dy * dy));\n        const angle = Math.atan2(dy, dx);\n\n        // little offset to stop the uvs from flowing over the edge..\n        // this matrix is inverted when used in the graphics\n        // add a tiny off set to prevent uv bleeding..\n        const m = new Matrix();\n\n        m.scale((dist / defaultSize), 1);\n        m.rotate(angle);\n        m.translate(x0, y0);\n\n        if (this.textureSpace === 'local')\n        {\n            m.scale(defaultSize, defaultSize);\n        }\n        this.transform = m;\n    }\n\n    /**\n     * Builds the internal texture and transform for the gradient.\n     * Called automatically when the gradient is first used.\n     * @internal\n     */\n    public buildGradient(): void\n    {\n        if (!this.texture) this._tick++;\n        if (this.type === 'linear')\n        {\n            this.buildLinearGradient();\n        }\n        else\n        {\n            this.buildRadialGradient();\n        }\n    }\n\n    /**\n     * Builds the internal texture and transform for the radial gradient.\n     * Called automatically when the gradient is first used.\n     * @internal\n     */\n    public buildRadialGradient(): void\n    {\n        if (this.texture) return;\n\n        const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;\n\n        const defaultSize = this._textureSize;\n        const { canvas, context } = getCanvas(defaultSize, defaultSize);\n\n        const { x: x0, y: y0 } = this.center;\n        const { x: x1, y: y1 } = this.outerCenter;\n\n        const r0 = this.innerRadius;\n        const r1 = this.outerRadius;\n\n        const ox = x1 - r1;\n        const oy = y1 - r1;\n\n        const scale = defaultSize / (r1 * 2);\n\n        const cx = (x0 - ox) * scale;\n        const cy = (y0 - oy) * scale;\n\n        const gradient = context.createRadialGradient(\n            cx,\n            cy,\n            r0 * scale,\n            (x1 - ox) * scale,\n            (y1 - oy) * scale,\n            r1 * scale\n        );\n\n        addColorStops(gradient, colorStops);\n\n        context.fillStyle = colorStops[colorStops.length - 1].color;\n        context.fillRect(0, 0, defaultSize, defaultSize);\n\n        context.fillStyle = gradient;\n\n        // First translate to center\n        context.translate(cx, cy);\n\n        // Then apply rotation\n        context.rotate(this.rotation);\n\n        // Then scale2\n        context.scale(1, this.scale);\n\n        // Finally translate back, taking scale into account\n        context.translate(-cx, -cy);\n\n        context.fillRect(0, 0, defaultSize, defaultSize);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressMode: this._wrapMode,\n            }),\n        });\n\n        const m = new Matrix();\n\n        // this matrix is inverted when used in the graphics\n        m.scale(1 / scale, 1 / scale);\n        m.translate(ox, oy);\n\n        if (this.textureSpace === 'local')\n        {\n            m.scale(defaultSize, defaultSize);\n        }\n\n        this.transform = m;\n    }\n\n    /** Destroys the gradient, releasing resources. This will also destroy the internal texture. */\n    public destroy(): void\n    {\n        this.texture?.destroy(true);\n        this.texture = null;\n        this.transform = null;\n        this.colorStops = [];\n        this.start = null;\n        this.end = null;\n        this.center = null;\n        this.outerCenter = null;\n    }\n\n    /**\n     * Returns a unique key for this gradient instance.\n     * This key is used for caching and texture management.\n     * @returns {string} Unique key for the gradient\n     */\n    public get styleKey(): string\n    {\n        return `fill-gradient-${this.uid}-${this._tick}`;\n    }\n}\n\nfunction addColorStops(gradient: CanvasGradient, colorStops: { offset: number, color: string }[]): void\n{\n    for (let i = 0; i < colorStops.length; i++)\n    {\n        const stop = colorStops[i];\n\n        gradient.addColorStop(stop.offset, stop.color);\n    }\n}\n\nfunction getCanvas(width: number, height: number): CanvasAndContext\n{\n    const canvas = DOMAdapter.get().createCanvas(width, height);\n    const context = canvas.getContext('2d');\n\n    return { canvas, context };\n}\n\n/**\n * Helper function to ensure consistent handling of gradient options.\n * This function handles both the new options object format and the deprecated parameter format.\n * @example\n * // New recommended way:\n * const options = ensureGradientOptions({\n *     start: { x: 0, y: 0 },\n *     end: { x: 100, y: 100 },\n *     textureSpace: 'local'\n * });\n *\n * // Deprecated way (will show warning in debug):\n * const options = ensureGradientOptions([0, 0, 100, 100, 'local']);\n * @param args - Arguments passed to gradient constructor\n * @returns Normalized gradient options object\n * @internal\n */\nfunction ensureGradientOptions(\n    args: any[],\n): GradientOptions\n{\n    let options = (args[0] ?? {}) as GradientOptions;\n\n    // @deprecated\n    if (typeof options === 'number' || args[1])\n    {\n        // #if _DEBUG\n        deprecation('8.5.2', `use options object instead`);\n        // #endif\n\n        options = {\n            type: 'linear',\n            start: { x: args[0], y: args[1] },\n            end: { x: args[2], y: args[3] },\n            textureSpace: args[4] as 'global' | 'local',\n            textureSize: args[5] ?? FillGradient.defaultLinearOptions.textureSize\n        };\n    }\n\n    return options;\n}\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPixelLine } from '../buildCommands/buildPixelLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { generateTextureMatrix as generateTextureFillMatrix } from './generateTextureFillMatrix';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { Topology } from '../../../../rendering/renderers/shared/geometry/const';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../FillTypes';\nimport type { GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { ShapePath, ShapePrimitiveWithHoles } from '../path/ShapePath';\n\n/**\n * A record of shape builders, keyed by shape type.\n * @category scene\n * @advanced\n */\nexport const shapeBuilders: Record<string, ShapeBuildCommand> = {};\n\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\n\nconst tempRect = new Rectangle();\nconst tempTextureMatrix = new Matrix();\n\n/**\n * @param context\n * @param gpuContext\n * @internal\n */\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);\n            }\n\n            if (hole)\n            {\n                // add the holes to the last shape primitive\n                shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;\n            }\n\n            addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const points: number[] = [];\n\n    const build = shapeBuilders.rectangle;\n\n    const rect = tempRect;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    if (!build.build(rect, points))\n    {\n        return;\n    }\n\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const texture = data.image;\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.baseColor = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle | ConvertedStrokeStyle,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) =>\n    {\n        const points: number[] = [];\n        const build = shapeBuilders[shape.type];\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n\n        if (!build.build(shape, points))\n        {\n            return;\n        }\n\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n        let topology: Topology = 'triangle-list';\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (holes)\n            {\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(holes);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style as ConvertedStrokeStyle;\n\n            if (!lineStyle.pixelLine)\n            {\n                buildLine(points, lineStyle, false, close, vertices, indices);\n            }\n            else\n            {\n                buildPixelLine(points, close, vertices, indices);\n                topology = 'line-list';\n            }\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = generateTextureFillMatrix(tempTextureMatrix, style, shape, matrix);\n\n            buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.attributeOffset = vertOffset;\n        graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.baseColor = style.color;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n        graphicsBatch.topology = topology;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(holePrimitives: ShapePrimitiveWithHoles[])\n{\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = shapeBuilders[holePrimitive.type] as ShapeBuildCommand;\n\n        if (holeBuilder.build(holePrimitive, holePoints))\n        {\n            holeArrays.push(holePoints);\n        }\n    }\n\n    return holeArrays;\n}\n","import type {\n    FillInstruction,\n    GraphicsContext,\n} from '../../GraphicsContext';\n\n/**\n * Determines if subpaths represent nested shapes or multiple holes pattern.\n * @param subpathsWithArea - Array of subpaths with their calculated areas\n * @returns True if nested pattern, false if multiple holes pattern\n * @internal\n */\nexport function checkForNestedPattern(subpathsWithArea: Array<{path: string, area: number}>): boolean\n{\n    if (subpathsWithArea.length <= 2)\n    {\n        return true;\n    }\n\n    const areas = subpathsWithArea.map((s) => s.area).sort((a, b) => b - a);\n\n    const [largestArea, secondArea] = areas;\n    const smallestArea = areas[areas.length - 1];\n\n    const largestToSecondRatio = largestArea / secondArea;\n    const secondToSmallestRatio = secondArea / smallestArea;\n\n    // If the largest shape is significantly bigger than the second (3x+)\n    // AND the smaller shapes are similar in size (2x or less difference),\n    // it suggests multiple holes pattern rather than nested shapes\n    if (largestToSecondRatio > 3 && secondToSmallestRatio < 2)\n    {\n        return false; // Multiple holes\n    }\n\n    return true; // Default to nested\n}\n\n/**\n * Gets fill instruction data from a graphics context.\n * @param context - The graphics context\n * @param index - Index of the fill instruction (default: 0)\n * @returns The fill instruction data\n * @throws Error if instruction at index is not a fill instruction\n * @internal\n */\nexport function getFillInstructionData(context: GraphicsContext, index: number = 0)\n{\n    const instruction = context.instructions[index];\n\n    if (!instruction || instruction.action !== 'fill')\n    {\n        throw new Error(`Expected fill instruction at index ${index}, got ${instruction?.action || 'undefined'}`);\n    }\n\n    return (instruction as FillInstruction).data;\n}\n","/**\n * @param points\n * @param x\n * @param y\n * @param radius\n * @param start\n * @param end\n * @param clockwise\n * @param steps\n * @internal\n */\nexport function buildArc(\n    points: number[],\n    x: number, y: number,\n    radius: number,\n    start: number,\n    end: number,\n    clockwise: boolean,\n    steps?: number\n)\n{\n    // determine distance between the two angles\n    // ...probably a nicer way of writing this\n    let dist = Math.abs(start - end);\n\n    if (!clockwise && start > end)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n    else if (clockwise && end > start)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n\n    // approximate the # of steps using the cube root of the radius\n\n    steps ||= Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / (Math.PI))));\n\n    // ensure we have at least 3 steps..\n    steps = Math.max(steps, 3);\n\n    let f = dist / (steps);\n    let t = start;\n\n    // modify direction\n    f *= clockwise ? -1 : 1;\n\n    for (let i = 0; i < steps + 1; i++)\n    {\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n\n        const nx = x + (cs * radius);\n        const ny = y + (sn * radius);\n\n        points.push(nx, ny);\n\n        t += f;\n    }\n}\n","import type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePath } from './ShapePath';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeArc(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number\n): void\n{\n    const vecFrom = (p: PointData, pp: PointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: PointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\n/**\n * Data structure for points with optional radius.\n * @category scene\n * @standard\n */\nexport type RoundedPoint = PointData & { radius?: number };\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeQuadraticCurve(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number,\n    smoothness?: number,\n): void\n{\n    const distance = (p1: PointData, p2: PointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: PointData, p2: PointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n","/**\n * Extracts the ID from an SVG url() reference.\n *\n * This function handles all valid SVG url() formats including:\n * - url(#id)\n * - url('#id')\n * - url(\"#id\")\n * - url( #id )\n * - url( '#id' )\n * - url( \"#id\" )\n *\n * The regex pattern matches:\n * - url followed by optional whitespace\n * - opening parenthesis followed by optional whitespace\n * - optional single or double quotes with optional whitespace\n * - # followed by the ID (any chars except quotes, whitespace, or closing paren)\n * - optional single or double quotes with optional whitespace\n * - closing parenthesis\n * @param url - The SVG url() string to parse\n * @returns The extracted ID string, or empty string if no valid ID found\n * @internal\n */\nexport function extractSvgUrlId(url: string): string\n{\n    // Handle all valid SVG url() formats\n    const match = url.match(/url\\s*\\(\\s*['\"]?\\s*#([^'\"\\s)]+)\\s*['\"]?\\s*\\)/i);\n\n    return match ? match[1] : '';\n}\n","/**\n * Parses a float value from an SVG element's attribute.\n * This is commonly used for parsing numeric attributes like coordinates, dimensions,\n * and other measurements from SVG elements.\n * @param svg - The SVG element to get the attribute from\n * @param id - The name of the attribute to parse (e.g. 'x', 'y', 'width', etc)\n * @param defaultValue - The value to return if the attribute doesn't exist or can't be parsed\n * @returns The parsed float value, or the default value if parsing fails\n * @example\n * // For SVG: <rect x=\"10.5\" width=\"20\"/>\n * parseSVGFloatAttribute(rectElement, 'x', 0) // Returns 10.5\n * parseSVGFloatAttribute(rectElement, 'y', 0) // Returns 0 since y is not specified\n * @internal\n */\nexport function parseSVGFloatAttribute(svg: SVGElement, id: string, defaultValue: number): number\n{\n    const value = svg.getAttribute(id) as string;\n\n    return value ? Number(value) : defaultValue;\n}\n","import { GraphicsPath } from '../../path/GraphicsPath';\n\n/**\n * Extracts individual subpaths from SVG path data by splitting on Move commands.\n * @param pathData - The SVG path data string\n * @returns Array of subpath strings\n * @internal\n */\nexport function extractSubpaths(pathData: string): string[]\n{\n    // Split on Move commands (M or m) to get individual subpaths\n    const parts = pathData.split(/(?=[Mm])/);\n    const subpaths = parts.filter((part) => part.trim().length > 0);\n\n    return subpaths;\n}\n\n/**\n * Calculates the area of a path using bounding box estimation.\n * @param pathData - The SVG path data string\n * @returns The estimated area of the path\n * @internal\n */\nexport function calculatePathArea(pathData: string): number\n{\n    const coords = pathData.match(/[-+]?[0-9]*\\.?[0-9]+/g);\n\n    if (!coords || coords.length < 4) return 0;\n\n    const numbers = coords.map(Number);\n    const xs = [];\n    const ys = [];\n\n    for (let i = 0; i < numbers.length; i += 2)\n    {\n        if (i + 1 < numbers.length)\n        {\n            xs.push(numbers[i]);\n            ys.push(numbers[i + 1]);\n        }\n    }\n\n    if (xs.length === 0 || ys.length === 0) return 0;\n\n    const minX = Math.min(...xs);\n    const maxX = Math.max(...xs);\n    const minY = Math.min(...ys);\n    const maxY = Math.max(...ys);\n\n    const area = (maxX - minX) * (maxY - minY);\n\n    return area;\n}\n\n/**\n * Parses SVG path data and appends instructions to a GraphicsPath.\n * @param pathData - The SVG path data string\n * @param graphicsPath - The GraphicsPath to append instructions to\n * @internal\n */\nexport function appendSVGPath(pathData: string, graphicsPath: GraphicsPath): void\n{\n    const tempPath = new GraphicsPath(pathData, false);\n\n    for (const instruction of tempPath.instructions)\n    {\n        graphicsPath.instructions.push(instruction);\n    }\n}\n","import { buildAdaptiveBezier } from './buildAdaptiveBezier';\n\nconst TAU = Math.PI * 2;\n\nconst out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\n\nconst mapToEllipse = (\n    { x, y }: {x: number, y: number},\n    rx: number, ry: number,\n    cosPhi: number, sinPhi: number,\n    centerX: number, centerY: number,\n    out: {x: number, y: number}\n): {x: number, y: number} =>\n{\n    x *= rx;\n    y *= ry;\n\n    const xp = (cosPhi * x) - (sinPhi * y);\n    const yp = (sinPhi * x) + (cosPhi * y);\n\n    out.x = xp + centerX;\n    out.y = yp + centerY;\n\n    return out;\n};\n\nfunction approxUnitArc(ang1: number, ang2: number): {x: number, y: number}[]\n{\n    // If 90 degree circular arc, use a constant\n    // as derived from http://spencermortensen.com/articles/bezier-circle\n\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n\n    return [\n        {\n            x: x1 - (y1 * a),\n            y: y1 + (x1 * a)\n        },\n        {\n            x: x2 + (y2 * a),\n            y: y2 - (x2 * a)\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\n\nconst vectorAngle = (ux: number, uy: number, vx: number, vy: number) =>\n{\n    const sign = ((ux * vy) - (uy * vx) < 0) ? -1 : 1;\n\n    let dot = (ux * vx) + (uy * vy);\n\n    if (dot > 1)\n    {\n        dot = 1;\n    }\n\n    if (dot < -1)\n    {\n        dot = -1;\n    }\n\n    return sign * Math.acos(dot);\n};\n\nconst getArcCenter = (\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    sinPhi: number,\n    cosPhi: number,\n    pxp: number,\n    pyp: number,\n    out: {\n        centerX: number,\n        centerY: number,\n        ang1: number,\n        ang2: number\n    }\n// eslint-disable-next-line max-params\n) =>\n{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n\n    let radicant = (rxSq * rySq) - (rxSq * pypSq) - (rySq * pxpSq);\n\n    if (radicant < 0)\n    {\n        radicant = 0;\n    }\n\n    radicant /= (rxSq * pypSq) + (rySq * pxpSq);\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n\n    const centerX = (cosPhi * centerXp) - (sinPhi * centerYp) + ((px + cx) / 2);\n    const centerY = (sinPhi * centerXp) + (cosPhi * centerYp) + ((py + cy) / 2);\n\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n\n    const ang1 = vectorAngle(1, 0, vx1, vy1);\n    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n    if (sweepFlag === 0 && ang2 > 0)\n    {\n        ang2 -= TAU;\n    }\n\n    if (sweepFlag === 1 && ang2 < 0)\n    {\n        ang2 += TAU;\n    }\n\n    out.centerX = centerX;\n    out.centerY = centerY;\n    out.ang1 = ang1;\n    out.ang2 = ang2;\n};\n\n/**\n * @param points\n * @param px\n * @param py\n * @param cx\n * @param cy\n * @param rx\n * @param ry\n * @param xAxisRotation\n * @param largeArcFlag\n * @param sweepFlag\n * @internal\n */\nexport function buildArcToSvg(\n    points: number[],\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xAxisRotation = 0,\n    largeArcFlag = 0,\n    sweepFlag = 0\n): void\n{\n    if (rx === 0 || ry === 0)\n    {\n        return;\n    }\n\n    const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n\n    const pxp = (cosPhi * (px - cx) / 2) + (sinPhi * (py - cy) / 2);\n    const pyp = (-sinPhi * (px - cx) / 2) + (cosPhi * (py - cy) / 2);\n\n    if (pxp === 0 && pyp === 0)\n    {\n        return;\n    }\n\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n\n    const lambda = (Math.pow(pxp, 2) / Math.pow(rx, 2)) + (Math.pow(pyp, 2) / Math.pow(ry, 2));\n\n    if (lambda > 1)\n    {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n\n    getArcCenter(\n        px,\n        py,\n        cx,\n        cy,\n        rx,\n        ry,\n        largeArcFlag,\n        sweepFlag,\n        sinPhi,\n        cosPhi,\n        pxp,\n        pyp,\n        out\n    );\n\n    let { ang1, ang2 } = out;\n    const { centerX, centerY } = out;\n\n    // If 'ang2' == 90.0000000001, then `ratio` will devalue to\n    // 1.0000000001. This causes `segments` to be greater than one, which is an\n    // unnecessary split, and adds extra points to the bezier curve. To alleviate\n    // this issue, we round to 1.0 when the ratio is close to 1.0.\n    let ratio = Math.abs(ang2) / (TAU / 4);\n\n    if (Math.abs(1.0 - ratio) < 0.0000001)\n    {\n        ratio = 1.0;\n    }\n\n    const segments = Math.max(Math.ceil(ratio), 1);\n\n    ang2 /= segments;\n\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n\n    const outCurvePoint = { x: 0, y: 0 };\n\n    for (let i = 0; i < segments; i++)\n    {\n        const curve = approxUnitArc(ang1, ang2);\n\n        const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n\n        buildAdaptiveBezier(\n            points,\n            lastX, lastY,\n            x1, y1, x2, y2, x, y\n        );\n\n        lastX = x;\n        lastY = y;\n\n        ang1 += ang2;\n    }\n}\n","// thanks to https://github.com/mattdesl/adaptive-bezier-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\n\n/**\n * @param points\n * @param sX\n * @param sY\n * @param cp1x\n * @param cp1y\n * @param cp2x\n * @param cp2y\n * @param eX\n * @param eY\n * @param smoothness\n * @internal\n */\nexport function buildAdaptiveBezier(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    // TODO expose as a parameter\n    const scale = 1;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    // dont need to actually ad this!\n    // points.push(sX, sY);\n    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\n\n// eslint-disable-next-line max-params\nfunction recursive(\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    x4: number, y4: number,\n    points: number[],\n    distanceTolerance: number,\n    level: number)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n\n    if (level > 0)\n    { // Enforce subdivision first time\n        // Try to approximate the full cubic curve by a single straight line\n        // ------------------\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n\n        const d2 = Math.abs(((x2 - x4) * dy) - ((y2 - y4) * dx));\n        const d3 = Math.abs(((x3 - x4) * dy) - ((y3 - y4) * dx));\n\n        let da1; let da2;\n\n        if (d2 > FLT_EPSILON && d3 > FLT_EPSILON)\n        {\n            // Regular care\n            // -----------------\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                // If the curvature doesn't exceed the distanceTolerance value\n                // we tend to finish subdivisions.\n                // ----------------------\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle & Cusp Condition\n                // ----------------------\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n                if (da2 >= pi) da2 = (2 * pi) - da2;\n\n                if (da1 + da2 < mAngleTolerance)\n                {\n                    // Finally we can stop the recursion\n                    // ----------------------\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n\n                    if (da2 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d2 > FLT_EPSILON)\n        {\n            // p1,p3,p4 are collinear, p2 is considerable\n            // ----------------------\n            if (d2 * d2 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d3 > FLT_EPSILON)\n        {\n            // p1,p2,p4 are collinear, p3 is considerable\n            // ----------------------\n            if (d3 * d3 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else\n        {\n            // Collinear case\n            // -----------------\n            dx = x1234 - ((x1 + x4) / 2);\n            dy = y1234 - ((y1 + y4) / 2);\n            if ((dx * dx) + (dy * dy) <= distanceTolerance)\n            {\n                points.push(x1234, y1234);\n\n                return;\n            }\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n","import { buildArc } from './buildArc';\n\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n * @param points\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @param radius\n * @internal\n */\nexport function buildArcTo(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    radius: number,\n): void\n{\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n\n        return;\n    }\n\n    const dd = (a1 * a1) + (b1 * b1);\n    const cc = (a2 * a2) + (b2 * b2);\n    const tt = (a1 * a2) + (b1 * b2);\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = (k1 * b2) + (k2 * b1);\n    const cy = (k1 * a2) + (k2 * a1);\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n\n    buildArc(points,\n        (cx + x1),\n        (cy + y1),\n        radius,\n        startAngle,\n        endAngle,\n        b1 * a2 > b2 * a1\n    );\n}\n","// thanks to https://github.com/mattdesl/adaptive-quadratic-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\n\n/**\n * @param points\n * @param sX\n * @param sY\n * @param cp1x\n * @param cp1y\n * @param eX\n * @param eY\n * @param smoothness\n * @internal\n */\nexport function buildAdaptiveQuadratic(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    const scale = 1.0;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n\n    points.push(eX, eY);\n}\n\nfunction recursive(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    distanceTolerance: number,\n    level: number\n)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((((x2 - x3) * dy) - ((y2 - y3) * dx)));\n\n    if (d > FLT_EPSILON)\n    {\n        // Regular care\n        // -----------------\n        if (d * d <= distanceTolerance * ((dx * dx) + (dy * dy)))\n        {\n            // If the curvature doesn't exceed the distance_tolerance value\n            // we tend to finish subdivisions.\n            // ----------------------\n            if (mAngleTolerance < curveAngleToleranceEpsilon)\n            {\n                points.push(x123, y123);\n\n                return;\n            }\n\n            // Angle & Cusp Condition\n            // ----------------------\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n\n            if (da >= pi) da = (2 * pi) - da;\n\n            if (da < mAngleTolerance)\n            {\n                // Finally we can stop the recursion\n                // ----------------------\n                points.push(x123, y123);\n\n                return;\n            }\n        }\n    }\n    else\n    {\n        // Collinear case\n        // -----------------\n        dx = x123 - ((x1 + x3) / 2);\n        dy = y123 - ((y1 + y3) / 2);\n        if ((dx * dx) + (dy * dy) <= distanceTolerance)\n        {\n            points.push(x123, y123);\n\n            return;\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n","import { Color } from '../../../../color/Color';\nimport { extractSvgUrlId } from './utils/extractSvgUrlId';\n\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillStyle, StrokeStyle } from '../FillTypes';\nimport type { Session } from './SVGParser';\n\n/**\n * A map of SVG style attributes and their default values.\n * Each attribute has a type and default value used for SVG parsing.\n * - 'paint' type can be a color or gradient\n * - 'number' type is a numeric value\n * - 'string' type is a text value\n * @category scene\n * @advanced\n */\nexport const styleAttributes = {\n    // Fill properties\n    fill: { type: 'paint', default: 0 }, // Fill color/gradient\n    'fill-opacity': { type: 'number', default: 1 }, // Fill transparency\n\n    // Stroke properties\n    stroke: { type: 'paint', default: 0 }, // Stroke color/gradient\n    'stroke-width': { type: 'number', default: 1 }, // Width of stroke\n    'stroke-opacity': { type: 'number', default: 1 }, // Stroke transparency\n    'stroke-linecap': { type: 'string', default: 'butt' }, // End cap style: butt, round, square\n    'stroke-linejoin': { type: 'string', default: 'miter' }, // Join style: miter, round, bevel\n    'stroke-miterlimit': { type: 'number', default: 10 }, // Limit on miter join sharpness\n    'stroke-dasharray': { type: 'string', default: 'none' }, // Dash pattern\n    'stroke-dashoffset': { type: 'number', default: 0 }, // Offset for dash pattern\n\n    // Global properties\n    opacity: { type: 'number', default: 1 }, // Overall opacity\n};\n\n/**\n * Represents the result of parsing SVG style attributes\n * @internal\n */\nexport type StyleResult = {\n    /** The stroke style properties */\n    strokeStyle: StrokeStyle;\n    /** The fill style properties */\n    fillStyle: FillStyle;\n    /** Whether fill should be applied */\n    useFill: boolean;\n    /** Whether stroke should be applied */\n    useStroke: boolean;\n};\n\n/**\n * Parses SVG style attributes and inline styles to determine fill and stroke properties.\n * Handles both direct attributes and CSS-style declarations in the style attribute.\n * @param svg - The SVG element to parse styles from\n * @param session - The current SVG parsing session containing definitions\n * @returns An object containing the parsed fill and stroke styles\n * @internal\n */\nexport function parseSVGStyle(svg: SVGElement, session: Session): StyleResult\n{\n    const style = svg.getAttribute('style');\n\n    const strokeStyle: StrokeStyle = {};\n\n    const fillStyle: FillStyle = {};\n\n    const result: StyleResult = {\n        strokeStyle,\n        fillStyle,\n        useFill: false,\n        useStroke: false,\n    };\n\n    // First parse direct style attributes\n    for (const key in styleAttributes)\n    {\n        const attribute = svg.getAttribute(key);\n\n        if (attribute)\n        {\n            parseAttribute(session, result, key, attribute.trim());\n        }\n    }\n\n    // Then parse inline styles which override direct attributes\n    if (style)\n    {\n        const styleParts = style.split(';');\n\n        for (let i = 0; i < styleParts.length; i++)\n        {\n            const stylePart = styleParts[i].trim();\n\n            const [key, value] = stylePart.split(':');\n\n            if (styleAttributes[key as keyof typeof styleAttributes])\n            {\n                parseAttribute(session, result, key, value.trim());\n            }\n        }\n    }\n\n    return {\n        strokeStyle: result.useStroke ? (strokeStyle as ConvertedStrokeStyle) : null,\n        fillStyle: result.useFill ? (fillStyle as ConvertedFillStyle) : null,\n        useFill: result.useFill,\n        useStroke: result.useStroke,\n    };\n}\n\n/**\n * Parses a single SVG style attribute and updates the style result accordingly.\n * Handles color values, gradients, opacities and other style properties.\n * @param session - The current SVG parsing session containing definitions\n * @param result - The style result object to update\n * @param id - The attribute name/id to parse\n * @param value - The attribute value to parse\n */\nfunction parseAttribute(\n    session: Session,\n    result: StyleResult,\n    id: string,\n    value: string\n): void\n{\n    switch (id)\n    {\n        case 'stroke':\n            if (value !== 'none')\n            {\n                if (value.startsWith('url('))\n                {\n                    // Extract gradient/pattern id from url reference\n                    const id = extractSvgUrlId(value);\n\n                    result.strokeStyle.fill = session.defs[id];\n                }\n                else\n                {\n                    // Parse as color value\n                    result.strokeStyle.color = Color.shared.setValue(value).toNumber();\n                }\n\n                result.useStroke = true;\n            }\n\n            break;\n        case 'stroke-width':\n            result.strokeStyle.width = Number(value);\n            break;\n        case 'fill':\n            if (value !== 'none')\n            {\n                if (value.startsWith('url('))\n                {\n                    // Extract gradient/pattern id from url reference\n                    const id = extractSvgUrlId(value);\n\n                    result.fillStyle.fill = session.defs[id];\n                }\n                else\n                {\n                    // Parse as color value\n                    result.fillStyle.color = Color.shared.setValue(value).toNumber();\n                }\n\n                result.useFill = true;\n            }\n            break;\n        case 'fill-opacity':\n            result.fillStyle.alpha = Number(value);\n            break;\n        case 'stroke-opacity':\n            result.strokeStyle.alpha = Number(value);\n            break;\n        case 'opacity':\n            // Global opacity affects both fill and stroke\n            result.fillStyle.alpha = Number(value);\n            result.strokeStyle.alpha = Number(value);\n            break;\n    }\n}\n","import { Point } from '../../../../maths/point/Point';\nimport { uid } from '../../../../utils/data/uid';\nimport { warn } from '../../../../utils/logging/warn';\nimport { parseSVGPath } from '../svg/parseSVGPath';\nimport { ShapePath } from './ShapePath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { Bounds } from '../../../container/bounds/Bounds';\nimport type { RoundedPoint } from './roundShape';\n\n/**\n * Represents a single drawing instruction in a `GraphicsPath`.\n * Each instruction consists of an action type and associated data.\n * @category scene\n * @advanced\n */\nexport interface PathInstruction\n{\n    action: 'moveTo' | 'lineTo' | 'quadraticCurveTo' |\n    'bezierCurveTo' | 'arc' | 'closePath' |\n    'addPath' | 'arcTo' | 'ellipse' |\n    'rect' | 'roundRect' | 'arcToSvg' |\n    'poly' | 'circle' |\n    'regularPoly' | 'roundPoly' | 'roundShape' | 'filletRect' | 'chamferRect'\n    data: any[];\n}\n\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n * @category scene\n * @advanced\n */\nexport class GraphicsPath\n{\n    public instructions: PathInstruction[] = [];\n\n    /** unique id for this graphics path */\n    public readonly uid: number = uid('graphicsPath');\n\n    private _dirty = true;\n    // needed for hit testing and bounds calculations\n    private _shapePath: ShapePath;\n\n    /**\n     * Controls whether shapes in this path should be checked for holes using the non-zero fill rule.\n     * When true, any closed shape that is fully contained within another shape will become\n     * a hole in that shape during filling operations.\n     *\n     * This follows SVG's non-zero fill rule where:\n     * 1. Shapes are analyzed to find containment relationships\n     * 2. If Shape B is fully contained within Shape A, Shape B becomes a hole in Shape A\n     * 3. Multiple nested holes are supported\n     *\n     * Mainly used internally by the SVG parser to correctly handle holes in complex paths.\n     * When false, all shapes are filled independently without checking for holes.\n     */\n    public checkForHoles: boolean;\n\n    /**\n     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n     * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n     */\n    get shapePath(): ShapePath\n    {\n        if (!this._shapePath)\n        {\n            this._shapePath = new ShapePath(this);\n        }\n\n        if (this._dirty)\n        {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n\n        return this._shapePath;\n    }\n\n    /**\n     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n     * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n     * @param signed\n     */\n    constructor(instructions?: string | PathInstruction[], signed = false)\n    {\n        this.checkForHoles = signed;\n\n        if (typeof instructions === 'string')\n        {\n            parseSVGPath(instructions, this);\n        }\n        else\n        {\n            this.instructions = instructions?.slice() ?? [];\n        }\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @param transform - An optional transformation to apply to the added path.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        path = path.clone();\n        this.instructions.push({ action: 'addPath', data: [path, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: [number, number, number, number, number, boolean]): this\n    {\n        this.instructions.push({ action: 'arc', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    // eslint-disable-next-line max-len\n    public arcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n    public arcToSvg(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcToSvg', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'bezierCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires two points: the second control point and the end point. The first control point is assumed to be\n     * The starting point is the last point in the current path.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cp1x = 0;\n        let cp1y = 0;\n\n        if (!last || last.action !== 'bezierCurveTo')\n        {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        }\n        else\n        {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n\n        this.instructions.push({ action: 'bezierCurveTo', data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.instructions.push({ action: 'closePath', data: [] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param matrix - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n    public ellipse(...args: [number, number, number, number, Matrix]): this\n    {\n        this.instructions.push({ action: 'ellipse', data: args });\n\n        // TODO nail this!\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'lineTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'moveTo', data: args });\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'quadraticCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It uses the previous point as the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveToShort(x: number, y: number, smoothness?: number): this\n    {\n        // check if we have a previous quadraticCurveTo\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n\n        if (!last || last.action !== 'quadraticCurveTo')\n        {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        }\n        else\n        {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n\n        this.instructions.push({ action: 'quadraticCurveTo', data: [cpx1, cpy1, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'rect', data: [x, y, w, h, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'circle', data: [x, y, radius, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n    public roundRect(...args: [number, number, number, number, number, Matrix?]): this\n    {\n        this.instructions.push({ action: 'roundRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n    public poly(...args: [number[] | PointData[], boolean, Matrix?]): this\n    {\n        this.instructions.push({ action: 'poly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'regularPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: [number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'roundPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: [RoundedPoint[], number, boolean, number]): this\n    {\n        this.instructions.push({ action: 'roundShape', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'filletRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'chamferRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @param transform - An optional `Matrix` object to apply a transformation to the star.\n     * This can include rotations, scaling, and translations.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    // eslint-disable-next-line max-len\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this\n    {\n        innerRadius ||= radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = (Math.PI * 2) / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n     * do not affect the original `GraphicsPath` and vice versa.\n     * @param deep - A boolean flag indicating whether the clone should be deep.\n     * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n     */\n    public clone(deep = false): GraphicsPath\n    {\n        const newGraphicsPath2D = new GraphicsPath();\n\n        newGraphicsPath2D.checkForHoles = this.checkForHoles;\n\n        if (!deep)\n        {\n            newGraphicsPath2D.instructions = this.instructions.slice();\n        }\n        else\n        {\n            for (let i = 0; i < this.instructions.length; i++)\n            {\n                const instruction = this.instructions[i];\n\n                newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n            }\n        }\n\n        return newGraphicsPath2D;\n    }\n\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n     * This method enables the modification of the path's geometry according to the provided\n     * transformation matrix, which can include translations, rotations, scaling, and skewing.\n     *\n     * Each drawing instruction in the path is updated to reflect the transformation,\n     * ensuring the visual representation of the path is consistent with the applied matrix.\n     *\n     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n     * allowing for fine-grained control over the path's appearance.\n     * @param matrix - A `Matrix` object representing the transformation to apply.\n     * @returns The instance of the current object for chaining further operations.\n     */\n    public transform(matrix: Matrix): this\n    {\n        if (matrix.isIdentity()) return this;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let x = 0;\n        let y = 0;\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n\n        let rx = 0;\n        let ry = 0;\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const data = instruction.data as any[];\n\n            switch (instruction.action)\n            {\n                case 'moveTo':\n                case 'lineTo':\n\n                    x = data[0];\n                    y = data[1];\n\n                    data[0] = (a * x) + (c * y) + tx;\n                    data[1] = (b * x) + (d * y) + ty;\n                    break;\n                case 'bezierCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n\n                    x = data[4];\n                    y = data[5];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n                    data[2] = (a * cpx2) + (c * cpy2) + tx;\n                    data[3] = (b * cpx2) + (d * cpy2) + ty;\n                    data[4] = (a * x) + (c * y) + tx;\n                    data[5] = (b * x) + (d * y) + ty;\n                    break;\n\n                case 'quadraticCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n\n                    x = data[2];\n                    y = data[3];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n\n                    data[2] = (a * x) + (c * y) + tx;\n                    data[3] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'arcToSvg':\n\n                    x = data[5];\n                    y = data[6];\n\n                    rx = data[0];\n                    ry = data[1];\n\n                    // multiply the radius by the transform..\n\n                    data[0] = (a * rx) + (c * ry);\n                    data[1] = (b * rx) + (d * ry);\n\n                    data[5] = (a * x) + (c * y) + tx;\n                    data[6] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'circle':\n                    data[4] = adjustTransform(data[3], matrix);\n                    break;\n                case 'rect':\n                    data[4] = adjustTransform(data[4], matrix);\n                    break;\n                case 'ellipse':\n                    data[8] = adjustTransform(data[8], matrix);\n                    break;\n                case 'roundRect':\n                    data[5] = adjustTransform(data[5], matrix);\n                    break;\n                case 'addPath':\n                    data[0].transform(matrix);\n                    break;\n                case 'poly':\n                    data[2] = adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    // #if _DEBUG\n                    warn('unknown transform action', instruction.action);\n                    // #endif\n                    break;\n            }\n        }\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    get bounds(): Bounds\n    {\n        return this.shapePath.bounds;\n    }\n\n    /**\n     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n     * This method is useful for operations that depend on the path's current endpoint,\n     * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n     * ensuring the last point's position is accurately determined regardless of the path's complexity.\n     *\n     * If the last instruction is a `closePath`, the method iterates backward through the instructions\n     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n     * the last point from the nested path.\n     * @param out - A `Point` object where the last point's coordinates will be stored.\n     * This object is modified directly to contain the result.\n     * @returns The `Point` object containing the last point's coordinates.\n     */\n    public getLastPoint(out: Point): Point\n    {\n        let index = this.instructions.length - 1;\n\n        let lastInstruction = this.instructions[index];\n\n        if (!lastInstruction)\n        {\n            out.x = 0;\n            out.y = 0;\n\n            return out;\n        }\n\n        while (lastInstruction.action === 'closePath')\n        {\n            index--;\n\n            if (index < 0)\n            {\n                out.x = 0;\n                out.y = 0;\n\n                return out;\n            }\n\n            lastInstruction = this.instructions[index];\n        }\n\n        switch (lastInstruction.action)\n        {\n            case 'moveTo':\n            case 'lineTo':\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case 'quadraticCurveTo':\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case 'bezierCurveTo':\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case 'arc':\n            case 'arcToSvg':\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case 'addPath':\n                // TODO prolly should transform the last point of the path\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n\n        return out;\n    }\n}\n\nfunction adjustTransform(currentMatrix?: Matrix, transform?: Matrix): Matrix\n{\n    if (currentMatrix)\n    {\n        return currentMatrix.prepend(transform);\n    }\n\n    return transform.clone();\n}\n","import { Color } from '../../../../color/Color';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../fill/FillGradient';\nimport { parseSVGFloatAttribute } from './parseSVGFloatAttribute';\n\nimport type { Session } from './SVGParser';\n\n/**\n * Parses SVG gradient definitions and stores them in the session for later use.\n * Currently supports linear gradients and has placeholder support for radial gradients.\n * @param svg - The root SVG element to parse definitions from\n * @param session - The parsing session to store definitions in\n * @internal\n */\nexport function parseSVGDefinitions(svg: SVGElement, session: Session): void\n{\n    // Find all <defs> elements in the SVG\n    const definitions = svg.querySelectorAll('defs');\n\n    // Process each <defs> element\n    for (let i = 0; i < definitions.length; i++)\n    {\n        const definition = definitions[i];\n\n        // Process each child element in the <defs>\n        for (let j = 0; j < definition.children.length; j++)\n        {\n            const child = definition.children[j];\n\n            // Handle different types of gradient definitions\n            switch (child.nodeName.toLowerCase())\n            {\n                case 'lineargradient':\n                    // Store the parsed linear gradient in the session defs using the gradient's ID\n                    session.defs[child.id] = parseLinearGradient(child as SVGElement);\n                    break;\n                case 'radialgradient':\n                    session.defs[child.id] = parseRadialGradient(child as SVGElement);\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n}\n\n/**\n * Parses an SVG linear gradient element into a FillGradient.\n * @param child - The SVG linear gradient element to parse\n * @returns A FillGradient configured based on the SVG element\n */\nfunction parseLinearGradient(child: SVGElement): FillGradient\n{\n    // Parse the gradient vector coordinates (defaults: horizontal line from 0 to 1)\n    const x0 = parseSVGFloatAttribute(child, 'x1', 0);\n    const y0 = parseSVGFloatAttribute(child, 'y1', 0);\n    const x1 = parseSVGFloatAttribute(child, 'x2', 1);\n    const y1 = parseSVGFloatAttribute(child, 'y2', 0);\n\n    // Get the gradient coordinate system\n    const gradientUnit = child.getAttribute('gradientUnits') || 'objectBoundingBox';\n\n    // Create gradient with coordinates and space mapping\n    const gradient = new FillGradient(\n        x0,\n        y0,\n        x1,\n        y1,\n        gradientUnit === 'objectBoundingBox' ? 'local' : 'global'\n    );\n\n    // Process each gradient stop\n    for (let k = 0; k < child.children.length; k++)\n    {\n        const stop = child.children[k] as SVGElement;\n\n        // Get stop position (0-1) and color\n        const offset = parseSVGFloatAttribute(stop, 'offset', 0);\n        const color = Color.shared.setValue(stop.getAttribute('stop-color')).toNumber();\n\n        gradient.addColorStop(offset, color);\n    }\n\n    return gradient;\n}\n\n/**\n * Placeholder function for parsing SVG radial gradients.\n * Currently returns a simple horizontal linear gradient and logs a warning.\n * @param _child - The SVG radial gradient element (currently unused)\n * @returns A default linear gradient\n */\nfunction parseRadialGradient(_child: SVGElement): FillGradient\n{\n    // #if _DEBUG\n    warn('[SVG Parser] Radial gradients are not yet supported');\n    // #endif\n\n    return new FillGradient(0, 0, 1, 0);\n}\n","import { warn } from '../../../../utils/logging/warn';\nimport { GraphicsPath } from '../path/GraphicsPath';\nimport { parseSVGDefinitions } from './parseSVGDefinitions';\nimport { parseSVGFloatAttribute } from './parseSVGFloatAttribute';\nimport { parseSVGStyle } from './parseSVGStyle';\nimport { checkForNestedPattern } from './utils/fillOperations';\nimport { appendSVGPath, calculatePathArea, extractSubpaths } from './utils/pathOperations';\n\nimport type { FillGradient } from '../fill/FillGradient';\nimport type { FillStyle, StrokeStyle } from '../FillTypes';\nimport type {\n    GraphicsContext,\n} from '../GraphicsContext';\n\n/**\n * Represents a session for SVG parsing. Contains the current state and resources needed during parsing.\n * @internal\n */\nexport interface Session\n{\n    /** The graphics context to render to */\n    context: GraphicsContext;\n    /** The current path being constructed */\n    path: GraphicsPath;\n    /** Map of definitions by id */\n    defs: Record<string, FillGradient>;\n}\n\n/**\n * Parses an SVG element or string and renders it to a graphics context.\n * Handles both SVG strings and SVG DOM elements as input.\n * @param svg - The SVG content to parse, either as a string or element\n * @param graphicsContext - Optional graphics context to render to\n * @returns The graphics context with the SVG rendered into it\n * @internal\n */\nexport function SVGParser(\n    svg: string | SVGElement | SVGSVGElement,\n    graphicsContext?: GraphicsContext\n): GraphicsContext\n{\n    // Convert string input to SVG element\n    if (typeof svg === 'string')\n    {\n        // eslint-disable-next-line no-restricted-globals\n        const div = document.createElement('div');\n\n        div.innerHTML = svg.trim();\n        svg = div.querySelector('svg') as SVGElement;\n    }\n\n    // Initialize parsing session\n    const session = {\n        context: graphicsContext,\n        defs: {},\n        path: new GraphicsPath(),\n    };\n\n    // Parse definitions (gradients, etc) first\n    parseSVGDefinitions(svg, session);\n\n    // Process all child elements except defs\n    const children = svg.children;\n\n    const { fillStyle, strokeStyle } = parseSVGStyle(svg, session);\n\n    for (let i = 0; i < children.length; i++)\n    {\n        const child = children[i] as SVGElement;\n\n        if (child.nodeName.toLowerCase() === 'defs') continue;\n        renderChildren(child, session, fillStyle, strokeStyle);\n    }\n\n    return graphicsContext;\n}\n\n/**\n * Recursively renders SVG elements and their children.\n * Handles styling inheritance and different SVG shape types.\n * @param svg - The SVG element to render\n * @param session - The current parsing session\n * @param fillStyle - The inherited fill style\n * @param strokeStyle - The inherited stroke style\n */\nfunction renderChildren(svg: SVGElement, session: Session, fillStyle: FillStyle, strokeStyle: StrokeStyle): void\n{\n    const children = svg.children;\n\n    // Parse element's style and merge with inherited styles\n    const { fillStyle: f1, strokeStyle: s1 } = parseSVGStyle(svg, session);\n\n    if (f1 && fillStyle)\n    {\n        fillStyle = { ...fillStyle, ...f1 };\n    }\n    else if (f1)\n    {\n        fillStyle = f1;\n    }\n\n    if (s1 && strokeStyle)\n    {\n        strokeStyle = { ...strokeStyle, ...s1 };\n    }\n    else if (s1)\n    {\n        strokeStyle = s1;\n    }\n\n    const noStyle = !fillStyle && !strokeStyle;\n\n    // Default to black fill if no styles specified\n    if (noStyle)\n    {\n        fillStyle = { color: 0 };\n    }\n\n    // Variables for shape attributes\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n\n    // Handle different SVG element types\n    switch (svg.nodeName.toLowerCase())\n    {\n        case 'path':\n        {\n            d = svg.getAttribute('d') as string;\n\n            const fillRule = svg.getAttribute('fill-rule') as string;\n\n            const subpaths = extractSubpaths(d);\n            const hasExplicitEvenodd = fillRule === 'evenodd';\n            const hasMultipleSubpaths = subpaths.length > 1;\n\n            const shouldProcessHoles = hasExplicitEvenodd && hasMultipleSubpaths;\n\n            if (shouldProcessHoles)\n            {\n                const subpathsWithArea = subpaths.map((subpath) => ({\n                    path: subpath,\n                    area: calculatePathArea(subpath)\n                }));\n\n                subpathsWithArea.sort((a, b) => b.area - a.area);\n\n                // For complex cases, prefer multiple holes approach\n                const useMultipleHolesApproach = subpaths.length > 3 || !checkForNestedPattern(subpathsWithArea);\n\n                if (useMultipleHolesApproach)\n                {\n                    // Multiple holes approach: first (largest) is fill, rest are holes\n                    for (let i = 0; i < subpathsWithArea.length; i++)\n                    {\n                        const subpath = subpathsWithArea[i];\n                        const isMainShape = i === 0;\n\n                        session.context.beginPath();\n                        const newPath = new GraphicsPath(undefined, true); // Always use evenodd for hole processing\n\n                        appendSVGPath(subpath.path, newPath);\n                        session.context.path(newPath);\n\n                        if (isMainShape)\n                        {\n                            if (fillStyle) session.context.fill(fillStyle);\n                            if (strokeStyle) session.context.stroke(strokeStyle);\n                        }\n                        else\n                        {\n                            session.context.cut();\n                        }\n                    }\n                }\n                else\n                {\n                    // Nested holes approach: alternate between fill and cut\n                    for (let i = 0; i < subpathsWithArea.length; i++)\n                    {\n                        const subpath = subpathsWithArea[i];\n                        const isHole = i % 2 === 1; // Odd indices are holes\n\n                        session.context.beginPath();\n                        const newPath = new GraphicsPath(undefined, true); // Always use evenodd for hole processing\n\n                        appendSVGPath(subpath.path, newPath);\n                        session.context.path(newPath);\n\n                        if (isHole)\n                        {\n                            session.context.cut();\n                        }\n                        else\n                        {\n                            if (fillStyle) session.context.fill(fillStyle);\n                            if (strokeStyle) session.context.stroke(strokeStyle);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                const useEvenoddForGraphicsPath = fillRule ? (fillRule === 'evenodd') : true;\n\n                graphicsPath = new GraphicsPath(d, useEvenoddForGraphicsPath);\n                session.context.path(graphicsPath);\n                if (fillStyle) session.context.fill(fillStyle);\n                if (strokeStyle) session.context.stroke(strokeStyle);\n            }\n            break;\n        }\n\n        case 'circle':\n            cx = parseSVGFloatAttribute(svg, 'cx', 0);\n            cy = parseSVGFloatAttribute(svg, 'cy', 0);\n            r = parseSVGFloatAttribute(svg, 'r', 0);\n            session.context.ellipse(cx, cy, r, r);\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'rect':\n            x = parseSVGFloatAttribute(svg, 'x', 0);\n            y = parseSVGFloatAttribute(svg, 'y', 0);\n            width = parseSVGFloatAttribute(svg, 'width', 0);\n            height = parseSVGFloatAttribute(svg, 'height', 0);\n            rx = parseSVGFloatAttribute(svg, 'rx', 0);\n            ry = parseSVGFloatAttribute(svg, 'ry', 0);\n\n            if (rx || ry)\n            {\n                session.context.roundRect(x, y, width, height, rx || ry);\n            }\n            else\n            {\n                session.context.rect(x, y, width, height);\n            }\n\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'ellipse':\n            cx = parseSVGFloatAttribute(svg, 'cx', 0);\n            cy = parseSVGFloatAttribute(svg, 'cy', 0);\n            rx = parseSVGFloatAttribute(svg, 'rx', 0);\n            ry = parseSVGFloatAttribute(svg, 'ry', 0);\n\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry);\n\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'line':\n            x1 = parseSVGFloatAttribute(svg, 'x1', 0);\n            y1 = parseSVGFloatAttribute(svg, 'y1', 0);\n            x2 = parseSVGFloatAttribute(svg, 'x2', 0);\n            y2 = parseSVGFloatAttribute(svg, 'y2', 0);\n\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'polygon':\n            pointsString = svg.getAttribute('points') as string;\n            points = pointsString.match(/-?\\d+/g).map((n) => parseInt(n, 10));\n            session.context.poly(points, true);\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'polyline':\n            pointsString = svg.getAttribute('points') as string;\n            points = pointsString.match(/-?\\d+/g).map((n) => parseInt(n, 10));\n            session.context.poly(points, false);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        // Group elements - just process children\n        case 'g':\n        case 'svg':\n            break;\n\n        default: {\n            // Log unsupported elements\n            warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n        }\n    }\n\n    if (noStyle)\n    {\n        fillStyle = null;\n    }\n\n    // Recursively process child elements\n    for (let i = 0; i < children.length; i++)\n    {\n        renderChildren(children[i] as SVGElement, session, fillStyle, strokeStyle);\n    }\n}\n","// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\n/**\n * A type representing a shape primitive with optional transformation and holes.\n * @category scene\n * @advanced\n */\nexport type ShapePrimitiveWithHoles = {\n    shape: ShapePrimitive,\n    transform?: Matrix,\n    holes?: ShapePrimitiveWithHoles[]\n};\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @category scene\n * @advanced\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: ShapePrimitiveWithHoles[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n    public readonly signed: boolean;\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n        this.signed = graphicsPath2D.checkForHoles;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        // Only clone if we need to transform\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        const shapePrimitives = this.shapePrimitives;\n        const start = shapePrimitives.length;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        // This section processes holes in polygons by checking if any polygon is contained within another.\n        // If a polygon is found to be inside another polygon (mainShape), it's treated as a hole.\n        // The hole polygon is removed from the main shapePrimitives array and added to the holes array\n        // of the containing polygon. This allows for proper rendering of shapes with holes.\n        if (path.checkForHoles && shapePrimitives.length - start > 1)\n        {\n            let mainShape = null;\n\n            // Process in place instead of creating a removal array\n            for (let i = start; i < shapePrimitives.length; i++)\n            {\n                const shapePrimitive = shapePrimitives[i];\n\n                if (shapePrimitive.shape.type === 'polygon')\n                {\n                    const polygon = shapePrimitive.shape as Polygon;\n                    const mainPolygon = mainShape?.shape as Polygon;\n\n                    if (mainPolygon && mainPolygon.containsPolygon(polygon))\n                    {\n                        // Initialize holes array only when needed\n                        mainShape.holes ||= [];\n                        mainShape.holes.push(shapePrimitive);\n\n                        // Remove the hole by moving elements left\n                        shapePrimitives.copyWithin(i, i + 1);\n                        shapePrimitives.length--;\n                        i--;\n                    }\n                    else\n                    {\n                        mainShape = shapePrimitive;\n                    }\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = startAngle - (i * delta);\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (lastShape.transform && !lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\n\n/**\n * Defines the repetition modes for fill patterns.\n *\n * - `repeat`: The pattern repeats in both directions.\n * - `repeat-x`: The pattern repeats horizontally only.\n * - `repeat-y`: The pattern repeats vertically only.\n * - `no-repeat`: The pattern does not repeat.\n * @category scene\n * @standard\n */\nexport type PatternRepetition = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\n\nconst repetitionMap = {\n    repeat: {\n        addressModeU: 'repeat',\n        addressModeV: 'repeat',\n    },\n    'repeat-x': {\n        addressModeU: 'repeat',\n        addressModeV: 'clamp-to-edge',\n    },\n    'repeat-y': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'repeat',\n    },\n    'no-repeat': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge',\n    },\n};\n\n/**\n * A class that represents a fill pattern for use in Text and Graphics fills.\n * It allows for textures to be used as patterns, with optional repetition modes.\n * @category scene\n * @standard\n * @example\n * const txt = await Assets.load('https://pixijs.com/assets/bg_scene_rotate.jpg');\n * const pat = new FillPattern(txt, 'repeat');\n *\n * const textPattern = new Text({\n *     text: 'PixiJS',\n *     style: {\n *         fontSize: 36,\n *         fill: 0xffffff,\n *         stroke: { fill: pat, width: 10 },\n *     },\n * });\n *\n * textPattern.y = (textGradient.height);\n */\nexport class FillPattern implements CanvasPattern\n{\n    /**\n     * unique id for this fill pattern\n     * @internal\n     */\n    public readonly uid: number = uid('fillPattern');\n    /**\n     * Internal tick counter to track changes in the pattern.\n     * This is used to invalidate the pattern when the texture or transform changes.\n     * @internal\n     */\n    public _tick: number = 0;\n    /** @internal */\n    public _texture: Texture;\n    /** The transform matrix applied to the pattern */\n    public transform = new Matrix();\n\n    constructor(texture: Texture, repetition?: PatternRepetition)\n    {\n        this.texture = texture;\n\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        if (repetition)\n        {\n            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU as WRAP_MODE;\n            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV as WRAP_MODE;\n        }\n    }\n\n    /**\n     * Sets the transform for the pattern\n     * @param transform - The transform matrix to apply to the pattern.\n     * If not provided, the pattern will use the default transform.\n     */\n    public setTransform(transform?: Matrix): void\n    {\n        const texture = this.texture;\n\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        //  transform.scale\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        this._tick++;\n    }\n\n    /** Internal texture used to render the gradient */\n    public get texture()\n    {\n        return this._texture;\n    }\n    public set texture(value: Texture)\n    {\n        if (this._texture === value) return;\n\n        this._texture = value;\n        this._tick++;\n    }\n\n    /**\n     * Returns a unique key for this instance.\n     * This key is used for caching.\n     * @returns {string} Unique key for the instance\n     */\n    public get styleKey(): string\n    {\n        return `fill-pattern-${this.uid}-${this._tick}`;\n    }\n\n    /** Destroys the fill pattern, releasing resources. This will also destroy the internal texture. */\n    public destroy(): void\n    {\n        this.texture.destroy(true);\n        this.texture = null;\n    }\n}\n","import { Color } from '../../../../color/Color';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { FillGradient } from '../fill/FillGradient';\nimport { FillPattern } from '../fill/FillPattern';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n} from '../FillTypes';\n\nfunction isColorLike(value: unknown): value is ColorSource\n{\n    return Color.isColorLike(value as ColorSource);\n}\n\nfunction isFillPattern(value: unknown): value is FillPattern\n{\n    return value instanceof FillPattern;\n}\n\nfunction isFillGradient(value: unknown): value is FillGradient\n{\n    return value instanceof FillGradient;\n}\n\nfunction isTexture(value: unknown): value is Texture\n{\n    return value instanceof Texture;\n}\n\n/**\n * Handles the case where the value is a ColorLike\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(0xff0000)\n * graphics.fill(new Color(0xff0000))\n * graphics.fill({ r: 255, g: 0, b: 0 })\n */\nfunction handleColorLike(\n    fill: FillStyle,\n    value: ColorSource,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    const temp = Color.shared.setValue(value ?? 0);\n\n    fill.color = temp.toNumber();\n    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n    fill.texture = Texture.WHITE;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a Texture\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new Texture(0xff0000))\n */\nfunction handleTexture(fill: FillStyle, value: Texture, defaultStyle: ConvertedFillStyle): ConvertedFillStyle\n{\n    fill.texture = value;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillPattern\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillPattern(0xff0000))\n */\nfunction handleFillPattern(\n    fill: FillStyle,\n    value: FillPattern,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillGradient\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillGradient(0, 0, 200, 0))\n */\nfunction handleFillGradient(\n    fill: FillStyle,\n    value: FillGradient,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    value.buildGradient();\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n    fill.textureSpace = value.textureSpace;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is not a direct Pixi Color, PatternFill, or GradientFill but instead\n * an object with potentially `color`\n * @example\n * {\n *   color: new Color(0xff0000)\n *   alpha: 0.5,\n *   texture?: null,\n *   matrix?: null,\n * }\n * @param value\n * @param defaultStyle\n */\nfunction handleFillObject(value: FillStyle, defaultStyle: ConvertedFillStyle): ConvertedFillStyle\n{\n    const style = { ...defaultStyle, ...(value as FillStyle) };\n\n    const color = Color.shared.setValue(style.color);\n\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n\n    return style as ConvertedFillStyle;\n}\n\n/**\n * Converts a value to a fill style, we do this as PixiJS has a number of ways to define a fill style\n * They can be a direct color, a texture, a gradient, or an object with these values in them\n * This function will take any of these input types and convert them into a single object\n * that PixiJS can understand and use internally.\n * @param value - The value to convert to a fill style\n * @param defaultStyle - The default fill style to use\n * @private\n */\nexport function toFillStyle<T extends FillInput>(\n    value: T,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    if (value === undefined || value === null)\n    {\n        return null;\n    }\n\n    const fill: ConvertedFillStyle = {} as ConvertedFillStyle;\n    const objectStyle = value as FillStyle;\n\n    if (isColorLike(value))\n    {\n        return handleColorLike(fill, value, defaultStyle);\n    }\n    else if (isTexture(value))\n    {\n        return handleTexture(fill, value, defaultStyle);\n    }\n    else if (isFillPattern(value))\n    {\n        return handleFillPattern(fill, value, defaultStyle);\n    }\n    else if (isFillGradient(value))\n    {\n        return handleFillGradient(fill, value, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillPattern(objectStyle.fill))\n    {\n        return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillGradient(objectStyle.fill))\n    {\n        return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n    }\n\n    return handleFillObject(objectStyle, defaultStyle);\n}\n\n/**\n * Converts a value to a stroke style, similar to `toFillStyle` but for strokes\n * @param value - The value to convert to a stroke style\n * @param defaultStyle - The default stroke style to use\n * @private\n */\nexport function toStrokeStyle(value: StrokeInput, defaultStyle: ConvertedStrokeStyle): ConvertedStrokeStyle\n{\n    const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;\n    const fill = toFillStyle(value, rest);\n\n    if (!fill)\n    {\n        return null;\n    }\n\n    return {\n        width,\n        alignment,\n        miterLimit,\n        cap,\n        join,\n        pixelLine,\n        ...fill,\n    };\n}\n","/* eslint-disable max-len */\nimport EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../../color/Color';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { type GCable, type GCData } from '../../../rendering/renderers/shared/GCSystem';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Bounds } from '../../container/bounds/Bounds';\nimport { type GpuGraphicsContext } from './GraphicsContextSystem';\nimport { GraphicsPath } from './path/GraphicsPath';\nimport { SVGParser } from './svg/SVGParser';\nimport { toFillStyle, toStrokeStyle } from './utils/convertFillInputToFillStyle';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { TextureDestroyOptions, TypeOrBool } from '../../container/destroyTypes';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillInput, StrokeInput } from './FillTypes';\nimport type { RoundedPoint } from './path/roundShape';\n\nconst tmpPoint = new Point();\n\n/**\n * The mode for batching graphics instructions.\n *\n * It can be:\n * - 'auto': Automatically determines whether to batch based on the number of instructions.\n * - 'batch': Forces batching of all instructions.\n * - 'no-batch': Disables batching, processing each instruction individually.\n * @category scene\n * @advanced\n */\nexport type BatchMode = 'auto' | 'batch' | 'no-batch';\n\n/** @internal */\nexport interface FillInstruction\n{\n    action: 'fill' | 'cut'\n    data: { style: ConvertedFillStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\n/** @internal */\nexport interface StrokeInstruction\n{\n    action: 'stroke'\n    data: { style: ConvertedStrokeStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\n/** @internal */\nexport interface TextureInstruction\n{\n    action: 'texture'\n    data: {\n        image: Texture,\n\n        dx: number\n        dy: number\n\n        dw: number\n        dh: number\n\n        transform: Matrix\n        alpha: number\n        style: number,\n    }\n}\n\n/** @internal */\nexport type GraphicsInstructions = FillInstruction | StrokeInstruction | TextureInstruction;\n\nconst tempMatrix = new Matrix();\n\n/**\n * The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths.\n * It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects,\n *\n * This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused,\n * much like sprites reusing textures.\n * @category scene\n * @standard\n */\nexport class GraphicsContext extends EventEmitter<{\n    update: GraphicsContext\n    destroy: GraphicsContext\n    unload: GraphicsContext\n}> implements GCable\n{\n    /** @internal */\n    public _gpuData: Record<number | string, GpuGraphicsContext> = Object.create(null);\n    /** @internal */\n    public _gcData?: GCData;\n    /** If set to true, the resource will be garbage collected automatically when it is not used. */\n    public autoGarbageCollect = true;\n    /** @internal */\n    public _gcLastUsed = -1;\n\n    /** The default fill style to use when none is provided. */\n    public static defaultFillStyle: ConvertedFillStyle = {\n        /** The color to use for the fill. */\n        color: 0xffffff,\n        /** The alpha value to use for the fill. */\n        alpha: 1,\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n        /** Whether coordinates are 'global' or 'local' */\n        textureSpace: 'local',\n    };\n\n    /** The default stroke style to use when none is provided. */\n    public static defaultStrokeStyle: ConvertedStrokeStyle = {\n        /** The width of the stroke. */\n        width: 1,\n        /** The color to use for the stroke. */\n        color: 0xffffff,\n        /** The alpha value to use for the stroke. */\n        alpha: 1,\n        /** The alignment of the stroke. */\n        alignment: 0.5,\n        /** The miter limit to use. */\n        miterLimit: 10,\n        /** The line cap style to use. */\n        cap: 'butt',\n        /** The line join style to use. */\n        join: 'miter',\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n        /** Whether coordinates are 'global' or 'local' */\n        textureSpace: 'local',\n        /** If the stroke is a pixel line. */\n        pixelLine: false,\n    };\n\n    /**\n     * unique id for this graphics context\n     * @internal\n     */\n    public readonly uid: number = uid('graphicsContext');\n    /**\n     * Indicates whether content is updated and have to be re-rendered.\n     * @internal\n     */\n    public dirty = true;\n    /** The batch mode for this graphics context. It can be 'auto', 'batch', or 'no-batch'. */\n    public batchMode: BatchMode = 'auto';\n    /** @internal */\n    public instructions: GraphicsInstructions[] = [];\n    /**\n     * Custom shader to apply to the graphics when rendering.\n     * @advanced\n     */\n    public customShader?: Shader;\n\n    /** Whether the graphics context has been destroyed. */\n    public destroyed = false;\n\n    private _activePath: GraphicsPath = new GraphicsPath();\n    private _transform: Matrix = new Matrix();\n\n    private _fillStyle: ConvertedFillStyle = { ...GraphicsContext.defaultFillStyle };\n    private _strokeStyle: ConvertedStrokeStyle = { ...GraphicsContext.defaultStrokeStyle };\n    private _stateStack: { fillStyle: ConvertedFillStyle; strokeStyle: ConvertedStrokeStyle, transform: Matrix }[] = [];\n\n    private _tick = 0;\n\n    private _bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n     * including the current drawing state, transformations, styles, and instructions.\n     * @returns A new GraphicsContext instance with the same properties and state as this one.\n     */\n    public clone(): GraphicsContext\n    {\n        const clone = new GraphicsContext();\n\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = { ...this._fillStyle };\n        clone._strokeStyle = { ...this._strokeStyle };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n\n        return clone;\n    }\n\n    /**\n     * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n     */\n    get fillStyle(): ConvertedFillStyle\n    {\n        return this._fillStyle;\n    }\n\n    set fillStyle(value: FillInput)\n    {\n        this._fillStyle = toFillStyle(value, GraphicsContext.defaultFillStyle);\n    }\n\n    /**\n     * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     */\n    get strokeStyle(): ConvertedStrokeStyle\n    {\n        return this._strokeStyle;\n    }\n\n    set strokeStyle(value: FillInput)\n    {\n        this._strokeStyle = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n    }\n\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n     *                or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(style: FillInput): this\n    {\n        this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n\n        return this;\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     *                or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(style: StrokeInput): this\n    {\n        this._strokeStyle = toFillStyle(style, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n\n        return this;\n    }\n\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture.\n     * If only a texture is provided, it uses the texture's width and height for drawing.\n     * @param texture - The Texture object to use.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture): this;\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n     * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n     * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this\n    {\n        this.instructions.push({\n            action: 'texture',\n            data: {\n                image: texture,\n\n                dx: dx || 0,\n                dy: dy || 0,\n\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? Color.shared.setValue(tint).toNumber() : 0xFFFFFF,\n            }\n        });\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        this._activePath = new GraphicsPath();\n\n        return this;\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillInput object for advanced fills.\n     * @param style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(style?: FillInput, alpha?: number): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction?.action === 'stroke')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            if (alpha !== undefined && typeof style === 'number')\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead');\n                // #endif\n\n                style = { color: style, alpha };\n            }\n            this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'fill',\n            // TODO copy fill style!\n            data: { style: this.fillStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    private _initNextPathLocation()\n    {\n        // Reset the _activePath with the last point of the current path\n        const { x, y } = this._activePath.getLastPoint(Point.shared);\n\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(style?: StrokeInput): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction?.action === 'fill')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            this._strokeStyle = toStrokeStyle(style, GraphicsContext.defaultStrokeStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'stroke',\n            // TODO copy fill style!\n            data: { style: this.strokeStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public cut(): this\n    {\n        for (let i = 0; i < 2; i++)\n        {\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n\n            const holePath = this._activePath.clone();\n\n            if (lastInstruction)\n            {\n                if (lastInstruction.action === 'stroke' || lastInstruction.action === 'fill')\n                {\n                    if (lastInstruction.data.hole)\n                    {\n                        lastInstruction.data.hole.addPath(holePath);\n                    }\n                    else\n                    {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n\n        this._initNextPathLocation();\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arc(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            radius,\n            startAngle,\n            endAngle,\n            counterclockwise,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcTo(\n            (t.a * x1) + (t.c * y1) + t.tx,\n            (t.b * x1) + (t.d * y1) + t.ty,\n            (t.a * x2) + (t.c * y2) + t.tx,\n            (t.b * x2) + (t.d * y2) + t.ty,\n            radius,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number,\n        largeArcFlag: number,\n        sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcToSvg(\n            rx, ry,\n            xAxisRotation, // should we rotate this with transform??\n            largeArcFlag,\n            sweepFlag,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        // TODO optimize for no transform\n        const t = this._transform;\n\n        this._activePath.bezierCurveTo(\n            (t.a * cp1x) + (t.c * cp1y) + t.tx,\n            (t.b * cp1x) + (t.d * cp1y) + t.ty,\n            (t.a * cp2x) + (t.c * cp2y) + t.tx,\n            (t.b * cp2x) + (t.d * cp2y) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this._tick++;\n\n        this._activePath?.closePath();\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this\n    {\n        this._tick++;\n\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this\n    {\n        this._tick++;\n\n        this._activePath.circle(x, y, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this\n    {\n        this._tick++;\n\n        this._activePath.addPath(path, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.lineTo(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty\n        );\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        const instructions = this._activePath.instructions;\n\n        const transformedX = (t.a * x) + (t.c * y) + t.tx;\n        const transformedY = (t.b * x) + (t.d * y) + t.ty;\n\n        if (instructions.length === 1 && instructions[0].action === 'moveTo')\n        {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n\n            return this;\n        }\n        this._activePath.moveTo(\n            transformedX,\n            transformedY\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.quadraticCurveTo(\n            (t.a * cpx) + (t.c * cpy) + t.tx,\n            (t.b * cpx) + (t.d * cpy) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this\n    {\n        this._tick++;\n\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this\n    {\n        this._tick++;\n\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this\n    {\n        this._tick++;\n\n        this._activePath.poly(points, close, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this\n    {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this\n    {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius = 0, rotation = 0): this\n    {\n        this._tick++;\n\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this\n    {\n        this._tick++;\n\n        SVGParser(svg, this);\n\n        return this;\n    }\n\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this\n    {\n        const state = this._stateStack.pop();\n\n        if (state)\n        {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n\n        return this;\n    }\n\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: { ...this._fillStyle },\n            strokeStyle: { ...this._strokeStyle },\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this._transform;\n    }\n\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        this._transform.identity();\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotate(angle: number): this\n    {\n        this._transform.rotate(angle);\n\n        return this;\n    }\n\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this._transform.scale(x, y);\n\n        return this;\n    }\n\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param transform - The matrix to set as the current transformation matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n\n            return this;\n        }\n\n        this._transform.set(a, b, c, d, dx, dy);\n\n        return this;\n    }\n\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param transform - The matrix to apply to the current transformation.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.append(a);\n\n            return this;\n        }\n\n        tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append(tempMatrix);\n\n        return this;\n    }\n\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translate(x: number, y: number = x): this\n    {\n        this._transform.translate(x, y);\n\n        return this;\n    }\n\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        this._activePath.clear();\n        this.instructions.length = 0;\n        this.resetTransform();\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    protected onUpdate(): void\n    {\n        // Every time the content is updated - we must invalidate bounds, regardless rendering `dirty` state.\n        // Bounds can be read multiple times per frame.\n        this._boundsDirty = true;\n\n        // Visual updates happen only once per frame.\n        // There is no need to dispatch an `update` in if it was already dispatched this frame.\n        if (this.dirty) return;\n        this.emit('update', this, 0x10);\n        this.dirty = true;\n    }\n\n    /** The bounds of the graphic shape. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        // TODO switch to idy dirty with tick..\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n\n            if (action === 'fill')\n            {\n                const data = instruction.data as FillInstruction['data'];\n\n                bounds.addBounds(data.path.bounds);\n            }\n            else if (action === 'texture')\n            {\n                const data = instruction.data as TextureInstruction['data'];\n\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === 'stroke')\n            {\n                const data = instruction.data as StrokeInstruction['data'];\n\n                const alignment = data.style.alignment;\n\n                const outerPadding = (data.style.width * (1 - alignment));\n\n                const _bounds = data.path.bounds;\n\n                bounds.addFrame(\n                    _bounds.minX - outerPadding,\n                    _bounds.minY - outerPadding,\n                    _bounds.maxX + outerPadding,\n                    _bounds.maxY + outerPadding\n                );\n            }\n        }\n\n        return bounds;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: PointData): boolean\n    {\n        // early out if the bounding box is not hit\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n\n        const instructions = this.instructions;\n        let hasHit = false;\n\n        for (let k = 0; k < instructions.length; k++)\n        {\n            const instruction = instructions[k];\n\n            const data = instruction.data as FillInstruction['data'];\n            const path = data.path;\n\n            if (!instruction.action || !path) continue;\n\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n\n            for (let i = 0; i < shapes.length; i++)\n            {\n                const shape = shapes[i].shape;\n\n                if (!style || !shape) continue;\n\n                const transform = shapes[i].transform;\n\n                const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n\n                if (instruction.action === 'fill')\n                {\n                    hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                }\n                else\n                {\n                    const strokeStyle = (style as ConvertedStrokeStyle);\n\n                    hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);\n                }\n\n                const holes = data.hole;\n\n                if (holes)\n                {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n\n                    if (holeShapes)\n                    {\n                        for (let j = 0; j < holeShapes.length; j++)\n                        {\n                            if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y))\n                            {\n                                hasHit = false;\n                            }\n                        }\n                    }\n                }\n\n                if (hasHit)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return hasHit;\n    }\n\n    /** Unloads the GPU data from the graphics context. */\n    public unload(): void\n    {\n        this.emit('unload', this);\n        for (const key in this._gpuData)\n        {\n            this._gpuData[key]?.destroy();\n        }\n        this._gpuData = Object.create(null);\n    }\n\n    /**\n     * Destroys the GraphicsData object.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * context.destroy();\n     * context.destroy(true);\n     * context.destroy({ texture: true, textureSource: true });\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false): void\n    {\n        if (this.destroyed) return;\n        this.destroyed = true;\n        this._stateStack.length = 0;\n        this._transform = null;\n\n        this.unload();\n        this.emit('destroy', this);\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fillStyle.texture)\n            {\n                this._fillStyle.fill && 'uid' in this._fillStyle.fill\n                    ? this._fillStyle.fill.destroy()\n                    : this._fillStyle.texture.destroy(destroyTextureSource);\n            }\n\n            if (this._strokeStyle.texture)\n            {\n                this._strokeStyle.fill && 'uid' in this._strokeStyle.fill\n                    ? this._strokeStyle.fill.destroy()\n                    : this._strokeStyle.texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fillStyle = null;\n        this._strokeStyle = null;\n\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n}\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { ViewContainer, type ViewContainerOptions } from '../../view/ViewContainer';\nimport { GraphicsContext } from './GraphicsContext';\nimport { type GraphicsGpuData } from './GraphicsPipe';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillInput, FillStyle, StrokeStyle } from './FillTypes';\nimport type { GraphicsPath } from './path/GraphicsPath';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * Constructor options used for Graphics instances.\n * Configures the initial state and behavior of a Graphics object.\n * @example\n * ```ts\n * const graphics = new Graphics({\n *     roundPixels: true,\n *     position: { x: 100.5, y: 100.5 }\n * });\n *\n * // Reuse graphics context\n * const sharedContext = new GraphicsContext();\n * const graphics1 = new Graphics({ context: sharedContext });\n * const graphics2 = new Graphics({ context: sharedContext });\n * ```\n * @see {@link Graphics} For the graphics class implementation\n * @see {@link GraphicsContext} For the graphics context API\n * @category scene\n * @standard\n */\nexport interface GraphicsOptions extends PixiMixins.GraphicsOptions, ViewContainerOptions\n{\n    /**\n     * The GraphicsContext to use, useful for reuse and optimisation\n     * If not provided, a new GraphicsContext will be created.\n     * @example\n     * ```ts\n     * const sharedContext = new GraphicsContext();\n     * const graphics1 = new Graphics({ context: sharedContext });\n     * const graphics2 = new Graphics({ context: sharedContext });\n     * ```\n     */\n    context?: GraphicsContext;\n    /**\n     * Whether or not to round the x/y position.\n     * @default false\n     * @example\n     * ```ts\n     * const graphics = new Graphics({ roundPixels: true });\n     * ```\n     */\n    roundPixels?: boolean;\n}\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Graphics extends PixiMixins.Graphics, ViewContainer<GraphicsGpuData> {}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them. It can also be used to create complex\n * masks and hit areas for interaction.\n * @example\n * ```ts\n * // Create a new graphics object\n * const graphics = new Graphics();\n *\n * // Draw a filled rectangle with a stroke\n * graphics\n *     .rect(0, 0, 100, 100)\n *     .fill({ color: 0xff0000 }) // Fill with red\n *     .stroke({ width: 2, color: 0x000000 }); // Stroke with black\n *\n * // Draw a complex shape\n * graphics\n *     .moveTo(50, 50)\n *     .lineTo(100, 100)\n *     .arc(100, 100, 50, 0, Math.PI)\n *     .closePath()\n *     .fill({ color: 0x00ff00, alpha: 0.5 }); // Fill the shape\n *\n * // Use as a mask\n * sprite.mask = graphics;\n * ```\n * @see {@link GraphicsContext} For the underlying drawing API\n * @see {@link GraphicsPath} For path creation\n * @category scene\n * @standard\n */\nexport class Graphics extends ViewContainer<GraphicsGpuData> implements Instruction\n{\n    /** @internal */\n    public override readonly renderPipeId: string = 'graphics';\n    /** @internal */\n    public batched: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * Creates a new Graphics object.\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this.context = this._ownedContext = new GraphicsContext();\n            this.context.autoGarbageCollect = this.autoGarbageCollect;\n        }\n        else\n        {\n            this.context = context;\n        }\n\n        this.didViewUpdate = true;\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        if (this._context)\n        {\n            this._context.off('update', this.onViewUpdate, this);\n            this._context.off('unload', this.unload, this);\n        }\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n        this._context.on('unload', this.unload, this);\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * The underlying graphics context used for drawing operations.\n     * Controls how shapes and paths are rendered.\n     * @example\n     * ```ts\n     * // Create a shared context\n     * const sharedContext = new GraphicsContext();\n     *\n     * // Create graphics objects sharing the same context\n     * const graphics1 = new Graphics();\n     * const graphics2 = new Graphics();\n     *\n     * // Assign shared context\n     * graphics1.context = sharedContext;\n     * graphics2.context = sharedContext;\n     *\n     * // Both graphics will show the same shapes\n     * sharedContext\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @see {@link GraphicsContext} For drawing operations\n     * @see {@link GraphicsOptions} For context configuration\n     */\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphics object.\n     * Returns the boundaries after all graphical operations but before any transforms.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a shape\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Get bounds information\n     * const bounds = graphics.bounds;\n     * console.log(bounds.width);  // 100\n     * console.log(bounds.height); // 100\n     * ```\n     * @readonly\n     * @see {@link Bounds} For bounds operations\n     * @see {@link Container#getBounds} For transformed bounds\n     */\n    override get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Graphics objects do not need to update their bounds as the context handles this.\n     * @private\n     */\n    protected updateBounds(): void { /** */ }\n\n    /**\n     * Checks if the object contains the given point.\n     * Returns true if the point lies within the Graphics object's rendered area.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a shape\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Check point intersection\n     * if (graphics.containsPoint({ x: 50, y: 50 })) {\n     *     console.log('Point is inside rectangle!');\n     * }\n     * ```\n     * @param point - The point to check in local coordinates\n     * @returns True if the point is inside the Graphics object\n     * @see {@link Graphics#bounds} For bounding box checks\n     * @see {@link PointData} For point data structure\n     */\n    public override containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @example\n     * ```ts\n     * // Destroy the graphics and its context\n     * graphics.destroy();\n     * graphics.destroy(true);\n     * graphics.destroy({ context: true, texture: true, textureSource: true });\n     * ```\n     */\n    public override destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    /**\n     * @param now - The current time in milliseconds.\n     * @internal\n     */\n    public _onTouch(now: number): void\n    {\n        this._gcLastUsed = now;\n        this._context._gcLastUsed = now;\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n     * Sets the current fill style of the graphics context.\n     * The fill style can be a color, gradient, pattern, or a complex style object.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color fill\n     * graphics\n     *     .setFillStyle({ color: 0xff0000 }) // Red fill\n     *     .rect(0, 0, 100, 100)\n     *     .fill();\n     *\n     * // Gradient fill\n     * const gradient = new FillGradient({\n     *    end: { x: 1, y: 0 },\n     *    colorStops: [\n     *         { offset: 0, color: 0xff0000 }, // Red at start\n     *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *         { offset: 1, color: 0x0000ff }, // Blue at end\n     *    ],\n     * });\n     *\n     * graphics\n     *     .setFillStyle(gradient)\n     *     .circle(100, 100, 50)\n     *     .fill();\n     *\n     * // Pattern fill\n     * const pattern = new FillPattern(texture);\n     * graphics\n     *     .setFillStyle({\n     *         fill: pattern,\n     *         alpha: 0.5\n     *     })\n     *     .rect(0, 0, 200, 200)\n     *     .fill();\n     * ```\n     * @param {FillInput} args - The fill style to apply\n     * @returns The Graphics instance for chaining\n     * @see {@link FillStyle} For fill style options\n     * @see {@link FillGradient} For gradient fills\n     * @see {@link FillPattern} For pattern fills\n     */\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context.\n     * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color stroke\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 2,\n     *         color: 0x000000\n     *     })\n     *     .rect(0, 0, 100, 100)\n     *     .stroke();\n     *\n     * // Complex stroke style\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 4,\n     *         color: 0xff0000,\n     *         alpha: 0.5,\n     *         join: 'round',\n     *         cap: 'round',\n     *         alignment: 0.5\n     *     })\n     *     .circle(100, 100, 50)\n     *     .stroke();\n     *\n     * // Gradient stroke\n     * const gradient = new FillGradient({\n     *    end: { x: 1, y: 0 },\n     *    colorStops: [\n     *         { offset: 0, color: 0xff0000 }, // Red at start\n     *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *         { offset: 1, color: 0x0000ff }, // Blue at end\n     *    ],\n     * });\n     *\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 10,\n     *         fill: gradient\n     *     })\n     *     .poly([0,0, 100,50, 0,100])\n     *     .stroke();\n     * ```\n     * @param {StrokeInput} args - The stroke style to apply\n     * @returns The Graphics instance for chaining\n     * @see {@link StrokeStyle} For stroke style options\n     * @see {@link FillGradient} For gradient strokes\n     * @see {@link FillPattern} For pattern strokes\n     */\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    /**\n     * Fills the current or given path with the current fill style or specified style.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Fill with direct color\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .fill('red'); // Red fill\n     *\n     * // Fill with texture\n     * graphics\n     *    .rect(0, 0, 100, 100)\n     *    .fill(myTexture); // Fill with texture\n     *\n     * // Fill with complex style\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({\n     *         color: 0x00ff00,\n     *         alpha: 0.5,\n     *         texture: myTexture,\n     *         matrix: new Matrix()\n     *     });\n     *\n     * // Fill with gradient\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *         { offset: 0, color: 0xff0000 },\n     *         { offset: 0.5, color: 0x00ff00 },\n     *         { offset: 1, color: 0x0000ff },\n     *     ],\n     * });\n     *\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill(gradient);\n     * ```\n     * @param {FillInput} style - The style to fill the path with. Can be:\n     * - A ColorSource\n     * - A gradient\n     * - A pattern\n     * - A complex style object\n     * If omitted, uses current fill style.\n     * @returns The Graphics instance for chaining\n     * @see {@link FillStyle} For fill style options\n     * @see {@link FillGradient} For gradient fills\n     * @see {@link FillPattern} For pattern fills\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha?: number): this;\n    public fill(...args: [FillStyle | ColorSource, number?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    /**\n     * Strokes the current path with the current stroke style or specified style.\n     * Outlines the shape using the stroke settings.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Stroke with direct color\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .stroke({\n     *         width: 2,\n     *         color: 0xff0000\n     *     }); // 2px red stroke\n     *\n     * // Fill with texture\n     * graphics\n     *    .rect(0, 0, 100, 100)\n     *    .stroke(myTexture); // Fill with texture\n     *\n     * // Stroke with gradient\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *         { offset: 0, color: 0xff0000 },\n     *         { offset: 0.5, color: 0x00ff00 },\n     *         { offset: 1, color: 0x0000ff },\n     *     ],\n     * });\n     *\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .stroke({\n     *         width: 4,\n     *         fill: gradient,\n     *         alignment: 0.5,\n     *         join: 'round'\n     *     });\n     * ```\n     * @param {StrokeStyle} args - Optional stroke style to apply. Can be:\n     * - A stroke style object with width, color, etc.\n     * - A gradient\n     * - A pattern\n     * If omitted, uses current stroke style.\n     * @returns The Graphics instance for chaining\n     * @see {@link StrokeStyle} For stroke style options\n     * @see {@link FillGradient} For gradient strokes\n     * @see {@link setStrokeStyle} For setting default stroke style\n     */\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    /**\n     * Adds a texture to the graphics context. This method supports multiple ways to draw textures\n     * including basic textures, tinted textures, and textures with custom dimensions.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic texture drawing\n     * graphics.texture(myTexture);\n     *\n     * // Tinted texture with position\n     * graphics.texture(myTexture, 0xff0000); // Red tint\n     *\n     * // Texture with custom position and dimensions\n     * graphics\n     *     .texture(\n     *         myTexture,    // texture\n     *         0xffffff,     // white tint\n     *         100, 100,     // position\n     *         200, 150      // dimensions\n     *     );\n     * ```\n     * Basic texture drawing:\n     * @param texture - The Texture object to use.\n     * @returns The instance of the current Graphics for chaining.\n     *\n     * Extended texture drawing:\n     * @param texture - The Texture object to use.\n     *        tint - A ColorSource to tint the texture (defaults to white).\n     *        dx - The x-coordinate for the texture placement.\n     *        dy - The y-coordinate for the texture placement.\n     *        dw - The width to draw the texture (defaults to texture width).\n     *        dh - The height to draw the texture (defaults to texture height).\n     * @returns The instance of the current Graphics for chaining.\n     * @see {@link Texture} For texture creation\n     * @see {@link FillPattern} For pattern fills\n     */\n    public texture(texture: Texture): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * graphics\n     *     .circle(150, 150, 50)\n     *     .fill({ color: 0x00ff00 })\n     *     .beginPath() // Starts a new path\n     *     .circle(250, 150, 50)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @returns The Graphics instance for chaining\n     * @see {@link Graphics#moveTo} For starting a new subpath\n     * @see {@link Graphics#closePath} For closing the current path\n     */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path.\n     *\n     * If a hole is not completely in a shape, it will fail to cut correctly.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw outer circle\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *     .circle(100, 100, 25) // Inner circle\n     *     .cut() // Cuts out the inner circle from the outer circle\n     * ```\n     */\n    public cut(): this\n    {\n        return this._callContextMethod('cut', []);\n    }\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @example\n     * ```ts\n     * // Draw a simple arc (quarter circle)\n     * const graphics = new Graphics();\n     * graphics\n     *     .arc(100, 100, 50, 0, Math.PI/2)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Draw a full circle using an arc\n     * graphics\n     *     .arc(200, 200, 30, 0, Math.PI * 2)\n     *     .stroke({ color: 0x00ff00 });\n     *\n     * // Draw a counterclockwise arc\n     * graphics\n     *     .arc(150, 150, 40, Math.PI, 0, true)\n     *     .stroke({ width: 2, color: 0x0000ff });\n     * ```\n     * @param x - The x-coordinate of the arc's center\n     * @param y - The y-coordinate of the arc's center\n     * @param radius - The arc's radius (must be positive)\n     * @param startAngle - The starting point of the arc, in radians\n     * @param endAngle - The end point of the arc, in radians\n     * @param counterclockwise - Optional. If true, draws the arc counterclockwise.\n     *                          If false (default), draws clockwise.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#circle} For drawing complete circles\n     * @see {@link Graphics#arcTo} For drawing arcs between points\n     * @see {@link Graphics#arcToSvg} For SVG-style arc drawing\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    /**\n     * Adds an arc to the current path that connects two points using a radius.\n     * The arc is drawn between the current point and the specified end point,\n     * using the given control point to determine the curve of the arc.\n     * @example\n     * ```ts\n     * // Draw a simple curved corner\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .arcTo(100, 50, 100, 100, 20) // Rounded corner with 20px radius\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create a rounded rectangle using arcTo\n     * graphics\n     *     .moveTo(150, 150)\n     *     .arcTo(250, 150, 250, 250, 30) // Top right corner\n     *     .arcTo(250, 250, 150, 250, 30) // Bottom right corner\n     *     .arcTo(150, 250, 150, 150, 30) // Bottom left corner\n     *     .arcTo(150, 150, 250, 150, 30) // Top left corner\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param x1 - The x-coordinate of the control point\n     * @param y1 - The y-coordinate of the control point\n     * @param x2 - The x-coordinate of the end point\n     * @param y2 - The y-coordinate of the end point\n     * @param radius - The radius of the arc in pixels (must be positive)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#arc} For drawing arcs using center point and angles\n     * @see {@link Graphics#arcToSvg} For SVG-style arc drawing\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * This is particularly useful when converting SVG paths to Graphics or creating complex curved shapes.\n     * @example\n     * ```ts\n     * // Draw a simple elliptical arc\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(100, 100)\n     *     .arcToSvg(50, 30, 0, 0, 1, 200, 100)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create a complex path with rotated elliptical arc\n     * graphics\n     *     .moveTo(150, 150)\n     *     .arcToSvg(\n     *         60,    // rx\n     *         30,    // ry\n     *         45,    // x-axis rotation (45 degrees)\n     *         1,     // large arc flag\n     *         0,     // sweep flag\n     *         250,   // end x\n     *         200    // end y\n     *     )\n     *     .stroke({ width: 4, color: 0x00ff00 });\n     *\n     * // Chain multiple arcs for complex shapes\n     * graphics\n     *     .moveTo(300, 100)\n     *     .arcToSvg(40, 20, 0, 0, 1, 350, 150)\n     *     .arcToSvg(40, 20, 0, 0, 1, 300, 200)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param rx - The x-radius of the ellipse (must be non-negative)\n     * @param ry - The y-radius of the ellipse (must be non-negative)\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative to the x-axis, in degrees\n     * @param largeArcFlag - Either 0 or 1, determines if the larger of the two possible arcs is chosen (1) or not (0)\n     * @param sweepFlag - Either 0 or 1, determines if the arc should be swept in\n     *                    a positive angle direction (1) or negative (0)\n     * @param x - The x-coordinate of the arc's end point\n     * @param y - The y-coordinate of the arc's end point\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#arc} For simple circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     * @see {@link Graphics#svg} For parsing complete SVG paths\n     */\n    public arcToSvg(\n        rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number\n    ): this;\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    /**\n     * Adds a cubic Bzier curve to the path, from the current point to the specified end point.\n     * The curve is influenced by two control points that define its shape and curvature.\n     * @example\n     * ```ts\n     * // Draw a simple curved line\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .bezierCurveTo(\n     *         100, 25,   // First control point\n     *         150, 75,   // Second control point\n     *         200, 50    // End point\n     *     )\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Adjust curve smoothness\n     * graphics\n     *     .moveTo(50, 200)\n     *     .bezierCurveTo(\n     *         100, 150,\n     *         200, 250,\n     *         250, 200,\n     *         0.5         // Smoothness factor\n     *     )\n     *     .stroke({ width: 4, color: 0x0000ff });\n     * ```\n     * @param cp1x - The x-coordinate of the first control point\n     * @param cp1y - The y-coordinate of the first control point\n     * @param cp2x - The x-coordinate of the second control point\n     * @param cp2y - The y-coordinate of the second control point\n     * @param x - The x-coordinate of the end point\n     * @param y - The y-coordinate of the end point\n     * @param smoothness - Optional parameter to adjust the curve's smoothness (0-1)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#quadraticCurveTo} For simpler curves with one control point\n     * @see {@link Graphics#arc} For circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    /**\n     * Closes the current path by drawing a straight line back to the start point.\n     *\n     * This is useful for completing shapes and ensuring they are properly closed for fills.\n     * @example\n     * ```ts\n     * // Create a triangle with closed path\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 100)\n     *     .lineTo(0, 100)\n     *     .closePath()\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#beginPath} For starting a new path\n     * @see {@link Graphics#fill} For filling closed paths\n     * @see {@link Graphics#stroke} For stroking paths\n     */\n    public closePath(): this\n    {\n        return this._callContextMethod('closePath', []);\n    }\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic ellipse\n     * graphics\n     *     .ellipse(100, 100, 50, 30)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw an ellipse with stroke\n     * graphics\n     *     .ellipse(200, 100, 70, 40)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the center of the ellipse\n     * @param y - The y-coordinate of the center of the ellipse\n     * @param radiusX - The horizontal radius of the ellipse\n     * @param radiusY - The vertical radius of the ellipse\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#circle} For drawing perfect circles\n     * @see {@link Graphics#arc} For drawing partial circular arcs\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    /**\n     * Draws a circle shape at the specified location with the given radius.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple filled circle\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a circle with gradient fill\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *           { offset: 0, color: 0xff0000 }, // Red at start\n     *           { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *           { offset: 1, color: 0x0000ff }, // Blue at end\n     *     ],\n     * });\n     *\n     * graphics\n     *     .circle(250, 100, 40)\n     *     .fill({ fill: gradient });\n     * ```\n     * @param x - The x-coordinate of the center of the circle\n     * @param y - The y-coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#ellipse} For drawing ellipses\n     * @see {@link Graphics#arc} For drawing partial circles\n     */\n    public circle(x: number, y: number, radius: number): this;\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * This allows for reuse of complex paths and shapes across different graphics instances.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * // Create a reusable path\n     * const heartPath = new GraphicsPath()\n     *     .moveTo(0, 0)\n     *     .bezierCurveTo(-50, -25, -50, -75, 0, -100)\n     *     .bezierCurveTo(50, -75, 50, -25, 0, 0);\n     *\n     * // Use the path multiple times\n     * graphics\n     *     .path(heartPath)\n     *     .fill({ color: 0xff0000 })\n     *     .translateTransform(200, 200)\n     *     .path(heartPath)\n     *     .fill({ color: 0xff0000, alpha: 0.5 });\n     * ```\n     * @param path - The `GraphicsPath` to add to the current path\n     * @returns The Graphics instance for method chaining\n     * @see {@link GraphicsPath} For creating reusable paths\n     * @see {@link Matrix} For creating transformations\n     * @see {@link Graphics#transform} For applying transformations\n     */\n    public path(path: GraphicsPath): this;\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    /**\n     * Connects the current point to a new point with a straight line.\n     * Any subsequent drawing commands will start from this new point.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a triangle\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 100)\n     *     .lineTo(0, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Create a complex shape with multiple lines\n     * graphics\n     *     .moveTo(200, 50)\n     *     .lineTo(250, 50)\n     *     .lineTo(250, 100)\n     *     .lineTo(200, 100)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the line's end point\n     * @param y - The y-coordinate of the line's end point\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#moveTo} For starting a new sub-path\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    /**\n     * Sets the starting point for a new sub-path.\n     *\n     * Moves the \"pen\" to a new location without drawing a line.\n     * Any subsequent drawing commands will start from this point.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Create multiple separate lines\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 50)\n     *     .moveTo(50, 100)    // Start a new line\n     *     .lineTo(100, 100)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create disconnected shapes\n     * graphics\n     *     .moveTo(150, 50)\n     *     .rect(150, 50, 50, 50)\n     *     .fill({ color: 0x00ff00 })\n     *     .moveTo(250, 50)    // Start a new shape\n     *     .circle(250, 75, 25)\n     *     .fill({ color: 0x0000ff });\n     *\n     * // Position before curved paths\n     * graphics\n     *     .moveTo(300, 50)\n     *     .bezierCurveTo(\n     *         350, 25,   // Control point 1\n     *         400, 75,   // Control point 2\n     *         450, 50    // End point\n     *     )\n     *     .stroke({ width: 3, color: 0xff00ff });\n     * ```\n     * @param x - The x-coordinate to move to\n     * @param y - The y-coordinate to move to\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#lineTo} For drawing lines\n     * @see {@link Graphics#beginPath} For starting a completely new path\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple curve\n     * graphics\n     *     .moveTo(50, 50)\n     *     .quadraticCurveTo(100, 25, 150, 50)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Adjust curve smoothness\n     * graphics\n     *     .moveTo(50, 200)\n     *     .quadraticCurveTo(\n     *         150, 150,   // Control point\n     *         250, 200,   // End point\n     *         0.5         // Smoothness factor\n     *     )\n     *     .stroke({\n     *         width: 4,\n     *         color: 0x0000ff,\n     *         alpha: 0.7\n     *     });\n     * ```\n     * @param cpx - The x-coordinate of the control point\n     * @param cpy - The y-coordinate of the control point\n     * @param x - The x-coordinate of the end point\n     * @param y - The y-coordinate of the end point\n     * @param smoothness - Optional parameter to adjust the curve's smoothness (0-1)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#bezierCurveTo} For curves with two control points\n     * @see {@link Graphics#arc} For circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    /**\n     * Draws a rectangle shape.\n     *\n     * This method adds a new rectangle path to the current drawing.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple filled rectangle\n     * graphics\n     *     .rect(50, 50, 100, 75)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Rectangle with stroke\n     * graphics\n     *     .rect(200, 50, 100, 75)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param w - The width of the rectangle\n     * @param h - The height of the rectangle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     * @see {@link Graphics#filletRect} For drawing rectangles with filleted corners\n     * @see {@link Graphics#chamferRect} For drawing rectangles with chamfered corners\n     */\n\n    public rect(x: number, y: number, w: number, h: number): this;\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    /**\n     * Draws a rectangle with rounded corners. The corner radius can be specified to\n     * determine how rounded the corners should be.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic rounded rectangle\n     * graphics\n     *     .roundRect(50, 50, 100, 75, 15)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param w - The width of the rectangle\n     * @param h - The height of the rectangle\n     * @param radius - The radius of the rectangle's corners (must be non-negative)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#rect} For drawing rectangles with sharp corners\n     * @see {@link Graphics#filletRect} For drawing rectangles with filleted corners\n     * @see {@link Graphics#chamferRect} For drawing rectangles with chamfered corners\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed.\n     *\n     * An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a triangle using array of numbers [x1,y1, x2,y2, x3,y3]\n     * graphics\n     *     .poly([50,50, 100,100, 0,100], true)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a polygon using point objects\n     * graphics\n     *     .poly([\n     *         { x: 200, y: 50 },\n     *         { x: 250, y: 100 },\n     *         { x: 200, y: 150 },\n     *         { x: 150, y: 100 }\n     *     ])\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Draw an open polygon with stroke\n     * graphics\n     *     .poly([300,50, 350,50, 350,100, 300,100], false)\n     *     .stroke({\n     *         width: 2,\n     *         color: 0x0000ff,\n     *         join: 'round'\n     *     });\n     * ```\n     * @param points - An array of numbers [x1,y1, x2,y2, ...] or an array of point objects [{x,y}, ...]\n     *                representing the vertices of the polygon in sequence\n     * @param close - Whether to close the polygon path by connecting the last point to the first.\n     *               Default is true.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing regular polygons\n     * @see {@link Graphics#roundPoly} For drawing polygons with rounded corners\n     * @see {@link Graphics#star} For drawing star shapes\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this;\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal,\n     * making shapes like triangles, squares, pentagons, etc.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple triangle (3 sides)\n     * graphics\n     *     .regularPoly(100, 100, 50, 3)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a hexagon (6 sides) with rotation\n     * graphics\n     *     .regularPoly(\n     *         250, 100,    // center position\n     *         40,          // radius\n     *         6,           // sides\n     *         Math.PI / 6  // rotation (30 degrees)\n     *     )\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     *\n     * // Draw an octagon (8 sides) with transform\n     * const transform = new Matrix()\n     *     .scale(1.5, 1)      // stretch horizontally\n     *     .rotate(Math.PI/4); // rotate 45 degrees\n     *\n     * graphics\n     *     .regularPoly(400, 100, 30, 8, 0, transform)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param x - The x-coordinate of the center of the polygon\n     * @param y - The y-coordinate of the center of the polygon\n     * @param radius - The radius of the circumscribed circle of the polygon\n     * @param sides - The number of sides of the polygon (must be 3 or more)\n     * @param rotation - The rotation angle of the polygon in radians (default: 0)\n     * @param transform - Optional Matrix to transform the polygon's shape\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#roundPoly} For drawing polygons with rounded corners\n     * @see {@link Graphics#star} For drawing star shapes\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     *\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic rounded triangle\n     * graphics\n     *     .roundPoly(100, 100, 50, 3, 10)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a rounded hexagon with rotation\n     * graphics\n     *     .roundPoly(\n     *         250, 150,     // center position\n     *         40,           // radius\n     *         6,            // sides\n     *         8,            // corner radius\n     *         Math.PI / 6   // rotation (30 degrees)\n     *     )\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the center of the polygon\n     * @param y - The y-coordinate of the center of the polygon\n     * @param radius - The radius of the circumscribed circle of the polygon\n     * @param sides - The number of sides of the polygon (must be 3 or more)\n     * @param corner - The radius of the corner rounding (must be non-negative)\n     * @param rotation - The rotation angle of the polygon in radians (default: 0)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing polygons without rounded corners\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a custom shape with rounded corners\n     * graphics\n     *     .roundShape([\n     *         { x: 100, y: 100, radius: 20 },\n     *         { x: 200, y: 100, radius: 10 },\n     *         { x: 200, y: 200, radius: 15 },\n     *         { x: 100, y: 200, radius: 5 }\n     *     ], 10)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using quadratic curves for corners\n     * graphics\n     *     .roundShape([\n     *         { x: 250, y: 100 },\n     *         { x: 350, y: 100 },\n     *         { x: 350, y: 200 },\n     *         { x: 250, y: 200 }\n     *     ], 15, true, 0.5)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     *\n     * // Shape with varying corner radii\n     * graphics\n     *     .roundShape([\n     *         { x: 400, y: 100, radius: 30 },\n     *         { x: 500, y: 100, radius: 5 },\n     *         { x: 450, y: 200, radius: 15 }\n     *     ], 10)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param points - An array of `RoundedPoint` representing the corners of the shape.\n     *                Each point can have its own radius or use the default.\n     *                A minimum of 3 points is required.\n     * @param radius - The default radius for corners without a specific radius defined.\n     *                Applied to any point that doesn't specify its own radius.\n     * @param useQuadratic - When true, corners are drawn using quadratic curves instead\n     *                      of arcs, creating a different visual style. Defaults to false.\n     * @param smoothness - Controls the smoothness of quadratic corners when useQuadratic\n     *                    is true. Values range from 0-1, higher values create smoother curves.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     * @see {@link Graphics#roundPoly} For drawing regular polygons with rounded corners\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    /**\n     * Draws a rectangle with fillet corners. Unlike rounded rectangles, this supports negative corner\n     * radii which create external rounded corners rather than internal ones.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a rectangle with internal fillets\n     * graphics\n     *     .filletRect(50, 50, 100, 80, 15)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a rectangle with external fillets\n     * graphics\n     *     .filletRect(200, 50, 100, 80, -20)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @param fillet - The radius of the corner fillets (can be positive or negative)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For standard rounded corners\n     * @see {@link Graphics#chamferRect} For angled corners\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    /**\n     * Draws a rectangle with chamfered (angled) corners. Each corner is cut off at\n     * a 45-degree angle based on the chamfer size.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic chamfered rectangle\n     * graphics\n     *     .chamferRect(50, 50, 100, 80, 15)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Add transform and stroke\n     * const transform = new Matrix()\n     *     .rotate(Math.PI / 4); // 45 degrees\n     *\n     * graphics\n     *     .chamferRect(200, 50, 100, 80, 20, transform)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @param chamfer - The size of the corner chamfers (must be non-zero)\n     * @param transform - Optional Matrix to transform the rectangle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For rounded corners\n     * @see {@link Graphics#filletRect} For rounded corners with negative radius support\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     * of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     *\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic 5-pointed star\n     * graphics\n     *     .star(100, 100, 5, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Star with custom inner radius\n     * graphics\n     *     .star(250, 100, 6, 50, 20)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the center of the star\n     * @param y - The y-coordinate of the center of the star\n     * @param points - The number of points on the star (must be >= 3)\n     * @param radius - The outer radius of the star (distance from center to point tips)\n     * @param innerRadius - Optional. The inner radius of the star (distance from center to inner vertices).\n     *                     If not specified, defaults to half of the outer radius\n     * @param rotation - Optional. The rotation of the star in radians. Default is 0,\n     *                  which aligns one point straight up\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing regular polygons\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#path} For creating custom shapes\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes\n     * and paths defined in SVG format to be drawn within the graphics context.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * graphics\n     *     .svg(`\n     *         <path d=\"M 50,50 L 100,50 L 100,100 L 50,100 Z\"\n     *               fill=\"blue\" />\n     *         <circle cx=\"150\" cy=\"75\" r=\"25\"\n     *               fill=\"green\" />\n     *     `)\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param svg - The SVG string to be parsed and rendered\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#path} For adding custom paths\n     * @see {@link Graphics#fill} For filling shapes after SVG parsing\n     * @see {@link Graphics#stroke} For stroking shapes after SVG parsing\n     */\n    public svg(svg: string): this;\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Save current state\n     * graphics.save();\n     *\n     * // Make temporary changes\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .setFillStyle({ color: 0xff0000 })\n     *     .circle(0, 0, 50)\n     *     .fill();\n     *\n     * // Restore to previous state\n     * graphics.restore();\n     *\n     * // Draw with original transform and styles\n     * graphics\n     *     .circle(50, 50, 30)\n     *     .fill();\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#save} For saving the current state\n     */\n    public restore(): this;\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    /**\n     * Saves the current graphics state onto a stack. The state includes:\n     * - Current transformation matrix\n     * - Current fill style\n     * - Current stroke style\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Save state before complex operations\n     * graphics.save();\n     *\n     * // Create transformed and styled shape\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .rotateTransform(Math.PI / 4)\n     *     .setFillStyle({\n     *         color: 0xff0000,\n     *         alpha: 0.5\n     *     })\n     *     .rect(-25, -25, 50, 50)\n     *     .fill();\n     *\n     * // Restore to original state\n     * graphics.restore();\n     *\n     * // Continue drawing with previous state\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .fill();\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#restore} For restoring the saved state\n     * @see {@link Graphics#setTransform} For setting transformations\n     */\n    public save(): this\n    {\n        return this._callContextMethod('save', []);\n    }\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * This matrix represents all accumulated transformations including translate, scale, and rotate.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Apply some transformations\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .rotateTransform(Math.PI / 4);\n     *\n     * // Get the current transform matrix\n     * const matrix = graphics.getTransform();\n     * console.log(matrix.tx, matrix.ty); // 100, 100\n     *\n     * // Use the matrix for other operations\n     * graphics\n     *     .setTransform(matrix)\n     *     .circle(0, 0, 50)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @returns The current transformation matrix.\n     * @see {@link Graphics#setTransform} For setting the transform matrix\n     * @see {@link Matrix} For matrix operations\n     */\n    public getTransform(): Matrix\n    {\n        return this.context.getTransform();\n    }\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing\n     * any transformations (rotation, scaling, translation) previously applied.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Apply transformations\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .scaleTransform(2, 2)\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     * // Reset transform to default state\n     * graphics\n     *     .resetTransform()\n     *     .circle(50, 50, 25) // Will draw at actual coordinates\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#getTransform} For getting the current transform\n     * @see {@link Graphics#setTransform} For setting a specific transform\n     * @see {@link Graphics#save} For saving the current transform state\n     * @see {@link Graphics#restore} For restoring a previous transform state\n     */\n    public resetTransform(): this\n    {\n        return this._callContextMethod('resetTransform', []);\n    }\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * Positive angles rotate clockwise, while negative angles rotate counterclockwise.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Rotate 45 degrees clockwise\n     * graphics\n     *     .rotateTransform(Math.PI / 4)\n     *     .rect(-25, -25, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param angle - The angle of rotation in radians\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#scaleTransform} For scaling transformations\n     * @see {@link Graphics#translateTransform} For position transformations\n     */\n    public rotateTransform(angle: number): this;\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally\n     * and by y vertically relative to the current origin.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Uniform scaling\n     * graphics\n     *     .scaleTransform(2)  // Scale both dimensions by 2\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Non-uniform scaling\n     * graphics\n     *     .scaleTransform(0.5, 2)  // Half width, double height\n     *     .rect(100, 100, 50, 50)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param x - The scale factor in the horizontal direction\n     * @param y - The scale factor in the vertical direction. If omitted, equals x\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#rotateTransform} For rotation transformations\n     * @see {@link Graphics#translateTransform} For position transformations\n     */\n    public scaleTransform(x: number, y?: number): this;\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    /**\n     * Sets the current transformation matrix of the graphics context.\n     *\n     * This method can either\n     * take a Matrix object or individual transform values to create a new transformation matrix.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Using a Matrix object\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4);\n     *\n     * graphics\n     *     .setTransform(matrix)\n     *     .rect(0, 0, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using individual transform values\n     * graphics\n     *     .setTransform(\n     *         2, 0,     // scale x by 2\n     *         0, 1,     // no skew\n     *         100, 100  // translate x,y by 100\n     *     )\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param transform - The matrix to set as the current transformation matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    /**\n     * Applies a transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix. This allows for complex transformations\n     * combining multiple operations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Using a Matrix object\n     * const matrix = new Matrix()\n     *     .scale(2, 1)      // Scale horizontally\n     *     .rotate(Math.PI/6); // Rotate 30 degrees\n     *\n     * graphics\n     *     .transform(matrix)\n     *     .rect(0, 0, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using individual transform values\n     * graphics\n     *     .transform(\n     *         1, 0.5,    // Skew horizontally\n     *         0, 1,      // No vertical skew\n     *         100, 100   // Translate\n     *     )\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param transform - The matrix to apply to the current transformation.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * This affects all subsequent drawing operations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic translation\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param x - The amount to translate in the horizontal direction\n     * @param y - The amount to translate in the vertical direction. If omitted, equals x\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#setTransform} For setting absolute transformations\n     * @see {@link Graphics#transform} For applying complex transformations\n     * @see {@link Graphics#save} For saving the current transform state\n     */\n    public translateTransform(x: number, y?: number): this;\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it.\n     * This includes clearing the current path, fill style, stroke style, and transformations.\n     *\n     * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.\n     * > Instead, they are intended to be used for static or semi-static graphics that\n     * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw some shapes\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 })\n     *     .rect(200, 100, 100, 50)\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Clear all graphics\n     * graphics.clear();\n     *\n     * // Start fresh with new shapes\n     * graphics\n     *     .circle(150, 150, 30)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#beginPath} For starting a new path without clearing styles\n     * @see {@link Graphics#save} For saving the current state\n     * @see {@link Graphics#restore} For restoring a previous state\n     */\n    public clear(): this\n    {\n        return this._callContextMethod('clear', []);\n    }\n    /**\n     * Gets or sets the current fill style for the graphics context. The fill style determines\n     * how shapes are filled when using the fill() method.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color fill\n     * graphics.fillStyle = {\n     *     color: 0xff0000,  // Red\n     *     alpha: 1\n     * };\n     *\n     * // Using gradients\n     * const gradient = new FillGradient({\n     *     end: { x: 0, y: 1 }, // Vertical gradient\n     *     stops: [\n     *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color\n     *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color\n     *     ]\n     * });\n     *\n     * graphics.fillStyle = {\n     *     fill: gradient,\n     *     alpha: 0.8\n     * };\n     *\n     * // Using patterns\n     * graphics.fillStyle = {\n     *     texture: myTexture,\n     *     alpha: 1,\n     *     matrix: new Matrix()\n     *         .scale(0.5, 0.5)\n     *         .rotate(Math.PI / 4)\n     * };\n     * ```\n     * @type {ConvertedFillStyle}\n     * @see {@link FillStyle} For all available fill style options\n     * @see {@link FillGradient} For creating gradient fills\n     * @see {@link Graphics#fill} For applying the fill to paths\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillInput)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * Gets or sets the current stroke style for the graphics context. The stroke style determines\n     * how paths are outlined when using the stroke() method.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic stroke style\n     * graphics.strokeStyle = {\n     *     width: 2,\n     *     color: 0xff0000,\n     *     alpha: 1\n     * };\n     *\n     * // Using with gradients\n     * const gradient = new FillGradient({\n     *   end: { x: 0, y: 1 },\n     *   stops: [\n     *       { offset: 0, color: 0xff0000, alpha: 1 },\n     *       { offset: 1, color: 0x0000ff, alpha: 1 }\n     *   ]\n     * });\n     *\n     * graphics.strokeStyle = {\n     *     width: 4,\n     *     fill: gradient,\n     *     alignment: 0.5,\n     *     join: 'round',\n     *     cap: 'round'\n     * };\n     *\n     * // Complex stroke settings\n     * graphics.strokeStyle = {\n     *     width: 6,\n     *     color: 0x00ff00,\n     *     alpha: 0.5,\n     *     join: 'miter',\n     *     miterLimit: 10,\n     * };\n     * ```\n     * @see {@link StrokeStyle} For all available stroke style options\n     * @see {@link Graphics#stroke} For applying the stroke to paths\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: StrokeStyle)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object that copies the current graphics content.\n     * The clone can either share the same context (shallow clone) or have its own independent\n     * context (deep clone).\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Create original graphics content\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Create a shallow clone (shared context)\n     * const shallowClone = graphics.clone();\n     *\n     * // Changes to original affect the clone\n     * graphics\n     *     .circle(200, 100, 30)\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Create a deep clone (independent context)\n     * const deepClone = graphics.clone(true);\n     *\n     * // Modify deep clone independently\n     * deepClone\n     *     .translateTransform(100, 100)\n     *     .circle(0, 0, 40)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @param deep - Whether to create a deep clone of the graphics object.\n     *              If false (default), the context will be shared between objects.\n     *              If true, creates an independent copy of the context.\n     * @returns A new Graphics instance with either shared or copied context\n     * @see {@link Graphics#context} For accessing the underlying graphics context\n     * @see {@link GraphicsContext} For understanding the shared context behavior\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        if (color !== undefined) fillStyle.color = color;\n        if (alpha !== undefined) fillStyle.alpha = alpha;\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n","/**\n * tiny-lru\n *\n * @copyright 2026 Jason Mulligan <jason.mulligan@avoidwork.com>\n * @license BSD-3-Clause\n * @version 11.4.7\n */\n/**\n * A high-performance Least Recently Used (LRU) cache implementation with optional TTL support.\n * Items are automatically evicted when the cache reaches its maximum size,\n * removing the least recently used items first. All core operations (get, set, delete) are O(1).\n *\n * @class LRU\n * @example\n * // Create a cache with max 100 items\n * const cache = new LRU(100);\n * cache.set('key1', 'value1');\n * console.log(cache.get('key1')); // 'value1'\n *\n * @example\n * // Create a cache with TTL\n * const cache = new LRU(100, 5000); // 5 second TTL\n * cache.set('key1', 'value1');\n * // After 5 seconds, key1 will be expired\n */\nclass LRU {\n\t/**\n\t * Creates a new LRU cache instance.\n\t * Note: Constructor does not validate parameters. Use lru() factory function for parameter validation.\n\t *\n\t * @constructor\n\t * @param {number} [max=0] - Maximum number of items to store. 0 means unlimited.\n\t * @param {number} [ttl=0] - Time to live in milliseconds. 0 means no expiration.\n\t * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().\n\t * @example\n\t * const cache = new LRU(1000, 60000, true); // 1000 items, 1 minute TTL, reset on access\n\t * @see {@link lru} For parameter validation\n\t * @since 1.0.0\n\t */\n\tconstructor (max = 0, ttl = 0, resetTtl = false) {\n\t\tthis.first = null;\n\t\tthis.items = Object.create(null);\n\t\tthis.last = null;\n\t\tthis.max = max;\n\t\tthis.resetTtl = resetTtl;\n\t\tthis.size = 0;\n\t\tthis.ttl = ttl;\n\t}\n\n\t/**\n\t * Removes all items from the cache.\n\t *\n\t * @method clear\n\t * @memberof LRU\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.clear();\n\t * console.log(cache.size); // 0\n\t * @since 1.0.0\n\t */\n\tclear () {\n\t\tthis.first = null;\n\t\tthis.items = Object.create(null);\n\t\tthis.last = null;\n\t\tthis.size = 0;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes an item from the cache by key.\n\t *\n\t * @method delete\n\t * @memberof LRU\n\t * @param {string} key - The key of the item to delete.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * cache.delete('key1');\n\t * console.log(cache.has('key1')); // false\n\t * @see {@link LRU#has}\n\t * @see {@link LRU#clear}\n\t * @since 1.0.0\n\t */\n\tdelete (key) {\n\t\tif (this.has(key)) {\n\t\t\tconst item = this.items[key];\n\n\t\t\tdelete this.items[key];\n\t\t\tthis.size--;\n\n\t\t\tif (item.prev !== null) {\n\t\t\t\titem.prev.next = item.next;\n\t\t\t}\n\n\t\t\tif (item.next !== null) {\n\t\t\t\titem.next.prev = item.prev;\n\t\t\t}\n\n\t\t\tif (this.first === item) {\n\t\t\t\tthis.first = item.next;\n\t\t\t}\n\n\t\t\tif (this.last === item) {\n\t\t\t\tthis.last = item.prev;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an array of [key, value] pairs for the specified keys.\n\t * Order follows LRU order (least to most recently used).\n\t *\n\t * @method entries\n\t * @memberof LRU\n\t * @param {string[]} [keys=this.keys()] - Array of keys to get entries for. Defaults to all keys.\n\t * @returns {Array<Array<*>>} Array of [key, value] pairs in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * console.log(cache.entries()); // [['a', 1], ['b', 2]]\n\t * console.log(cache.entries(['a'])); // [['a', 1]]\n\t * @see {@link LRU#keys}\n\t * @see {@link LRU#values}\n\t * @since 11.1.0\n\t */\n\tentries (keys = this.keys()) {\n\t\tconst result = new Array(keys.length);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key = keys[i];\n\t\t\tresult[i] = [key, this.get(key)];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Removes the least recently used item from the cache.\n\t *\n\t * @method evict\n\t * @memberof LRU\n\t * @param {boolean} [bypass=false] - Whether to force eviction even when cache is empty.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('old', 'value').set('new', 'value');\n\t * cache.evict(); // Removes 'old' item\n\t * @see {@link LRU#setWithEvicted}\n\t * @since 1.0.0\n\t */\n\tevict (bypass = false) {\n\t\tif (bypass || this.size > 0) {\n\t\t\tconst item = this.first;\n\n\t\t\tdelete this.items[item.key];\n\n\t\t\tif (--this.size === 0) {\n\t\t\t\tthis.first = null;\n\t\t\t\tthis.last = null;\n\t\t\t} else {\n\t\t\t\tthis.first = item.next;\n\t\t\t\tthis.first.prev = null;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the expiration timestamp for a given key.\n\t *\n\t * @method expiresAt\n\t * @memberof LRU\n\t * @param {string} key - The key to check expiration for.\n\t * @returns {number|undefined} The expiration timestamp in milliseconds, or undefined if key doesn't exist.\n\t * @example\n\t * const cache = new LRU(100, 5000); // 5 second TTL\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.expiresAt('key1')); // timestamp 5 seconds from now\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#has}\n\t * @since 1.0.0\n\t */\n\texpiresAt (key) {\n\t\tlet result;\n\n\t\tif (this.has(key)) {\n\t\t\tresult = this.items[key].expiry;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Retrieves a value from the cache by key. Updates the item's position to most recently used.\n\t *\n\t * @method get\n\t * @memberof LRU\n\t * @param {string} key - The key to retrieve.\n\t * @returns {*} The value associated with the key, or undefined if not found or expired.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.get('key1')); // 'value1'\n\t * console.log(cache.get('nonexistent')); // undefined\n\t * @see {@link LRU#set}\n\t * @see {@link LRU#has}\n\t * @since 1.0.0\n\t */\n\tget (key) {\n\t\tconst item = this.items[key];\n\n\t\tif (item !== undefined) {\n\t\t\t// Check TTL only if enabled to avoid unnecessary Date.now() calls\n\t\t\tif (this.ttl > 0) {\n\t\t\t\tif (item.expiry <= Date.now()) {\n\t\t\t\t\tthis.delete(key);\n\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fast LRU update without full set() overhead\n\t\t\tthis.moveToEnd(item);\n\n\t\t\treturn item.value;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Checks if a key exists in the cache.\n\t *\n\t * @method has\n\t * @memberof LRU\n\t * @param {string} key - The key to check for.\n\t * @returns {boolean} True if the key exists, false otherwise.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.has('key1')); // true\n\t * console.log(cache.has('nonexistent')); // false\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#delete}\n\t * @since 9.0.0\n\t */\n\thas (key) {\n\t\treturn key in this.items;\n\t}\n\n\t/**\n\t * Efficiently moves an item to the end of the LRU list (most recently used position).\n\t * This is an internal optimization method that avoids the overhead of the full set() operation\n\t * when only LRU position needs to be updated.\n\t *\n\t * @method moveToEnd\n\t * @memberof LRU\n\t * @param {Object} item - The cache item with prev/next pointers to reposition.\n\t * @private\n\t * @since 11.3.5\n\t */\n\tmoveToEnd (item) {\n\t\t// If already at the end, nothing to do\n\t\tif (this.last === item) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remove item from current position in the list\n\t\tif (item.prev !== null) {\n\t\t\titem.prev.next = item.next;\n\t\t}\n\n\t\tif (item.next !== null) {\n\t\t\titem.next.prev = item.prev;\n\t\t}\n\n\t\t// Update first pointer if this was the first item\n\t\tif (this.first === item) {\n\t\t\tthis.first = item.next;\n\t\t}\n\n\t\t// Add item to the end\n\t\titem.prev = this.last;\n\t\titem.next = null;\n\n\t\tif (this.last !== null) {\n\t\t\tthis.last.next = item;\n\t\t}\n\n\t\tthis.last = item;\n\n\t\t// Handle edge case: if this was the only item, it's also first\n\t\tif (this.first === null) {\n\t\t\tthis.first = item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array of all keys in the cache, ordered from least to most recently used.\n\t *\n\t * @method keys\n\t * @memberof LRU\n\t * @returns {string[]} Array of keys in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * cache.get('a'); // Move 'a' to most recent\n\t * console.log(cache.keys()); // ['b', 'a']\n\t * @see {@link LRU#values}\n\t * @see {@link LRU#entries}\n\t * @since 9.0.0\n\t */\n\tkeys () {\n\t\tconst result = new Array(this.size);\n\t\tlet x = this.first;\n\t\tlet i = 0;\n\n\t\twhile (x !== null) {\n\t\t\tresult[i++] = x.key;\n\t\t\tx = x.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sets a value in the cache and returns any evicted item.\n\t *\n\t * @method setWithEvicted\n\t * @memberof LRU\n\t * @param {string} key - The key to set.\n\t * @param {*} value - The value to store.\n\t * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.\n\t * @returns {Object|null} The evicted item (if any) with shape {key, value, expiry, prev, next}, or null.\n\t * @example\n\t * const cache = new LRU(2);\n\t * cache.set('a', 1).set('b', 2);\n\t * const evicted = cache.setWithEvicted('c', 3); // evicted = {key: 'a', value: 1, ...}\n\t * @see {@link LRU#set}\n\t * @see {@link LRU#evict}\n\t * @since 11.3.0\n\t */\n\tsetWithEvicted (key, value, resetTtl = this.resetTtl) {\n\t\tlet evicted = null;\n\n\t\tif (this.has(key)) {\n\t\t\tthis.set(key, value, true, resetTtl);\n\t\t} else {\n\t\t\tif (this.max > 0 && this.size === this.max) {\n\t\t\t\tevicted = {...this.first};\n\t\t\t\tthis.evict(true);\n\t\t\t}\n\n\t\t\tlet item = this.items[key] = {\n\t\t\t\texpiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,\n\t\t\t\tkey: key,\n\t\t\t\tprev: this.last,\n\t\t\t\tnext: null,\n\t\t\t\tvalue\n\t\t\t};\n\n\t\t\tif (++this.size === 1) {\n\t\t\t\tthis.first = item;\n\t\t\t} else {\n\t\t\t\tthis.last.next = item;\n\t\t\t}\n\n\t\t\tthis.last = item;\n\t\t}\n\n\t\treturn evicted;\n\t}\n\n\t/**\n\t * Sets a value in the cache. Updates the item's position to most recently used.\n\t *\n\t * @method set\n\t * @memberof LRU\n\t * @param {string} key - The key to set.\n\t * @param {*} value - The value to store.\n\t * @param {boolean} [bypass=false] - Internal parameter for setWithEvicted method.\n\t * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('key1', 'value1')\n\t *      .set('key2', 'value2')\n\t *      .set('key3', 'value3');\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#setWithEvicted}\n\t * @since 1.0.0\n\t */\n\tset (key, value, bypass = false, resetTtl = this.resetTtl) {\n\t\tlet item = this.items[key];\n\n\t\tif (bypass || item !== undefined) {\n\t\t\t// Existing item: update value and position\n\t\t\titem.value = value;\n\n\t\t\tif (bypass === false && resetTtl) {\n\t\t\t\titem.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;\n\t\t\t}\n\n\t\t\t// Always move to end, but the bypass parameter affects TTL reset behavior\n\t\t\tthis.moveToEnd(item);\n\t\t} else {\n\t\t\t// New item: check for eviction and create\n\t\t\tif (this.max > 0 && this.size === this.max) {\n\t\t\t\tthis.evict(true);\n\t\t\t}\n\n\t\t\titem = this.items[key] = {\n\t\t\t\texpiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,\n\t\t\t\tkey: key,\n\t\t\t\tprev: this.last,\n\t\t\t\tnext: null,\n\t\t\t\tvalue\n\t\t\t};\n\n\t\t\tif (++this.size === 1) {\n\t\t\t\tthis.first = item;\n\t\t\t} else {\n\t\t\t\tthis.last.next = item;\n\t\t\t}\n\n\t\t\tthis.last = item;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an array of all values in the cache for the specified keys.\n\t * Order follows LRU order (least to most recently used).\n\t *\n\t * @method values\n\t * @memberof LRU\n\t * @param {string[]} [keys=this.keys()] - Array of keys to get values for. Defaults to all keys.\n\t * @returns {Array<*>} Array of values corresponding to the keys in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * console.log(cache.values()); // [1, 2]\n\t * console.log(cache.values(['a'])); // [1]\n\t * @see {@link LRU#keys}\n\t * @see {@link LRU#entries}\n\t * @since 11.1.0\n\t */\n\tvalues (keys = this.keys()) {\n\t\tconst result = new Array(keys.length);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tresult[i] = this.get(keys[i]);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\n/**\n * Factory function to create a new LRU cache instance with parameter validation.\n *\n * @function lru\n * @param {number} [max=1000] - Maximum number of items to store. Must be >= 0. Use 0 for unlimited size.\n * @param {number} [ttl=0] - Time to live in milliseconds. Must be >= 0. Use 0 for no expiration.\n * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().\n * @returns {LRU} A new LRU cache instance.\n * @throws {TypeError} When parameters are invalid (negative numbers or wrong types).\n * @example\n * // Create cache with factory function\n * const cache = lru(100, 5000, true);\n * cache.set('key', 'value');\n *\n * @example\n * // Error handling\n * try {\n *   const cache = lru(-1); // Invalid max\n * } catch (error) {\n *   console.error(error.message); // \"Invalid max value\"\n * }\n * @see {@link LRU}\n * @since 1.0.0\n */\nfunction lru (max = 1000, ttl = 0, resetTtl = false) {\n\tif (isNaN(max) || max < 0) {\n\t\tthrow new TypeError(\"Invalid max value\");\n\t}\n\n\tif (isNaN(ttl) || ttl < 0) {\n\t\tthrow new TypeError(\"Invalid ttl value\");\n\t}\n\n\tif (typeof resetTtl !== \"boolean\") {\n\t\tthrow new TypeError(\"Invalid resetTtl value\");\n\t}\n\n\treturn new LRU(max, ttl, resetTtl);\n}export{LRU,lru};","import type { TextStyle } from '../../TextStyle';\n\nconst genericFontFamilies = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n];\n\n/**\n * Generates a font style string to use for `TextMetrics.measureFont()`.\n * @param style\n * @returns Font style string, for passing to `TextMetrics.measureFont()`\n * @internal\n */\nexport function fontStringFromTextStyle(style: TextStyle): string\n{\n    // build canvas api font setting from individual components. Convert a numeric style.fontSize to px\n    const fontSizeString = (typeof style.fontSize === 'number') ? `${style.fontSize}px` : style.fontSize;\n\n    // Clean-up fontFamily property by quoting each font name\n    // this will support font names with spaces\n    let fontFamilies: string | string[] = style.fontFamily;\n\n    if (!Array.isArray(style.fontFamily))\n    {\n        fontFamilies = style.fontFamily.split(',');\n    }\n\n    for (let i = fontFamilies.length - 1; i >= 0; i--)\n    {\n        // Trim any extra white-space\n        let fontFamily = fontFamilies[i].trim();\n\n        // Check if font already contains strings\n        if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily) && !genericFontFamilies.includes(fontFamily))\n        {\n            fontFamily = `\"${fontFamily}\"`;\n        }\n        (fontFamilies as string[])[i] = fontFamily;\n    }\n\n    // eslint-disable-next-line max-len\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${(fontFamilies as string[]).join(',')}`;\n}\n","import { DOMAdapter } from '../../environment/adapter';\nimport { nextPow2 } from '../../maths/misc/pow2';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\n\n// Internal canvas for measuring bounds\nlet _internalCanvas: ICanvas | null = null;\nlet _internalContext: ICanvasRenderingContext2D | null = null;\n\nfunction ensureInternalCanvas(width: number, height: number): void\n{\n    if (!_internalCanvas)\n    {\n        _internalCanvas = DOMAdapter.get().createCanvas(256, 128);\n        _internalContext = _internalCanvas.getContext('2d', { willReadFrequently: true });\n        _internalContext.globalCompositeOperation = 'copy';\n        _internalContext.globalAlpha = 1;\n    }\n\n    if (_internalCanvas.width < width || _internalCanvas.height < height)\n    {\n        // Use power-of-two dimensions for better performance\n        _internalCanvas.width = nextPow2(width);\n        _internalCanvas.height = nextPow2(height);\n    }\n}\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/** @internal */\nexport interface GetCanvasBoundingBoxOptions\n{\n    /** The canvas to measure */\n    canvas: ICanvas;\n    /** Optional. The width to analyze (defaults to canvas.width) */\n    width?: number;\n    /** Optional. The height to analyze (defaults to canvas.height) */\n    height?: number;\n    /**\n     * Optional. The resolution at which to analyze the canvas, between 0-1.\n     * Lower values improve performance for large canvases but may be less precise.\n     * Default is 1 (full resolution).\n     */\n    resolution?: number;\n    /** Optional. The rectangle to store the result in. */\n    output?: Rectangle;\n}\n\n/**\n * Measures the bounding box of a canvas's visible (non-transparent) pixels.\n *\n * This function analyzes the alpha channel of the canvas pixels to find the smallest\n * rectangle containing all non-transparent pixels. It's useful for optimizing sprite\n * rendering by trimming transparent borders.\n *\n * Uses an internal canvas with `willReadFrequently: true` for efficient pixel data access.\n * This internal canvas is reused between calls for better performance.\n * @example\n * ```typescript\n * // Basic usage - get trim bounds at full resolution\n * const bounds = getCanvasBoundingBox({ canvas: myCanvas });\n * console.log(bounds); // Rectangle{x: 10, y: 5, width: 100, height: 200}\n * // Optimized for performance with lower resolution scanning\n * const fastBounds = getCanvasBoundingBox({\n *     canvas: largeCanvas,\n *     width: largeCanvas.width,\n *     height: largeCanvas.height,\n *     resolution: 0.5\n * });\n * // Resolution of 0.5 means scanning at half size, much faster for large canvases\n *\n * // Using custom dimensions - only analyze part of the canvas\n * const partialBounds = getCanvasBoundingBox({ canvas: myCanvas, width: 100, height: 100 });\n * // Only analyzes a 100x100 region starting from top-left\n * ```\n * @param options - The options for measuring the bounding box, including the canvas to measure.\n * @returns The bounding box as a Rectangle containing the visible content.\n *          Returns Rectangle.EMPTY if the canvas is completely transparent.\n * @internal\n */\nexport function getCanvasBoundingBox(\n    options: GetCanvasBoundingBoxOptions,\n): Rectangle;\n/**\n * @param canvas\n * @param resolution\n * @internal\n * @deprecated since 8.10.0\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution?: number): Rectangle;\n/**\n * @param {...any} args\n * @internal\n */\nexport function getCanvasBoundingBox(...args: [GetCanvasBoundingBoxOptions] | [ICanvas, number?]): Rectangle\n{\n    let options = args[0] as GetCanvasBoundingBoxOptions;\n\n    if (!options.canvas)\n    {\n        options = { canvas: args[0] as ICanvas, resolution: args[1] };\n    }\n\n    const { canvas } = options; // canvas is correctly extracted from options\n\n    // Cap resolution at 1\n    const resolution = Math.min(options.resolution ?? 1, 1);\n    const width = options.width ?? canvas.width;\n    const height = options.height ?? canvas.height;\n    let output = options.output;\n\n    // Ensure internal canvas is large enough\n    ensureInternalCanvas(width, height);\n\n    if (!_internalContext)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    // Set up for pixel replacement (no blending)\n    _internalContext.drawImage(\n        canvas as unknown as CanvasImageSource,\n        0, 0,\n        width, height,\n        0, 0,\n        width * resolution, height * resolution\n    );\n\n    // Get the image data at full resolution\n    const imageData = _internalContext.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    _internalContext.globalCompositeOperation = 'source-over';\n    // draw the rect on the canvas\n    _internalContext.strokeRect(left, top, right - left, bottom - top);\n    _internalContext.globalCompositeOperation = 'copy';\n\n    output ??= new Rectangle();\n\n    output.set(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n\n    return output;\n}\n\n","import { lru } from 'tiny-lru';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle, TextStyleWhiteSpace } from '../TextStyle';\n\n// The type for Intl.Segmenter is only available since TypeScript 4.7.2, so let's make a polyfill for it.\ninterface ISegmentData\n{\n    segment: string;\n}\ninterface ISegments\n{\n    [Symbol.iterator](): IterableIterator<ISegmentData>;\n}\ninterface ISegmenter\n{\n    segment(input: string): ISegments;\n}\ninterface IIntl\n{\n    Segmenter?: {\n        prototype: ISegmenter;\n        /**\n         * Creates a new Intl.Segmenter object.\n         * @returns A new Intl.Segmenter object.\n         */\n        new(): ISegmenter;\n    };\n}\n\n/**\n * A number, or a string containing a number.\n * @category text\n * @typedef {object} FontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n * @advanced\n */\nexport interface FontMetrics\n{\n    ascent: number;\n    descent: number;\n    fontSize: number;\n}\n\ntype CharacterWidthCache = Record<string, number>;\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { CanvasTextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = CanvasTextMetrics.measureText('Your text', style);\n * @category text\n * @advanced\n */\nexport class CanvasTextMetrics\n{\n    /** The text that was measured. */\n    public text: string;\n\n    /** The style that was measured. */\n    public style: TextStyle;\n\n    /** The measured width of the text. */\n    public width: number;\n\n    /** The measured height of the text. */\n    public height: number;\n\n    /** An array of lines of the text broken by new lines and wrapping is specified in style. */\n    public lines: string[];\n\n    /** An array of the line widths for each line matched to `lines`. */\n    public lineWidths: number[];\n\n    /** The measured line height for this style. */\n    public lineHeight: number;\n\n    /** The maximum line width for all measured lines. */\n    public maxLineWidth: number;\n\n    /** The font properties object from TextMetrics.measureFont. */\n    public fontProperties: FontMetrics;\n\n    /**\n     * String used for calculate font metrics.\n     * These characters are all tall to help calculate the height required for text.\n     */\n    public static METRICS_STRING = '|q';\n\n    /** Baseline symbol for calculate font metrics. */\n    public static BASELINE_SYMBOL = 'M';\n\n    /** Baseline multiplier for calculate font metrics. */\n    public static BASELINE_MULTIPLIER = 1.4;\n\n    /** Height multiplier for setting height of canvas to calculate font metrics. */\n    public static HEIGHT_MULTIPLIER = 2.0;\n\n    /**\n     * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n     * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n     * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n     * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n     * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n     * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n     * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n     * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n     * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n     */\n    public static graphemeSegmenter: (s: string) => string[] = (() =>\n    {\n        if (typeof (Intl as IIntl)?.Segmenter === 'function')\n        {\n            const segmenter = new (Intl as IIntl).Segmenter();\n\n            return (s: string) =>\n            {\n                const segments = segmenter.segment(s);\n                const result = [];\n\n                let i = 0;\n\n                for (const segment of segments)\n                {\n                    result[i++] = (segment.segment);\n                }\n\n                return result;\n            };\n        }\n\n        return (s: string) => [...s];\n    })();\n\n    public static _experimentalLetterSpacingSupported?: boolean;\n\n    /**\n     * Checking that we can use modern canvas 2D API.\n     *\n     * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n     * @see TextMetrics.experimentalLetterSpacing\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n     * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n     */\n    public static get experimentalLetterSpacingSupported(): boolean\n    {\n        let result = CanvasTextMetrics._experimentalLetterSpacingSupported;\n\n        if (result === undefined)\n        {\n            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n\n            result\n                = CanvasTextMetrics._experimentalLetterSpacingSupported\n                = 'letterSpacing' in proto || 'textLetterSpacing' in proto;\n        }\n\n        return result;\n    }\n\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     * @see TextMetrics.experimentalLetterSpacingSupported\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** Cache of {@link TextMetrics.FontMetrics} objects. */\n    private static _fonts: Record<string, FontMetrics> = {};\n\n    /** Cache of new line chars. */\n    private static readonly _newlines: number[] = [\n        0x000A, // line feed\n        0x000D, // carriage return\n    ];\n\n    /** Cache of breaking spaces. */\n    private static readonly _breakingSpaces: number[] = [\n        0x0009, // character tabulation\n        0x0020, // space\n        0x2000, // en quad\n        0x2001, // em quad\n        0x2002, // en space\n        0x2003, // em space\n        0x2004, // three-per-em space\n        0x2005, // four-per-em space\n        0x2006, // six-per-em space\n        0x2008, // punctuation space\n        0x2009, // thin space\n        0x200A, // hair space\n        0x205F, // medium mathematical space\n        0x3000, // ideographic space\n    ];\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __canvas: ICanvas;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __context: ICanvasRenderingContext2D;\n\n    /** Cache for measured text metrics */\n    private static readonly _measurementCache = lru<CanvasTextMetrics>(1000);\n\n    /**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text: string, style: TextStyle, width: number, height: number, lines: string[], lineWidths: number[],\n        lineHeight: number, maxLineWidth: number, fontProperties: FontMetrics)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @param wordWrap\n     * @returns Measured width and height of the text.\n     */\n    public static measureText(\n        text = ' ',\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas,\n        wordWrap: boolean = style.wordWrap,\n    ): CanvasTextMetrics\n    {\n        const textKey = `${text}-${style.styleKey}-wordWrap-${wordWrap}`;\n\n        // check if we have already measured this text with the same style\n        if (CanvasTextMetrics._measurementCache.has(textKey))\n        {\n            return CanvasTextMetrics._measurementCache.get(textKey);\n        }\n\n        const font = fontStringFromTextStyle(style);\n        const fontProperties = CanvasTextMetrics.measureFont(font);\n\n        // fallback in case UA disallow canvas data extraction\n        if (fontProperties.fontSize === 0)\n        {\n            fontProperties.fontSize = style.fontSize as number;\n            fontProperties.ascent = style.fontSize as number;\n        }\n\n        const context = CanvasTextMetrics.__context; // canvas.getContext('2d', contextSettings);\n\n        context.font = font;\n\n        const outputText = wordWrap ? CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array<number>(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n\n        const strokeWidth = style._stroke?.width || 0;\n\n        let width = maxLineWidth + strokeWidth;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadow.distance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize;\n\n        let height = Math.max(lineHeight, fontProperties.fontSize + (strokeWidth))\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadow.distance;\n        }\n\n        const measurements = new CanvasTextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n\n        // cache the measurements\n        CanvasTextMetrics._measurementCache.set(textKey, measurements);\n\n        return measurements;\n    }\n\n    private static _measureText(\n        text: string,\n        letterSpacing: number,\n        context: ICanvasRenderingContext2D\n    )\n    {\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        const metrics = context.measureText(text);\n        let metricWidth = metrics.width;\n        const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n        const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n        let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n\n        if (metricWidth > 0)\n        {\n            if (useExperimentalLetterSpacing)\n            {\n                metricWidth -= letterSpacing;\n                boundsWidth -= letterSpacing;\n            }\n            else\n            {\n                const val = (CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n\n                metricWidth += val;\n                boundsWidth += val;\n            }\n        }\n\n        // NOTE: this is a bit of a hack as metrics.width and the bounding box width do not measure the same thing\n        // We can't seem to exclusively use one or the other, so are taking the largest of the two\n        return Math.max(metricWidth, boundsWidth);\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns New string with new lines applied where required\n     */\n    private static _wordWrap(\n        text: string,\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas\n    ): string\n    {\n        const context = canvas.getContext('2d', contextSettings);\n\n        let width = 0;\n        let line = '';\n        let lines = '';\n\n        const cache: CharacterWidthCache = Object.create(null);\n        const { letterSpacing, whiteSpace } = style;\n\n        // How to handle whitespaces\n        const collapseSpaces = CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = CanvasTextMetrics._collapseNewlines(whiteSpace);\n\n        // whether or not spaces may be added to the beginning of lines\n        let canPrependSpaces = !collapseSpaces;\n\n        // There is letterSpacing after every char except the last one\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n        // so for convenience the above needs to be compared to width + 1 extra letterSpace\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n        // ________________________________________________\n        // And then the final space is simply no appended to each line\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n        // break text into words, spaces and newline chars\n        const tokens = CanvasTextMetrics._tokenize(text);\n\n        for (let i = 0; i < tokens.length; i++)\n        {\n            // get the word, space or newlineChar\n            let token = tokens[i];\n\n            // if word is a new line\n            if (CanvasTextMetrics._isNewline(token))\n            {\n                // keep the new line\n                if (!collapseNewlines)\n                {\n                    lines += CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = '';\n                    width = 0;\n                    continue;\n                }\n\n                // if we should collapse new lines\n                // we simply convert it into a space\n                token = ' ';\n            }\n\n            // if we should collapse repeated whitespaces\n            if (collapseSpaces)\n            {\n                // check both this and the last tokens for spaces\n                const currIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n\n                if (currIsBreakingSpace && lastIsBreakingSpace)\n                {\n                    continue;\n                }\n            }\n\n            // get word width from cache if possible\n            const tokenWidth = CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n\n            // word is longer than desired bounds\n            if (tokenWidth > wordWrapWidth)\n            {\n                // if we are not already at the beginning of a line\n                if (line !== '')\n                {\n                    // start newlines for overflow words\n                    lines += CanvasTextMetrics._addLine(line);\n                    line = '';\n                    width = 0;\n                }\n\n                // break large word over multiple lines\n                if (CanvasTextMetrics.canBreakWords(token, style.breakWords))\n                {\n                    // break word into characters\n                    const characters = CanvasTextMetrics.wordWrapSplit(token);\n\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++)\n                    {\n                        let char = characters[j];\n                        let lastChar = char;\n\n                        let k = 1;\n\n                        // we are not at the end of the token\n                        while (characters[j + k])\n                        {\n                            const nextChar = characters[j + k];\n\n                            // should not split chars\n                            if (!CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                            {\n                                // combine chars & move forward one\n                                char += nextChar;\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            lastChar = nextChar;\n                            k++;\n                        }\n\n                        j += k - 1;\n\n                        const characterWidth = CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n\n                        if (characterWidth + width > wordWrapWidth)\n                        {\n                            lines += CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = '';\n                            width = 0;\n                        }\n\n                        line += char;\n                        width += characterWidth;\n                    }\n                }\n\n                // run word out of the bounds\n                else\n                {\n                    // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0)\n                    {\n                        lines += CanvasTextMetrics._addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n\n                    const isLastToken = i === tokens.length - 1;\n\n                    // give it its own line if it's not the end\n                    lines += CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = '';\n                    width = 0;\n                }\n            }\n\n            // word could fit\n            else\n            {\n                // word won't fit because of existing words\n                // start a new line\n                if (tokenWidth + width > wordWrapWidth)\n                {\n                    // if its a space we don't want it\n                    canPrependSpaces = false;\n\n                    // add a new line\n                    lines += CanvasTextMetrics._addLine(line);\n\n                    // start a new line\n                    line = '';\n                    width = 0;\n                }\n\n                // don't add spaces to the beginning of lines\n                if (line.length > 0 || !CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces)\n                {\n                    // add the word to the current line\n                    line += token;\n\n                    // update width counter\n                    width += tokenWidth;\n                }\n            }\n        }\n\n        lines += CanvasTextMetrics._addLine(line, false);\n\n        return lines;\n    }\n\n    /**\n     * Convenience function for logging each line added during the wordWrap method.\n     * @param line    - The line of text to add\n     * @param newLine - Add new line character to end\n     * @returns A formatted line\n     */\n    private static _addLine(line: string, newLine = true): string\n    {\n        line = CanvasTextMetrics._trimRight(line);\n\n        line = (newLine) ? `${line}\\n` : line;\n\n        return line;\n    }\n\n    /**\n     * Gets & sets the widths of calculated characters in a cache object\n     * @param key            - The key\n     * @param letterSpacing  - The letter spacing\n     * @param cache          - The cache\n     * @param context        - The canvas context\n     * @returns The from cache.\n     */\n    private static _getFromCache(key: string, letterSpacing: number, cache: CharacterWidthCache,\n        context: ICanvasRenderingContext2D): number\n    {\n        let width = cache[key];\n\n        if (typeof width !== 'number')\n        {\n            width = CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n\n        return width;\n    }\n\n    /**\n     * Determines whether we should collapse breaking spaces.\n     * @param whiteSpace - The TextStyle property whiteSpace\n     * @returns Should collapse\n     */\n    private static _collapseSpaces(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');\n    }\n\n    /**\n     * Determines whether we should collapse newLine chars.\n     * @param whiteSpace - The white space\n     * @returns should collapse\n     */\n    private static _collapseNewlines(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal');\n    }\n\n    /**\n     * Trims breaking whitespaces from string.\n     * @param text - The text\n     * @returns Trimmed string\n     */\n    private static _trimRight(text: string): string\n    {\n        if (typeof text !== 'string')\n        {\n            return '';\n        }\n\n        for (let i = text.length - 1; i >= 0; i--)\n        {\n            const char = text[i];\n\n            if (!CanvasTextMetrics.isBreakingSpace(char))\n            {\n                break;\n            }\n\n            text = text.slice(0, -1);\n        }\n\n        return text;\n    }\n\n    /**\n     * Determines if char is a newline.\n     * @param char - The character\n     * @returns True if newline, False otherwise.\n     */\n    private static _isNewline(char: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param char - The character\n     * @param [_nextChar] - The next character\n     * @returns True if whitespace, False otherwise.\n     */\n    public static isBreakingSpace(char: string, _nextChar?: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Splits a string into words, breaking-spaces and newLine characters\n     * @param text - The text\n     * @returns A tokenized array\n     */\n    private static _tokenize(text: string): string[]\n    {\n        const tokens: string[] = [];\n        let token = '';\n\n        if (typeof text !== 'string')\n        {\n            return tokens;\n        }\n\n        for (let i = 0; i < text.length; i++)\n        {\n            const char = text[i];\n            const nextChar = text[i + 1];\n\n            if (CanvasTextMetrics.isBreakingSpace(char, nextChar) || CanvasTextMetrics._isNewline(char))\n            {\n                if (token !== '')\n                {\n                    tokens.push(token);\n                    token = '';\n                }\n\n                // treat \\r\\n as a single new line token\n                if (char === '\\r' && nextChar === '\\n')\n                {\n                    tokens.push('\\r\\n');\n                    i++;\n                }\n                else\n                {\n                    tokens.push(char);\n                }\n\n                continue;\n            }\n\n            token += char;\n        }\n\n        if (token !== '')\n        {\n            tokens.push(token);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     * @param _token - The token\n     * @param breakWords - The style attr break words\n     * @returns Whether to break word or not\n     */\n    public static canBreakWords(_token: string, breakWords: boolean): boolean\n    {\n        return breakWords;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param _char - The character\n     * @param _nextChar - The next character\n     * @param _token - The token/word the characters are from\n     * @param _index - The index in the token of the char\n     * @param _breakWords - The style attr break words\n     * @returns whether to break word or not\n     */\n    public static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number,\n        _breakWords: boolean): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     * @param token - The token to split\n     * @returns The characters of the token\n     * @see CanvasTextMetrics.graphemeSegmenter\n     */\n    public static wordWrapSplit(token: string): string[]\n    {\n        return CanvasTextMetrics.graphemeSegmenter(token);\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     * @param font - String representing the style of the font\n     * @returns Font properties object\n     */\n    public static measureFont(font: string): FontMetrics\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (CanvasTextMetrics._fonts[font])\n        {\n            return CanvasTextMetrics._fonts[font];\n        }\n\n        const context = CanvasTextMetrics._context;\n\n        context.font = font;\n        const metrics = context.measureText(CanvasTextMetrics.METRICS_STRING + CanvasTextMetrics.BASELINE_SYMBOL);\n\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n\n        CanvasTextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n\n    /**\n     * Clear font metrics in metrics cache.\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    public static clearMetrics(font = ''): void\n    {\n        if (font)\n        {\n            delete CanvasTextMetrics._fonts[font];\n        }\n        else\n        {\n            CanvasTextMetrics._fonts = {};\n        }\n    }\n\n    /**\n     * Cached canvas element for measuring text\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _canvas(): ICanvas\n    {\n        if (!CanvasTextMetrics.__canvas)\n        {\n            let canvas: ICanvas;\n\n            try\n            {\n                // OffscreenCanvas2D measureText can be up to 40% faster.\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext('2d', contextSettings);\n\n                if (context?.measureText)\n                {\n                    CanvasTextMetrics.__canvas = c as ICanvas;\n\n                    return c as ICanvas;\n                }\n\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            catch (_cx)\n            {\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            CanvasTextMetrics.__canvas = canvas;\n        }\n\n        return CanvasTextMetrics.__canvas;\n    }\n\n    /**\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _context(): ICanvasRenderingContext2D\n    {\n        if (!CanvasTextMetrics.__context)\n        {\n            CanvasTextMetrics.__context = CanvasTextMetrics._canvas.getContext('2d', contextSettings);\n        }\n\n        return CanvasTextMetrics.__context;\n    }\n}\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ConvertedFillStyle } from '../../../graphics/shared/FillTypes';\nimport type { CanvasTextMetrics } from '../CanvasTextMetrics';\n\n// 5 decimal places\nconst PRECISION = 100000;\n\n/**\n * Converts a PixiJS fill style into a Canvas-compatible fill style.\n * Handles solid colors, textures, patterns, and gradients.\n * @param fillStyle - The PixiJS fill style to convert\n * @param context - The canvas rendering context\n * @param textMetrics - Metrics about the text being rendered\n * @param padding - Padding to add to the text metrics (used to ensure that the gradient accommodates the stroke width)\n * @returns Canvas-compatible fill style (string, CanvasGradient, or CanvasPattern)\n * @internal\n */\nexport function getCanvasFillStyle(\n    fillStyle: ConvertedFillStyle,\n    context: ICanvasRenderingContext2D,\n    textMetrics?: CanvasTextMetrics,\n    padding = 0\n): string | CanvasGradient | CanvasPattern\n{\n    // Solid color fill\n    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill)\n    {\n        return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();\n    }\n    // Basic texture fill\n    else if (!fillStyle.fill)\n    {\n        const pattern = context.createPattern(fillStyle.texture.source.resource, 'repeat');\n        const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    // Pattern fill\n    else if (fillStyle.fill instanceof FillPattern)\n    {\n        const fillPattern = fillStyle.fill;\n        const pattern = context.createPattern(fillPattern.texture.source.resource, 'repeat');\n        const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n\n        tempMatrix.scale(\n            fillPattern.texture.frame.width,\n            fillPattern.texture.frame.height\n        );\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    // Gradient fill\n    else if (fillStyle.fill instanceof FillGradient)\n    {\n        const fillGradient = fillStyle.fill;\n\n        const isLinear = fillGradient.type === 'linear';\n        const isLocal = fillGradient.textureSpace === 'local';\n\n        let width = 1;\n        let height = 1;\n\n        // Use text dimensions if in local space\n        if (isLocal && textMetrics)\n        {\n            width = textMetrics.width + padding;\n            height = textMetrics.height + padding;\n        }\n\n        let gradient: CanvasGradient;\n        let isNearlyVertical = false;\n\n        if (isLinear)\n        {\n            const { start, end } = fillGradient;\n\n            gradient = context.createLinearGradient(\n                start.x * width,\n                start.y * height,\n                end.x * width,\n                end.y * height\n            );\n\n            // Check if gradient is nearly vertical (10% threshold)\n            isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);\n        }\n        else\n        {\n            const { center, innerRadius, outerCenter, outerRadius } = fillGradient;\n\n            gradient = context.createRadialGradient(\n                center.x * width,\n                center.y * height,\n                innerRadius * width,\n                outerCenter.x * width,\n                outerCenter.y * height,\n                outerRadius * width\n            );\n        }\n\n        // For vertical gradients in local space, repeat gradient per text line\n        if (isNearlyVertical && isLocal && textMetrics)\n        {\n            const ratio = (textMetrics.lineHeight) / height;\n\n            for (let i = 0; i < textMetrics.lines.length; i++)\n            {\n                const start = ((i * textMetrics.lineHeight) + (padding / 2)) / height;\n\n                fillGradient.colorStops.forEach((stop) =>\n                {\n                    // Convert to global space\n                    const globalStop = start + (stop.offset * ratio);\n\n                    gradient.addColorStop(\n                        // fix to 5 decimal places to avoid floating point precision issues\n                        Math.floor(globalStop * PRECISION) / PRECISION,\n                        Color.shared.setValue(stop.color).toHex()\n                    );\n                });\n            }\n        }\n        else\n        {\n            // Standard global space gradient handling\n            fillGradient.colorStops.forEach((stop) =>\n            {\n                gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n            });\n        }\n\n        return gradient;\n    }\n\n    // #if _DEBUG\n    warn('FillStyle not recognised', fillStyle);\n    // #endif\n\n    return 'red';\n}\n","import { Color } from '../../../color/Color';\nimport { Rectangle } from '../../../maths/shapes/Rectangle';\nimport { type CanvasAndContext, CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { type TextStyle } from '../TextStyle';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\n/**\n * Temporary rectangle for getting the bounding box of the text.\n * @internal\n */\nconst tempRect = new Rectangle();\n\n/**\n * Utility for generating and managing canvas-based text rendering.\n *\n * This class is responsible for rendering text to canvas elements based on provided styles,\n * measuring the resulting text dimensions, and managing the lifecycle of canvas resources.\n *\n * CanvasTextGenerator supports:\n * - Text rendering with various styles (fill, stroke, gradient, etc.)\n * - Drop shadows and letter spacing\n * - Automatic trimming of transparent pixels\n * - Canvas resource pooling\n *\n * As a singleton, it's accessed via the exported `CanvasTextGenerator` constant.\n * @example\n * ```typescript\n * // Basic usage - render text to a canvas\n * import { CanvasTextGenerator } from 'pixi.js';\n * import { TextStyle } from 'pixi.js';\n *\n * // Create a text style\n * const style = new TextStyle({\n *   fontFamily: 'Arial',\n *   fontSize: 24,\n *   fill: 0xff1010,\n *   align: 'center',\n * });\n *\n * // Get a canvas with the text rendered to it\n * const { canvasAndContext, frame } = CanvasTextGenerator.getCanvasAndContext({\n *   text: 'Hello Pixi!',\n *   style,\n *   resolution: 1\n * });\n *\n * @internal\n */\nclass CanvasTextGeneratorClass\n{\n    /**\n     * Creates a canvas with the specified text rendered to it.\n     *\n     * Generates a canvas of appropriate size, renders the text with the provided style,\n     * and returns both the canvas/context and a Rectangle representing the text bounds.\n     *\n     * When trim is enabled in the style, the frame will represent the bounds of the\n     * non-transparent pixels, which can be smaller than the full canvas.\n     * @param options - The options for generating the text canvas\n     * @param options.text - The text to render\n     * @param options.style - The style to apply to the text\n     * @param options.resolution - The resolution of the canvas (defaults to 1)\n     * @param options.padding\n     * @returns An object containing the canvas/context and the frame (bounds) of the text\n     */\n    public getCanvasAndContext(options: {text: string, style: TextStyle, resolution?: number, padding?: number})\n    {\n        const { text, style, resolution = 1 } = options;\n\n        const padding = (style as TextStyle)._getFinalPadding();\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        this._renderTextToCanvas(text, style, padding, resolution, canvasAndContext);\n\n        const frame = style.trim\n            ? getCanvasBoundingBox({ canvas: canvasAndContext.canvas, width, height, resolution: 1, output: tempRect })\n            : tempRect.set(0, 0, width, height);\n\n        return {\n            canvasAndContext,\n            frame\n        };\n    }\n\n    /**\n     * Returns a canvas and context to the pool.\n     *\n     * This should be called when you're done with the canvas to allow reuse\n     * and prevent memory leaks.\n     * @param canvasAndContext - The canvas and context to return to the pool\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     * @param text - The text to render\n     * @param style - The style of the text\n     * @param padding - The padding of the text\n     * @param resolution - The resolution of the text\n     * @param canvasAndContext - The canvas and context to render the text to\n     */\n    private _renderTextToCanvas(\n        text: string,\n        style: TextStyle,\n        padding: number,\n        resolution: number,\n        canvasAndContext: CanvasAndContext\n    ): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n        context.scale(resolution, resolution);\n        context.textBaseline = style.textBaseline;\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context, measured, padding * 2) : null;\n\n                if (style._stroke?.width)\n                {\n                    const strokePadding = (style._stroke.width * 0.5) + (padding * 2);\n\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context, measured, strokePadding);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + padding,\n                        linePositionY + padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + padding,\n                        linePositionY + padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     *\n     * This method handles rendering text with the correct letter spacing, using either:\n     * 1. Native letter spacing if supported by the browser\n     * 2. Manual letter spacing calculation if not natively supported\n     *\n     * For manual letter spacing, it calculates the position of each character\n     * based on its width and the desired spacing.\n     * @param text - The text to draw\n     * @param style - The text style to apply\n     * @param canvasAndContext - The canvas and context to draw to\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Whether to render the stroke (true) or fill (false)\n     * @private\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n}\n\n/** @internal */\nexport const CanvasTextGenerator = new CanvasTextGeneratorClass();\n","import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { type Filter } from '../../filters/Filter';\nimport { uid } from '../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../graphics/shared/fill/FillPattern';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext';\nimport { toFillStyle, toStrokeStyle } from '../graphics/shared/utils/convertFillInputToFillStyle';\n\nimport type { TextureDestroyOptions, TypeOrBool } from '../container/destroyTypes';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n    StrokeStyle\n} from '../graphics/shared/FillTypes';\n\n/**\n * The alignment of the text.\n *\n * - 'left': Aligns text to the left edge.\n * - 'center': Centers text horizontally.\n * - 'right': Aligns text to the right edge.\n * - 'justify': Justifies text, aligning both left and right edges.\n * @example\n * ```ts\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   align: 'center', // or 'left', 'right', 'justify'\n * });\n * ```\n * @category text\n * @standard\n */\nexport type TextStyleAlign = 'left' | 'center' | 'right' | 'justify';\n/**\n * The fill style input for text styles.\n *\n * This can be:\n * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'\n * - A hex number like 0xff0000 for red\n * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }\n * - A FillGradient for gradient fills\n * - A FillPattern for pattern/texture fills\n * @example\n * ```ts\n * // Simple Fills\n * new TextStyle({ fill: 'red' }); // Color string\n * new TextStyle({ fill: 0x00ff00 }); // Hex color\n * new TextStyle({ fill: 'rgb(255,0,0)' }); // RGB string\n * // Gradients\n * new TextStyle({\n *     fill: new FillGradient({\n *         end: { x: 1, y: 1 },\n *         stops: [\n *             { color: 0xff0000, offset: 0 }, // Red at start\n *             { color: 0x0000ff, offset: 1 }, // Blue at end\n *         ]\n *     }),\n * });\n * // Patterns\n * new TextStyle({\n *    fill: new FillPattern(Assets.get('pattern.png'))\n * });\n * ```\n * @category text\n * @standard\n */\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\n/**\n * The font style input for text styles. Controls the slant or italicization of the text.\n * @example\n * ```ts\n * // Create text with normal font style\n * const normalText = new Text({\n *     text: 'Normal Style Text',\n *     style: {\n *         fontStyle: 'normal',\n *         fontSize: 24\n *     }\n * });\n *\n * // Create italic text\n * const italicText = new Text({\n *     text: 'Italic Style Text',\n *     style: {\n *         fontStyle: 'italic',\n *         fontSize: 24,\n *         fontFamily: 'Arial'\n *     }\n * });\n *\n * // Create oblique text\n * const obliqueText = new Text({\n *     text: 'Oblique Style Text',\n *     style: {\n *         fontStyle: 'oblique',\n *         fontSize: 24,\n *         fontFamily: 'Times New Roman'\n *     }\n * });\n *\n * // Dynamic style changes\n * let isItalic = false;\n * text.style = {\n *     ...text.style,\n *     fontStyle: isItalic ? 'italic' : 'normal'\n * };\n * ```\n *\n * Supported values:\n * - 'normal': Regular upright text with no slant\n * - 'italic': True italics using specifically designed italic glyphs\n * - 'oblique': Slanted version of the regular glyphs\n * @remarks\n * - 'italic' uses specially designed glyphs with cursive characteristics\n * - 'oblique' is a mechanical slant of the normal glyphs\n * - Not all fonts include true italic designs; some may fall back to oblique\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-style | MDN font-style}\n * @category text\n * @standard\n */\nexport type TextStyleFontStyle = 'normal' | 'italic' | 'oblique';\n/**\n * The font variant input for text styles. Controls the capitalization and presentation of letters.\n * Used to enable special rendering like small caps.\n * @example\n * ```ts\n * // Create text with normal font variant\n * const normalText = new Text({\n *     text: 'Normal Text',\n *     style: {\n *         fontVariant: 'normal',\n *         fontSize: 24\n *     }\n * });\n *\n * // Create text with small-caps variant\n * const smallCapsText = new Text({\n *     text: 'Small Caps Text',\n *     style: {\n *         fontVariant: 'small-caps',\n *         fontSize: 24,\n *         fontFamily: 'Arial'\n *     }\n * });\n *\n * // Use in a TextStyle instance\n * const style = new TextStyle({\n *     fontVariant: 'small-caps',\n *     fontSize: 32,\n *     fill: 0x4a4a4a\n * });\n *\n * // Update variant dynamically\n * text.style = {\n *     ...text.style,\n *     fontVariant: text.style.fontVariant === 'normal' ? 'small-caps' : 'normal'\n * };\n * ```\n *\n * Supported values:\n * - 'normal': Regular text rendering with standard capitalization\n * - 'small-caps': Renders lowercase letters as smaller versions of capital letters\n * @remarks\n * Small caps are only available if the font supports them.\n * Not all fonts include true small caps glyphs.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant | MDN font-variant}\n * @category text\n * @standard\n */\nexport type TextStyleFontVariant = 'normal' | 'small-caps';\n/**\n * The font weight input for text styles. Controls the thickness or boldness of the text.\n * @example\n * ```ts\n * // Create text with different font weights\n * const normalText = new Text({\n *     text: 'Normal Weight',\n *     style: { fontWeight: 'normal' }\n * });\n *\n * const boldText = new Text({\n *     text: 'Bold Weight',\n *     style: { fontWeight: 'bold' }\n * });\n *\n * // Using numeric weights\n * const lightText = new Text({\n *     text: 'Light Weight',\n *     style: { fontWeight: '300' }\n * });\n *\n * const mediumText = new Text({\n *     text: 'Medium Weight',\n *     style: { fontWeight: '500' }\n * });\n *\n * const heavyText = new Text({\n *     text: 'Heavy Weight',\n *     style: { fontWeight: '900' }\n * });\n *\n * // Responsive weight changes\n * const adaptiveText = new Text({\n *     text: 'Adaptive Weight',\n *     style: { fontWeight: window.innerWidth > 600 ? 'bold' : 'normal' }\n * });\n * ```\n *\n * Supported values:\n * - 'normal': Standard weight (equivalent to 400)\n * - 'bold': Bold weight (equivalent to 700)\n * - 'bolder': One weight darker than the parent element\n * - 'lighter': One weight lighter than the parent element\n * - '100': Thin (Hairline)\n * - '200': Extra Light (Ultra Light)\n * - '300': Light\n * - '400': Normal\n * - '500': Medium\n * - '600': Semi Bold (Demi Bold)\n * - '700': Bold\n * - '800': Extra Bold (Ultra Bold)\n * - '900': Heavy (Black)\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight | MDN font-weight}\n * @category text\n * @standard\n */\nexport type TextStyleFontWeight =\n    | 'normal' // Standard weight (400)\n    | 'bold' // Bold weight (700)\n    | 'bolder' // Relative weight increase\n    | 'lighter' // Relative weight decrease\n    | '100' // Thin\n    | '200' // Extra Light\n    | '300' // Light\n    | '400' // Normal\n    | '500' // Medium\n    | '600' // Semi Bold\n    | '700' // Bold\n    | '800' // Extra Bold\n    | '900'; // Heavy\n/**\n * The line join style for text strokes. Determines how lines connect at corners.\n * @example\n * ```ts\n * // Create text with miter joins (sharp corners)\n * const sharpText = new Text({\n *     text: 'Sharp Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'miter'  // Sharp corners\n *         }\n *     }\n * });\n *\n * // Create text with round joins\n * const roundText = new Text({\n *     text: 'Rounded Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'round'  // Smooth rounded corners\n *         }\n *     }\n * });\n *\n * // Create text with beveled joins\n * const bevelText = new Text({\n *     text: 'Beveled Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'bevel'  // Flattened corners\n *         }\n *     }\n * });\n * ```\n * Available values:\n * - 'miter': Creates sharp corners by extending the outer edges until they meet\n * - 'round': Creates smooth, rounded corners using a circular arc\n * - 'bevel': Creates flattened corners by filling an additional triangle between the outer edges\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin | MDN lineJoin}\n * @category text\n * @standard\n */\nexport type TextStyleLineJoin = 'miter' | 'round' | 'bevel';\n/**\n * The text baseline for text styles.\n *\n * This can be:\n * - 'alphabetic': The alphabetic baseline\n * - 'top': The top of the text\n * - 'hanging': The hanging baseline\n * - 'middle': The middle of the text\n * - 'ideographic': The ideographic baseline\n * - 'bottom': The bottom of the text\n * @category text\n * @standard\n */\nexport type TextStyleTextBaseline = 'alphabetic' | 'top' | 'hanging' | 'middle' | 'ideographic' | 'bottom';\n/**\n * Controls how whitespace (spaces, tabs, and line breaks) is handled within the text.\n * This affects text wrapping and spacing behavior.\n * @example\n * ```ts\n * // Normal mode (collapse spaces and newlines)\n * const normalText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'normal',\n *         fontSize: 24\n *     }\n * }); // Renders as: \"Hello World New Line\"\n *\n * // Pre mode (preserve all whitespace)\n * const preText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'pre',\n *         fontSize: 24\n *     }\n * }); // Preserves spaces and line breaks exactly\n *\n * // Pre-line mode (preserve newlines, collapse spaces)\n * const preLineText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'pre-line',\n *         fontSize: 24\n *     }\n * }); // Preserves line breaks, collapses multiple spaces\n *\n * // With word wrap enabled\n * const wrappedText = new Text({\n *     text: 'A long text with    multiple spaces\\nand line breaks',\n *     style: {\n *         whiteSpace: 'pre-line',\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *         fontSize: 24\n *     }\n * });\n * ```\n *\n * Supported values:\n * - 'normal': Collapses all whitespace (spaces, tabs, line breaks) into a single space\n * - 'pre': Preserves all whitespace characters exactly as written\n * - 'pre-line': Preserves line breaks but collapses multiple spaces into a single space\n * @remarks\n * - 'normal' is best for single-line text or when you want to ignore formatting\n * - 'pre' is useful for code blocks or when exact spacing is important\n * - 'pre-line' is good for formatted text where you want to keep line breaks but clean up spaces\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/white-space | MDN white-space}\n * @see {@link TextStyle#wordWrap} For controlling text wrapping\n * @category text\n * @standard\n */\nexport type TextStyleWhiteSpace = 'normal' | 'pre' | 'pre-line';\n\n/**\n * Defines a drop shadow effect for text rendering.\n * Drop shadows add depth and emphasis to text by creating a shadow offset from the text.\n * @example\n * ```ts\n * // Create text with basic drop shadow\n * const text = new Text({\n *     text: 'Shadow Text',\n *     style: {\n *         fontSize: 48,\n *         dropShadow: {\n *             alpha: 0.5,         // 50% opacity shadow\n *             angle: Math.PI / 6, // 30 degrees\n *             blur: 4,            // Soft shadow edge\n *             color: '#000000',   // Black shadow\n *             distance: 6         // Shadow offset\n *         }\n *     }\n * });\n *\n * // Dynamic shadow updates\n * text.style.dropShadow = {\n *     alpha: Math.sin(Date.now() / 1000) * 0.5 + 0.5, // Pulsing opacity\n *     angle: Date.now() / 1000,                        // Rotating angle\n *     blur: 4,\n *     color: '#000000',\n *     distance: 6\n * };\n * ```\n * @category text\n * @standard\n */\nexport type TextDropShadow = {\n    /**\n     * The opacity of the drop shadow.\n     * - Range: 0 to 1\n     * - 0 = fully transparent\n     * - 1 = fully opaque\n     * @example\n     * ```ts\n     * // Set drop shadow opacity to 50%\n     * dropShadow: {\n     *    alpha: 0.5\n     * }\n     * ```\n     * @default 1\n     */\n    alpha: number;\n\n    /**\n     * The angle of the drop shadow in radians.\n     * - 0 = right\n     * - Math.PI/2 = down\n     * - Math.PI = left\n     * - Math.PI*1.5 = up\n     * @example\n     * ```ts\n     * // Set drop shadow angle to 30 degrees\n     * dropShadow: {\n     *    angle: Math.PI / 6 // 30 degrees\n     * }\n     * ```\n     * @default Math.PI/6 (30 degrees)\n     */\n    angle: number;\n\n    /**\n     * The blur radius of the shadow.\n     * - 0 = sharp shadow\n     * - Higher values = softer shadow\n     * @example\n     * ```ts\n     * // Set drop shadow blur radius to 10 pixels\n     * dropShadow: {\n     *   blur: 10\n     * }\n     * ```\n     * @default 0\n     */\n    blur: number;\n\n    /**\n     * The color of the drop shadow.\n     * Accepts any valid CSS color string, hex number, or RGB/RGBA values.\n     * @example '#000000', 'rgba(0,0,0,0.5)', 0x000000\n     * @default 'black'\n     */\n    color: ColorSource;\n\n    /**\n     * The distance of the drop shadow from the text.\n     * Measured in pixels.\n     * @example\n     * ```ts\n     * // Set drop shadow distance to 5 pixels\n     * dropShadow: {\n     *   distance: 5\n     * }\n     * ```\n     * @default 5\n     */\n    distance: number;\n};\n\n/**\n * Constructor options used for `TextStyle` instances. Defines the visual appearance and layout of text.\n * @example\n * ```ts\n * // Basic text style\n * const basicStyle = new TextStyle({\n *     fontSize: 24,\n *     fill: 'black',\n *     fontFamily: 'Arial'\n * });\n *\n * // Rich text style with multiple features\n * const richStyle = new TextStyle({\n *     fontFamily: ['Arial', 'Helvetica', 'sans-serif'],\n *     fontSize: 36,\n *     fontWeight: 'bold',\n *     fill: 'red',\n *     stroke: { color: '#4a1850', width: 5 },\n *     align: 'center',\n *     dropShadow: {\n *         color: '#000000',\n *         blur: 4,\n *         distance: 6,\n *         angle: Math.PI / 6\n *     },\n *     wordWrap: true,\n *     wordWrapWidth: 440,\n *     lineHeight: 40,\n *     textBaseline: 'middle'\n * });\n * ```\n * @see {@link TextStyle} For the main style class\n * @category text\n * @standard\n */\nexport interface TextStyleOptions\n{\n    /**\n     * Alignment for multiline text, does not affect single line text\n     * @default 'left'\n     */\n    align?: TextStyleAlign;\n    /**\n     * Whether to allow line breaks within words.\n     * Requires wordWrap to be true.\n     * @example\n     * ```ts\n     * // Enable word breaking\n     * const style = new TextStyle({\n     *    breakWords: true,\n     *    wordWrap: true,\n     *    wordWrapWidth: 200\n     * });\n     * ```\n     * @default false\n     */\n    breakWords?: boolean;\n    /**\n     * Drop shadow configuration for the text.\n     * Can be boolean or a TextDropShadow object.\n     * @default null\n     */\n    dropShadow?: boolean | Partial<TextDropShadow>;\n    /**\n     * Fill style for the text.\n     * Can be a color, gradient, or pattern.\n     * @default 'black'\n     */\n    fill?: FillInput;\n    /**\n     * Font family or families to use.\n     * Can be single name or array of fallbacks.\n     * @example\n     * ```ts\n     * // Single font family\n     * fontFamily: 'Arial'\n     * // Multiple font families\n     * fontFamily: ['Helvetica', 'Arial', 'sans-serif']\n     * ```\n     * @default 'Arial'\n     */\n    fontFamily?: string | string[];\n    /**\n     * Font size in pixels or as string.\n     *\n     * Equivalents are '26px','20pt','160%' or '1.6em')\n     * @example\n     * ```ts\n     * // Numeric size\n     * fontSize: 26\n     * // String size\n     * fontSize: '26px'\n     * // Percentage size\n     * fontSize: '160%' // 1.6 times the parent element's font size\n     * // Em size\n     * fontSize: '1.6em' // 1.6 times the parent element's font size\n     * @default 26\n     */\n    fontSize?: number | string;\n    /**\n     * Font style (normal, italic, oblique).\n     * @default 'normal'\n     */\n    fontStyle?: TextStyleFontStyle;\n    /**\n     * Font variant (normal, small-caps).\n     * @default 'normal'\n     */\n    fontVariant?: TextStyleFontVariant;\n    /**\n     * Font weight (normal, bold, bolder, lighter, 100-900).\n     * @default 'normal'\n     */\n    fontWeight?: TextStyleFontWeight;\n    /** The height of the line, a number that represents the vertical space that a letter uses. */\n    leading?: number;\n    /** The amount of spacing between letters, default is 0 */\n    letterSpacing?: number;\n    /** The line height, a number that represents the vertical space that a letter uses */\n    lineHeight?: number;\n    /**\n     * Padding around the text.\n     *\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from\n     * happening by adding padding to all sides of the text.\n     */\n    padding?: number;\n    /**\n     * Stroke style for text outline.\n     * @default null\n     */\n    stroke?: StrokeInput;\n    /**\n     * Vertical alignment baseline.\n     * @default 'alphabetic'\n     */\n    textBaseline?: TextStyleTextBaseline;\n    /**\n     * Whether to trim transparent edges.\n     * > [!NOTE] This is an expensive operation and should only be used when necessary.\n     * @default false\n     */\n    trim?: boolean;\n    /**\n     * How to handle whitespace.\n     *\n     * It needs wordWrap to be set to true for this to have an effect.\n     * @default 'pre'\n     */\n    whiteSpace?: TextStyleWhiteSpace;\n    /** Indicates if word wrap should be used */\n    wordWrap?: boolean;\n    /** The width at which text will wrap, it needs wordWrap to be set to true */\n    wordWrapWidth?: number;\n    /**\n     * Array of filters to apply to the text.\n     *\n     * These filters will be applied to the text as it is created, resulting in faster rendering for static text\n     * compared to applying the filter directly to the text object (which would be applied at run time).\n     * @default undefined\n     */\n    filters?: Filter[] | readonly Filter[];\n}\n\n/**\n * A TextStyle Object contains information to decorate Text objects.\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @example\n * ```ts\n * // Create a basic text style\n * const style = new TextStyle({\n *     fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *     fontSize: 36,\n *     fill: 0xff1010,\n *     align: 'center'\n * });\n *\n * // Create a rich text style with multiple features\n * const richStyle = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 32,\n *     fill: 'white',\n *     stroke: {\n *         color: '#4a1850',\n *         width: 5\n *     },\n *     dropShadow: {\n *         color: '#000000',\n *         blur: 4,\n *         distance: 6,\n *         angle: Math.PI / 6\n *     },\n *     wordWrap: true,\n *     wordWrapWidth: 440,\n *     lineHeight: 40,\n *     align: 'center'\n * });\n *\n * // Share style between multiple text objects\n * const text1 = new Text({\n *     text: 'Hello',\n *     style: richStyle\n * });\n *\n * const text2 = new Text({\n *     text: 'World',\n *     style: richStyle\n * });\n *\n * // Update style dynamically - affects all text objects\n * richStyle.fontSize = 48;\n * richStyle.fill = 0x00ff00;\n * ```\n *\n * Key Features:\n * - Shared styling between multiple text objects\n * - Rich text formatting options\n * - Gradient and pattern fills\n * - Drop shadows and strokes\n * - Word wrapping and alignment\n * - Dynamic updates\n * @category text\n * @standard\n */\nexport class TextStyle extends EventEmitter<{\n    update: TextDropShadow\n}>\n{\n    /**\n     * Default drop shadow settings used when enabling drop shadows on text.\n     * These values are used as the base configuration when drop shadows are enabled without specific settings.\n     * @example\n     * ```ts\n     * // Customize default settings globally\n     * TextStyle.defaultDropShadow.alpha = 0.5;    // 50% opacity for all shadows\n     * TextStyle.defaultDropShadow.blur = 2;       // 2px blur for all shadows\n     * TextStyle.defaultDropShadow.color = 'blue'; // Blue shadows by default\n     * ```\n     */\n    public static defaultDropShadow: TextDropShadow = {\n        alpha: 1,\n        angle: Math.PI / 6,\n        blur: 0,\n        color: 'black',\n        distance: 5\n    };\n\n    /**\n     * Unique identifier for the TextStyle class.\n     * This is used to track instances and ensure uniqueness.\n     * @internal\n     */\n    public uid = uid('textStyle');\n    /**\n     * Internal tick counter used to track updates and changes.\n     * This is incremented whenever the style is modified, allowing for efficient change detection.\n     * @internal\n     */\n    public _tick = 0;\n\n    /**\n     * Default text style settings used when creating new text objects.\n     * These values serve as the base configuration and can be customized globally.\n     * @example\n     * ```ts\n     * // Customize default text style globally\n     * TextStyle.defaultTextStyle.fontSize = 16;\n     * TextStyle.defaultTextStyle.fill = 0x333333;\n     * TextStyle.defaultTextStyle.fontFamily = ['Arial', 'Helvetica', 'sans-serif'];\n     * ```\n     */\n    public static defaultTextStyle: TextStyleOptions = {\n        align: 'left',\n        breakWords: false,\n        dropShadow: null,\n        fill: 'black',\n        fontFamily: 'Arial',\n        fontSize: 26,\n        fontStyle: 'normal',\n        fontVariant: 'normal',\n        fontWeight: 'normal',\n        leading: 0,\n        letterSpacing: 0,\n        lineHeight: 0,\n        padding: 0,\n        stroke: null,\n        textBaseline: 'alphabetic',\n        trim: false,\n        whiteSpace: 'pre',\n        wordWrap: false,\n        wordWrapWidth: 100\n    };\n\n    // colors!!\n    /** @internal */\n    public _fill: ConvertedFillStyle;\n    private _originalFill: FillInput;\n\n    /** @internal */\n    public _stroke: ConvertedStrokeStyle;\n    private _originalStroke: StrokeInput;\n\n    private _dropShadow: TextDropShadow;\n\n    private _fontFamily: string | string[];\n    private _fontSize: number;\n    private _fontStyle: TextStyleFontStyle;\n    private _fontVariant: TextStyleFontVariant;\n    private _fontWeight: TextStyleFontWeight;\n\n    private _breakWords: boolean;\n    private _align: TextStyleAlign;\n    private _leading: number;\n    private _letterSpacing: number;\n    private _lineHeight: number;\n\n    private _textBaseline: TextStyleTextBaseline;\n    private _whiteSpace: TextStyleWhiteSpace;\n    private _wordWrap: boolean;\n    private _wordWrapWidth: number;\n    private _filters: readonly Filter[];\n\n    private _padding: number;\n\n    private _trim: boolean;\n\n    constructor(style: Partial<TextStyleOptions> = {})\n    {\n        super();\n\n        convertV7Tov8Style(style);\n\n        const fullStyle = { ...TextStyle.defaultTextStyle, ...style };\n\n        for (const key in fullStyle)\n        {\n            const thisKey = key as keyof typeof this;\n\n            this[thisKey] = fullStyle[key as keyof TextStyleOptions] as any;\n        }\n\n        this.update();\n        this._tick = 0;\n    }\n\n    /**\n     * Alignment for multiline text, does not affect single line text.\n     * @type {'left'|'center'|'right'|'justify'}\n     */\n    get align(): TextStyleAlign { return this._align; }\n\n    set align(value: TextStyleAlign)\n    {\n        if (this._align === value) return;\n\n        this._align = value;\n        this.update();\n    }\n\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n    get breakWords(): boolean { return this._breakWords; }\n\n    set breakWords(value: boolean)\n    {\n        if (this._breakWords === value) return;\n\n        this._breakWords = value;\n        this.update();\n    }\n\n    /** Set a drop shadow for the text. */\n    get dropShadow(): TextDropShadow { return this._dropShadow; }\n\n    set dropShadow(value: boolean | TextDropShadow)\n    {\n        if (this._dropShadow === value) return;\n\n        if (value !== null && typeof value === 'object')\n        {\n            this._dropShadow = this._createProxy({ ...TextStyle.defaultDropShadow, ...value });\n        }\n        else\n        {\n            this._dropShadow = value ? this._createProxy({ ...TextStyle.defaultDropShadow }) : null;\n        }\n\n        this.update();\n    }\n\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    get fontFamily(): string | string[] { return this._fontFamily; }\n\n    set fontFamily(value: string | string[])\n    {\n        if (this._fontFamily === value) return;\n\n        this._fontFamily = value;\n        this.update();\n    }\n\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    get fontSize(): number { return this._fontSize; }\n\n    set fontSize(value: string | number)\n    {\n        if (this._fontSize === value) return;\n\n        if (typeof value === 'string')\n        {\n            // eg '34px' to number\n            this._fontSize = parseInt(value as string, 10);\n        }\n        else\n        {\n            this._fontSize = value as number;\n        }\n        this.update();\n    }\n\n    /**\n     * The font style.\n     * @type {'normal'|'italic'|'oblique'}\n     */\n    get fontStyle(): TextStyleFontStyle { return this._fontStyle; }\n\n    set fontStyle(value: TextStyleFontStyle)\n    {\n        if (this._fontStyle === value) return;\n\n        this._fontStyle = value.toLowerCase() as TextStyleFontStyle;\n        this.update();\n    }\n\n    /**\n     * The font variant.\n     * @type {'normal'|'small-caps'}\n     */\n    get fontVariant(): TextStyleFontVariant { return this._fontVariant; }\n\n    set fontVariant(value: TextStyleFontVariant)\n    {\n        if (this._fontVariant === value) return;\n\n        this._fontVariant = value;\n        this.update();\n    }\n\n    /**\n     * The font weight.\n     * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    get fontWeight(): TextStyleFontWeight { return this._fontWeight; }\n\n    set fontWeight(value: TextStyleFontWeight)\n    {\n        if (this._fontWeight === value) return;\n\n        this._fontWeight = value;\n        this.update();\n    }\n\n    /** The space between lines. */\n    get leading(): number { return this._leading; }\n\n    set leading(value: number)\n    {\n        if (this._leading === value) return;\n\n        this._leading = value;\n        this.update();\n    }\n\n    /** The amount of spacing between letters, default is 0. */\n    get letterSpacing(): number { return this._letterSpacing; }\n\n    set letterSpacing(value: number)\n    {\n        if (this._letterSpacing === value) return;\n\n        this._letterSpacing = value;\n        this.update();\n    }\n\n    /** The line height, a number that represents the vertical space that a letter uses. */\n    get lineHeight(): number { return this._lineHeight; }\n\n    set lineHeight(value: number)\n    {\n        if (this._lineHeight === value) return;\n\n        this._lineHeight = value;\n        this.update();\n    }\n\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     * > [!NOTE] This will NOT affect the positioning or bounds of the text.\n     */\n    get padding(): number { return this._padding; }\n\n    set padding(value: number)\n    {\n        if (this._padding === value) return;\n\n        this._padding = value;\n        this.update();\n    }\n\n    /**\n     * An optional filter or array of filters to apply to the text, allowing for advanced visual effects.\n     * These filters will be applied to the text as it is created, resulting in faster rendering for static text\n     * compared to applying the filter directly to the text object (which would be applied at run time).\n     * @default null\n     */\n    get filters(): readonly Filter[] { return this._filters; }\n\n    set filters(value: Filter[])\n    {\n        if (this._filters === value) return;\n\n        this._filters = Object.freeze(value);\n        this.update();\n    }\n\n    /**\n     * Trim transparent borders from the text texture.\n     * > [!IMPORTANT] PERFORMANCE WARNING:\n     * > This is a costly operation as it requires scanning pixel alpha values.\n     * > Avoid using `trim: true` for dynamic text, as it could significantly impact performance.\n     */\n    get trim(): boolean { return this._trim; }\n\n    set trim(value: boolean)\n    {\n        if (this._trim === value) return;\n\n        this._trim = value;\n        this.update();\n    }\n\n    /**\n     * The baseline of the text that is rendered.\n     * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    get textBaseline(): TextStyleTextBaseline { return this._textBaseline; }\n\n    set textBaseline(value: TextStyleTextBaseline)\n    {\n        if (this._textBaseline === value) return;\n\n        this._textBaseline = value;\n        this.update();\n    }\n\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     * @type {'normal'|'pre'|'pre-line'}\n     */\n    get whiteSpace(): TextStyleWhiteSpace { return this._whiteSpace; }\n\n    set whiteSpace(value: TextStyleWhiteSpace)\n    {\n        if (this._whiteSpace === value) return;\n\n        this._whiteSpace = value;\n        this.update();\n    }\n\n    /** Indicates if word wrap should be used. */\n    get wordWrap(): boolean { return this._wordWrap; }\n\n    set wordWrap(value: boolean)\n    {\n        if (this._wordWrap === value) return;\n\n        this._wordWrap = value;\n        this.update();\n    }\n\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */\n    get wordWrapWidth(): number { return this._wordWrapWidth; }\n\n    set wordWrapWidth(value: number)\n    {\n        if (this._wordWrapWidth === value) return;\n\n        this._wordWrapWidth = value;\n        this.update();\n    }\n\n    /**\n     * The fill style that will be used to color the text.\n     * This can be:\n     * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'\n     * - A hex number like 0xff0000 for red\n     * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }\n     * - A FillGradient for gradient fills\n     * - A FillPattern for pattern/texture fills\n     *\n     * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,\n     * while gradients at any other angle are spread across the entire text body as a whole.\n     * @example\n     * // Vertical gradient applied per line\n     * const verticalGradient = new FillGradient(0, 0, 0, 1)\n     *     .addColorStop(0, 0xff0000)\n     *     .addColorStop(1, 0x0000ff);\n     *\n     * const text = new Text({\n     *     text: 'Line 1\\nLine 2',\n     *     style: { fill: verticalGradient }\n     * });\n     *\n     * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.\n     * @type {string|number|FillStyle|FillGradient|FillPattern}\n     */\n    get fill(): FillInput\n    {\n        return this._originalFill;\n    }\n\n    set fill(value: FillInput)\n    {\n        if (value === this._originalFill) return;\n\n        this._originalFill = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () =>\n            {\n                this._fill = toFillStyle(\n                    { ...this._originalFill as FillStyle },\n                    GraphicsContext.defaultFillStyle\n                );\n            });\n        }\n\n        this._fill = toFillStyle(\n            value === 0x0 ? 'black' : value,\n            GraphicsContext.defaultFillStyle\n        );\n        this.update();\n    }\n\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n    get stroke(): StrokeInput\n    {\n        return this._originalStroke;\n    }\n\n    set stroke(value: StrokeInput)\n    {\n        if (value === this._originalStroke) return;\n\n        this._originalStroke = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () =>\n            {\n                this._stroke = toStrokeStyle(\n                    { ...this._originalStroke as StrokeStyle },\n                    GraphicsContext.defaultStrokeStyle\n                );\n            });\n        }\n\n        this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n        this.update();\n    }\n\n    public update()\n    {\n        this._tick++;\n        this.emit('update', this);\n    }\n\n    /** Resets all properties to the default values */\n    public reset()\n    {\n        const defaultStyle = TextStyle.defaultTextStyle;\n\n        for (const key in defaultStyle)\n        {\n            this[key as keyof typeof this] = defaultStyle[key as keyof TextStyleOptions] as any;\n        }\n    }\n\n    /**\n     * Returns a unique key for this instance.\n     * This key is used for caching.\n     * @returns {string} Unique key for the instance\n     */\n    public get styleKey(): string\n    {\n        return `${this.uid}-${this._tick}`;\n    }\n\n    /**\n     * Creates a new TextStyle object with the same values as this one.\n     * @returns New cloned TextStyle object\n     */\n    public clone(): TextStyle\n    {\n        return new TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            filters: this._filters ? [...this._filters] : undefined\n        });\n    }\n\n    /**\n     * Returns the final padding for the text style, taking into account any filters applied.\n     * Used internally for correct measurements\n     * @internal\n     * @returns {number} The final padding for the text style.\n     */\n    public _getFinalPadding(): number\n    {\n        let filterPadding = 0;\n\n        if (this._filters)\n        {\n            for (let i = 0; i < this._filters.length; i++)\n            {\n                filterPadding += this._filters[i].padding;\n            }\n        }\n\n        return Math.max(this._padding, filterPadding);\n    }\n\n    /**\n     * Destroys this text style.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * // Destroy the text style and its textures\n     * textStyle.destroy({ texture: true, textureSource: true });\n     * textStyle.destroy(true);\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false)\n    {\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fill?.texture)\n            {\n                this._fill.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalFill as FillStyle)?.texture)\n            {\n                (this._originalFill as FillStyle).texture.destroy(destroyTextureSource);\n            }\n\n            if (this._stroke?.texture)\n            {\n                this._stroke.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalStroke as FillStyle)?.texture)\n            {\n                (this._originalStroke as FillStyle).texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n\n    private _createProxy<T extends object>(value: T, cb?: (property: string, newValue: any) => void): T\n    {\n        return new Proxy<T>(value, {\n            set: (target, property, newValue) =>\n            {\n                if (target[property as keyof T] === newValue) return true;\n\n                target[property as keyof T] = newValue;\n                cb?.(property as string, newValue);\n                this.update();\n\n                return true;\n            }\n        });\n    }\n\n    private _isFillStyle(value: FillInput): value is FillStyle\n    {\n        return ((value ?? null) !== null\n            && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern));\n    }\n}\n\nfunction convertV7Tov8Style(style: TextStyleOptions)\n{\n    const oldStyle = style as TextStyleOptions & {\n        dropShadowAlpha?: number;\n        dropShadowAngle?: number;\n        dropShadowBlur?: number;\n        dropShadowColor?: number;\n        dropShadowDistance?: number;\n        fillGradientStops?: number[];\n        strokeThickness?: number;\n    };\n\n    if (typeof oldStyle.dropShadow === 'boolean' && oldStyle.dropShadow)\n    {\n        const defaults = TextStyle.defaultDropShadow;\n\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance: oldStyle.dropShadowDistance ?? defaults.distance\n        };\n    }\n\n    if (oldStyle.strokeThickness !== undefined)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'strokeThickness is now a part of stroke');\n        // #endif\n\n        const color = oldStyle.stroke;\n        let obj: FillStyle = {};\n\n        // handles stroke: 0x0, stroke: { r: 0, g: 0, b: 0, a: 0 } stroke: new Color(0x0)\n        if (Color.isColorLike(color as ColorSource))\n        {\n            obj.color = color as ColorSource;\n        }\n        // handles stroke: new FillGradient()\n        else if (color instanceof FillGradient || color instanceof FillPattern)\n        {\n            obj.fill = color as FillGradient | FillPattern;\n        }\n        // handles stroke: { color: 0x0 } or stroke: { fill: new FillGradient() }\n        else if (Object.hasOwnProperty.call(color, 'color') || Object.hasOwnProperty.call(color, 'fill'))\n        {\n            obj = color as FillStyle;\n        }\n        else\n        {\n            throw new Error('Invalid stroke value.');\n        }\n\n        style.stroke = {\n            ...obj,\n            width: oldStyle.strokeThickness\n        };\n    }\n\n    if (Array.isArray(oldStyle.fillGradientStops))\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'gradient fill is now a fill pattern: `new FillGradient(...)`');\n        // #endif\n\n        if (!Array.isArray(oldStyle.fill) || oldStyle.fill.length === 0)\n        {\n            throw new Error('Invalid fill value. Expected an array of colors for gradient fill.');\n        }\n\n        if (oldStyle.fill.length !== oldStyle.fillGradientStops.length)\n        {\n            // #if _DEBUG\n            warn('The number of fill colors must match the number of fill gradient stops.');\n            // #endif\n        }\n\n        const gradientFill = new FillGradient({\n            start: { x: 0, y: 0 },\n            end: { x: 0, y: 1 },\n            textureSpace: 'local'\n        });\n\n        const fillGradientStops = oldStyle.fillGradientStops.slice();\n        const fills: number[] = oldStyle.fill\n            .map((color: ColorSource) => Color.shared.setValue(color).toNumber());\n\n        fillGradientStops.forEach((stop, index) =>\n        {\n            gradientFill.addColorStop(stop, fills[index]);\n        });\n\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n\n"],"names":["video","key","LoaderParserPriority","path","src","y2","x0","y0","x1","x2","y1","generateTextureFillMatrix","out","id","i"],"mappings":"mEAKI,8DEAE,EAAa,IAAI,EAAA,MAAO,EAAA,CAAA,GFgB9B,GAAA,IER+C,CAAA,CAAA,CAAA,CAC/C,EAAA,6DACyB,AAIsB,AAEtB,CIIK,CAAA,GJFrB,CKES,CAAA,KLJmB,CAAA,CAAA,CAE5B,EAAa,CKOd,AHNW,CJKA,CAAA,KIPM,+CARU,CAAiB,CAAA,CAAA,CAAgB,CACpE,EAAA,AACU,IAAA,EAAA,EAAA,UAAA,CAAA,GAA8B,EC0C3B,AD1C2B,CAAA,EAE/B,UAAa,EAAA,EAElB,IAAA,EAAA,EAAA,UAAmB,CAAW,EDwBA,CCxBI,EAAA,CAAE,QAAS,EAAA,CAAA,QFDU,CAAA,CAAA,GEexB,CGIA,AHJmB,CGInB,AHJmB,CJKtB,AILsB,CJKtB,AILuC,CACvE,EAAA,OACS,EAUD,IAAW,EATf,EAUA,EAAA,AAC8B,CGHH,CAAA,AHGU,MAAQ,CAAA,CC8FJ,CAAA,AD9FU,EAAN,GAElC,CAF8C,CAAA,CAAA,iBAE9C,KAEA,MAAA,CAAO,EAAO,cAAA,0EATd,GArBoC,EAAM,EAAW,AAAX,OAAA,GAAqB,CAAA,CAAA,gBAEvC,GAEnC,EAAA,OAF+C,CAAA,EAE/C,EAAkB,CEMd,AHiBQ,iBCrBS,sBAEV,CAAO,8EELQ,CFHL,MEIrB,CAAA,IAAc,CAAA,eAKG,MACb,IACS,CAAA,IAAA,CAAK,ENCJA,AMDY,ELFV,EKEc,CAAA,ANCC,CMGxB,CLAP,IKAY,CACZ,CAAA,iBAKS,CAAA,mBAAA,CNHe,AMGO,CNHP,AMGS,ELFN,CAAA,CKEsB,UAAA,EAAA,MAAA,CAAA,CAAA,SAExC,CAAK,UAAA,CAAA,IAAkB,CAAA,mBAAA,CAAA,UAClB,KFNqD,CAAA,CAAA,OEMpC,CAAA,CAAA,IAAM,CAAA,CD6FL,kBC7FK,CAAA,UAEvB,UAAa,CAAA,CCJL,EDOf,OACP,CACsB,IAAA,EAAM,MAAf,IAAS,YACb,CAAK,UAAa,EAAA,IAAA,OACX,CAAA,KAAA,CAChB,AAEO,CCLP,SDKiB,CAAA,CAAgB,CACjC,CAAA,CD4FmB,CAAA,IC3FL,ECLP,KDMH,EAAA,AACkB,EAAA,ECLC,EDKD,CAAK,IAAA,CAAM,EAAQ,CCLP,EDS3B,eAAA,CAAA,CAA+B,CACtC,CAAA,GACuB,IAAA,CAAK,IAAA,CAAM,EAAQ,GAGnC,cAAA,CAAA,CAA4B,CACnC,CAAA,QAIW,EAHD,ENHA,EMGA,CAAY,GAGD,CAHC,CAAA,AAGK,KNNL,AMMU,OAIhC,CDyFA,EE9F2B,GDMlB,KAAM,EAAA,CAAA,AAGf,OAAc,KAAK,CACnB,CAAA,QACW,aAAgB,EAAA,MAAA,CAAA,CAnElB,EAEK,SAAA,CAA+B,EAAA,aAAc,CAAA,UAAA,sCLRlD,EAQT,GDhBA,CAAA,GCSJ,CAAA,IAOgB,CACZ,CAAA,CALA,IAAA,CAAA,QAAkB,CAAA,WAEJ,CAAA,CMClB,ADAA,AHsBqB,CEgBR,AEtCb,AJsBqB,mBFjBJ,IAAA,CAAA,IAAA,CAAK,EAAQ,IAAI,CAAA,MAIlB,CAAA,CACZ,KACI,CAAA,IAAY,CAAA,aAQhB,OAAA,KAAA,CACA,CAAA,CKDgB,MLEW,UAAhB,OAAO,KA1BJ,SAAA,CAAA,EAAA,aAA6C,CAAA,UAAA,8ED2BvC,CAAA,iEOPR,CNAZ,CAAA,CMEI,IAAA,CAAA,IAAA,CAAY,EACZ,EADY,EACZ,CAAA,IAAA,CAAA,cAA2B,EAAA,GHJ1B,SGKS,UAAa,CAAA,CAAA,EAGpB,OACP,CACsB,YAAT,IAAS,aACR,UAAa,EAAA,YACb,cAAiB,CAAA,CAAA,WACf,CAAA,MAGT,UAAU,CAAA,CAAA,CACjB,CAAA,GACkB,IAAA,CAAA,IAAW,CAAA,EAAA,GAGtB,CAHsB,cAGP,CAAA,CAAgB,CACtC,CAAA,GACuB,IAAA,CAAK,IAAM,CAAA,EAAQ,GAGnC,CDIP,aCJqB,CAAA,CAAc,CACnC,CAAA,QAIW,EAHM,IAAK,CAAA,IAAA,CAGX,YAIX,KACI,CAAK,KAAM,EAAA,QAGD,KAAK,CAAA,CACnB,CACI,EPDA,KOCO,aAAgB,EAAA,SAAA,IAtDb,SAAA,CAA+B,EAAA,aAAc,CAAA,UAAA,OPyDD,4DG3C7B,EAAA,aACjC,CAAA,6BAEW,cAAA,CAAiB,+BAMM,CAAA,CAAA,cAGX,CACnB,CAAA,CDzBkB,CAAA,CIGJ,CAAA,eHuBS,gBAAoB,EAAA,EHhBvC,KAAA,CGgBuC,KAAoB,gBACvD,EAAuB,IAAvB,OAAO,AAAgB,WAAA,EAAe,QAAoB,KAAA,WAAA,EAC1D,UAAW,CAAA,UAAA,EAAc,QAAoB,KAAA,UAAA,CAAA,aAdR,EAAA,aAAA,CAAc,GHAjB,CAAA,CAAA,QGAiB,+EHjBzC,CEfhB,UFiBF,GAAA,CAAA,EAAA,CAAa,cAGH,EAAA,AAAK,AADI,CIRb,AFDe,CAAA,UFSS,CAAA,GAAA,GAAM,YAAA,CAAa,EAAG,CAAC,CAAA,CAAA,AAC/B,UAAA,CAAW,CGaT,MHbgB,CAAA,CAAA,MAIzB,EADX,IACW,kCAGL,EAAQ,MAAA,IAAU,CODE,CAAA,KPCF,CAAiC,AAAC,QAEhDA,EAAAA,SAAiB,KINE,CAAA,CAAA,MJMF,CAAA,SAEvBA,EAAAA,YAAM,CAAe,EIND,CAAA,CAAA,CCyDJ,CLnDmBA,GACnCA,EAAAA,CADwC,CAAA,CAAA,IACxCA,CAAgB,IAAM,EAAA,CINA,CAAA,CAAA,EJMA,GAChB,QAAA,EAAW,KAAA,CAAA,SACG,CAAA,qBACJ,CAAA,CCCG,MDCnBA,EAAAA,GAAY,CAAA,0sBACZA,COAR,CAAA,IPAmB,CIAR,CJAQ,CAAA,QAKJ,CMIf,INLI,CMKJ,oCNDoB,COJJ,CPIO,aAAc,KAE9B,WAAA,CAAY,EAAG,UAAA,CAAY,OAExB,COLH,CPKiB,EAAG,iBAAkB,EAAA,CAAA,EAEtC,eAAA,CAAgB,CK6FH,CL7FM,AK6FN,AL7FM,WAAA,CAAa,KAChC,MAD2C,CAAA,CAAA,IOLM,CAAA,CAAA,MPMjD,CACC,EAAA,WAAG,CAAA,EAAA,iBAAA,CAEH,EAAA,UAAG,CACH,EACA,CAAA,IAGD,WAAA,CAAY,EAAG,8BAAA,EAAgC,GAClD,EADuD,AACpD,CADoD,CAAA,AOG3D,SPFmB,CAAA,EAAA,kCAAuC,CAAA,EAAA,AAAG,IAAI,CAAA,CAAA,EAC1D,UAAA,CAAW,EAAG,UAAA,CAAY,CAAG,CAAA,EAAA,AAAG,IAAA,CAAM,EAAG,IAAA,CAAM,EAAG,aAAA,CAAe,KAAK,CAAA,CAEnE,AAFmE,EAE3D,EMMP,ENNW,WAAW,CMMD,ANNE,CAAA,CAAA,OAE3B,EAAA,UAAA,CAAA,EAAc,CAAG,CAAA,CAAA,CAAG,EAAG,EAAG,IAAA,CAAM,EAAG,aAAA,CAAe,KAAK,AAEvD,CAFuD,CAAA,AMQ9D,eAAA,CNNyB,KAClB,aAAA,CAAc,GACd,EAAA,MKgGC,MLhGD,CAAa,oBAAoB,CAAA,EAAG,WAAY,EAAA,CAAA,EAEtC,EAAC,EAAK,CAAM,CAAA,CAAC,CAAA,CAAI,sBAAwB,6BAAA,CAAA,CACvD,EAAA,CAAA,CAAA,AAEI,UKvBJ,IAAA,EAAA,MAAM,CJvCK,SIuCe,EAAA,aACjC,CAAA,YAoEQ,CAEJ,CAAA,CD/GkB,AFDA,AGiHd,CHjHc,AECA,ICgHd,CAAM,GA7CV,IAAA,CAAO,OAAU,CAAA,GAEjB,CCrDI,GDqDJ,CAAO,cAAiB,CAAA,QA8CV,EAAA,CACN,GAAG,EAAY,cAAA,CACf,GAAA,CAAA,MAGJ,CAAA,WAAmB,EAAA,MACnB,CAAA,oBAA4B,CAAA,CAAA,EACvB,CLhGJ,CAAA,CAAA,CKgGI,CAAA,UAAA,CAAa,EAAQ,EC5FH,CAAA,MD4FgB,EAAA,CAAA,CAAA,AACvC,IAAA,CAAK,IEjGmB,CPGxB,UK8FuB,CAAA,CAAA,CAAA,AAClB,IAAA,CAAA,QAAA,CAAgC,CL9F1B,IK8FK,EAAQ,CD9FE,OC8FW,KAChC,CAAA,CD7FL,QC6FK,CAAY,EAAQ,SAAa,EAAA,6BAAA,CAAA,AAGtC,IAAA,CAAK,0BAA6B,CAAA,IAAA,CAAK,0BAA2B,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA,AAC3E,EL9FG,EAAA,CAAA,gCK8FqC,CL9FH,AK8FG,CL9FH,GK8FG,CAAA,IAExC,CAAK,KAAQ,CD9FV,AC8FU,KACb,EL7FG,EK6FH,CAAK,QAAW,CAAA,KAChB,EL7FG,EK6FH,CAAK,EC7FF,KD6FY,CAAA,KAGf,IAAA,CAAK,UAAa,CAAA,IAAA,CAAK,UAAW,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA,AAC3C,IAAA,CAAK,UC7Fa,OAAA,CAAA,ID6FO,CAAK,GC7FD,cD6FmB,CAAA,CElGD,GFkGC,CAAK,CC7FG,CAAA,CAAA,CD6FC,CAAA,CAAA,IACzD,CAAA,QAAgB,CAAA,IAAA,CAAK,QAAS,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA,AACvC,IAAA,CAAK,IL/FD,EOFD,MFiGiB,CAAA,IAAA,CAAK,YAAa,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA,IAC/C,CAAK,WAAc,CAAA,IAAA,CAAK,WAAY,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA,AAC7C,CL/FA,CAAA,EK+FA,CAAK,SAAY,CE9FV,CAAA,GF8FU,CAAK,SAAU,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA,CAEhB,GC7FsB,CAAA,AD6F3C,CACJ,AC9F+C,CD6FnC,CACZ,IADI,GAAQ,EAEH,IAAA,CAAK,IAAK,EACnB,CE7FJ,AF8FA,AAGU,aACV,KACQ,IAAA,CAAK,SACT,EAAA,GAII,CLpGoB,CAAA,CAAA,CKoGpB,CAAK,ECzFc,QD0FvB,CAAA,CAEI,IAAM,EAAY,ELjGnB,AKiGmB,CLjGnB,IKiGmB,CAAA,CAAO,MAAO,CAAA,SAAA,CAAY,IAAA,CAAK,QAAS,CAAA,YAAA,AAE1D,CAF0D,IAE1D,CAAK,eAAkB,CAAA,IAAA,CAAK,KAAM,CAAA,IAAA,CAAK,eAAA,CAAkB,IAGzD,CAAC,IAHiE,AAGjE,CAAK,AAH4D,CAAA,SAG9C,EAAA,IAAA,CAAK,eAAA,EAAmB,CAChD,EAAA,EACS,IAAA,CAAA,eAAA,CAAkB,IAAA,CAAK,UAAa,CAAA,IAAA,CAAK,KAAA,CAAM,GAAO,CAAA,IAAA,CAAK,UAAU,CAAI,EAAA,CAAA,CAAA,AAG9E,IAAA,CAAK,OACT,EAAA,AACI,IAAA,CAAK,MAAO,EAAA,CAAA,AAChB,CACJ,AAGQ,0BACR,EAAA,CACI,IAAA,CAAK,WAAY,EAAA,CAAA,AAEb,IAAA,CAAK,SACT,CACI,CADJ,GACI,CAAK,gCAAmC,CAAA,IAAA,CAInC,AAJmC,IAInC,CAAA,gCAAA,CAAmC,IAAA,CAAK,QAAS,CAAA,yBAAA,CAClD,IAAK,CAAA,0BAAA,CAEb,CACJ,AAMA,IAAW,OACX,EAAA,CACW,MAAA,CAAC,CAAC,IAAK,CAAA,QAAA,CAAS,UAAA,EAAc,CAAC,CAAC,IAAA,CAAK,QAAS,CAAA,WAAA,CAAA,AACzD,AAMA,MAAa,IACb,EAAA,CACI,GAAI,IAAA,CAAK,KACT,CACI,CADJ,MACW,IAAK,CAAA,KAAA,CAAA,AAGhB,IAAM,EAAS,IAAK,CAAA,QAAA,CACd,AADc,EACJ,IAAK,CAAA,OAAA,CAAA,AAwDrB,MArDK,CAAA,EAAO,IAAP,MAAsB,GAAA,EAAO,IAAP,YAA2B,EAAA,EAAO,IAAP,MAAsB,GAAA,EAAO,IAAP,YACrE,AAD4E,GAC5E,EAAO,IAAP,CAAgB,EAAA,EAAO,IAAP,EACvB,EAAA,CACK,EAAe,QAAW,EAAA,CAAA,CAAA,CAAA,AAIxB,EAAA,IAAA,YAAA,CAAiB,MAAQ,CAAA,IAAA,CAAK,YAAY,CAAA,CAAA,AAC1C,EAAA,IAAA,YAAA,CAAiB,OAAS,CAAA,IAAA,CAAK,WAAW,CAAA,CAAA,AAC1C,EAAA,IAAA,YAAA,CAAiB,QAAU,CAAA,IAAA,CAAK,SAAS,CAAA,CAAA,AAG3C,IAAK,CAAA,cAAA,EACV,CAYI,CAZJ,GAYI,CAAK,WAAY,EAAA,CAAA,CAXb,AAAC,EAAQ,OACb,EAAA,AAEW,EAAA,IAAA,YAAA,CAAiB,SAAW,CAAA,IAAA,CAAK,UAAU,CAAA,CAAA,AAE/C,EAAA,IAAA,YAAA,CAAiB,gBAAkB,CAAA,IAAA,CAAK,iBAAiB,CAAA,CAAA,AAChE,EAAO,IAAP,YAAwB,CAAA,OAAA,CAAS,IAAK,CAAA,QAAA,EAAU,IAAI,AAQnD,CARmD,CAAA,EAQnD,CAAA,SAAA,CAAY,MAAM,IAGvB,IAAA,CAAK,KAAQ,CAAA,IAAI,CAH2B,EAAA,CAAA,GAGnB,CAAA,CAAC,EAAS,KAE3B,CADR,GACQ,CAAK,CADb,MAEI,CACI,CADJ,CACY,IAAI,CAAA,AAAZ,CAAY,CAIZ,IAAA,CAAK,QAAW,CAAA,EAChB,IAAA,CAAK,AADW,CAAA,MACD,CAAA,EAEX,AAA6B,IAFlB,CAAA,AAGf,CAAA,CADI,CACJ,GADY,gBAAA,GAEH,IAAA,CAAA,eAAA,CAAkB,WAAW,KAE9B,CADJ,GACI,CAAK,QAAA,CAAS,IAAI,UAAA,CAAW,CAAA,4BAAA,EAA+B,EAAQ,KAAA,WAAgB,CAAA,EAAA,CAAI,CAAC,CAAA,CAAA,CAC5F,CAAA,CAAA,AAEL,EAAO,IAAP,AAAY,EAAA,CAAA,AAChB,CACH,CAAA,CAAA,AAEM,IAAK,CAAA,KAAA,CAAA,AAChB,AAMQ,SAAS,CACjB,CAAA,CACI,IAAA,CAAK,QAAS,CAAA,mBAAA,CAAoB,OAAS,CAAA,IAAA,CAAK,QAAA,EAAU,GACrD,CADyD,CAAA,CAAA,CACzD,CAAA,IAAA,CAAK,QAAS,GAEf,EAFoB,CAAA,CAEpB,AAFoB,CAEf,OACT,EAAA,CACI,IAAA,CAAK,OAAA,CAAQ,GACb,EADkB,CAAA,CAAA,AAClB,CAAK,OAAU,CAAA,IAAA,CAAA,AACf,IAAA,CAAK,QAAW,CAAA,IAAA,CAAA,AACpB,CACJ,AAMQ,gBACR,EAAA,CACI,IAAM,EAAS,IAAK,CAAA,QAAA,CAAA,AAEpB,MAAQ,CAAC,EAAO,IAAP,EAAiB,EAAA,CAAC,EAAO,IAAA,CAAA,CAAA,AACtC,AAMQ,cACR,EAAA,CAGI,OAFe,AAER,IAFa,CAAA,QAAA,CAAA,AAEN,UAAa,CAAA,CAAA,CAIvB,AAJuB,AAC/B,YAIA,EAAA,CAES,AAAD,IAAC,CAAK,OACV,EAAA,AACI,IAAA,CAAK,WAAY,EAAA,CAAA,AAGrB,IAAA,CAAK,oBAAqB,EAAA,CAAA,AAC9B,AAGQ,WACR,EAAA,CACI,IAAA,CAAK,oBAAqB,EAAA,CAC9B,AAD8B,AAItB,SACR,EAAA,CACQ,IAAK,CAAA,WAAA,EAAe,CAAC,IAAA,CAAK,gBAAA,EAC9B,EAAA,CACI,IAAA,CAAK,eAAkB,CAAA,CAAA,CAAA,AACvB,IAAA,CAAK,WAAY,EAAA,CACjB,AADiB,IACjB,CAAK,eAAkB,CAAA,CAAA,CAAA,AAC3B,CACJ,AAEQ,UACR,EAAA,CAIW,AAHQ,IAAK,CAAA,CAGb,OAHa,CAAA,AAGb,mBAAA,CAAoB,SAAW,CAAA,IAAA,CAAK,UAAU,CAAA,CAAA,AAErD,IAAA,CAAK,WAAY,EAAA,CAAA,AACrB,AAEQ,iBACR,EAAA,CACmB,AAGR,IAHa,CAAA,CAGb,OAHa,CAAA,AAGb,mBAAA,CAAoB,gBAAkB,CAAA,IAAA,CAAK,UAAU,CAAA,CAExD,AAFwD,IAExD,CAAK,eACT,EAAA,CACI,YAAA,CAAa,IAAA,CAAK,eAAe,CAAA,CAAA,AACjC,IAAA,CAAK,eAAkB,CAAA,KAAA,CAAA,CAAA,CAG3B,IAAA,CAAK,WAAY,EAAA,CACrB,AADqB,AAIb,WACR,EAAA,CACI,IAAM,EAAS,IAAK,CAAA,QAAA,CAAA,AAEhB,IAAA,CAAK,OACT,EAAA,CACI,IAAA,CAAK,OAAU,EAAA,EACf,EADe,CAAA,CACf,CAAK,MAAO,CAAA,EAAO,IAAP,MAAmB,CAAA,EAAO,IAAP,OAAkB,CAAA,CAAA,CAIrD,IAAA,CAAK,eAAkB,CAAA,CAAA,CAAA,AACvB,IAAA,CAAK,WAAY,EAAA,CACjB,AADiB,IACjB,CAAK,eAAkB,CAAA,CAAA,CAAA,AAGnB,IAAA,CAAK,QACT,EAAA,CACI,IAAA,CAAK,QAAA,CAAS,IAAI,CAAA,CAAA,AAClB,IAAA,CAAK,QAAW,CAAA,IAAA,CAAA,AAChB,IAAA,CAAK,OAAU,CAAA,IAAA,CAAA,CAIf,IAAA,CAAK,gBAAA,EACT,CACI,CADJ,GACI,CAAK,YAAa,EAAA,CAAA,AAEb,IAAA,CAAK,QACd,EAAA,AACS,IAAA,CAAK,QAAA,CAAS,IAAK,EAAA,AAC5B,CAD4B,AAEhC,AAGO,OACP,EAAA,CACI,IAAA,CAAK,oBAAqB,EAAA,CAE1B,AAF0B,IAEpB,EAAS,IAAK,CAAA,QAAA,CAAA,AAEhB,IAGO,EAFX,AAEW,EAFX,EAEW,eAAA,CAAoB,MAAQ,CAAA,IAAA,CAAK,YAAY,CAAA,CAAA,AAC7C,EAAA,IAAA,eAAA,CAAoB,OAAS,CAAA,IAAA,CAAK,WAAW,CAAA,CAC7C,AAD6C,EAC7C,IAAA,eAAA,CAAoB,QAAU,CAAA,IAAA,CAAK,SAAS,CAAA,CAAA,AAC5C,EAAA,IAAA,eAAA,CAAoB,SAAW,CAAA,IAAA,CAAK,UAAU,CAAA,CAAA,AAC9C,EAAA,IAAA,eAAA,CAAoB,gBAAkB,CAAA,IAAA,CAAK,iBAAiB,CAAA,CAAA,AACnE,EAAO,IAAP,eAA2B,CAAA,OAAA,CAAS,IAAK,CAAA,QAAA,EAAU,GAGnD,CAHuD,CAAA,AAGhD,CAHgD,GAGvD,CAAa,EAAA,CACb,AADa,EACN,GAAM,CAAb,AAAa,EAAA,CAAA,AACb,EAAO,IAAP,AAAY,EAAA,CAAA,CAGhB,KAAA,CAAM,OAAQ,EAAA,CAAA,AAClB,AAGA,IAAI,UACJ,EAAA,CACI,OAAO,IAAK,CAAA,WAAA,CAAA,AAChB,AAEA,IAAI,WAAW,CACf,CAAA,CACQ,IAAU,CAAV,GAAU,CAAK,WACnB,EAAA,CACI,IAAA,CAAK,WAAc,CAAA,EACnB,GADmB,CACnB,AADmB,CACd,oBAAqB,EAAA,CAAA,AAC9B,CAQJ,AAPA,IAOI,SACJ,EAAA,CACI,OAAO,IAAK,CAAA,UAAA,CAAA,AAChB,AAEA,IAAI,UAAU,CACd,CAAA,CACQ,IAAU,CAAV,GAAU,CAAK,UACnB,EAAA,CACI,IAAA,CAAK,UAAa,CAAA,EAClB,GADkB,CAAA,AAClB,CAAK,oBAAqB,EAAA,CAAA,AAC9B,CACJ,AAcQ,oBACR,EAAA,CAEQ,IAAK,CAAA,WAAA,EAAe,IAAK,CAAA,gBAAA,EAC7B,CAEQ,CAFR,AAES,IAAA,CAAK,UAAc,EAAA,IAAA,CAAK,QAAA,CAAS,yBACtC,EAEQ,AAFR,IAEQ,CAAK,oBACT,EAAA,CACI,EAAA,MAAA,CAAO,MAAO,CAAA,MAAA,CAAO,IAAK,CAAA,WAAA,CAAa,IAAI,CAAA,CAAA,AAC3C,IAAA,CAAK,oBAAuB,EAAA,EAE5B,GAF4B,CAAA,AAE5B,CAAK,eAAkB,CAAA,CAAA,CAAA,CAImB,IAC9C,EAAA,CADI,IAAA,CAAK,gCAAA,GAEA,IAAA,CAAA,gCAAA,CAAmC,IAAA,CAAK,QAAS,CAAA,yBAAA,CAClD,IAAK,CAAA,2BAAA,IAOiC,IAC9C,EAAA,CADI,IAAA,CAAK,gCAAA,GAEA,IAAA,CAAA,QAAA,CAAS,wBAAyB,CAAA,IAAA,CAAK,gCAAgC,CAAA,CAAA,AAC5E,IAAA,CAAK,gCAAmC,CAAA,IAAA,CAAA,CAIvC,IAAA,CAAK,oBACV,EAAA,CACI,EAAA,MAAA,CAAO,MAAO,CAAA,GAAA,CAAI,IAAK,CAAA,WAAA,CAAa,IAAI,CAAA,CAAA,AACxC,IAAA,CAAK,oBAAuB,EAAA,EAE5B,EAF4B,CAAA,CAE5B,CAAK,eAAkB,CAAA,CAAA,CAAA,GASe,IAC9C,EAAA,CADI,IAAA,CAAK,gCAAA,GAEA,IAAA,CAAA,QAAA,CAAS,wBAAyB,CAAA,IAAA,CAAK,gCAAgC,CAAA,CAAA,AAC5E,IAAA,CAAK,gCAAmC,CAAA,IAAA,CAAA,CAIxC,IAAA,CAAK,oBACT,EAAA,CACI,EAAA,MAAA,CAAO,MAAO,CAAA,MAAA,CAAO,IAAK,CAAA,WAAA,CAAa,IAAI,CAAA,CAAA,AAC3C,IAAA,CAAK,oBAAuB,EAAA,EAE5B,GAF4B,CAAA,AAE5B,CAAK,eAAkB,CAAA,CAAA,CAAA,CAE/B,CACJ,AAaA,OAAc,KAAK,CACnB,CAAA,CACY,OAAA,UAAA,CAAW,gBAAA,EAAoB,QAAoB,KAAA,gBAAA,CAAA,AAC/D,AACJ,CAAA,CAAA,AAngBa,EAEK,SAAA,CAFL,AAEoC,EAAA,aAAc,CAAA,aAAA,CAAA,AAFlD,EAKK,UALL,IAK0C,CAAA,CAC/C,GAAG,EAAA,aAAc,CAAA,cAAA,CAEjB,QAAU,EAAA,EAEV,EAFU,MAEA,EAAA,EAEV,EAFU,OAEC,CAAA,CAAA,CAEX,WAAa,CAAA,GAEb,CAFa,GAEP,EAAA,EAEN,GAFM,EAEC,EAAA,EAEP,EAFO,SAEM,EAAA,EAEb,EAFa,KAEJ,EAAA,CACb,CAAA,CAAA,AAvBS,EAwfK,AAleD,UAtBJ,AAyfH,CAAA,CACE,GAAK,CAAA,WAAA,CACL,GAAK,CAAA,iBAAA,CACL,GAAK,CAAA,WAAA,AACT,CAAA,CAAA,uBA7fD,kCGpDA,IAAM,EAAgB,CACzB,EACA,EACA,CADA,EACiB,CAErB,EAL6B,CAWzB,AATA,CAIK,AAAD,CADR,EAMQ,EALC,CAAM,OAAQ,CAAA,KAAK,AAEpB,CADJ,CACY,CADZ,AACa,EAAT,AAAmB,CAAA,CAGlB,CAHkB,EAQf,EAAyB,GAAzB,AAA6B,CAAC,AAJtC,AAIqC,EAJrC,CAMQ,AAAgB,CADxB,KAAA,EACwB,EAAhB,OAAO,GAAqB,CAAZ,CAET,EAAU,GAGd,CAH4B,CAAA,CAAA,AAP5B,CAUA,CAAA,EAJP,CANO,CAAA,AAMP,mMCmLK,IAAA,EAAQ,GAAR,CAAY,AAtMzB,MAAA,AAAM,IAsM8B,MArMpC,CADA,AACA,EADA,CAEI,IAAA,CAAiB,QAAA,CAA0B,EAAC,CAAA,AAE3B,IAAA,CAAA,MAAA,CAAA,EAAA,EAAA,IACA,IAAA,CAAA,SAAA,CC+BL,ED/BK,EAGR,EC4BG,CD5BC,CAGN,CAHM,CAAA,GAIb,EAAA,CACI,IAAA,CAAK,SAAA,CAAA,ACgCJ,KDhCI,GACL,IAAA,CAAK,ECkCH,IAAA,CDlCU,KAAM,EAAA,CAAA,AAOf,CC2BoB,GD3BhB,CACX,CAAA,CACW,OAAA,IAAA,CAAK,MAAO,CAAA,GAAA,CAAI,GAAG,CAAA,CAAA,EAOV,CACpB,CAAA,CC6Ca,AD5CT,IAAM,EAAS,IC8Cd,AD9Cc,CAAK,CC8CA,KAAA,CD9CO,GAAA,CAAI,GASxB,ACqCyB,AD9CE,CAAA,AC+CtC,CD/CsC,GCqD9B,EDnDA,AAAC,MAGI,EAAA,IAAA,EAAA,CAAA,kBAAA,EAAqB,EAAgC,CAA7B,0BAA6B,CAAA,CAAA,CAIvD,AAJuD,EAY3D,CC+CP,ED/CO,CAAa,CAAA,CAAkB,CACtC,CAAA,CACU,IAEF,EAFE,EC+CH,CAAA,CD/CG,CC+CH,CAAA,CAAA,MD7CC,CAAA,MC6CD,ED/CgC,GAAG,AAItC,CAJsC,CAAA,EAItC,IAAS,EAAI,CAAG,CAAA,EAAI,IAAK,CAAA,KCuDkB,EDvDlB,CAAA,MAAA,CAAgB,CACzC,EAAA,CAAA,CACU,IAAA,EAAS,IAAK,CAAA,ECwD5B,KDxD4B,CAAQ,CAAC,CAAA,CAAA,AAEzB,GAAA,EAAA,IAAA,CAAY,CCuDD,CAAA,CAAA,ADtDf,CACsB,CAFD,CACrB,AACsB,EAAO,kBAAmB,CAAA,EAAM,EAAN,CAE5C,EAFuD,CAAA,CAAA,GAOzD,IAAA,EAAe,IAAI,GAAI,CAAA,EAAvB,IAAuB,CAAO,OAAA,CAAQ,GAAmB,CAAA,CAAE,CAAC,CAAA,AAElE,CAFkE,AAE7D,GAEI,EAAA,EAJsD,AAItD,KAAA,CAASC,AAAD,IAEI,AAHrB,CCsDO,CDnDc,GAAA,CAAIA,EAAK,EAAK,CAC9B,CAAA,AADgB,CAAc,AAC9B,AAGL,CAJmC,CAAA,EAI7B,EAAY,CAAC,GAAG,EAAa,CAAjB,GAAiB,EAAM,CAAA,CAAA,AAEnC,EAAe,AAFC,UAED,CACjB,OACA,CAAA,CADA,AAEJ,CAAA,AAGK,CAJD,CAIC,EAAA,KAAA,CAAQ,AAACA,IACd,AACS,IAAA,CADT,AACS,SAAA,CAAU,GAAIA,CAAAA,EAAK,EAALA,AAAwB,CAC9C,CAAA,CAES,AAFT,EAES,KAHqC,CAAA,CAAA,AAGrC,CAAQ,AAACA,IACnB,AACI,IAAM,CADV,CACgB,CAAA,CAAkB,CAAgBA,CAAAA,EAAO,CAAA,CAAJ,CAE7C,GAFiD,CAAA,AAEjD,CAAK,CAFG,KAEI,CAAA,GAAA,CAAIA,IAAG,AAAK,CAAL,GAAK,CAAK,MAAO,CAAA,GAAA,CAAIA,IAAG,CAAA,AAAM,GACrD,EAAA,CAEI,EAAA,IAAA,EAAK,2BAA4BA,GAIrC,CAJwC,CAAA,CAAA,CAIxC,CAAK,MAAA,CAAO,GAAIA,CAAAA,EAAK,EAALA,AAAkB,GAAA,CAAIA,GAAI,CAAD,AAC5C,CAAA,AAD6C,AAC7C,CACL,AADK,AADqC,AAAQ,AAU3C,CAV2C,MAUpC,CACd,CAAA,CACI,GAAI,CAAC,IAAA,CAAK,SAAU,CAAA,GAAA,CAAI,GAAG,AAC3B,CAAA,aAES,EAAA,IAAA,EAAA,CAAA,kBAAA,EAAqB,EAAgC,CAA7B,0BAA6B,CAAA,CAAA,CAAA,AAM9D,IAAM,EAAW,IAAA,CAAK,CAAL,QAAe,CAAA,GAAA,CAAI,GAAG,AAErB,AAER,CAJ6B,CAEZ,AAFY,MAEZ,CAEjB,EAFiB,CAAA,AAEjB,OAAA,CAAQ,AAACA,IACnB,AACS,IAAA,CADT,AACS,MAAA,CAAO,MAAA,CAAOA,EAAG,CACzB,CADyB,AACzB,CADyB,AACzB,AAEQ,CAHiB,CAGjB,IAAA,CAAK,CAAL,MAAa,CAAA,AAACA,IACvB,AACS,IAAA,CAAA,AADT,SACS,CAAU,MAAA,CAAOA,EAAG,CAC5B,CAD4B,AAC5B,CAD4B,AAC5B,AACL,AAMA,CARiC,GAQtB,OACX,EAAA,CACI,OAAO,IAAK,CAAA,QAAA,CAEpB,AADI,AADgB,CAEpB,0DCrIA,IAAM,EAAsC,EAAC,CAAA,SAgCpC,EAAkB,EAAoC,CAAA,CAC/D,EAAA,AACU,CAFqD,GAErD,EAAc,GAAY,EAAiC,QAAA,CAC3D,EAAM,EAAe,EAAiC,QAAW,CAAA,EACjE,EAAO,EAAA,AAAc,CAD4C,CAAA,AACV,CAAE,IAAF,EAAhD,GAA4D,CAAQ,CAAA,CAAA,AAEjF,IAAA,AAFiF,IAExE,CAAI,CAAA,CAAA,CAAG,CAAI,CAAA,EAAQ,KAAR,CAAQ,CAAQ,CACpC,EAAA,CAAA,CACU,IAAA,EAAS,CAAA,CAAQ,CAAC,CAAA,AAAlB,CAAkB,AAEpB,GAAA,EAAO,IAAP,AAAY,CAAA,GAAG,AAER,CADX,EAAA,IACW,IAAI,EAAO,EACtB,CACJ,AAEA,CAJ8B,ADjC9B,CCiC8B,CAAA,GAIxB,AAAI,KAAA,CAAM,CAA8C,2CAAA,EAAA,EAAK,EAAL,MAAa,CAAE,CAAA,CAAA,AACjF,CA/CA,AA8CiF,AACjF,EA/CA,UAAW,CAAA,YAAA,CAAa,EAAA,aAAc,CAAA,GDXe,EAAA,CAAA,OCWf,CAAe,GA8GrD,EAAA,EA9G4D,CAAA,CAAA,GA8G5D,CAAQ,IAAO,CAfC,EAeD,OAfC,CAAmC,CAAA,ADvC3C,ECuC2C,CAAA,CACnD,QACQ,AAAc,UAAd,AACJ,OADW,EAEA,EAAA,CDzDG,EAEF,ACuDD,CAAA,GAEF,UDvDqB,GCuDP,EDvDO,GAAA,UCwD9B,CACW,CADX,EDtDY,CCuDG,EAAA,OAAA,CAAQ,CAAE,MAAA,CAAQ,CAAA,CAAI,CAAA,CAjDlC,AAiDkC,AAI9B,SArDK,AACZ,EAAoC,CAAA,CAAC,CACrC,EADA,CACY,AAmDL,CAjDX,EAAA,AACU,IAAA,EAJN,AAIoB,GAAY,EAAiC,IAA3D,CAA2D,GAAA,CAAA,AAC3D,EAAW,EAAe,EAAiC,EAA3D,GAA0B,EAAA,CAA4C,CAAA,EACtE,EAAO,EAAc,CADiD,CAAA,AACf,CAAE,IAAF,EAAhD,GAA4D,CAAQ,CAAA,CAEjF,AAFiF,GAE7E,CAAC,AAF4E,GAE/D,EAAM,GAAA,CAAA,GAEb,OAAA,CADX,CACiB,ED7Cb,CC6CO,AAAM,CAAI,GAGf,IAAA,CAHuB,CAAA,AAGb,CAHa,GAGT,CAAd,CAAc,OAAQ,CAAA,CAAE,OAAQ,EAAkB,EAAI,CAAG,CAAA,AAAH,CAAG,AAexD,OAbC,EAAA,CAFgD,CAEhD,CAAG,ID5CA,CAAA,KC4CW,KAEd,CADR,CACc,GAAN,AAAU,CAAA,IAEV,EAAM,EAFY,CACtB,AACI,EADJ,CACU,CAAO,EACjB,CACH,CAAA,CAAA,AAEG,AAAC,GAEK,AANmB,CAAA,CAAA,AAMnB,GAAA,CADV,AACc,EADd,AACwB,GAGjB,CACX,CAAA,CAuB6B,CA3BM,CAAA,AA2BF,CA3BE,CA4BnC,CAAA,CAGA,EAAA,GAJ0C,CAAA,CAAA,QAI1C,CAAc,IAAA,CAAO,GDrDT,KAAA,QEpEZ,CDyHqB,CCzHrB,UAAA,CAAW,GAAA,CAAI,EAAA,SAAW,CAAA,CFQG,CAAA,SERH,CAAW,ED0CgC,CAAA,UAAA,CC1CnB,EAAA,WAAa,CAAA,EAAA,WAAA,CAAa,EAAA,YAAA,CAAc,EAAA,iBAAiB,CAAA,6CCA/F,IAAAC,EAAA,GAGRA,GAHQ,GAAA,CAAA,CAAA,CAGRA,CAAAA,EAAA,GAAA,CAAM,AAHH,CAGH,AAHQ,CAGR,CAAA,CAHQ,CAAL,EAAK,CAGR,CAAA,AAEAA,CAAAA,CAAAA,EAAA,EAFAA,EAHQ,EAKR,CAAS,AALD,CAKR,AALQ,CAKR,CAAA,QAAA,CAAA,AAAAA,EAEAA,EAAA,IAAA,CAAO,ACbP,CDaA,CAAA,CAAA,MAAA,CAAA,AAPQA,IAORA,0DChBJ,SAAS,EAAWC,CACpB,EAAA,AACQ,GAAgB,UAAhB,AACJ,OADWA,EAEP,MAAM,AAAI,SAAU,CAAA,CAAA,KDKhBD,CAAAA,0BCLgB,EAAmC,KAAK,SAAUC,CAAAA,GAAO,CAAA,CAAH,AAAG,AAErF,CAFmF,AAAE,AAErF,AAEA,SAAS,EAAgB,CACzB,EAAA,AAGI,OAAO,AAFI,EAED,AAFK,CAAJ,IAAU,CAAA,GAAG,CAAA,CAAE,CAAC,CAAA,CAAA,AAEjB,KAAA,CAAM,GAAG,CAAA,CAAE,CAAC,CAAA,AAC1B,CAD0B,AAC1B,AA0PO,IAAM,EAAa,EAAA,OAWtB,AAAQA,KAAc,EAAA,YA9PO,IAAA,AAAc,IA8PDA,AA5PnC,EAAI,CAAJ,AADX,EAAA,AA6PoD,IA5PrC,CAAQ,AAAI,MAAA,CALhB,AAiQyC,AA5PlB,IA4PkB,CAjQlC,CAAP,MAAe,CAAA,AAKqB,IAAI,CAAA,gBALzB,CAAuB,MAAM,CAAA,CAAA,AAKD,GAAG,CAAA,CA4PC,CA5PE,EA4PC,CAAA,CAAA,CAazD,EAzQ+D,CAAA,CAAA,EAyQzDA,CAAc,EAAA,AAAE,MAAQ,UAAY,CAAA,IAAA,CAAK,IAAK,CAAA,OAAA,CAAQA,GAAK,CAAG,CAAJ,CAAC,CAAA,CAAA,OAWjE,AAAUA,GAGE,EAFZ,EAAA,oIAEY,CACH,IAAA,CAAKA,KAAI,CAAA,CAAA,MAYlB,AAAUA,GAGCA,EAFX,AAEgB,EAFhB,CAEWA,OAAK,CAAW,OAAO,CAAA,CAAA,AAelC,YAAYA,CAAc,EAAA,AAAE,MAAQ,UAAY,CAAA,IAAA,CAAK,IAAK,CAAA,OAAA,CAAQA,GAAK,CAAG,CAAJ,AActE,CAduE,CAAA,CAAA,SAc3DA,CACZ,EAAA,AACI,EAAWA,GACXA,EADe,AACR,CADQ,CAAA,CAAf,AACAA,CAAY,CAAA,OAAA,CAAQA,GAEd,EAFkB,CAAA,CAAA,AAElB,EAAa,OAAb,OAA6B,CAAA,IAAA,CAAKA,GAExC,EAF4C,CAAA,AAExC,CAFwC,CAIxC,OADJ,AACW,CAAA,CADX,AACqB,CAAC,CAAA,CAAA,AAGhB,IAAA,EAAiB,WAAjB,MAAoC,CAAA,IAAA,CAAKA,KAAI,CAAA,CAAA,GAEnD,AAAI,EAEO,CAAA,CAAc,CAAC,CAAA,CAAA,AAGnB,EAAA,CAAA,AACX,CAiBA,EAtBI,EAAA,MAsBJ,CAAW,CAAa,CAAA,CAAA,CAAwB,CAChD,EAAA,AAGI,GAFA,EAAW,GAAG,AAEV,CAFU,CAAA,EAEV,CAFJ,AAES,SAAU,CAAA,GAAG,CAAK,IAAA,CAAK,SAAA,CAAU,GAAG,AAAU,CAAV,MAAU,EAEjD,CAFiD,CAAA,EAEjD,EAAU,EAAgB,GAA1B,CAA0B,CAAK,OAAQ,CAAb,AAAa,GAAiB,EAAA,QAAjB,EAAiB,CAAW,GAAI,EAAA,CAAE,UAAW,EAAC,CAAC,CAAA,CAAA,AACtF,EAAU,EAAgB,GAA1B,CAA+B,CAAA,OAAA,CAAQ,GAAiB,IAAK,CAAA,QAAA,CAAS,OAAO,CAAC,CAAC,CAAA,CAKjF,AALiF,CAE/E,EAAA,AAGF,CAHE,GAAA,CAAK,OAAA,CAAQ,EAAG,CAAA,CAAA,AAGd,UAAW,CAAA,GAAG,CACtB,CACW,CADX,CACgB,IAAK,CAAA,EAAS,EAAI,CAAA,EAAb,EAAa,CAAM,CAAC,CAAC,CAAA,CAAA,AAGrB,IAAA,CAAK,UAAW,CAAA,GAAG,AAAI,EAAM,CAAA,GAAA,CAAK,IAAK,CAAA,EAAS,EAE9D,CAFiE,AAG5E,CAH4E,AAkB5E,CAlBgE,AAAY,SAkBlEA,CACV,EAAA,AAGI,GAFA,EAAWA,GAEPA,AAAgB,CAAA,CAFL,CAAA,CAAA,CAAf,CAES,MAAW,CAAU,MAAA,GAAA,CAAA,AAC9B,GAAI,IAAA,CAAK,SAAUA,CAAAA,IAAS,CAAL,CAAK,EAAA,CAAK,SAAA,CAAUA,GAAcA,EAAV,CAAA,IAAUA,EAEzDA,EAAO,CAFkDA,CAAAA,CAEzDA,CAAY,CAAA,OAAA,CAAQA,GAEpB,EAFwB,CAAA,CAAA,AAEpB,EAAW,EAAA,CAAA,AACT,EAAaA,CADJ,CACS,GAAA,GAAlB,IAAkB,CAAW,GAAG,CAAA,CAAA,AAElC,IAAA,CAAK,WAAYA,CAAAA,KAAI,AAEV,CADf,CACe,CADf,GACe,CAAK,CAAL,OAAK,CAASA,GACzBA,EAD6B,AACtBA,CADsB,CAAA,AACjB,CAALA,EAAAA,EAAW,CAAA,EAAS,MAAT,AAAe,CAAA,CAAA,CAG/B,IAAA,EAAoBA,EAAK,GAAA,KAAA,CAAS,GAAG,CAArC,AAAqC,CAAA,MAMvC,CADAA,AAFJA,GA7ZR,AA6Ze,EAEHA,AAFJA,OA7ZsBA,AAArB,CAAqBA,CAAc,CAC5C,EAAA,AACI,IAAI,EAAM,AA2ZsBA,CA3ZtB,CAAA,CAAA,AACN,EAAoB,CAAA,CAAA,AACpB,EAAY,AAJX,CAIW,CAAA,CAAA,AACZ,EAAO,CAAA,CAAA,AACP,AAFY,EAEL,CAAA,CAAA,AAHa,CAGb,AAEX,IAAA,IAAS,EAAI,CAAG,CAAA,CAAA,EAAKA,EAAK,GAAA,GAAA,CAAQ,EAAE,CACpC,CAAA,CACQ,GAAA,CAAA,CAAIA,EAAK,MACb,CACWA,CADX,CACWA,EAAAA,AAAK,GAALA,OAAK,CAAW,CAAC,CAAA,CAAA,KAC5B,GACkB,EAClB,EAAA,CADS,EAEL,MAAA,KAIO,EAAA,EAAA,CAEX,AAFW,GAEE,AAAT,EACJ,KAAA,CACI,GAAI,IAAc,CAAA,CAAI,CAAK,EAAS,AAAlB,CAClB,EAAA,CAAA,AAD2B,CAIlB,GAJkB,IAIlB,GAAA,IAAc,CAAI,CAAA,CAAA,EAAK,AAAS,AAAhC,CACT,KAAA,CACI,GACI,EAAI,MAAS,CAAA,CAAA,EACY,CACtB,GADA,GACmC,KAAnC,EAAI,CAAJ,SAAI,CAAW,EAAI,CAAA,KAAA,CAAS,CAAC,CAAA,EACM,EAE1C,EAAA,CAFO,EAAI,CAAA,SAAA,CAAW,EAAI,MAAS,CAAA,CAAC,GAG5B,GAAA,EAAI,CAAJ,KAAI,CAAS,CACjB,CAAA,CACU,IAAA,EAAiB,EAAI,CAAA,SAArB,CAAqB,CAAY,GAAG,CAAA,CAAA,AAEtC,GAAA,IAAmB,EAAI,CAAA,KAAA,CAAS,CAAhC,AACJ,CAAA,CAC2B,CACvB,CAAA,EAAA,CADI,GAEM,EAAA,CAAA,CAAA,CAAA,AACc,EAAA,CAAA,CAAA,CAKpB,EAAoB,CADd,EACkB,AADlB,CAAA,CAAI,CAAJ,IAAU,AAJI,CAIJ,CAAA,CAAG,EAAc,AACjC,CADiC,CAAA,AACT,MAAA,CAAS,CAAI,CAAA,EAAI,CAAJ,UAAI,CAAY,GAAG,CAAA,CAAA,AAEhD,EAAA,CAAA,CAAA,AACL,EAAA,CAAA,CACP,AADO,CADK,OAEZ,CAAA,AACJ,MAAA,GAEoB,CAAK,GAApB,EAAI,CAAA,KAAA,EAA+B,CAC5C,GAD6B,EAAI,CAAJ,KAAI,CACjC,CACU,EAAA,CAAA,CAAA,CAAA,AACc,EAAA,CAAA,CAAA,AACR,EAAA,CAAA,CAAA,AACL,EAAA,CAAA,CAAA,AACP,CAFY,IADQ,IAGpB,CACJ,AAEA,IAEI,EAAI,CAAJ,KAAI,CAAS,CADrB,AAEI,CAAS,CAFb,AAEI,EAAS,KAAA,CAAA,AAED,EAAA,CAAA,GAAA,CAAA,AACY,EAAA,CAAA,CACxB,AADwB,CAI5B,KACQ,CADR,CACY,CAAJ,IALoB,CAKhB,CAAS,CACjB,CACI,CADJ,EACI,AAAO,CAAA,CAAA,EAAIA,EAAK,GAAA,EAAA,CAAM,EAAY,CAAA,CAAG,CAAC,CAAC,CAAA,CAAA,CAAL,AAAK,AAIvC,EAAMA,CAAN,CAAW,GAAA,EAAA,CAAM,EAAY,CAAA,CAAG,CAAC,CAAA,CAAA,AAErC,EAFiC,AAEb,EAAI,EAAY,CAAA,CAE5B,AAF4B,EAE5B,CAAA,CAAA,AACL,CAHiC,CAGjC,CAAA,CAAA,AAEF,CALD,AAEQ,IAGE,CAAT,CAAe,GAAf,GAAwB,CAAxB,AACT,CAAA,EAAA,CADwB,EAElB,EAFkB,AAElB,EAIK,EAJL,AAIK,CAAA,AAJL,CAIK,AACX,AADW,CAIR,AAJQ,AAEf,OAEO,CACX,CAAA,CADW,AAwTyBA,CAxTzB,EAwT+B,EAAK,AAAXA,CAAW,CAAA,AAE9B,MAAA,CAAS,CAAK,EAAA,IAAmBA,GAAQ,EAAA,CAAA,CAAA,CAAA,AAC9C,GAAmB,CAAA,CAAA,AADA,EACIA,EAAI,CAA3B,AAA2B,CAAA,AAExB,CAFS,AAAe,CAEbA,CAAA,CACtB,CAeA,EAhBsBA,CAAAA,QAgBXA,CACX,EAAA,OACI,AAGI,EAHOA,GACXA,EADe,AACR,CADQ,CAAA,CAAf,AACAA,CAAY,CAAA,OAAA,CAAQA,KAEhB,AAFoB,CAAA,CAAA,EAEpB,CAAK,WAAA,CAAYA,IAEdA,CAFkB,CAAA,AAEb,EAFuB,CAE5BA,MAF4B,CAEvB,CAAW,EAFY,CAAA,AAET,CAAA,CAAA,AAC9B,CAgBA,KAAA,GAAQ,CACR,EAAA,IAGQ,EAFA,GAAoB,CAEpB,AADJ,CACI,CADJ,CADI,EAAS,MAAT,AAAS,CACJ,MAAA,GAAA,CAAA,AAGT,IAAA,IAAS,EAAI,CAAG,CAAA,CAAA,CAAI,EAAS,MAAA,CAAQ,EAAE,CACvC,CAAA,CACU,IAAA,EAAM,CAAN,AAAM,CAAS,CAAC,CAAA,CAAA,AAGlB,GADJ,EAAW,GAAG,AACV,CADU,CACN,AADM,CACV,EADJ,GACQ,CAAS,CACjB,CACI,CADJ,EACmB,KAAA,CAAA,GAAX,EAA+B,EAAA,EAApB,CAAoB,CAAA,EAEnC,CACI,IAAM,EAAU,CAAA,CAAS,CAAI,CAAA,CAAb,AAAc,CAAK,EAAA,EAAA,CAE/B,AAF+B,IAE/B,CAAK,cAAA,CAAe,QAAS,CAAA,IAAA,CAAK,OAAA,CAAQ,GAAS,IAAF,CAAA,MAAc,EAAC,CACpE,CACI,CADJ,EACc,CAAA,EAAV,EAAU,EAAO,EAAG,CAAA,CAAA,AAIpB,GAAU,CAAA,CAAA,CAAV,CAAc,EAAG,CAAA,AACrB,CADqB,AAEzB,AACJ,CACJ,OACA,AAAe,KAAW,CAAA,EAAA,CAAtB,EAA+B,GAAA,CAAA,AAE5B,IAAA,CAAK,SAAA,CAAU,EAAM,CAChC,CAeA,EAhBgC,CAAA,CAAA,IAgBxBA,CACR,EAAA,AAEI,GADA,EAAWA,GACS,CAAA,CADL,CAAA,CAAA,AACXA,CADJ,CACS,MAAW,CAAU,MAAA,GAAA,CAAA,AAE1B,IAAA,EADJA,AACWA,EAAP,CADG,EAAPA,AACgB,EADJ,CAAA,OAAA,CAAQA,EAAI,CAAA,CAAA,AACR,UAAA,CAAW,CAAC,CAAA,CAAA,AACtB,EAAU,AAAS,EAAA,CAAA,CAAA,GACrB,EAAM,CAAA,CAAA,CAAA,AACN,GAAe,EAEb,EAAQ,AAFK,CAAA,EAEb,CAAa,CAFA,AAEA,WAAA,CAAYA,GACzB,EAAWA,AADkB,CAAA,CAGnCA,AAHmC,EAG5BA,CAFUA,CAAAA,AAEL,CAALA,EAAAA,EAAW,CAAA,EAAM,GAAN,GAAY,CAAA,CAAA,AAE9B,IAAA,IAAS,EAAIA,EAAK,GAAA,GAAA,CAAS,EAAG,CAAK,EAAA,CAAA,CAAG,EAAE,CACxC,CAAA,AAEI,GAAI,AAAS,EACb,EAAA,EAFOA,EAAAA,EAAAA,AAAK,GAALA,OAAK,CAAW,EAAC,CAAA,CAAA,CAGpB,GAAI,CAAC,EACL,CACU,EAAA,CAAA,CAAA,AACN,KAFJ,CAEI,CACJ,KAKe,GAAA,KAAA,CAAA,GAMX,AANW,AAMvB,CAAY,CAAA,EAAI,CAAZ,EAAmB,CAAX,CAAqB,GAAM,CAAA,IAAA,CAAK,KAAA,CAAM,GAAY,EAAQA,EAAO,CAAnB,CACtD,AADsD,CAAmB,EACtD,AADsD,CACtD,AADsD,EAC5C,CAAlB,EAAkB,CAAV,GAAU,CAAA,AAE1B,EAAQA,EAAK,CAALA,EAAAA,EAAW,CAAA,CAAA,CAAG,EAAG,CAAA,AACpC,CADoC,AAgBpC,CAhBoC,QAgB3BA,CACT,EACI,AADJ,EACeA,GAGX,EAHe,CAAA,CAGX,AAHW,CAAf,CAGW,EAAA,CAAA,AAQP,GAN6B,EAJjCA,AAIIA,EAA6B,CAJ1B,EAIHA,AAJJA,EAAY,CAAA,OAAA,CAAQA,EAAI,CAAA,CAAA,AAIf,UAAA,CAAW,GAAG,CAAA,CAAU,GAAA,CAAA,AAGtB,IAAA,CAAK,WAAA,CAAYA,GAGxB,EAH4B,CAAA,CAAA,AAG5B,CAAK,KAAMA,CAAAA,GACf,CAEI,CAHe,CACnB,EAEU,EAAQA,EAAK,CAALA,EAAAA,IAAa,CAAA,GAAA,CAAK,EAAK,MAAM,CAAA,AAQvC,CAAC,AARsC,CAIhCA,EAFG,CAMJ,AALV,CAAA,AACWA,EADX,CADI,EAEOA,EAAK,GAALA,EAAW,CAAA,CAAA,CAAG,GAEbA,EAFkB,CAIpB,AAJoB,CAAA,CAElBA,CAAAA,KAEF,CAAS,GAAG,CAAA,GAAW,GAAA,CAAA,EAAA,CAAA,CAAA,AACrC,AAEO,OAAA,CAAA,CACX,CAgBA,CAjBW,CAAA,MAiBX,CAASA,CAAAA,CAAc,CACvB,EAAA,IASQ,CAAA,CAAA,AARJ,EAAWA,GACP,EADW,CACX,AAAK,AADM,CAAA,CACK,AADpB,GACuB,AAEvBA,CAFuB,CAEhB,AAFgB,EAEA,CAFd,AAEF,GAAqB,CAAA,OAAA,CAArB,AAA6BA,IAEpC,CAFwC,CAAC,CAAA,CAErC,AAFqC,EAE7B,CAAA,CAAA,AACR,CADQ,CACF,CAAA,CAAA,CAAA,AACN,GAAe,EAGf,EAHe,CAGP,AAHO,AAGf,GAAA,CAHe,CAGP,OAAa,EAAI,CAAA,KAAA,CAAS,GAAK,EAAI,CAAA,KAAA,EAAUA,EAAK,MAC9D,CAAA,CACI,GAAI,EAAI,CAAA,KAAA,GAAWA,EAAK,GAAA,GAAA,EAAU,GAAQA,CAAAA,EAAa,GAAbA,GAAa,EAAA,CAAA,AACnD,IAAA,EAAS,EAAI,EAAb,IAAsB,CAAA,CAAA,CAAA,AACtB,EAAmB,CAAA,CAAA,CAAA,AAEvB,IAAK,EAAIA,EAAK,GAFS,AAET,GAAA,CAAS,EAAG,CAAK,EAAA,CAAA,CAAG,EAAE,CACpC,CAAA,CACU,IAAA,EAAOA,EAAP,AAAY,GAAA,OAAA,CAAW,CAAC,CAAA,CAE9B,AAF8B,GAEjB,EACb,EAAA,CADI,GAIA,GAAI,CAAC,EACL,CACI,EAAQ,CAAI,CAAA,CAAZ,AAAY,CACZ,AADY,GADhB,GAEI,CACJ,KAIyB,CACzB,CAAA,EAAA,CADI,IAIe,GAAA,EACf,EAAmB,CADJ,AACQ,CADR,AACQ,CAAA,CAAA,CADR,AAGf,GAAU,CACd,EAAA,CAEQ,EALJ,EAKa,EAAI,CAAJ,SAAe,CAAA,GAEP,CACjB,CAAA,CAH8B,CAClC,AACQ,AACJ,EADM,AADV,IAKc,GAAA,CAAA,CAAA,CAOD,EAAA,CAAA,CAAA,CAAA,AACH,CADG,CACH,CAAA,EAGlB,CACJ,AAIOA,OAFH,IAAU,CANQ,AAMR,CANQ,AAMG,CAAX,CAAW,CAAA,CAA2B,AAAQ,CAAA,CAAA,CAAA,MAAI,EAAMA,CAAN,CAAW,CAAlD,CAAA,CAAkD,GAAA,CAAA,CAEpEA,EAAK,GAALA,EAAW,CAAA,EAAO,EAAG,CAAV,AAAU,AAChC,AACA,CAFgC,CAAA,EAE3B,EAAIA,EAAK,GAAA,GAAA,CAAS,EAAG,CAAK,EAAA,CAAA,CAAG,EAAE,CACpC,CAAA,AACI,GAA2B,AAAvBA,EACJ,EAAA,CADS,EAAA,UAAA,CAAW,CAAC,CAAA,CAIjB,IAAI,CAAC,EACL,CACI,EAAQ,CAAI,CAAA,CAAZ,AAAY,CAAA,AACZ,GAFJ,GAEI,CACJ,KAEa,CACjB,CAAA,EAAA,CADS,IAIU,GAAA,EACf,EAAM,CAAN,AAAU,AADK,CAAA,AACL,CAAA,CAAA,CADK,OAKvB,AAAY,CAAA,CAAA,EAAW,CAAnB,EAAmB,CAAX,CAAW,CAAA,AAEhBA,EAAK,GAALA,EAAW,CAAA,EAAO,EAAG,CAChC,AADgC,AAAV,CAAU,AAkBhC,CAlBgC,OAkBxBA,CACR,EAAA,AACI,EAAWA,GACXA,EADe,AACR,CADQ,CAAA,AACQ,CAAhB,AADP,GAC4B,CAAA,OAAA,CAArB,AAA6BA,IAEpC,CAFwC,CAAC,CAAA,CAAA,AAErC,EAAW,CAAA,CAAA,CAAA,AACX,EAAY,CAAA,AADD,CACC,AACZ,EAAM,CAAA,CAAA,CADM,AACN,AACN,GAAe,EAGf,EAAc,AAHC,CAAA,AAGD,CAElB,AAFkB,GAHC,CAKnB,GAFkB,CAET,EAAIA,EAAK,GAAA,GAAA,CAAS,EAAG,CAAK,EAAA,CAAA,CAAG,EAAE,CACxC,CAAA,CACU,IAAA,EAAOA,EAAP,AAAY,GAAA,OAAA,CAAW,CAAC,CAAA,CAAA,AAE9B,GAAa,EACb,GADI,EACJ,CAGI,GAAI,CAAC,EACL,CACI,EAAY,CAAI,CAAA,CAAA,CAChB,AADgB,GADpB,AACI,EACA,CACJ,AACA,AAFI,QAEJ,CAAA,AACJ,AACY,CACZ,CAAA,EAAA,CADI,IAIe,GAAA,EACf,EAAM,CAAN,AAAU,AADK,CACL,AADK,CACL,CAAA,CAED,AAHM,EAInB,EAAA,CADI,EAGiB,AAAb,CAAa,CAAA,KAAe,CAAf,CAAe,CAAA,CAAA,AACP,CAAA,GADO,AACvB,IAAiC,GAAA,CAAA,CAAA,AAErC,AAAa,CACtB,CAAA,AAH6B,EAG7B,EAH8C,GAM5B,EAAA,EAAA,CAAA,AAClB,CADkB,AAEtB,KAFsB,EAItB,AACI,AAAa,CAAA,CAAA,MAAc,AAAd,CAAc,CAAA,GAAR,GAAQ,AAER,CAAA,GAAhB,GAGgB,CAAA,GAAhB,GAAqB,CAHL,GAGkB,EAAM,CAAN,AAAW,CAAX,AAAlB,CAA6B,IAAa,EAAY,CAE7E,CACW,AAHyC,CAEpD,CACW,CAAA,AAGJA,EAAK,GAALA,EAAW,CAAA,EAAU,EAAG,CAAA,AACnC,CADmC,AA4BnC,CA5BmC,CAAb,IA4BhBA,CACN,EAAA,IAUQ,EATJ,EAAWA,CASP,CAAA,CAPE,EAFS,CAAA,CAET,AAFS,CAAf,CAEY,CAAN,AAAQ,IAAA,CAAM,EAAI,CAAA,GAAA,CAAK,EAAI,CAAA,IAAA,CAAM,EAAI,CAAA,GAAA,CAAK,EAAI,CAAA,IAAA,CAAM,EAAG,CAAA,CAAA,AAE7D,GAAoB,CAAA,GAAhBA,EAAK,MAAW,CAAU,OAAA,EAG1B,CAH0B,CAAA,EAG1B,EAAOA,CAFXA,CAEI,CAFG,EAES,AAFO,CAAhB,GAAqB,CAAA,OAAA,CAArB,AAA6BA,GAAK,CAAA,CAAA,AAEzB,AAFwB,UAExB,CAAW,CAAC,CAAA,CAAA,AACtB,EAAa,IAAK,CAAA,GAAlB,OAAkB,CAAWA,GAI/B,EAAA,AAJmC,CAAA,AAInC,CAJmC,EAInC,CAAO,IAAK,CAAA,QAAA,CAASA,GAIb,EAFR,AAFyB,CAAA,CAAA,CAEX,AAEN,IAFM,CAAK,EAAL,SAAiBA,CAAAA,GAEvB,CAAA,CAF2B,AAE3B,AAIA,CALZ,AAKY,CAAA,AAEZ,CAPA,GAOI,EAAW,CAAA,CAAA,CAAA,AACX,EAAY,CADD,AACC,CAAA,AACZ,EAAM,CAAA,CAAA,CACN,AADM,AADM,EAEG,GACf,CADe,AACf,CADe,AACXA,EAAK,GADM,GACG,CAAA,CAAA,CAAA,AAIlB,EAAc,CAAA,CAAA,AAGX,KAAA,CAAA,CAHW,CAGN,EAAO,EAAE,CAAF,AACnB,CAAA,CAEI,GAAI,AAAS,EACb,IAFOA,EAAAA,EAAAA,AAAK,GAALA,OAAK,CAAW,EAAC,CAAA,CAExB,AAFwB,CAKpB,GAAI,CAAC,EACL,CACI,EAAY,CAAI,CAAA,CAAA,CAAA,AAChB,GAFJ,AACI,EACA,CAEJ,AADA,AADI,QAEJ,CAEQ,AAFR,AACJ,CAEA,CAAA,EAAA,CADI,IAIe,GAAA,EACf,EAAM,CADS,AACf,AAAU,CADK,AACL,CAAA,CAAA,CADK,AAGN,EACb,EAAA,CADI,EAGiB,CAAA,CAAA,GAAb,EAA4B,EAAA,CAAA,CACP,AADO,CACP,CADR,EACR,AADuB,IACU,GAAA,CAAA,CAAA,AAErC,AAAa,CACtB,CAAA,AAH6B,EAG7B,EAH8C,GAM5B,EAAA,EAAA,CAAA,AAClB,CADkB,AAEtB,KAFsB,EAKL,CAAA,CAAA,GAAb,GAA2B,CAAA,CAAA,GAAd,AAAM,GAAQ,AAER,CAAA,GAAhB,GAGgB,CAAA,GAAhB,GAAqB,CAHL,GAGkB,EAAM,CAAN,AAAW,CAAX,AAAlB,CAA6B,IAAa,EAAY,CAE7E,CAFoD,AAGpC,CACZ,AAFJ,CAEI,EAAA,CADI,IAEkB,CAAK,GAAnB,GAAmB,EAAY,EAAI,CAAJ,GAAI,CAAO,CAAvB,CAA2B,CAAA,GAAA,CAAOA,EAAK,GAAA,EAAA,CAAM,EAAG,GAAG,AACrE,CADqE,CAAA,AACjE,CAAJ,GAAI,CAAO,EAAI,CAAA,GAAA,CAAOA,EAAK,GAAA,EAAA,CAAM,EAAW,GAAG,CAAA,CAKpD,AALoD,AAKtC,OAAK,EAAnB,CAEA,EAAI,CAAJ,GAAWA,CAAAA,AADf,EAAA,AACoB,GAALA,EAAW,CAAA,CAAA,CAAG,GACzB,EAAI,CAAJ,EADiC,CAAA,AACtBA,CAAAA,AADsB,EACjB,GAALA,EAAW,CAAA,CAAA,CAAG,GAAG,CAAA,CAAA,AAI5B,EAAI,CAAJ,GAAWA,CAAAA,EAAK,GAALA,EAAW,CAAA,EAAW,GACjC,EAAI,CAAJ,CADsB,CAAmB,CAAA,AAC9BA,CAAAA,AAD8B,EACzB,GAALA,EAAW,CAAA,EAAW,GAAG,CAAA,AAExC,CAFwC,CAEpC,CAFsB,AAE1B,EAAUA,CAAAA,EAAK,GAALA,EAAW,CAAA,EAAU,GAAG,CAGlC,AAHkC,CAAA,CAGlC,AAHqB,CAGrB,EAAA,CAAM,IAAK,CAAA,OAAA,CAAQA,GAGhB,CAAA,CAHoB,AAI/B,CAJ+B,AAGpB,AAGX,CAN+B,AAGpB,EAGN,CAAA,GAAA,CACL,SAAW,CAAA,GAAA,CACX,cAAA,CAAgB,CAAC,OAAO,CAAA,AAC5B,wHM71BO,OAAM,EAAN,aAAA,IJ/DoB,EIwEN,MDoNC,EE1QF,uBDsDsE,CAAA,CAClF,CCvDa,SDuDF,GAAA,IDqNN,iBCpNgB,CAAC,EAAU,IAC5B,CAAA,CADkB,CACf,AAAH,EAAc,EAAA,IAAH,AAAG,CAAK,kBAAkB,CAAA,EAAG,EAAO,CAAA,CACnD,GADmD,sBACzB,CAAC,EAAU,IACjC,EAAc,OADmB,AACnB,CAAQ,CAAG,EAAX,AAAW,EAAW,EAAA,IAAH,AAAG,CAAK,kBAAkB,CAAA,CAAA,CAAI,EAAE,CAAA,yBAIjE,CAAqB,IAAA,CAAK,+BAAgC,CAAA,SAAA,CAAA,0BAWpD,GJ3De,CAAA,CAAA,+BI2DsB,CAAA,mBAAA,CAQ3C,AAR2C,CD4N/C,CE/RC,ED2EG,CAAA,yBAAA,CAGM,IAAA,CAAK,+BAAgC,CAAA,wBAAA,CAAA,KAE3C,EC9EG,OAAA,CD8E0C,CAAA,OAC7C,eAAA,CAAiC,CDiNnB,CAAA,iBChN2B,oBAEM,CAAA,MAIvD,CAAQ,QAAA,CAAqC,CAAA,CAAC,CAAA,oBAQnB,CAC3B,CAAA,CAKQ,GAJC,IAAA,CAAA,kBAAA,CAAqB,EAAiB,SAAA,EAAa,GAAb,CAAkB,CAAA,kBAAA,CAAA,AACxD,IAAA,CAAA,oBAAA,CAAA,EAAA,mBAAwC,EAAuB,IAAK,CAAA,oBAAA,CAAA,AACpE,IAAA,CAAA,yBAAA,CAA4B,EAAiB,cAAA,UAAA,EAA4B,IAAK,CAAA,yBAAA,CAEI,AAFJ,AAE/E,KACJ,EAAA,CADI,IAAA,CAAA,yBAAA,CAA+B,KAAO,CAAA,IAAA,CAAK,oBAAA,CAAqB,KAAO,CAAA,KAAK,CAAC,CAAA,CAEvE,MAAA,AAAI,MAAM,8DAoBjB,OAAA,GAAA,CACP,CCzD4B,CD0DX,EAAA,OAAA,CAAQ,AAAC,IAEb,IAAA,CAAA,eAAA,CAAgB,IAAA,CAAK,GAEtB,AAAC,EAAO,CC1DA,OD2DZ,CC3DwB,ID6Db,GC5DF,KD4Da,CAAA,MAAA,CAAO,IAAK,CAAA,EAAO,IAAP,GAAa,CAAA,CAAA,EAInD,IAAA,CAAA,aAAA,CAAqB,CAAA,CAAC,CAAA,AAW1B,IAAA,SAAoB,CDoNK,CCnNzB,EDmNoC,GClNhC,CAAK,SAAY,CAAA,EAGrB,IAAA,UAAA,CAEI,OAAO,IAAK,CAAA,SAAA,CAAA,AAchB,IAAW,CC9EG,QD8EM,CACpB,CAAA,CACI,IAAA,CAAK,SAAY,CAAA,CAAA,CACrB,AAEA,IAAA,EAHqB,CAAA,OAIrB,CCzDuB,AD0DnB,OAAO,IAAK,CAAA,SAAA,CAwChB,IAAW,SACX,CACI,OAAO,GC/BK,CAAA,CD+BA,QAAA,CAIT,AAJS,OAKhB,CACS,CChCL,GDgCK,CAAA,mBAAA,CAAoB,IAAA,CAAK,+BAA+B,CAAA,CAAA,IAE7D,CAAK,SAAA,CAAY,CAAA,CAAC,CAAA,qBACK,EAAC,CAAA,KAGnB,EClC+B,MAEhC,KAAA,CAAA,CAAA,EDiCJ,CChCA,GDgCA,CAAA,SAAiB,CAAA,CD+NL,GC/NK,CAAA,cACA,CAAA,GD+ND,CAAA,AC/NC,CACjB,AADiB,IACjB,CAAK,SAAY,CDgOjB,AChOiB,IAAA,CAAA,AACjB,IAAA,CAAK,QAAA,CAAW,CAAA,EAChB,IAAA,CAAK,oBAAuB,CAAA,4BAOF,CAC9B,CAAA,CACQ,AAAwB,QAC5B,EAAA,OADW,EAEP,IAAA,CAAK,oBAAuB,CAAA,EAMvB,IAAA,CAAA,CD7EJ,ICuE2B,CAAA,cAMvB,CAAuB,OAAO,IAAK,CAAA,GACnC,GAAI,CAAA,AAAC,GAAQ,CAAG,AAD8B,EAC9B,kBAAA,CAAmB,GAAG,AAAC,CAAA,EAAI,mBAAmB,AAH/C,CAG2D,CAAA,EAAI,CAAD,AAAE,CAAA,CAAE,CACjF,CAAA,GAJe,CAIf,AAJe,CAIV,GAAG,CAAA,AACjB,CADiB,AAErB,AAMO,SAAS,CAChB,CAAA,CACU,GAAA,OAAE,CAAO,KAAA,CAAA,CAAQ,CAAA,EAahB,GAbgB,CAAA,EACF,CAAA,AAYd,EAZc,EAAA,QAYd,CAAA,IAZc,EACjB,GAAS,EAAA,AAAK,AAAC,CAAN,EAEL,AAAqB,EADzB,KAAA,CACyB,EAAjB,AAAkC,OAA3B,EAA2B,EAElC,CAFiB,EAAiB,CAAA,CAElC,CAAM,OAAA,CAAQ,GAAe,EAAV,AAAgB,CAAhB,EAAG,AAAiB,CAAA,AAAC,CAAO,EAAA,CAAA,EAAmB,KAAO,CAAC,CAAA,CAAA,AAE1E,GAAO,EAAA,CAAA,CAAY,CAAP,CAAa,GAAA,CAAA,AAEtB,GACR,EADQ,AAGR,CACX,AAJmB,AAWZ,CAVI,WAUQ,CACnB,CAAA,CACQ,IAAA,CAAK,SACT,EAAA,GAEI,EAAA,IAAA,EAAK,8DAA8D,CAAA,CAAA,AAIvE,IAAA,CAAK,SAAY,CAAA,EAER,EAAA,IAFQ,CAAA,CAER,CAAA,CAAQ,OAAQ,CAAA,AAAC,IAEtB,EADJ,EACI,CAAK,EADT,OACmB,CAAA,EAAO,IAAP,AAAa,CAAA,EAAO,IAAP,EAAa,CAAA,CAAA,AAC5C,CAAA,CAuBE,AAvBF,AACL,SAsBO,CAAU,CAAA,CAAkB,CACnC,CAAA,CACI,IAAM,EAAuB,EAAC,CAAA,AAC1B,EAAqC,CAErC,CAAC,IAFoC,CAAA,AAEpC,CAAM,KAF8B,EAEtB,CAAA,KAGG,CAHG,CACzB,AAEsB,EAFtB,IAEsB,CAAO,MAAP,CAAO,CAAQ,GAAQ,GAAF,AAAE,CAAF,AAAM,CAAC,CAAC,EAAO,EACtD,CADsD,AAAG,EAErD,AAAmB,EADvB,MACuB,EAAf,OAAO,GAAQ,AAAY,KAAM,CAAA,OAAA,CAAQ,GAAG,AAErC,CADX,EAAA,IACa,MAAO,CAAI,CAAA,CAAA,AAGjB,AAHiB,OAGf,EAAO,GAAA,AAAG,CAAI,CAAA,CAAA,AAC1B,CAAA,CAAA,AAQW,EAAA,OAAA,CAAQ,AAAC,IAErB,CAFY,AAChB,GAGQ,EAFE,AADV,CAGQ,CAAA,AAFS,EAAM,GAAA,CAAA,AACb,EAAU,EAAM,GAAA,EAAA,CAAA,AAGlB,GAAmB,QACvB,EADI,OAAO,EACX,CACI,IAAM,EAAgB,IAAA,CAAK,MAAL,cAA0B,CAAA,EAAU,GAE1D,EAAW,CAFqC,CAAiB,CAAA,CAAA,AAEtD,CAAK,GACV,AADN,EACM,CAAA,AAAC,EAAS,EAAa,CAAA,AAGjC,EAJiC,CAAA,CAAA,AAIjC,CACU,IAAA,CAJuB,CAIX,EAAQ,GAAI,CAAA,AAAC,CAAzB,EAAkC,IAAK,CAAA,oBAAA,CAAqB,EAAU,IAAI,AAErE,CAFsE,CAAL,AAAK,AAEtE,CAFsE,GAEtE,CAAK,GAAL,AAAQ,GACnB,EAAM,CAAN,AAAO,GADqB,AAClB,CADkB,CAAA,GACN,EAAH,AAAY,CAAA,AACnC,AAEA,CAHuB,GAGvB,CAAK,CAH8B,EAG1B,CAAA,CACL,GAAG,CAAA,CAEC,KAAO,CAAA,EACP,CADO,EACF,CAAA,CACT,CACH,CAAA,CAFY,AAEZ,AACJ,CAAA,CAAA,AAEI,IAAA,CAAA,QAAA,CAAS,EAAY,CAAA,CAAA,CAC9B,AA6BO,GA9BmB,CA+BtB,CAEJ,CAAA,CACI,CAlC0B,CAAA,EA6CtB,EAXE,EAA4B,EAAC,CAAA,AAE/B,CASA,CAAA,GATA,CAAM,OAAQ,CAAA,GAEP,EAAA,EAFc,CACzB,CACW,CADX,AACgB,GAAI,GAIhB,EAAO,EAJsC,CAAA,CAAA,AAI7C,AAAO,CAAK,GAOhB,EAAW,AAAC,EAP8B,CAAA,AAQ1C,CAR0C,AASlC,EAFR,EACA,AACQ,CAAK,MAAO,CAAA,GAAG,CACnB,AAES,CAAA,CAFT,CAES,EAAA,IAAA,EAAA,CAAA,4BAAA,EAA+B,EAAiB,CAAd,WAAc,CAAA,CAAA,AAEzD,CAFyD,AAG7D,CAAA,AAGM,AAGK,CAHL,EAAa,EAAA,KAGR,QAHQ,EAAc,GAGtB,GAH4B,CAAA,CAAA,EAG5B,CAAQ,AAAC,IAEV,CADV,EACU,GADV,EACY,CAAA,CAAQ,CAAA,EACZ,GADY,CAAA,EAEZ,CAAA,QACA,CAAA,CACA,UAAY,CAAA,CAAA,CACZ,MAAQ,CAAA,CAAA,CACR,CAAA,EAKE,EAAA,CALF,AAKE,CALF,CAK0C,EAAA,aAAA,AAAwB,EAAA,GAAG,AAAE,CAAA,EAAA,CAAI,AAACC,IAChF,AACQ,GAAe,EADvB,MAEI,EAAA,AADI,OAAOA,EACF,KJ/cf,EAAS,EAAO,EAAhB,EAAgB,CAAA,CAAM,AAFd,EGmRI,GHjRe,CAAA,CAAA,KAFnB,CAAA,GAIS,EAAC,CAAA,GAEpB,EKFK,ALGT,CACI,GKJa,CLIP,EAAkB,EAAC,CAAA,EAElB,OAAA,CAAQ,IAGL,CKTkB,GLSlB,EAAQ,EAAA,CAAR,QAAuB,CAAA,CAAA,CAAG,EAAK,MAAS,CAAA,CAAC,CAAE,CAAA,KAAA,CAAM,GAAG,CAAA,CAAA,AAE1D,CKX+B,CLW3B,IAAA,CAAK,cA5CZ,EAAS,CAAA,CAAc,CAAiB,CAAA,CAAA,CAA/B,ADOe,ACP+B,CAAA,CAAkB,CAClF,EAAA,ACI4E,CFG5E,KCNe,CAAA,CAAI,EAAK,CDOC,ECPD,EAEpB,IAAS,CAAI,CAAA,CAAA,CAAA,EAAO,EAAA,AAAG,MAAA,CAAQ,CAC/B,EAAA,CAAA,QACkB,CAAG,CAAC,CAAA,CAAA,AAEd,EAAQ,EAAI,AG8MX,CH9MD,AAAY,EELO,CAAA,CHUM,CAAA,ACLb,CAAS,CACzB,CACa,CADb,CACa,EAAK,CDMf,CCNU,ADMV,KCNuB,CAAA,CAAA,CAAO,EAAK,CAAG,GAAQ,EAAH,AAAQ,CAAR,AAAQ,CAAQ,CAAG,CAAA,CAAX,CAAmB,GAIrE,CAJ6D,AAAY,CAIpE,AAJoE,CAAA,CImE9E,EAAA,CAAA,EAAA,OJ/DoB,CAAQ,CAAA,CAAO,EAAK,CAAG,EAAH,GAAQ,CAAC,AIgeRA,CJheQ,CAAA,EAiC1B,CAAG,CAAA,EAAQ,IAAI,CAAA,CAAA,GAGzC,CACS,IAAA,CAAK,GAGP,GAHa,CAAA,CG4QhB,AH5QgB,EAGb,CIwbwC,CAAA,AAEnC,CAFmC,CJxbxC,AG2QS,KC+KG,MAAM,OAAQA,CAAAA,GAAOA,CAAJ,CAAU,AAANA,CAAOA,CAAPA,CAAU,CAAA,AACzC,CADyC,AACzC,CAAA,AAEK,EAAe,IAAK,CAAA,KAApB,GAAoB,CAAS,GAG7B,EAHkC,CAAA,CAAA,CAGlC,CAAA,OAAA,CAAQ,GAAgB,EAAa,OAAjB,AAAiB,CAAb,AAAqB,EAArB,CAAiC,EAAS,GAAb,AAI3D,CAJ2D,GAIrD,EAAkC,EAAC,CAAA,AAJ2C,AAO9E,CAP8E,CAOnE,AAAC,AAPkE,GAQpF,CACU,EAFJ,EACN,AACU,EAAS,IAAT,AAAS,CAAK,QAAS,CAAA,IAAA,CAAK,AAAC,CAAM,EAAA,CAAA,CAAE,IAAK,CAAA,GAAG,CAE5C,AAF6C,CAAA,CAAA,IAE7C,CACH,GAAG,GAAQ,GAAA,EAAA,CAAM,EAAG,CAAA,AACpB,GAAK,CAAA,CAAA,CACT,CADS,AACT,AACJ,CAAA,AAEU,EAAA,OAAA,CAAQ,AAAC,IACnB,AACS,EAAA,EAAA,CADT,IACS,CAAQ,AAACA,IACd,AACI,IAAI,CADR,CACyB,CAAA,CAAC,CAAA,AAwBtB,GAtBmB,QACnB,EADI,AACJ,OADWA,EAGP,EAAiB,EAASA,IAAG,AAI7B,CAJ6B,CAAA,AAItBA,EAAP,AAAW,EAJX,EAImB,EAAA,EACnB,EAASA,AADU,CAAA,CACN,EAAb,IAAuB,EAAA,GACnBA,EAAI,CADe,CAAA,AACnBA,QAAkBA,EAAAA,EAAI,EAAJA,IAAI,AAC1B,EAAA,EACI,EAAwBA,EAAI,UAAc,EAAA,EAC1C,EAAoBA,CADpB,CACwB,MAAU,EAAA,GAGrB,EAAA,AAHb,CAIA,CAL0C,CAAA,CAKvC,EAASA,EAAI,EAAJA,CAAO,CAJe,AAItBA,AADC,AACM,CACnB,AALkC,GAK/BA,CAAAA,AAAA,CACP,CAAA,CAIA,CAAC,EAED,MAAM,AAAI,IADd,CACc,CAAM,AADpB,CACqE,8CAAA,EAAA,EAAe,GAAG,CAAE,CAAA,CAAA,CAAA,AAGxE,EAAA,GAHoD,CAGpD,CAAK,OAAL,YAAK,CAAoB,EAAgB,CACtD,OAAS,CAAA,GAD6C,IAEtD,IAAA,CADS,IAET,EACA,IADA,MACY,CAAA,EACZ,MAAQ,CAAA,EACR,UAFY,GAEE,EADN,AACY,GAAA,SAAA,CACvB,CAAA,CAAA,AAED,EAAe,IAAA,CAAK,EAAc,CACrC,CAAA,CAAA,AACJ,CAAA,CAAA,AAEY,AAJL,EAIK,KAJ6B,CAAA,CAAA,AAI7B,CAAQ,AAAC,EAAT,EAEJ,CADT,GACS,CAAA,CADT,QACS,CAAU,EAAS,CAAA,CAAA,CAAJ,AACvB,CAAA,CAAA,AACJ,CAAA,CAAA,AACL,AA4CO,QA/C6B,CAAA,KA+Cf,CAErB,CAAA,CACU,IAAA,SHpmBkD,EGomBlD,GAAc,EHpmBoC,CGomBvB,AHpmB+B,GGsmBhE,EAAA,CAAA,EAAY,CAF8B,CAAA,AAE9B,CAF8B,CAE1C,WAAY,EAAsB,GAElC,IAAM,EAAqD,AAFhB,CAAA,AAEgB,CAFhB,AAEiB,CAAA,AAuB5D,OArBU,EAAA,OAAA,CAAS,AAAD,IAER,IADV,AACU,EAAa,GADvB,CAC4B,CAAA,GAAlB,KAAkB,CAAS,EAAQ,CAAA,AAEzC,GAAI,EAFqC,AAGzC,CACU,IAAA,EAAU,CADpB,GACyB,CAAA,AAAf,OAAe,CAAQ,GAEvB,EAAwC,CAAA,CAAC,CAAA,AAE/C,EAJuC,CAAA,CAIvC,AAJuC,IAI5B,KAAO,EAClB,CACU,IADV,AACU,EAAQ,CAAA,CAAQ,CAAhB,CAAmB,CAEzB,AAFyB,CAEzB,CAAO,IAAK,CAAA,yBAAA,CAA0B,EAAU,GAAG,AAAK,CAAJ,AAAI,CAAA,CAAR,AACpD,AAEA,CAAA,CAAI,CAHwD,CAAA,AAG5C,CAAA,CAAA,CACpB,CACH,CAAA,CAAA,AAEM,AAJa,CAAI,CAAA,AAIH,CAAA,CAAI,CAAU,CAAA,CAAC,CAAC,CAAI,CAAA,CAAA,AAApB,CACzB,AAOO,CARsC,CAAA,SAQ3B,CAClB,CAAA,CACU,IAAA,EAAS,IAAT,AAAc,CAAA,OAAA,CAAQ,GAExB,AAFqC,CAAA,CAAA,CAEtB,QACnB,EADI,OAAO,EACX,CACI,IAAM,EAA8B,CAAA,CAAC,CAAA,AAErC,IAAA,IAAW,KAAK,EAEZ,CAAA,CAAI,CAAC,CADT,AACS,CADT,AACc,CAAyC,CAAA,CAAC,CAAE,CAAA,GAAA,CAGnD,AAHmD,OAGnD,CAAA,CACX,AAEA,CAHW,CAAA,KAGH,EAAyB,GAAA,CAAA,AACrC,AAmBO,AApB8B,QAoBtB,CACf,CAAA,CACU,IAAA,EH7qB2C,CAAC,QG6qB5C,GAAc,EH7qBoC,CG6qBvB,GAEjC,CAFqC,CAAA,AAE9B,CAF8B,AAE9B,CAAP,CAAO,EAAA,aAAA,EAAsB,GAE7B,CAFiC,CAAA,CAAA,CAE3B,EAAwC,CAAA,CAAC,CA8C/C,AA9C+C,OAE1C,EAAA,EAAA,KAAA,CAAQ,AAAC,GACd,CACI,GAAI,CADR,AACS,IAAA,CAAK,aAAc,CAAA,EACxB,CAD2B,AAEnB,CADR,EACQ,IAAA,CAAK,SAAU,CAAA,EACnB,CADsB,AACtB,CACQ,IAAA,EAAS,IAAT,AAAc,CAAA,SAAA,CAAU,EAAG,CAAA,AACzB,EAAiB,IAAK,CAAA,OAAtB,WAAsB,CAAmB,GAE/B,GAFqC,AAErC,CAFqC,CAAA,MAErC,CAAS,EAAT,KAAiB,CAAA,AAAC,IAE9B,EAAe,KADnB,CAC0B,CAAA,EAAa,CAAA,AADvC,EACI,KAAmC,CAAF,AAAU,AAAC,IAExC,CADJ,GACU,EAAiB,AAD3B,EACkC,IAAP,EAAc,CAAC,AAAD,GAE7B,AAFe,EAEf,AADR,CACQ,CAAM,EACV,CAFJ,CAEI,AACW,CAAA,CAAM,EAAwC,GAFb,AAEa,GAMzD,EANyD,AAM1C,CAN0C,AAAN,KAOvD,EAAA,CACa,EAAA,CAAA,CAAA,AACb,CACH,AAFgB,CAAA,AAEhB,CAAA,AACJ,CAAA,CAAA,AAED,IAAA,CAAK,aAAc,CAAA,EAAO,CAAJ,AAAI,CAAA,CAAO,CAAC,CAAA,CAAA,AAGtC,KACI,CADJ,GACI,CAAK,aAAc,CAAA,EAAO,CAAA,AAAJ,IAAI,CAAK,mBAAoB,CAAA,CAC/C,KAAA,CAAO,CAAC,EAAG,CAAA,AACX,GAAK,CAAA,CAAA,CACT,CADS,AACN,CAAA,CAAE,CAAA,CAAA,AAIb,CAAA,CAAO,EAAG,CAAA,AAAI,IAAK,CAAA,aAAA,CAAc,EAAG,CAAA,AACvC,CAAA,CAEM,AAFN,EAEoB,CAAA,CAAO,CAAK,CAAA,CAAC,CAAC,CAAI,CAAA,CAAlB,AAAkB,CAC3C,AAMO,IAPoC,CAAA,EAO7B,CACd,CAAA,CACI,MAAO,CAAC,CAAC,IAAK,CAAA,SAAA,CAAU,EAAG,CAC/B,AAMO,AAPwB,UAOd,CACjB,CAAA,CACI,MAAO,CAAC,CAAC,IAAK,CAAA,QAAA,CAAS,EAAG,CAOtB,AAPsB,AAC9B,AAD8B,mBAOH,CAC3B,CAAA,CACI,IAAA,IAAS,CAAI,CAAA,CAAA,CAAG,CAAI,CAAA,EAAO,IAAP,EAAO,CAAQ,CACnC,EAAA,CAAA,CACU,IAAA,EAAQ,CAAA,CAAO,CAAf,AAAgB,CAAA,CAAA,AAEhB,EAAY,IAAA,CAAK,EAAL,aAAqB,CAAA,IAAA,CAAK,AAAC,GACzC,EAAW,KAD8B,CAC9B,CAAO,CAAP,KAAc,CAAA,QAAA,CAAS,EAAM,GAAA,GAAM,CAAC,CAAA,CAAA,AAEnD,GAAI,EAEO,OADX,AACW,CACX,CAGG,AALH,AAGJ,OAFe,AAIR,CAJQ,GAIR,CAAK,eAAA,CAAgB,CAAC,CAAA,CAAA,AACjC,AAOQ,2BAA2B,CACnC,CAAA,CACI,GAAI,CAAC,IAAK,CAAA,oBAAA,CAA6B,OAAA,EAEvC,CAFuC,CAAA,EAEjC,EAAkB,IAAA,CAAM,IAAK,CAAA,EAAX,CAAc,AAAI,GAAM,CAAA,GAAA,CAAA,AAEhD,MAAO,CAAA,EAAG,EAAG,CAAA,CAAG,EAAc,EAAG,IAAA,CAAK,KAAR,eAA4B,CAAA,CAAA,CAC9D,AAEQ,AAHsD,mBAGtD,CAAoB,CAAA,CAA+B,CAQ3D,CAAA,CACU,GAAA,SAAE,CAAA,CAAS,IAAM,CAAA,CAAA,YAAW,CAAA,CAAY,QAAQ,QAAA,CAAA,cAAQ,CAAA,CAAiB,CAAA,EAkBxE,EAlBwE,CAAA,IAE3E,IAAA,CAAK,SAAa,EAAA,IAAA,CAAK,SAAA,AAC3B,EAAA,EACmB,EAAA,GAAA,CAAM,EAAA,IAAA,CAAK,CAAX,SAAsB,CAAA,EAAe,GAAA,CAAK,IAAK,CAAA,GAAzB,MAAyB,CAAW,IAAA,CAAK,UAAS,CAAA,CAAA,AAG3F,EAAe,KAAA,CAAQ,GAAW,EAAe,CAAjD,CAAkC,GAAwB,EAAA,CAAC,EAAe,EAAxC,CAA2C,CAAA,CAAA,AAC7E,EAAe,GAAM,CAAA,IAAA,CAAK,GAA1B,uBAAqD,CAAA,EAAe,GAAG,CAAA,CAAA,AACxD,EAAA,IAAA,CADsC,AAC/B,CAAE,GAAG,GAAZ,AAAyB,CAAA,CAAI,CAAA,GAAG,AAApB,EAAmC,IAAK,CAAA,CAAA,AACpD,EAAA,UAAA,CAAa,CAAb,EAA2B,EAAe,UAAA,CAAA,AAC1C,CAD0C,CAC1C,MAAA,CAAS,GAAU,EAAe,AAAlC,MAAkC,CAAA,AACjD,EAAe,GADkC,GAClC,CAAS,GAAU,EAAlC,AAAiD,CAAf,KAAyB,EAAgB,AAgBxE,EAhBwD,AAA+B,CAgBnF,CAhB2B,CAA2D,CAAA,AAgBtF,CAhBsF,IAgBtF,CAAM,GAAG,CAAA,CAhB2C,AAgBzC,GAAA,EAAM,CAAA,KAAA,CAAM,GAAG,CAAA,CAAE,KAAM,EAAA,CACxC,KAAM,CAAA,GAAG,EACT,KAAM,EAAA,CAAA,AAjBc,KACrB,CAAA,EAAA,CADI,GAEA,GAAe,WAAf,CAA8B,CAAA,CAAA,CAAA,CAAA,AAG3B,CAAA,CACX,AACJ,CAAA,AA7uBa,EAOK,MAPL,GA2uBE,CAAA,GApuBmB,CAAA,cAAA,CAAA,IL7ErB,EAAmB,CAAC,EAAmB,SAE1C,ECPA,EDOyB,KAAM,CAAA,GAAG,CAAA,CAAE,CAAC,CAAA,CAAA,OAEvC,IAEA,GAAa,CAAA,CAAA,EAAA,EAAA,CADjB,AACiB,AAAgB,CAAA,CAG1B,IIwRP,8CAlFS,EAAN,MAAM,EAkFT,YAAY,CAAA,CAA2D,CACvE,CAAA,CA1EA,CHrN0C,GGqN1C,CAAO,CHjNC,WAAA,CGiNgC,EAAC,CAAA,AA2ErC,CH3RA,GG2RI,EAAU,EAET,GAAsC,ICrNhC,cDqNkD,EAAA,aAC7D,EAAA,CACc,CE9QM,CF8QN,CACN,IADM,ICtNd,ADuNiB,OACH,IAGd,ECzN0B,GDyNpB,CAAA,QAAA,CAAE,MAAS,CAAM,aAAA,EAAc,EAAA,CAAO,CAAA,KAArB,CAEvB,CAF4C,AAEvC,CAFuC,UAEzB,CAAA,OACd,CH/QE,GG8QY,CAAA,GACd,CAAW,IH9QhB,GG8QmC,EH9QnC,IG8QmC,EAAA,OAAA,CAAU,EAAU,IAAA,CACvD,AADuD,IACvD,CAAK,aAAA,CAAA,EAAwB,MAAA,CAAA,AAC7B,IAAA,CAAK,QAAA,CAAA,CAAA,MACL,CAAK,UAAA,CAAa,CAAA,CAAC,CAAA,KACd,GH3QL,CAAA,CG2QY,GH3QK,CG2QL,IAEN,EAAiB,UAAA,CAAW,CAAX,CAAgB,EAAA,EAAA,CAAK,KAAe,CAAA,CAAA,GAIvD,EE/RkE,EF+RlE,CAAK,QADT,EACsB,CAAA,EACV,EAAA,MAAA,CAAO,GADG,CAAA,MACH,CAAa,IAAK,CAAA,UAAA,CAAA,CAI5B,IAAA,CAAA,UAAA,CAAa,EAAQ,MAAO,CAAA,WAAA,CAAA,YAGhC,CAAU,CE/RJ,GAAA,CAAA,IF+Rc,CAAA,MAAA,CAAA,eACP,CAAA,OAAA,IAAY,CAAA,IAAA,CAAK,OAAO,CAAA,CAAA,iCAEzB,CAAA,KAOd,OACP,EE1Re,MF2RJ,IAAI,OAAQ,CAAA,AAAC,IAEhB,GADJ,CACI,CAAK,GADT,MACqB,CAAA,EACjB,IAAA,CADiB,AACZ,CE1RN,AFyRkB,CEzRlB,SF0RoB,CAAA,CAAA,CAEf,IAAK,CAAA,UAAA,CAAW,MAAA,EAAU,EC/MW,UD+MX,AC/MW,ADgNzC,EAAA,AACI,IAAA,CAAK,SExQW,KAAA,CFwQI,CAAC,CAAA,CAAA,uBACG,GACxB,IAAA,CAAK,cAAe,EAAA,CAAA,KAIpB,CAAK,GE1QN,OF0QiB,EAAA,CAAA,AE1QuB,EFmR3C,eAAe,CACvB,CAAA,SAEU,EAAA,EAAwB,EE3QK,QF2QL,CAAA,AAE9B,KAAO,EAAa,EAAoB,CE5Qd,EF4Q2B,EAAa,IAAA,AAA1B,CAA+B,GAAL,OAAK,CAAW,MAClF,EAAA,OACc,IAAK,CAAA,UAAA,CAAW,EAAU,CAAA,EACvB,IAAK,CAAA,OAAA,CAAA,EAAS,CACrB,AADqB,EACd,EAAK,CE5QG,CF4QH,GAAA,CAElB,AAFkB,GAEd,AE9QiB,EF+QrB,CACI,CADJ,AE7QJ,GAAA,EF8QoB,EE7QpB,EF6QoB,CACZ,AADY,EACD,KACL,ECpND,CDoN+B,IAAjB,CAAiB,CAAZ,KCnNhC,EDmN4C,EAAS,EAAK,UAC5C,CAAA,EAAK,EAAL,QAAK,CAAa,EAAK,EAAA,GAAA,CAAA,AAEvB,EAAO,EE9Qb,EF8QiB,EAAA,SAAA,CACb,ECtNwB,CCzDI,AFgR5B,AE9QC,ADuDuB,CDwNxB,IAAK,CAAA,KAAA,CAAM,EAAW,CAAC,EAAI,IAAK,CAAV,AAAU,UAAA,CAChC,IAAK,CAAA,KAAA,CAAM,EAAW,CAAC,EAAI,IAAK,CAAV,AAAU,UAAA,EAKhC,EAFA,EAAK,CAEL,MADJ,CACY,CADZ,GACgB,EAAA,SAAA,CACR,IAAK,CAAA,KAAA,CAAM,EAAK,CAAC,CAAD,CAAK,IAAK,CAAA,UAAA,CAC1B,IAAK,CAAA,KAAA,CAAM,EAAK,CAAC,CAAD,CAAK,IAAK,CAAA,UAAA,CAC1B,IAAK,CAAA,KAAA,CAAM,EAAK,CAAC,CAAD,CAAK,IAAK,CAAA,UAAA,CAC1B,IAAK,CAAA,KAAA,CAAM,EAAK,CAAC,CAAD,CAAK,IAAK,CAAA,UAAA,EAKtB,IAAI,EElRlB,KAAA,IFkRkB,CACR,KAAK,IElRjB,CFkRiB,CAAM,EAAK,CAAC,EAAI,IAAK,CAAA,UAAA,CAC1B,CEjRL,IFiRU,KAAA,CAAM,EAAK,CAAA,CAAA,CAAK,IAAK,CAAA,UAAA,CAC1B,IAAK,CAAA,KAAA,CAAM,EAAK,CAAC,EAAI,IAAK,CAAA,UAAA,CAC1B,ECjNpB,GAAA,KDiNyB,CAAM,EAAK,CAAC,CAAD,CAAK,IAAA,CAAK,UAAA,EAKb,AAAjB,IAAK,GAAA,EElRD,KFkRC,EAAqB,EAAK,EAAL,cAC9B,EAAA,CACI,EAAA,IAAW,EAAA,SAAA,CACP,EEnRS,GFmRJ,KAAM,CAAA,EAAK,EAAL,cAAsB,CAAA,CAAC,EAAI,IAAK,CAAA,UAAA,CAC3C,GEjRV,EFiRe,KAAM,CAAA,EAAK,gBAAiB,CAAA,CAAC,EAAI,IAAK,CAAA,UAAA,CAAA,KACtC,KAAA,CAAM,EAAK,CAAC,CAAD,CAAK,IAAK,CAAA,UAAA,CAC1B,GEtQC,CFsQI,CAAA,KAAA,CAAM,EAAK,CAAA,CAAA,CAAK,IAAK,CAAA,UAAA,OAIlC,CAAK,QAAS,CAAA,CAAC,CAAI,CAAA,IAAI,EAAA,OAAQ,CAAA,CAC3B,OAAQ,IAAA,CAAK,aAAA,OAEb,KAAA,EACA,IAAA,GACA,IAAA,KACuB,CAAI,GAAnB,AAAmB,CAAA,CAAnB,OAAA,iBACY,MAAA,KE3QA,oBF4QC,CAErB,KAAA,CE1QQ,AF0QD,EAAE,QAAS,EAAA,MAI1B,CACJ,CAII,oBAAA,CAEJ,IAAM,EAAa,GEtQX,CFsQW,CAAK,IAAK,CAAA,CEtQK,SFsQL,EAAc,CAAA,CAAC,CAAA,AAE5C,IAAA,IAAW,KAAY,EACvB,KACS,CAAA,EADT,QACS,CAAW,CEvQV,CFuQ2C,CAAI,EAAC,CAAA,AACtD,IExQoC,AFwQpC,IAAS,EAAI,CAAG,CAAA,CAAA,CEvQK,AFuQD,CAAA,CAAW,EAAQ,CAAE,KAAF,CAAE,CAAQ,CACjD,EAAA,CAAA,OACsB,CAAA,CAAW,EAAQ,CAAE,CAAC,CAAA,CAAA,EAAH,EAErC,CAAK,MEzQL,IAAA,CFyQgB,EAAQ,CAAE,IAAA,CAAF,AAAO,IAAK,CAAA,QAAA,CAAS,EAAU,CAAA,CAAA,EAM3D,GAN0D,aAOlE,CACI,IAAM,EAAW,IAAK,CAAA,SAAA,AAEtB,CAFsB,CEnQd,GFqQR,CAAK,SAAY,CAAA,KACjB,IAAA,CAAK,WAAc,CEnQH,AFmQG,CAAA,CAAA,AACV,EAAA,IAAA,CAAK,IAAM,CAAA,IAAA,CAAK,QAAQ,CAAA,CAAA,AAI7B,YACR,CACI,IAAA,CElQgB,AFkQX,cAAe,CAAA,IAAA,CAAK,WAAc,CAAA,EAAY,UAAZ,AAAsB,CAAA,CAAA,AACxD,IAAA,CAAA,WAAA,GACL,WAAW,GE/PU,EFiQb,IAAA,CAAA,WAAmB,CAAA,EAAY,UAAZ,AAAyB,CAAA,IAAA,CAAK,UAAA,CAAW,MAChE,CACI,CADJ,GACI,CAAK,GEjQS,OFiQE,EAAA,CAAA,CAIhB,IAAA,CAAK,kBAAA,GACL,IAAA,CAAA,cAAoB,EAAA,CAAA,EAEzB,WAOQ,GAAc,CAC7B,CAAA,CACe,IAAA,IAAA,CAAA,IAAK,IAAA,CAAA,QAChB,CAAA,AACS,IAAA,CAAA,QAAA,CAAS,CAAC,CAAA,CAAE,OAAQ,EAAA,aAEd,CEhQE,CAAA,IFiQjB,IAAA,CAAA,UAAkB,CAAA,cACN,CAAA,kBACI,CAAA,SAGZ,IAAA,CAAK,QAAA,EAAA,UACL,IAAA,CAAK,aAAA,CAAc,OAAA,IAEvB,IAAA,CAAK,QAAW,CAAA,IAAA,CAAA,AAChB,IAAA,CAAK,aAAgB,CAAA,IAAA,CAAA,AACrB,IAAA,CAAK,YAAA,CAAe,EAAC,CAAA,AAE7B,CAAA,GA5R2B,UAAa,CAAA,GAAA,CAAA,IE5LlC,EAAc,CAAC,CLhBjB,KKgBwB,MAAO,CF0Qb,CAAA,KE1QqB,OAAQ,eACtC,OAAQ,MAAO,OAAQ,MAAO,MAAO,MAAO,YAAc,MAAO,CLmB1E,MKnBgF,CAkDvE,EAAmB,CAC5B,UAAA,EAAA,aAAyB,CAAA,KAAA,CFwQW,AEtQpC,CFsQoC,KEtQ7B,CACH,KAAM,AAAC,GAAuB,eAC9B,EAD+C,WAAA,MAC3B,CAAC,EAAgB,EAAhB,EAAuC,AArDpE,UAAS,EAAmB,CAAgB,CAAA,CAAA,CAAoB,CAChE,CAoDuF,CApDvF,AACI,IAAM,EAA2B,CAAA,CAAC,CAYlC,AAZkC,CD0FY,ECxFzC,EAAA,OAAA,CAAQ,AAAC,GACd,CACI,CAAA,CAAA,EADJ,AACe,CAAA,CAAA,CACd,EAED,OAAO,IAAA,CAAK,EAAA,QAAc,CAAE,CAAA,OAAA,CAAS,AAAD,GACpC,EACQ,CAAA,CAAA,CADR,CACW,EAAM,WAAW,CAAA,EAAG,EAAK,CAAF,AAAE,CAAA,CAAI,EAAM,GAAA,KAAA,CAAS,EAAG,CAAA,EAGtD,CAAC,EACL,CACI,IAAM,EAAW,EAAA,IADrB,AACqB,CAAK,OAAQ,CAAA,CAAA,CAAK,CAAC,CAAC,CAAA,CAErC,AAFqC,EAE/B,GAAN,SAAmB,CAAA,OAAA,CAAQ,CAAC,EAAmB,CAC/C,CAD4B,GAIjB,CF0Rf,AE7RI,MAGW,MAAA,CAAO,EAFD,EAAmB,CAEb,AAFc,CAAA,EAAG,CAEb,CAAA,AAFyB,CAEzB,AAFyB,EAAA,EAAM,CAAV,EAAI,CAAW,CAA9C,AAA8C,IAAA,CAAK,mBAAA,CAAoB,CAAC,CAAC,CAAE,CAAA,CAAA,CAAG,GAAM,IAAI,CAAA,CAMtG,AANsG,OAMtG,EACX,CAAA,CA0BuF,EAAM,EAAN,AAAa,GAAK,CACrG,CADqG,AAGrG,CAHqG,OAG3F,CAAA,CACN,SAAW,CAAA,CACP,KAAM,EAAA,aAAc,CAAA,aAAA,CACpB,IAAM,CAAA,oBAAA,EAEV,KAAM,AAAC,IAGG,CAFV,EF2QiB,CEzQP,EADU,AACF,EADQ,CAChB,EADU,EAAY,CAAA,IAAG,CAAE,CAAC,CAAA,CACZ,AADY,KACZ,CAAM,GAAG,CAAA,CACzB,AADyB,CF8QzB,CE7QY,AF2QkB,EE3QZ,GAAI,EAAA,CACtB,AADsB,EACb,EF6QT,AE7Qe,EAAf,AF4Q8B,CE5QX,GAEzB,MAAqB,SAAd,GAAwB,EAAY,QAAA,CAAA,AAAS,EAAM,CAC9D,CACA,EAF8D,CAAA,CAAA,EAEvD,AAAC,IAEE,CF4QU,AE7QpB,GACU,EAAQ,EF6QC,AE7QK,CAAd,AF6QS,IE7QK,CAAM,GAAG,CAAA,CAAA,AAEtB,MAAA,CACH,WAAY,WAAA,EAAA,aAAoB,CAAc,IAAA,CAAK,IAAK,CAAA,AAAI,CAAJ,AAAK,CAAA,EAAK,GAAG,CAAA,CACrE,OAAQ,CAAA,CAAM,EAAM,MAAA,CAAS,CAAC,CAAA,CAC9B,IAAK,CD4DL,AC5DK,CACT,AD4DA,AC5DA,CAAA,AACJ,AD4DC,CC3DL,AD2DK,CCpDL,ADoDK,MCpDG,CAAA,CFgRQ,AE9QZ,CF8QY,GE9QN,CAAA,oBACN,GAAI,cAEJ,UAAW,CFiRU,AEhRjB,KAAA,EAAA,aAAoB,CAAA,CFiRQ,SEjRR,CACpB,SAAU,EAAA,oBAAqB,CAAA,MAAA,CAC/B,IAAM,CAAA,qBAGJ,UAAN,MAAgB,EAAwB,GAAxB,CAEwC,OAAA,GAA5C,CFkRA,CAAA,IElRA,CAAK,OAAQ,CAAA,EAAQ,GAAG,CAAA,CAAE,WAAA,EAAkB,EAAW,CAAC,CAAC,EAAM,GAAA,GAAA,CAG3E,AAH2E,MAGrE,MACF,CACA,CAAA,CAAA,CAOA,CAEJ,EAAA,AACU,IAcF,EAdE,CACF,IAaA,CAAA,GAbS,CAAA,EAAA,GFuQL,CAAA,SEtQJ,CFuQA,AEvQA,gBACA,CAAA,EAAA,WACA,CAAA,CACJ,CAAI,GAAS,GF4QL,AAAa,CE5QR,EAAQ,CAAA,CAAC,CAEtB,EAAe,EAAA,IAAA,CAAK,GF2QQ,IE3QA,CAAA,EAAQ,GAAG,CAAA,CAAA,AASvC,GAPI,GAAY,EAAS,WAAA,CAAY,GAAG,CAAO,GAAA,EAAS,MAAA,AAAT,CAAkB,CACjE,EAAA,CACgB,GAAA,GAAA,CAAA,CAAA,AAKZ,MFyQJ,EAAA,CAAA,IEzQ4B,EAAA,OAC5B,CACc,CADd,CACc,KAAA,CAGd,CACU,IAAA,CAJI,CAAA,AAIQ,EAAiB,GAAY,EAAzC,CAA0D,EAAjB,AAAuB,GAAvB,CAA4B,CAAA,GAA5B,EAA4B,CAAA,CAAQ,EAAQ,GAAG,CAAA,CAAA,AAI9F,EFqQZ,AErQsB,CFqQtB,CACuB,KExQU,EAAO,IAAP,AAAqB,CAAA,CAAC,CAAE,GAAA,CAAK,EAAW,IAAA,CAAM,CAAe,CAAC,AAAtB,EAAuB,CAAA,AFwQzE,CExQyE,AAEnE,EAAS,CAAA,AAGxB,IAAA,CALgF,CAKlE,IAAI,AFmC7B,EEnCyC,CAChC,QAAS,EAAQ,MAAA,CACjB,IAAM,CAAA,eACN,CACH,AFyQD,CEzQC,AAED,CAFC,MAEK,EAAY,KAAM,EAAA,CAAA,AAIlB,IAAA,EAAa,GAAO,IAAM,CAA1B,CAA0B,mBAAA,CAAA,AAE5B,GAAA,KAAA,CAAM,OAAQ,CAAA,GAClB,CACI,IAAM,EFqQlB,AErQsE,EAAC,CAAA,AAE3D,IAAA,IAAW,KAAQ,EACnB,CACQ,GAAgB,QACpB,EADI,AACJ,OADW,EAEP,EFkQC,CAAA,ME/PL,IAAI,EAAU,EAAW,CAGrB,GAAQ,AAHa,CAAA,CAAA,EAGrB,AAAQ,EAAM,iBAClB,CAIU,EAAA,EFgQjB,AEhQkC,CFgQlC,CEhQ2C,CAA1B,CAAkC,GAAR,AAAW,CAAA,CAEtC,AAFsC,AAAX,EAE3B,EF+PrB,AACA,CElQsB,CAED,CAAK,EAAO,IAAmC,CAAA,CACpD,IAAK,EACL,KADK,AACC,gBACF,EACA,YADA,GACiB,EAAA,EFmQL,CAAA,CEnQK,GAK7B,IAAM,EAAM,CAAA,KAAM,OAAQ,CAAA,GAAA,CAAI,GAE9B,EAAY,GAF0B,CAAA,CAAA,IAEtC,GAA2B,CAAA,EACvB,CADuB,CACvB,AADuB,CACvB,ADgChB,MChCgB,CAAS,AAAD,IAER,AADJ,EACS,GADT,SACwB,CAAA,CAAC,EAAW,CAAE,MAAO,CAAA,CAAT,CAAqB,SAAZ,GAAyB,CAAA,MAAA,CAAO,AAAC,EAAA,CAAQ,EAAO,EAAA,IAAK,CAAC,CAAA,AAIhG,CAJgG,ADoC/G,MChCe,GAGX,CFiQA,KEjQM,MAAA,CAAO,CAA0B,CAAA,CAAA,CAAgB,CACvD,EAAA,AACI,MAAM,EAAA,MAAO,CAAO,EAAY,aAAA,CAAc,aAAa,CAAA,CAAA,AAE3D,EAAY,OAAA,CAAA,CAAA,GAChB,CACJ,EH5OJ,EAAA,UAAA,CAAW,EHUH,CAAA,CAAA,kCOZR,EAAO,OAAO,CAyBd,EAzBiB,OAyBR,AAAM,CAAI,EAClB,IAAI,EAAO,EAAE,CAqBb,OApBA,EAAK,OAAO,CAAC,EAAS,SAAS,CAAC,CAAE,CAAO,CAAE,CAAI,EAC9C,MAAI,EAAO,EAAQ,WAAW,GAU9B,IATA,EASO,AAgBD,CADH,EAxBgB,AAwBN,EAxBN,AAwBW,KAAK,CAAC,IACR,EAAQ,GAAG,CAAC,QAAU,EAAE,CAtB5B,KAAR,GAAe,EAAK,MAAM,CAAG,GAAG,CACnC,EAAK,IAAI,CAAC,CAAC,EAAQ,CAAC,MAAM,CAAC,EAAK,MAAM,CAAC,EAAG,KAC1C,EAAO,IACP,EAAqB,KAAX,EAAiB,IAAM,OAGrB,CACZ,GAAI,EAAK,MAAM,EAAI,CAAM,CAAC,EAAK,CAE9B,CAFgC,MAChC,EAAK,OAAO,CAAC,GACN,EAAK,IAAI,CAAC,GAElB,GAAI,EAAK,MAAM,CAAG,CAAM,CAAC,EAAK,CAAE,MAAM,AAAI,MAAM,uBAChD,EAAK,IAAI,CAAC,CAAC,EAAQ,CAAC,MAAM,CAAC,EAAK,MAAM,CAAC,EAAG,CAAM,CAAC,EAAK,GACvD,CACD,GACO,CACR,EAzCA,IAAI,EAAS,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAOpE,EAAU,mCAoCV,EAAS,uFM3CT,EACA,yCDwBY,EAAa,CHlBT,CGkB0B,CAC9C,AHnBoB,CAAA,CGmBpB,SAEqB,CJfF,CAAA,OAAA,EAAA,OIkBc,GACQ,KAGjC,EAAQ,GAAA,AJlBA,OIsBZ,EJlBI,EIkBK,EAAI,CAAA,CAAA,EAAA,EAAgB,MAAA,CAAQ,IACrC,CACU,IAAA,EAAU,CAAA,CAAS,CAAC,CAAA,CAApB,AAAoB,AACpB,EAAO,CAAA,CAAP,AAAe,CAAC,CAAA,CAAA,AAGtB,OAAQ,OAEC,CJlBJ,GImBG,EAAQ,CAAA,CAAK,CAAC,CAAA,CAAA,AACd,EAAQ,CAAA,CAAA,EAAM,CAET,EAAA,MAAA,CAAO,EAAO,GACnB,EADwB,CAAA,CAAA,CAE5B,KAAK,GAAA,CACD,GAAS,CJdE,CAAA,EIcI,CAAA,AACf,GAAS,CJdE,CAAA,EAAA,CIgBN,EAAA,EAAA,IAAA,CAAO,EAAO,KAAK,CAAA,CAAA,CAE5B,KAAK,IACD,EAAQ,CAAA,CAAA,EAAM,CAET,EAAA,EAAA,IAAA,CAAO,EAAO,KAAK,CAAA,CAAA,CAE5B,KAAK,OACQ,CAAA,CAAK,CAAC,CAAA,CAAA,EAEV,MAAA,CAAO,EAAO,GFiCV,CAAA,CEjCe,CAAA,CAAA,CAE5B,KAAK,QACY,CAAC,CAAA,CAAA,CC0Bc,CAAA,MDxBvB,CAAO,EAAO,QAEvB,KAAK,cAGI,MAAA,CAAO,CCyCE,CDzCK,aAElB,IACD,EAAQ,CAAA,CAAK,CAAb,AAAc,CAAA,CAAA,EACN,CAAA,CAAK,CC2CP,AD3CQ,CAAA,GAET,MAAA,CAAO,EAAO,GACnB,EADwB,CAAA,CAAA,CAE5B,CADI,IACC,GAAA,CACD,GAAS,CAAA,CAAT,AAAc,CAAC,CAAA,CAAA,AACf,GAAS,CAAA,CAAT,AAAc,CAAC,CAAA,CAAA,AAEV,EAAA,EAAA,IAAA,CAAO,EAAO,GACnB,EADwB,CAAA,CAAA,CAE5B,CADI,IACC,GAAA,CACD,EAAQ,CAAA,CAAK,CAAb,AAAc,CAAA,CAAA,AACd,EAAQ,CAAA,CAAK,CAAb,AAAc,CAAA,CAET,AAFS,EAET,EAAA,WAAA,CAAA,CAAA,CACI,CAAC,CAAA,CAAG,CAAA,CAAK,CAAC,CAAA,CACf,CAAA,CAAK,CAAC,CAAA,CAAG,CAAA,CD8BH,AC9BQ,CAAC,CAAA,CACf,EAAO,GAAP,EAAO,GAGf,CHoEJ,IGpES,oBAEG,EAAQ,CAAA,CAAK,CAAC,CAAA,CAAG,EAAQ,CAAA,CAAK,CAAC,CAAA,CAC/B,EAAQ,CAAA,CAAK,CAAb,CAAc,CAAA,EAAW,CAAA,CAAK,CAAC,CAAA,CAC/B,EAAQ,CAAA,CAAA,EAAM,CAAG,EAAQ,CAAA,CAAA,EAAA,KAGpB,CAAA,CAAA,EAAM,CAAA,AACf,GAAS,CF4CN,CAAA,AE5CW,CAAC,CAAA,CAAA,AACf,KACJ,KAAK,EF8CK,CE9CL,GApEI,IAqES,CACd,AADc,CFgDb,CE/CO,AAtEH,CFqHJ,AErHI,CFqHJ,AE/CY,CF+CZ,AE/Ca,CAAA,CAAA,AAET,CF8CJ,CE9CI,EAAA,gBAAA,CACD,CAAA,CAAK,CAAC,CAAA,CAAG,CAAA,CAAK,CAAC,CAAA,MAGnB,KACJ,KAAA,IACS,EAAA,EAAA,gBAAA,CACD,EAAQ,CAAA,CAAK,CAAC,AAAd,CAAc,CAAG,EAAQ,CAAA,CAAK,CAAb,AAAc,CAAA,CAC/B,EAAQ,CAAA,CAAK,CAAC,AAAd,CAAc,CAAG,EAAQ,CAAA,CAAK,CAAb,AAAc,CAAA,EAGnC,GAAS,CAAA,CAAT,AAAc,CAAC,CAAA,CACf,GAAS,CCmEX,CDnEgB,CCmEhB,CDnEiB,CACf,AADe,KAEnB,KAAK,GAAA,CACD,EAAQ,CCqEL,CAFN,AAEM,ADrEU,CCqEV,ADrEW,CAAA,CACd,AADc,EACN,CAAA,CAAK,CAAb,AAAc,CAAA,CAAA,AAET,EAAA,gBAAA,CACD,CAAA,CAAK,CAAC,CAAA,CAAG,CAAA,CAAK,EAAC,WAIvB,KAAK,yBAEW,CAAA,CAAK,EAAC,CDsDL,ECtDgB,CAAA,CAAK,EAAC,GACvB,CDwDd,CCxDmB,ADwDnB,ECxDoB,CAAG,EAAQ,CAAA,CAAK,CAAb,CAAa,EAGlC,GAAS,CAAA,CAAK,CAAC,CAAA,CACf,GAAS,CAAA,CAAK,CFyEf,AEzEgB,CAAA,CAAA,AACf,KACJ,CADI,IACC,GAAA,CACD,EAAQ,CAAA,CAAK,CAAb,AAAc,CAAA,CACd,AADc,EACN,CAAA,CAAK,CAAb,AAAc,CAAA,CAET,AAFS,EAET,EAAA,mBAAA,CACD,EAAO,GAEX,AAFI,EAAO,CCyFnB,EDtFI,KAAA,IACI,GAAS,CAAA,CAAK,AAAd,CAAe,CAAA,CAAA,AACf,GAAS,CAAA,CAAK,CAAC,CAAA,CAAA,AAEV,EAAA,EAAA,mBAAA,CACD,EAAO,KAAA,GAGf,CD+DA,IC/DK,IACD,EAAQ,CAAA,CAAK,CAAC,CAAA,CAAA,AACd,EAAQ,CAAA,CAAK,CAAb,CAAc,CAAA,AAET,EAAA,CD+DN,CAAA,MC/DM,CACD,CAAA,CAAK,CAAC,CAAA,CACN,CAAA,CAAA,EAAM,CACN,CAAA,CAAK,EAAA,GACA,CAAC,ACgGZ,CAAA,CD/FM,CAAA,CAAK,CAAC,CAAA,CACN,EAAO,GAEX,KACJ,CCwGA,IAAA,WDvGmB,CAAA,OACA,GAEV,QAAA,CACD,CAAA,CAAA,EAAA,CACA,CAAA,CAAK,CAAC,CAAA,CACN,CAAA,CAAK,CAAC,CAAA,GACD,CAAC,CAAA,CACN,CAAA,CAAK,CAAC,CAAA,CACN,EAAA,GAEJ,KACJ,KAAK,GAAA,CAAA,AACL,IAAK,GAAA,iBAEY,MAAA,CAAS,CACtB,MAEqB,EAAS,GAAI,EAAA,CAAA,CAAA,CAG1B,EC6GE,EAAA,MAAA,CD5GF,EAAQ,EAAe,CAAvB,KAAuB,CAAA,AC8GE,ED1GjB,EAAA,CAAA,CAAA,AACA,CADA,CACA,CAAA,CAAA,EAGC,EAAA,KACjB,EF+FZ,eE5FiB,EAAA,IAAA,EAAA,CAAA,0BAAA,EAA6B,EAAI,CAAE,CAAF,AAAE,AC8GH,CD9GG,AAKnC,MAAT,GAAS,AAAgB,KAC7B,CADa,SAGT,KACI,EAAiB,CAAE,MAAA,CAAQ,EAAO,GAAA,GAAA,CAAQ,CAAM,CAAA,CAAA,AAChD,EAAS,AADuC,IACvC,CAAK,CAAd,GAKL,OAAA,GALiC,CAAA,AAKjC,CALiC,AAKjC,sEDhIS,CAAA,CAAG,CAAI,AF7D3B,CE6D2B,AF7D3B,CE6D2B,CAAG,EAAS,CACnC,CAAA,KARA,CAAgB,IAAwB,CCvB5B,ADuB4B,SASpC,IAAA,CAAK,CAAI,CAAA,CC/BA,AD+BA,CAAA,MACA,CAAA,cACK,UAyBd,OAAO,IAAA,EAAW,IAAA,CAAK,CAAA,CAAG,IAAK,CAAA,CAAA,CAAG,IAAA,CAAK,MAAM,CAAA,CAAA,AA4B1C,SAAA,CAAA,CAAoB,CAAA,CAAA,CAEvB,GAAI,IAAA,CAAK,MAAU,EAAA,CAAA,CAAU,OAAA,EAEvB,GAFuB,CAEvB,AAFuB,EAEvB,AAAK,IAAK,CAAA,MAAA,CAAS,IAAK,CAAA,MAAA,CAAA,AAC1B,EAAM,EC3CS,EAAA,CD2CJ,CAAI,CAAA,CAAA,CAAA,AACf,EAAA,AAAM,IAAA,CAAK,CAAI,CAAA,CAAA,CAAA,OAEb,EAAA,CAAA,EC7CE,AD6CF,AACA,CADA,CACA,CFkCV,IEhCiB,EAAM,CAAA,EAAA,AAwBhB,CAxBgB,MFiCS,QETV,CAAA,CAAW,CAAW,CFkCrB,CElCqB,CAAe,EAAoB,EAC/E,CAAA,IACwB,CAAA,CFiCG,ACzBjB,OCRG,MAAW,CAAU,MAAA,CAAA,aAEb,CAAI,CAAA,SACJ,CAAI,CAAA,IACN,IAAK,CAAA,MAAA,CAAA,KACI,CDSY,AACD,CCVE,CAAA,KAAA,CAAA,GACf,IAAA,CAAM,ADSO,CAAA,CCTF,EAAA,AAAO,EAAK,EAAG,CAAA,CAAA,MAExC,GAAY,EAAA,GAAA,AAAuB,EDUrC,ACVgD,GAAU,EAAQ,CAA7B,AAA6B,CAAA,CAC5E,AAoBO,AArBqE,CAAA,AAAlB,SAqBzC,CACjB,CAAA,CAQW,OAPP,GAAA,CAAA,CC9DQ,CAAA,AD8DA,CAAR,GAAY,EAAA,SAAU,CAAA,CAAA,AAElB,CAFkB,CAElB,CAAA,CAAI,EC/DA,ED+DK,CAAA,CAAA,CAAI,IAAK,CAAA,MAAA,CAAA,AAClB,EAAA,CAAA,CAAI,EC/DC,ED+DI,CAAA,CAAA,CAAI,IAAK,CAAA,MAAA,CAClB,AADkB,EAClB,CAAA,IAAA,CAAsB,AAAtB,CAAsB,CAAA,AAAtB,IAAA,CAAA,MAAsB,CACtB,EAAA,CAAA,KAAA,CAAuB,CAAA,CAAd,AAAc,IAAd,CAAK,MAAS,CAEpB,CC/DM,CDgFV,SAAA,CACP,CAAA,CAKW,YAJF,CAAA,CAAA,EAAW,CAAA,CAChB,IAAA,CAAK,CAAA,CAAA,EAAA,CAAA,CACL,IAAA,CAAK,GCvEQ,GAAA,CDuEC,EAAO,EFmCO,IAAA,CEjCrB,IAAA,CCxEW,ADwEX,AAiBJ,OAAA,CACP,CAAA,CAGW,OAFP,EAAO,CCjFC,OAAA,CDiFQ,IAAA,EAET,EAIJ,UACP,CACW,MAAA,CAAA,uBAAA,EAA0B,IAAA,CAAA,CAAM,CAAA,GAAA,EAAM,IAAA,CAAK,CAAC,CAAA,QAAA,EAAW,IAAA,CAAK,MAAM,CAAA,CAAA,CAAA,CAAA,iDDxLjE,EAAA,CAAO,CAAA,EAAI,CAAA,CAAG,EEzDN,AFyDkB,CAAA,CAAG,AExDzC,EFwDsD,CACtD,CAAA,CATA,IAAA,CAAgB,IAAO,CEzBX,AFyBW,SAAA,CAAA,AAUnB,IAAA,CAAK,CAAI,CAAA,CElCA,AFkCA,CAAA,AACT,IAAA,CAAK,CAAI,CAAA,CAAA,CACT,AADS,IACT,CAAK,GEjCQ,MFiCI,CAAA,iBACC,CAAA,ECVkB,ADkCjC,CClCiC,IDmCxC,EAAA,CAzBsB,AA0BX,CA1BW,MA0BX,IAAA,EAAY,IAAK,CAAA,CAAA,CAAG,IAAA,CAAK,CAAG,CAAA,IAAA,CAAK,SAAW,CAAA,IAAA,CAAK,UAAU,CAAA,CAAA,AAsB/D,SAAS,CAAA,CAAW,CAC3B,CAAA,CACI,GAAA,IAAS,CAAA,SAAA,CE3Cc,CF2CD,GAAK,IAAA,CAAA,UAAA,EAAmB,CAC9C,CACW,CADX,MACW,EAIX,IAAI,EAAU,CAAA,CAAA,CAAI,IAAK,EAAA,EAAK,IAAK,CAAA,SAAA,CAAA,AACjC,EAAA,CAAc,CAAA,CAAA,IAAS,EAAA,EAAK,IAAK,CAAA,UAAA,CAAA,AAKjC,OAHS,GAAA,EACA,GAAA,EAED,EAAQ,GAAS,CAAA,CAAA,AA4BtB,eAAe,CAAA,CAAW,CAAW,CAAA,CAAA,CAAqB,EAAoB,EACrF,CAAA,CACU,GAAA,WAAE,CAAA,YAAW,CAAA,CAAe,CAAA,IAAA,CAAA,AAE9B,GAAA,GAAa,GAAK,GAAc,CACpC,CACW,CADX,IADsB,CAEX,CAAA,MAGL,EAAmB,GAAe,CAAI,CAAA,CAAA,CAAA,CAAA,AACtC,CADsC,CE7D/B,EF8D0B,IAEf,EAAY,IACd,EAAa,CADC,CAG9B,EALiC,AAKf,CALe,CAKH,EAFD,EADC,AAId,CAJc,CAID,EAE7B,EAAc,AALe,CAAA,CAKX,IAHY,AAGP,CAAA,AAHO,CAGP,CAAA,AACvB,EAAc,EAAI,CCVJ,GDUS,CAAA,CAAA,CAAA,AAQtB,OClBoC,ADYpB,AAMhB,EEzEC,AFmE6B,GAAgB,EAAkB,CAAA,CAC/D,CAAA,CAD6B,CACf,CADe,EACC,CADD,CACiB,CAAA,CAAA,CAAA,AAKhC,CALd,AAA8C,EAK3B,AE1EnB,EFuE6B,CAFf,EAAgC,AAED,EAAkB,CAAA,CAC/D,CAAA,EAAc,AAEqB,CAHN,EACC,CADD,CACiB,CAAA,CAAA,CAAA,CAEX,AAFW,AAA9C,CAEmC,CAAA,AA0BxC,GA5BmB,EAAgC,KA4BzC,CAAA,CACjB,QACI,GAAA,CAAA,EAAQ,IAAI,EAAA,SAAU,CAAA,CAAA,AAElB,CAFkB,CAElB,CAAA,CAAI,IAAK,CAAA,CAAA,CAAI,IAAK,CAAA,SAAA,CAAA,AAClB,EAAA,CAAA,CAAA,IAAA,CAAA,CAAS,CAAI,IAAK,CAAA,UAAA,CAAA,OAClB,CGaS,AHbgB,CAAA,CAAjB,AAAiB,IAAjB,CAAK,CGaJ,CAAA,OHbgB,CACzB,EAAA,CAAA,KAAA,CAA2B,CAAA,CAAlB,IAAA,CAAK,UAAa,CAExB,EAiBJ,SAAS,CAAA,CAChB,CAMW,OALP,IAAA,CAAK,CAAA,CAAI,EAAQ,CAAA,CAAA,AACjB,IAAA,CAAK,CAAA,CAAI,EAAQ,CAAA,CACjB,IAAA,CAAK,SAAA,CAAA,EAAoB,SAAA,CAAA,AACzB,IAAA,CAAA,UAAA,CAAkB,EAAQ,KAAA,KAAA,CAAA,AAEnB,IAAA,CAAA,OAiBG,CACd,CE3F4B,UF4FhB,QAAA,CAAS,IAAA,EAEV,EAIJ,UACP,CE/FY,AC+GE,AHfH,MAAA,CAAA,wBAAA,EAA2B,IAAK,CAAA,CAAC,CAAM,GAAA,EAAA,IAAA,CAAK,CAAC,CAAA,WAAA,EAAc,IAAK,CAAA,SAAS,CAAe,YAAA,EAAA,IAAA,CAAK,UAAU,CAAA,CAAA,CAAA,CAAA,sDGrMlH,YAAA,GAAe,CACf,CAAA,CAZA,IAAA,CAAgB,IAAwB,CFK3B,AEL2B,CFK3B,eEQE,MAAM,GFPH,CAAA,GEOW,CAAA,CJgBW,CIhBJ,CDrCA,ACqCC,CDrCD,ACqCE,CDrCF,AHqDI,AIhBF,CAAI,CAAO,CAAA,CAAC,CAAI,CAAA,KAG3B,CAH2B,CAAA,MAIlD,SADW,CAAA,CAAK,CAAC,CAAA,CACjB,OACU,EAAc,EAAC,CAAA,AAErB,IAAA,EDzCI,ECyCK,EAAI,CAAG,CAAA,EAAK,EAAK,MAAQ,CAAA,CAAA,CAAI,EAAI,CAC1C,EAAA,CAAA,EACM,EDzCG,ECyCH,CAAA,CAAA,CAAA,EAAY,CAAgB,CAAA,CAAI,CAAK,CAAA,CDzCf,ACyCgB,CAAA,CAAgB,CAAC,CAAA,CAAA,EAGtD,CAAA,AD1CF,CC0CE,AAGX,IAAA,CAAK,ID3CG,EC2CM,CAAA,EAEd,IAAA,CAAK,GD3CQ,MC2CI,EAAA,EA0Bd,EA1Bc,CAAA,UA2BrB,CACI,IAAI,EAAO,CAAA,CAAA,AACX,EAAe,IAAA,CAAA,MAAK,CAAA,AACpB,EAAe,EAAO,MAAA,CAAA,AAEtB,IAAA,IAAS,CAAI,CAAA,CAAA,CAAG,CAAI,CAAA,EAAQ,GAAK,CAAb,AACpB,CAAA,CACU,IAAA,EAAA,AAAK,CDvDH,ACuDG,CAAA,EAAQ,CAAA,AACb,EAAA,AAAK,CDxDc,ACwDd,CAAA,EAAW,CAAC,CAAA,CAAA,AAId,GAAA,CAHE,AAGF,CAHE,CAAA,AAAQ,CAAI,EAAA,CAAA,EAAK,EAAM,CAAA,AAGpB,CAAA,EAHoB,AAGpB,CAFR,AAEQ,CAFH,CAAA,CAAQ,CAAI,CAAA,CAAA,EAAK,EAAM,CAAA,AAER,CAAA,CAAA,CAG9B,AALsC,CHTtC,MGcO,EAAO,CD1DN,AC0DM,CAAA,AAuBX,gBAAgB,CAAA,CACvB,CAEU,IAAA,EAAa,CDnEX,GCmEgB,CAAA,SAAA,CAAU,GAC5B,EAAc,EAAQ,ADnEpB,CCkEkC,CAAA,CAAA,EACd,EAAtB,EAAsB,CAAU,GAEtC,GAAI,CAAC,EAF0C,AAE/B,CAF+B,CAAA,UAElB,CAAA,GAElB,MAAA,CAAA,CAF6B,CACxC,AAKA,EALA,EAKM,EDtEO,ACsEE,EAAQ,KAAA,CAAA,CAAA,AAEvB,IAAA,IAAS,EAAA,EAAO,CAAA,CAAI,EAAO,IAAA,EAAA,CAAQ,GAAK,CACxC,CAAA,CACU,IAAA,CAAA,CAAA,CAAA,CAAW,CAAC,CAAA,CAAA,AACZ,CAAA,CAAI,CAAO,CAAA,CAAA,CAAI,CAAC,CAAA,CAAA,AAGtB,GAAA,CAAK,IAAA,CAAA,QAAc,CAAA,CAAA,CAAG,CAAC,CACvB,CACW,CADX,MACW,KAAA,IAIR,EAmBJ,KACP,EAAA,CAEU,IAAA,CDtFE,CCsFQ,IAAI,CAAd,CADS,IAAK,CAAA,AACA,CAAQ,KADR,CACc,AADP,CACO,CAAA,GADD,EAAA,CAAA,CAK1B,OAFP,EAAQ,EDvFA,OAAA,CCuFY,IAAK,CAAA,SAAA,CAAA,AAElB,CAAA,CAkBJ,SAAS,CAAA,CAAW,CAAA,CAAA,OAEV,GAIP,EAAS,IAAK,CAAA,MAAA,CAAO,MAAS,CAAA,CAAA,CAAA,IAE3B,IAAA,CHhBF,AGgBE,CHhBF,AGgBM,EAAG,CAAI,CAAA,EAAS,EAAG,CAAI,CAAA,EAAQ,EAAI,CAChD,CADoC,CACpC,CAAA,CACI,IAAM,EAAA,IAAK,CAAK,MAAO,CAAI,CAAC,CAAL,CAAA,CAAK,CAAA,AACtB,EAAK,IAAA,CAAK,MAAQ,CAAI,EAAJ,CAAA,CAAS,CAAC,CAAA,CAAA,AAC5B,EAAK,CDpGH,GCoGG,CAAK,MAAO,CAAI,CAAC,CAAL,CAAA,CAAK,CAAA,AACtB,EAAK,CDrGI,GCqGJ,CAAK,MAAQ,CAAI,EAAJ,CAAA,CAAS,CAAC,CAAA,AAGlC,CAFoB,AADc,EACT,CAAA,EAAQ,EAAK,CAAA,EAAQ,AAG9C,CAHoD,CAAA,CAAa,CAAA,CAAI,CAAA,CAAO,EAAA,EAAA,AAAK,CAAA,CAAQ,CAAA,CAArC,AAAqC,EAAhC,AAAL,CAAK,CAAQ,CAAwB,EAAA,CAAA,AAAxB,CAAA,EAIpD,CAAA,CAAA,SAIV,EAwBJ,eAAe,CAAA,CAAW,CAAW,CAAA,CAAA,CAAqB,EAAY,EAC7E,CAAA,KACU,EAAqB,EAAc,CD9GF,GC+Gb,GAAsB,CAAI,CAAA,CAAA,CAAA,AADX,CAAA,AACW,AAC9C,CAD8C,CAC3B,EAAqB,EAExC,CAAA,MAHoB,CAGpB,CAAA,CAAA,CAAa,GAF2B,CAE3B,AAF2B,CAAA,AAE3B,AACnB,EAAwB,EAAO,IAAP,EAAiB,CAAqB,CAAA,CAArB,AAAqB,CAArB,AAAqB,IAArB,CAAK,SAAA,GAAY,CAAI,KAErD,CAAI,CAAA,CHlBN,AGkBM,CHlBN,AGkBS,CAAI,CAAA,EAAiB,GAAK,CAC1C,CAAA,CACU,IAAA,EAAA,AAAK,CAFK,AD7GK,CC+GH,EAAC,CD/GE,AC+GF,AACb,EDhHe,ACgHV,CDhHU,ACgHH,CAAA,CAAA,CAAI,CAAC,CAAA,CAAA,AACjB,EAAK,CAAA,CAAA,CAAQ,CAAI,EAAA,CAAA,CAAK,EAAO,MAAM,CAAA,CAAA,AACzC,EAAW,CAAA,CAAA,AAAQ,CAAI,GAAA,CAAA,CAAK,EAAO,MAAA,CAAA,CAMnC,GLnUL,AK+T6B,AAIxB,SLnUI,AACZ,CAAW,CAAA,CAAA,CACX,CAAY,CAAA,CAAA,CACZ,CAAA,CAAY,CAEhB,EAAA,IAeQ,EAAA,AACA,AK0SyD,CL3SzD,CACA,CAAA,CAbM,EAAK,IACL,EAAK,EAGT,EAAS,CCLI,ADKA,CAAA,EAAM,CAAI,CAAA,CIgBQ,AHrBlB,ADKU,SAI7B,KACI,EAAA,CANS,CALH,AAKO,CALH,CAAA,CAAA,CAAA,CAAA,AAKG,EAAA,AAJP,CAAI,AGYlB,ADDA,CAAA,CFXkB,CAAA,CAAA,CAAA,CAIa,CAAA,CAMvB,CAAA,EAMA,CC9BF,CD8BU,CACZ,CIkBI,CJjBK,AADT,EACS,IACA,EAAA,CAAA,AACT,CIiBY,CJjBZ,GAEA,EACS,EAAA,AACA,CIgBQ,AJjBR,CACA,EAAA,CAAA,CAKL,CIYQ,CJZR,AAAK,EAAM,EIcH,AJdG,EACX,EAAA,AAAK,EAAM,EAAQ,AIcX,CAAe,AJdJ,EAGvB,IAAA,EAAW,CAAI,AIcH,CJdG,EAAA,AACT,CADS,CACJ,CAAI,AIcF,CJdE,EAAA,AAEP,CAFO,MAEP,EAAK,AAAL,EIaI,AJbQ,EAAA,GKoRyC,CAAA,CAAG,EAAG,EAAI,EAAA,AAAI,EAAI,EAAE,CAAA,CAAA,AAIjD,CAAO,CAAI,CD5GnC,AC0Ga,CAEW,AD/GR,GC6GE,CAAA,IAAA,CAAA,CAAO,EAAK,CD5GlC,CC4GkC,CAAO,GAAI,CAAA,CAAS,CAAA,CAAA,EAAA,AAAK,CAAA,CAAO,EAAA,CAAA,CAAA,AAAI,CAAA,CAAI,CAAA,CAAA,AAEnC,CAFmC,CAEhB,CAAA,CACtD,CAAA,EAAA,IACW,GAIR,CD9GP,AC0Ge,CAAA,AAFwB,ED3G/B,ECiHD,GAqBJ,EArBI,CAAA,OAqBM,CACjB,CAAA,KACI,EAAQ,IAAI,EAAA,SAAU,CAAA,CAEtB,AAFsB,CAAA,AJUN,GIRV,EAAS,IAAK,CAAA,MAAA,CAAA,AAEhB,EAAO,EAAA,EACP,EAAO,CAAA,CADA,AACA,CADA,EAGP,EAAO,EAFA,AAEA,CAFA,CAGX,EAAW,CAAA,CJYS,GIVX,IAAA,CJWuB,GIXvB,CAAA,CAAI,EAAG,CAAI,CAAA,EAAO,IAAP,EAAO,CAAQ,CAAI,CAAA,CAAA,CAAG,GAAK,CAC/C,CAAA,CACU,IAAA,CAAA,CAAI,CAAA,CAAO,CAAC,CAAA,CACZ,AADY,CACZ,CJQ8B,AIR1B,CAAO,CAAA,CAAA,CAAI,CAAC,CAAA,CAAA,AAEf,EAAA,CAAA,AJMqC,CINjC,EAAO,CAAI,CAAA,EACf,EADe,AACf,CADe,AACf,AJMC,CING,EAAO,CAAI,CAAA,EAEf,EAFe,AAEf,CAFe,AAEf,CAAI,EAAO,CAAI,CAAA,EACf,EAAA,AADe,CACf,AADe,CACX,EAAA,EAAW,EASnB,EATmB,CAAA,IAG1B,EAAA,CAAA,AAAQ,CJGwB,AIHxB,EACR,EADQ,AACJ,CADI,AACR,CJEoC,GAAA,CIFxB,EAAO,EAAA,AAEnB,EAFmB,AAEnB,CAFmB,AAEnB,AAAQ,CAAA,EACR,EADQ,AACR,CADQ,AACR,CJDqD,IICrD,CAAa,EAAO,EAAA,AAEb,EAFa,AAmBjB,CAnBiB,AAEb,AJFK,CIEL,OAiBK,CAChB,CAAA,CJZgB,AIgBL,GJhB+C,IIajD,IAAA,CAAA,MAAA,CAAS,EAAQ,IJbF,CIaE,CAAA,CAAO,KAAM,EAAA,CAAA,AACnC,IAAA,CAAK,SAAA,CAAY,EAAQ,CJda,IIcb,IAAA,CAAA,AAElB,IAAA,CAAA,AAiBJ,OAAO,CACd,CAAA,CAGW,OAFP,EAAQ,KAAR,GAAQ,CAAS,IAAI,CAAA,CAAA,AAEd,CAAA,CAIJ,AAHP,KADW,CAAA,EAKX,EAAA,CACI,MAAO,CAAA,iCAAA,EACc,IAAK,CAAA,SAAS,CACnB,OAAA,EAAA,IAAA,CAAK,MAAA,CAAO,MAAO,CAAA,CAAC,EAAY,IAAiB,CAAA,EAAG,CAApB,CAA8B,EAAA,CAA9B,CAAmC,EAAY,CAAA,CAAjB,AAAqB,EAAE,CAAC,CAAA,CAAA,CAAA,CAC1G,AAgBA,AAjB0G,CAAP,GAiB/F,KACJ,EAAA,CACI,OAAO,IAAK,CAAA,MAAA,CAAO,IAAK,CAAA,MAAA,CAAO,MAAA,CAAS,CAAC,CAAA,CAAA,AAC7C,AAeA,IAAI,KACJ,EAAA,CACI,OAAO,IAAK,CAAA,MAAA,CAAO,IAAK,CAAA,MAAA,CAAO,MAAA,CAAS,CAAC,CAAA,CAAA,AAC7C,AAOA,IAAI,CACJ,EAAA,CAKI,SAHA,EAAA,WAAA,EAAY,SAAU,gEAAgE,CAAA,CAAA,AAG/E,IAAK,CAAA,MAAA,CAAO,IAAK,CAAA,MAAA,CAAO,MAAA,CAAS,CAAC,CAAA,CAAA,AAC7C,AAOA,IAAI,CACJ,EAAA,CAKI,SAHA,EAAA,WAAA,EAAY,SAAU,4DAA4D,CAAA,CAAA,AAG3E,IAAK,CAAA,MAAA,CAAO,IAAK,CAAA,MAAA,CAAO,MAAA,CAAS,CAAC,CAAA,CAAA,AAC7C,AAcA,IAAI,MACJ,EAAA,CACW,OAAA,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA,CAAA,AACxB,AAeA,IAAI,MACJ,EAAA,CACW,OAAA,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA,CAAA,AACxB,AACJ,6BJ5hBA,IAAA,EAA6B,CACzB,EACA,EAAA,AACA,EACA,EACA,EACA,EACA,CAFA,CAAA,GAKA,IAAM,EAAK,CDKI,CCLC,CDKD,CAAA,ACJT,CGiBM,AHnBhB,CAEe,CDKI,CCLC,CGoBV,CHnBA,AAHV,EAGqB,CDMX,EKdN,EJQsB,IAAA,CAAM,EAAK,EAAO,AAAP,EAAY,EAAG,CAAA,CAAA,MAEzC,GAAY,CDKb,AKoBV,CAAA,AJzBgC,GAAoB,GAAY,EAAS,EAyBlE,CAzB6C,CAAqB,IAArB,CAyB7C,EAkGH,CDvGA,ICpBqE,CAAA,MA2HzD,CAAI,CAAA,CAAA,CAAG,CGrFO,AHqFH,ADrGvB,CCqGuB,CAAA,CAAG,EAAQ,CAAG,CAAA,EAAS,CAAG,CAAA,EAAZ,AAAqB,EAC1D,CAAA,CAVA,AASiD,IATjD,CAAA,IAAwC,CAAA,mBAWpC,IAAA,CAAK,CAAI,CAAA,CG/DD,AH+DC,CACT,IAAA,CAAK,CAAI,CAAA,CG/DA,AH+DA,CACT,AADS,IACT,CAAK,KAAQ,CAAA,EACb,IAAA,CAAK,MAAS,CAAA,EACd,IAAA,CAAK,KG9DG,CH8DM,CAAA,CAAA,CAClB,AAuBO,IAxBW,CAAA,KAwBD,CACjB,CAAA,CAQW,OAPP,GAAA,CAAA,CGnEQ,CAAA,AHmEA,CAAR,GAAY,EAAA,SAAU,CAAA,CAAA,AAEtB,CAFsB,CAElB,CAAJ,AAAI,CAAI,EGpEA,EHoEK,CAAA,CAAA,CAAA,AACb,EAAI,CAAA,CAAI,EGpEC,EHoEI,CAAA,CAAA,CAAA,AACb,EAAI,CAAJ,GGpEa,CAAA,CHoED,IAAK,CAAA,KAAA,CAAA,AACjB,EAAI,CAAJ,KAAI,CAAS,IAAK,CAAA,MAAA,CAAA,AAEX,CAAA,CAwBJ,AAvBP,AIrBA,CJoBW,CGtEsB,AHsEtB,KAyBX,CACW,CEnCD,CAAA,CC7CE,IHgFD,GG/EE,CH+EE,EAAiB,IAAA,CAAK,CAAG,CAAA,IAAA,CAAK,CAAG,CAAA,IAAA,CAAK,KAAO,CAAA,IAAA,CAAK,MAAQ,CAAA,IAAA,CAAK,MAAM,CAAA,CAAA,AACpF,AEjCA,AFsDO,SAAS,CAChB,CAAA,CAMW,GCjCH,ID4BJ,CIRA,GJQA,CAAK,CAAA,CAAI,EAAU,CAAA,CAAA,AACnB,CC3BW,AACX,CADW,ED2BX,CADmB,AACd,CAAA,CAAI,CGvFD,CCgFD,AJOY,CElCD,AE2BX,AJOY,CAAA,AACnB,IAAA,CAAK,KAAA,CAAQ,EAAU,KAAA,CAAA,IACvB,CAAK,MAAA,CAAS,CElCgB,CFkCN,MAAA,CAAA,AAEjB,CElCD,GFkCC,CC3BgC,AD2BhC,AACX,AAqBO,OAAO,CACd,CAAA,CAGW,CGjGC,MH+FR,EAAU,QAAA,CAAS,IAAI,CAAA,CAAA,AAEhB,CAAA,CAsBJ,EGpHS,KH8FL,CAAA,CAsBK,CAAA,CAAW,CAC3B,CAAA,CACI,GIHU,AJGN,CGxGI,GHwGC,CAAA,KAAA,CIAL,CJAc,CAAK,EAAA,IAAA,CAAK,MAAA,EAAU,CACtC,CACW,CADX,MACW,CGzGH,ACwGA,CJGR,CIDA,EJCI,GAAK,IAAK,CAAA,CAAA,EAAK,GAAK,IAAK,CAAA,CAAA,CAAI,IAAA,CAAK,KACtC,EAAA,AACQ,GAAK,IAAK,CAAA,CAAA,EAAK,GAAK,IAAK,CAAA,CAAA,CAAI,IAAA,CAAK,MACtC,CAAA,KACU,EAAS,CEnCF,IFmCO,GAAA,CAAI,CAAG,CAAA,IAAA,CAAK,GAAA,CAAI,IAAK,CAAA,MAAA,CAAQ,IAAK,CAAA,GAAA,CAAI,IAAA,CAAK,KAAO,CAAA,IAAA,CAAK,MAAM,CAAA,CAAI,CAAC,CAAC,CAAA,CAAA,AAEvF,GAAK,GAAA,IAAU,CAAA,CAAA,CAAI,GAAU,CAAK,EAAA,IAAA,CAAK,CAAA,CAAI,IAAK,CAAA,MAAA,CAAS,GACjD,CAAK,EAAA,IAAA,CAAK,CAAA,CAAI,GAAU,CAAA,EAAK,AAAL,IAAK,CAAK,CAAI,CAAA,IAAA,CAAK,KAAA,CAAQ,MAC3D,EAAA,CACW,EAEP,EAFO,CAAA,CAEP,EAAA,AAAK,CAAK,EAAA,CAAA,GAAA,CAAK,CAAI,CAAA,CAAA,CAAA,CAAA,AACnB,CADmB,CACd,EAAK,KAAA,CAAK,CAAI,CAAA,CAAA,CAAA,CAAA,AACjB,CADiB,CACP,EAAS,ECvBhB,GDyBJ,CAFoB,CAAA,AAEf,EAAA,AAAO,CCxBR,CDwBa,EAAA,CAAO,GAKxB,CADL,CACU,CGpHN,AHmHC,CAHL,AAGU,EAHV,AAGU,IAAA,CAAK,CAAI,CAAA,IAAA,CAAK,KAAQ,CAAA,CAAA,CAAA,CAAA,CAAA,AACtB,EAAA,AAAO,EAAK,EAAA,CAAO,GAKxB,EGvHL,AHuHU,EAAA,AAJV,AAGA,AACiB,CGxHjB,CHoHA,AGpHA,AHwHsB,AADtB,CAAK,CAAK,EAAA,CAAA,GAAA,CAAK,CAAI,CAAA,IAAA,CAAK,MAAS,CAAA,CAAA,CAAA,CAAA,CAAA,AACX,EAAA,CAAO,GAKxB,CADA,CACK,CADL,AEvCb,CFuCa,AAHL,EAGU,AAHV,CAGK,GAAK,CAAK,CAAA,CAAI,CAAA,CAAA,CAAA,CAAA,AACT,CEtCX,CFsCW,AAAO,CGxHb,CHwHkB,EAAA,CAAA,EAbX,OAAA,AAcX,EAMD,OAAA,CAAA,CAwBJ,GAxBI,WAwBW,CAAA,CAAA,CAAY,CAAY,CAAA,CAAA,CAAqB,EAAoB,EACvF,CAAA,CACI,GAAM,GAAE,CAAG,CAAA,GAAA,CAAG,OAAO,QAAA,CAAA,QAAQ,CAAA,CAAW,CAAA,IAAA,CAAA,AAElC,EAAmB,GAAe,CAAI,CAAA,CAAA,CAAA,CAAA,AACtC,CADsC,CACnB,EAAc,EAEjC,AAHA,AAAmB,EAGV,CAAI,CAAA,EACb,CAHiC,CAGxB,CAAI,CADA,AACA,CADA,CAEb,EAJiC,AAIpB,CAJoB,CAIX,AADT,AACkB,CADlB,AACkB,CAAA,EAC/B,EAAc,AADd,AAA+B,EACE,CAAA,CAAT,AAAS,EACjC,EAAa,CADb,AACiB,CADgB,AAChB,EACjB,EAAc,CADG,AACC,CADD,AACC,MAAA,CAAA,CAGxB,CAAM,GAAM,AAAZ,CAAgB,CAAA,GAAoB,EAAM,CAAA,CAAA,CAAI,GACtC,EAAM,CAAA,EADE,AACW,GAAoB,EAAA,CAAM,EAAvC,AAAoD,CAAA,CAC3D,EAAA,EAAA,CAAM,CADkC,EACxB,EAAA,CAAA,AAAM,EAAS,GAMtC,CAAM,GAAM,CAAI,CAAA,EALhB,CAKoC,CALpC,CAK0C,CAAA,CAAA,CAAI,GACtC,EAAM,CAAA,EAAc,GAAoB,EAAA,CAAM,EAAc,CAAtD,AAAsD,CAC7D,EAAA,EAAA,CAAM,CADmC,EACzB,EAAA,CAAA,AAAM,EAAS,GAQjC,EAAK,CIZC,EJYS,EAPpB,AAOoB,AAAK,CIZd,CJKX,AILW,CJaA,EAAqB,CAArB,CAAyB,EAAA,AAAI,EAAQ,EACpC,AIPD,EJOS,AINT,EAEA,AJI2B,EIH3B,EJKH,EAAA,AAAK,AAHF,EAGe,GAAU,EAAK,CAAf,EAAA,AACf,EAAA,CAAA,CAAA,EAAA,EAA0C,EAAQ,EACjD,EADyC,AACjC,EAAkB,IAE9B,AAHG,EAGE,EAAa,GAAU,EAAA,AAAK,CAAL,AAFhB,CAEmC,CAFjB,AAEzB,EACF,EAAqB,CAArB,CAAqB,AAAI,EAAI,AAAJ,EAAiB,EAAQ,EAAc,EAC/D,AADyC,EACjC,AADiC,EAAsB,AACrC,EAA1B,AADD,CAAgE,CAGnE,EAAA,AAAK,GAAU,EAAK,AAAL,CAAA,CAAmB,CAFtB,EAGT,AAH2B,EAGN,CAArB,CAAqB,AAAI,EAAA,AAAI,EAAQ,EAAc,EAAtB,AAC5B,EAAQ,EAD0C,AACxB,EAAgB,CAC1D,AAFkE,AAK3D,CALQ,OAMf,EAAA,CACI,MAAO,CAAoC,iCAAA,EAAA,IAAA,CAAK,CAAC,CAAA,GAAA,EAAM,IAAA,CAAK,CAAC,CAAA,MAAA,EAC9C,IAAK,CAAA,KAAK,CAAW,QAAA,EAAA,IAAA,CAAK,MAAM,CAAA,QAAA,EAAW,IAAA,CAAK,MAAM,CAAA,CAAA,CAAA,CAAA,AACzE,6MS1Y8B,CAAA,CAAA,CAAA,CAA+B,CAAA,CAAiB,CAAA,CAAA,YAGxE,EAAI,EAAE,CAAA,CAAA,AFeM,CKdsC,CHA9C,CCJ4C,CDI5C,CAAA,KACE,CAAA,gCAKD,oBAC2B,CAAA,AYqGgD,cZjGtF,IAAA,EAAA,EAAA,EAAA,EAAA,IACA,CKKkC,ACRA,UNIN,CAAA,EACd,CAAA,CAAA,EAAiB,EAAA,UAEE,EAAI,CAAK,CAAA,EAAA,MACpB,CUwBI,CAAA,CAAA,EVxBW,EAAA,EAAS,EAAA,CAAA,wCOxB3B,CTsBN,CAAA,CIRK,CAAA,EAAA,MAAA,sBKRf,yBAGI,WAAA,CAAA,eAIA,QAAA,CAAA,wEAcoB,gBACJ,CAAA,wCAMM,GAAA,yCAKA,CAAA,QAAA,eAKzB,OAAA,IAAA,CAAA,YAAA,CAAA,OAAA,KAGA,CEKE,UAAA,6BFHqB,CAAK,cAC5B,EAAA,6BAC2B,CAAA,AAGpB,CJXC,AL4BR,CM1BY,CSHhB,UNeI,CJXI,MAAA,OIaQ,CJZI,AOuBF,GAAA,CAAA,SAAA,GHVD,CJZG,EIYI,EAAA,CHRX,CAAA,KAAA,EAAA,CAAA,IAAA,CAAA,GGQmD,GACtD,EAAa,IAAK,CAAA,UAAA,kCAIK,CJZL,ASyPO,CAAA,EL7Oc,UAAU,GAC/C,IAAK,CAAA,KAAA,CAAQ,EAAW,QAAA,EAAA,CAAa,GAAQ,EAAA,EAAA,CAAA,CAAA,CAAA,EAGjC,IAAL,IAAA,CAAK,KAAA,EAAA,EAAA,6BAKb,CAAA,UAAA,EAAA,gBAAmC,EJfK,OIkBrC,CACd,CAAA,CJjB0B,EIkBZ,WAAA,CAAA,IAAmB,CAAA,WAAA,iBACF,CAAA,SAAA,CAAA,EAEjB,eAAA,CAAA,IAAuB,CAAA,eAAA,CAAA,oBACF,CAAA,CK2O/B,KAAA,GRjP2C,IGMZ,CAAA,AHNY,YGQrB,IAAA,CAAA,SAAA,aACC,CAAA,KAAA,GAEb,CJdV,MAAA,CIcoB,IAAK,CAAA,OAAA,CAAA,AACzB,EAAU,YAAA,CAAA,IAAoB,CAAA,YAAA,CAAA,EAEpB,QAAA,CAAW,EE2BQ,CAAI,CF3BP,CAAA,QAAA,CAAA,OAI9B,KACI,CAAA,cAAsB,EAAA,MACtB,CAAA,UAAkB,CMEH,ANFG,KAClB,IAAA,CAAA,QAAgB,CAAA,gBAGb,SACP,gBACsB,CAAA,GE0BM,CF1BN,cACH,0CAEC,oEJnGoC,2FAgBjC,kBAAA,CAKf,GAAA,CADA,CMcE,CAAA,EAAA,EAAA,MNde,AMcf,GNbQ,sBAKC,eAIN,YAAA,EAAA,IAAA,CACT,CAKQ,KAJJ,AAEK,EAAA,SAAQ,CACb,EAHA,AAGK,EAAA,UAAA,CACD,GAAA,GAAW,GAAM,GACrB,COoB6B,SPjBzB,AARJ,EAQI,CAAA,GARJ,EASY,CAAA,CACZ,EAAA,EAAA,aAKkB,EAAA,KAAoB,CAAA,MACP,MAAA,CAAS,CAAA,CAAA,UAFpB,EAKJ,CAAA,CAAI,CCME,AKqCJ,CN1ClB,CUQA,CAAA,EAAA,KAAA,GVRmB,CAAA,EAAA,KAAA,GAAA,CAAY,EAAA,MAAY,CAAQ,GM4CG,AF7BhB,CJfkB,AM4CF,AF7BhB,CAAA,GJfkB,CAAI,EAAW,OAAA,EACtD,CADgE,CAAC,CAAC,CAE9E,EAAa,OAGb,GAAK,EAAK,AAAL,EAEH,MAAA,CAAA,aAII,IAAA,CAAA,IAAW,KAAA,IAAU,CAAA,EAAK,IACnC,EAAA,AAAS,EAAT,EAAS,AAAW,CAAI,GAAf,EAAe,AAAW,CAAI,ACQF,GDRb,WAInB,MAAA,CAAA,EAGX,EUkBJ,CAAA,AVlBc,GACV,CUiBJ,SVhBQ,CAAA,CAAO,CAAC,CAAA,CAAA,CAAW,CAAA,CAAC,CAAA,CAAI,CAAI,CAAA,EAAA,AAC5B,CAAA,AAD4B,CACrB,EAAA,CAAK,CAAO,CAAA,EAAA,CAAA,EAAS,EAAA,CAAA,AAC5B,CAAA,EAAQ,CAAI,CAAO,CAAA,CAAC,AIeN,CAAA,CJfU,CAAI,CAAA,EAAA,CAAA,AAC5B,CAAO,CSsPR,ATtPS,AQMhB,CAAA,CRNoB,CAAO,CAAA,CAAC,CAAA,CAAA,EAAQ,CIehB,CJfgB,AIehB,CJfgB,YAMlB,EAAJ,CAAA,CAAe,IAAL,AAAS,EAAK,QAEzB,CAAA,CAAA,EAEA,EAAK,IACL,EAAA,AACL,EAAK,CAAI,CAAA,EAAA,CAAA,CSuPjB,ETtPiB,MACA,KAEb,CAAA,CAAO,IAAQ,CAAA,QACA,CAAA,GACR,CAAA,EAAA,EAAA,CAAQ,CSuPD,CTvPC,ASuPD,CTtPP,CAAA,EAAA,EAAA,CAAA,WAIQ,EAAA,GAEX,CAAO,CUmBA,GAAA,CVnBQ,EAAA,AACf,CADe,AACf,CAAO,IAAA,CAAA,EACA,CAAA,CAAA,EAAE,EAAMC,CAAAA,GAAAA,AACR,CADQA,AM6DT,AN5DC,CM4DD,CN5DC,EAAA,CAAQ,EAGnB,IAAA,IAAS,CAAI,CAAA,CAAA,CMgET,ANhEY,CAAI,AUiBlB,CAAA,EVjBqB,CACvB,EAAA,CAAA,CACI,IAAM,CAAI,CAAA,KAAK,EAAK,CAAA,EAAK,CAAI,GAAA,CAAA,CACvBC,AADuB,CAAA,CAClB,EAAA,AAAM,AUgBG,CJ+CS,AG0LZ,ACzOG,IVhBE,GAAA,CAAI,CAAC,CAAI,CAAA,EAAA,AACzBC,CADyB,CACpB,EAAA,AAAM,GMgEP,CNhEY,CAAA,GAAA,CAAA,GAAS,EACzBC,AADyB,CAAA,CACpB,CAAIF,CAAAA,CUiBS,CAAA,AVhBlBG,EM8DsC,AN9DtCA,EAASH,EACTI,EUmBd,CAAA,CVnBuBH,EACTF,EAAK,CUoBnB,AJ8CoB,ANlEGE,CAAAA,EAEf,CAAA,CAAO,EUmBf,EAAA,CAAA,GVlBQ,CAAO,IAAQG,CAAAA,EACR,CAAA,CAAA,EAAE,EAAE,CAAIA,EACR,CADQA,AACR,CAAA,EAAE,EAAE,AAAID,CAAAA,GACf,CAAA,IAAA,CAAeA,IACR,IAAA,CAAA,IACA,EAAE,EAAMJ,CAAAA,EACR,CAAA,CAAA,EAAA,EAAA,CAAA,IAGN,IACA,CMyEE,CNzEG,CQkDN,GRjDC,EAAI,IACJ,EAAI,EAAA,CAAA,CACJ,CQmDG,CRnDH,MACC,EAAK,EAAI,EAAA,CAAA,ASoQD,QTlQP,IAAQ,CAAA,EAAA,CAAA,AACf,CAAA,IAAe,CQsDP,GRrDD,CAAA,EAAA,EAAA,CAAA,GACA,CAAA,EAAA,EAAA,CAAQ,OAIX,CAAA,IAAA,CAAA,GACA,CAAO,IAAA,CAAA,GACA,CAAA,EAAE,EAAA,CAAA,GACF,CAAA,EAAE,EAAM,CAAA,oBAMH,CM4EH,CN5EG,CAAU,CAAgB,CAAA,CAAA,CAAgB,CAAA,CAAS,CACvE,EAAA,AACQ,GAAA,GACJ,CADI,EAAA,AU8C8B,MV9C9B,QAMJ,IAAI,EAAA,IACU,CAAA,CAEd,AAFc,CU6CQ,GV3CtB,IAAS,EAAI,CMyER,ANzEW,CAAA,EAAI,EAAO,MAAA,CAAQ,GAAK,CACxC,CAAA,AACI,CMwEC,EAAA,CAAA,CNxEiB,EAAC,CAAA,AACR,CU+CX,EV/CW,CQqDR,CRrDe,CMyEZ,CAAA,CI7BgB,CJ6BhB,CNvEV,GAAY,CU+CO,CV/CA,MAAS,CAAA,KAChB,EM2EhB,CAAA,KN3EgC,CAAA,QAGhB,GAEH,CAAA,EAAQ,CMyEC,CNzEiB,CU6CJ,AV7CI,AAA1B,CU6CH,EV5CI,CAAA,EAAQ,CADiB,CAAA,AACC,CMyEb,ANzEb,CAA0B,CAAK,QACrB,QAGpB,IAAA,EAAa,CMuES,ANvEN,CAAA,EAAI,CU8CM,CV9CC,CMuEL,KNvEK,CAAQ,GQoDT,ARpDc,CQoDd,ARnD1B,CAAA,EU6C0B,IV5Ca,CAAA,CAAA,CU8CI,AV9CG,CAAC,CAAA,EAC3C,CAAU,EAAQ,EAAkB,CAAC,CAAA,CAAI,CAAA,CAAO,EAAI,AMsElC,CNtEmC,CAAA,CAAA,AAErD,EAAQ,CACR,IACI,CAAA,IAA2B,CAAA,EAC3B,CAAA,CQmDwB,ARnDxB,CAD2B,AQoDH,GRnDxB,CAA2B,EACnB,CAAA,CAAA,IAAA,CAAmB,EAAQ,CUgDf,AVhDe,CAAA,MAMnC,CAAA,IAAe,CAAA,EAAA,GACvB,CAAA,IAAA,CAAA,GACQ,CAAA,CQyDJ,GAAA,CRzDuB,EAAA,IAMtB,CMkEH,CAAA,CNlEoB,GAAG,CQwDA,CCwMA,ADxMA,ARxDa,SAAA,CAAW,CAAE,GAAG,EAAY,SAAA,CAAW,IAAM,CAAA,SAAA,CAAY,EAAA,AAE1F,EAAwB,CAAE,GAAG,CAAa,WAAW,CAAE,GAAG,EAAY,GQ2DjB,MR3DiB,MAAiB,kBAAA,CAAqB,4BMpMhH,EAAA,CAAA,CAAA,CAAA,CAGL,CAAA,CAAA,CAAA,CAAA,CAGA,CAAA,CAAA,CACA,CAAA,CACA,CAEJ,EAAA,IAOQ,CHlBJ,iCGiCY,MAAK,IApBN,AAqBC,CTpCC,CSeG,EAAA,EAqBJ,EACN,EAAM,EArBI,EAAA,EAqBJ,IACA,EArBI,CLhBK,CAAA,EKqCT,SAGN,CFNN,CAAA,IAAA,CAAA,EAAA,KEOM,IAAA,CAAA,EAAA,mBAwBN,CAAA,CAAA,CAAA,CAAA,CAAA,CAGA,CAAA,CAAA,CACA,CAAA,CAAA,CAGJ,EAAA,CCpBmE,ODqB3C,IACL,EAAA,EAEf,EAAa,KAAK,CIzCR,IJyCc,CAAA,EAAA,GACpB,CNzCI,CMyCK,KAAA,KAAK,CAAA,EAAA,EAAA,EAAA,aAIJ,AAAU,GADxB,IACc,EAAA,OAEkB,OAER,CADxB,CACc,CClBV,IDkBe,EAAK,EAGxB,CCnBA,GAAA,EAAA,EHVA,EE8BkB,EAAS,EAGrB,EAAS,GN5CG,EM4CE,IAAA,CAAA,EAAe,EAAW,EAAS,GF5BvD,EAAA,CAAA,GE0BM,KAAA,GAAoB,CAAI,EInClB,CJsC2B,KAAK,IAAA,CAAK,GAAU,IAAK,CAAA,EAAA,EAAO,CAAK,CAAA,CAAA,CAAA,AAC5E,EAAiB,EAAA,EAIjB,QAAA,EACA,GACU,IAAA,CAAK,EAAI,KACT,IAAA,CAAK,EAAI,EAAE,KAER,IAAA,EAAA,EAAO,EAAA,EAAA,EAAA,EAAA,IAAuC,GAAS,EAEtD,CG4MT,CAAA,IH5MS,CAAK,AADf,EACmB,GACT,EAAA,CF7BV,GE6BU,CAAA,EAAY,KAAA,GAAS,CAAA,GAAS,EAAA,EAAA,KACpB,GAAI,CAAA,GAAS,KAG3B,CAH2B,GAG3B,CAAK,EAAA,KACL,IAAA,CAAA,EAAA,OAGV,GACU,EItBL,EJsBK,CAAA,EAAA,KACA,IAAA,CAAA,EAAS,EAAE,CAAA,UAEJ,EAAG,EAAQ,EAAY,EAAI,EAAU,CAAA,EAAA,CAAK,EAAL,CAAc,EAEtD,EAAA,IADV,AACU,CADV,AACU,EAAA,KAAiB,GAAA,CAAA,GAAa,EAAA,EAAA,KACpB,GAAA,CAAA,GAAA,GACV,EAAA,IAAA,CAAK,EAAA,KAGT,IAAA,CAAK,EAAA,KACL,IAAA,CAAK,EAAA,UAGG,IZpJP,SAAS,EAAO,CAAI,CAAE,CAAW,CAAE,EAAM,CAAC,EAErD,IAOI,EAAM,EAAM,EAPV,EAAW,GAAe,EAAY,MAAM,CAC5C,EAAW,EAAW,CAAW,CAAC,EAAE,CAAG,EAAM,EAAK,MAAM,CAC1D,EAAY,EAAW,EAAM,EAAG,EAAU,GAAK,GAC7C,EAAY,EAAE,CAEpB,GAAI,CAAC,GAAa,EAAU,IAAI,GAAK,EAAU,IAAI,CAAE,OAAO,EAO5D,GAHI,IAAU,EAuPlB,AAvP8B,SAuPrB,AAAe,CAAI,CAAE,CAAW,CAAE,CAAS,CAAE,CAAG,EACrD,IAAM,EAAQ,EAAE,CAEhB,IAAK,IAAI,EAAI,EAAG,EAAM,EAAY,MAAM,CAAE,EAAI,EAAK,IAAK,CACpD,IAAM,EAAQ,CAAW,CAAC,EAAE,CAAG,EACzB,EAAM,EAAI,EAAM,EAAI,CAAW,CAAC,EAAI,EAAE,CAAG,EAAM,EAAK,MAAM,CAC1D,EAAO,EAAW,EAAM,EAAO,EAAK,GAAK,GAC3C,IAAS,EAAK,IAAI,GAAE,EAAK,OAAO,EAAG,CAAA,EACvC,EAAM,IAAI,CAkMlB,AAlMmB,SAkMV,AAAY,CAAK,EACtB,IAAI,EAAI,EACJ,EAAW,EACf,GAAG,AACK,EAAE,CAAC,CAAG,EAAS,CAAC,EAAK,EAAE,CAAC,GAAK,EAAS,CAAC,EAAI,EAAE,CAAC,CAAG,GAAS,AAAC,IAAG,EAAW,GAC7E,EAAI,EAAE,IAAI,OACL,IAAM,EAAO,AAEtB,OAAO,CACX,EA3M+B,GAC3B,CAEA,EAAM,IAAI,CAAC,GAGX,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAAK,AACnC,EAAY,AAsBpB,SAAS,AAAc,CAAI,CAAE,CAAS,EAClC,IAAM,EAAS,AAanB,SAAwB,AAAf,CAAmB,CAAE,CAAS,EACnC,IAII,EAJA,EAAI,EACF,EAAK,EAAK,CAAC,CACX,EAAK,EAAK,CAAC,CACb,EAAK,CAAC,IAMV,GAAI,EAAO,EAAM,GAAI,OAAO,EAC5B,EAAG,CACC,GAAI,EAAO,EAAM,EAAE,IAAI,EAAG,OAAO,EAAE,IAAI,CAClC,GAAI,GAAM,EAAE,CAAC,EAAI,GAAM,EAAE,IAAI,CAAC,CAAC,EAAI,EAAE,IAAI,CAAC,CAAC,GAAK,EAAE,CAAC,CAAE,CACtD,IAAM,EAAI,EAAE,CAAC,CAAG,AAAC,GAAK,EAAE,CAAC,GAAK,CAAD,CAAG,IAAI,CAAC,CAAC,CAAG,EAAE,CAAC,GAAK,CAAD,CAAG,IAAI,CAAC,CAAC,CAAG,GAAE,AAAC,EAC/D,GAAI,GAAK,GAAM,EAAI,IACf,AADmB,EACd,EACL,EAAI,EAAE,CAAC,CAAG,EAAE,IAAI,CAAC,CAAC,CAAG,EAAI,EAAE,IAAI,CAC3B,IAAM,GAAI,OAAO,CAE7B,CACA,CAHgC,CAG5B,EAAE,IAAI,AACd,OAAS,IAAM,EAEf,AAF0B,GAEtB,CAAC,EAAG,OAAO,KAMf,IAAM,EAAO,EACP,EAAK,EAAE,CAAC,CACR,CAdmF,CAc9E,EAAE,CAAC,CACV,EAAS,IAEb,EAAI,EAEJ,EAAG,CACC,GAAI,GAAM,EAAE,CAAC,EAAI,EAAE,CAAC,EAAI,GAAM,IAAO,EAAE,CAAC,EAChC,EAAgB,EAAK,EAAK,EAAK,EAAI,EAAI,EAAI,EAAI,EAAK,EAAK,EAAK,EAAI,EAAI,EAAE,CAAC,CAAE,EAAE,CAAC,EAAG,KAkBnE,CAAC,GAhBnB,IAAM,EAAM,KAAK,GAAG,CAAC,EAAK,EAAE,CAAC,GAAK,CAAD,CAAM,GAAE,AAAC,EAEtC,CAFyC,CAE3B,EAAG,KAChB,EAAM,EAAP,CAHsD,AAGpC,IAAQ,IAAW,EAAE,CAAC,CAAG,EAAE,AAAT,CAAU,EAAK,EAAE,CAAC,GAAK,EAAE,CAAC,IAAI,CAAqB,EAatE,CAAC,CAbwE,EAcrE,EAA1B,EAAK,EAAE,IAAI,CAAE,EAAG,EAAE,IAAI,GAAmC,EAA1B,EAAK,EAAE,IAAI,CAAE,EAAG,EAAE,IAAI,EAd0C,CAAG,CAAE,GAAG,AAClG,EAAI,EACJ,EAAS,EAEjB,CAEA,EAAI,EAAE,IAAI,AACd,OAAS,IAAM,EAAM,AAErB,OAAO,CACX,EAnEkC,EAAM,GACpC,GAAI,CAAC,EACD,MADS,CACF,EAGX,IAAM,EAAgB,EAAa,EAAQ,GAI3C,OADA,EAAa,EAAe,EAAc,IAAI,EACvC,EAAa,EAAQ,EAAO,IAAI,CAC3C,EAjCkC,CAAK,CAAC,EAAE,CAAE,GAGxC,OAAO,CACX,EA1Q6C,EAAM,EAAa,EAAW,EAAA,EAGnE,EAAK,MAAM,CAAG,GAAK,EAAK,CACxB,EAAO,CAAI,CAAC,EAAE,CACd,EAAO,CAAI,CAAC,EAAE,CACd,IAAI,EAAO,EACP,EAAO,EAEX,IAAK,IAAI,EAAI,EAAK,EAAI,EAAU,GAAK,EAAK,CACtC,IAAM,EAAI,CAAI,CAAC,EAAE,CACX,EAAI,CAAI,CAAC,EAAI,EAAE,CACjB,EAAI,IAAM,EAAO,GACjB,EAAI,IAAM,EAAO,GACjB,EAAI,GAAM,GAAO,GACjB,EAAI,IAAM,GAAO,CACzB,CAIA,EAAU,AAAY,KADtB,EAAU,KAAK,GAAG,CAAC,EAAO,EAAM,EAAO,EAAA,EACb,MAAQ,EAAU,CAChD,CAIA,OAFA,AAgDJ,SAAS,EAAa,CAAG,CAAE,CAAS,CAAE,CAAG,CAAE,CAAI,CAAE,CAAI,CAAE,CAAO,CAAE,CAAI,EAChE,GAAI,CAAC,EAAK,MAGN,EAAC,GAAQ,GA6RjB,AA7R0B,SA6RjB,AAAW,CAAK,CAAE,CAAI,CAAE,CAAI,CAAE,CAAO,EAC1C,IAAI,EAAI,EACR,GACQ,AADL,AACa,MAAN,CAAC,GAAQ,EAAE,CAAC,CAAG,EAAO,EAAE,CAAC,CAAE,EAAE,CAAC,CAAE,EAAM,EAAM,EAAA,EAClD,EAAE,KAAK,CAAG,EAAE,IAAI,CAChB,EAAE,KAAK,CAAG,EAAE,IAAI,CAChB,EAAI,EAAE,IAAI,OACL,IAAM,EAAO,AAEtB,EAAE,KAAK,CAAC,KAAK,CAAG,KAChB,EAAE,KAAK,CAAG,KAEV,AAKJ,SAAS,AAAW,CAAI,EAEpB,IADI,EACA,EAAS,EAEb,EAAG,CACC,IACI,EADA,EAAI,EAER,EAAO,KACP,IAAI,EAAO,KAGX,IAFA,EAAY,EAEL,GAAG,CACN,IACA,IAAI,EAAI,EACJ,EAAQ,EACZ,IAAK,IAAI,EAAI,EAAG,EAAI,IAChB,IACA,EAAI,EAAE,KAAK,EAFa,IAAK,CAKjC,IAAI,EAAQ,EAEZ,KAAO,EAAQ,GAAM,EAAQ,GAAK,EAAI,CAEpB,IAAV,CAAe,GAAW,IAAV,GAAe,CAAC,GAAK,EAAE,CAAC,EAAI,GAAE,AAAC,GAAG,AAClD,EAAI,EACJ,EAAI,EAAE,KAAK,CACX,MAEA,EAAI,EACJ,EAAI,EAAE,KAAK,CACX,KAGA,EAAM,EAAK,KAAK,CAAG,EAClB,EAAO,EAEZ,EAAE,KAAK,CAAG,EACV,EAAO,EAGX,EAAI,CACR,CAEA,EAAK,KAAK,CAAG,KACb,GAAU,CAEd,OAAS,EAAY,EAGzB,AAH4B,EApDb,EACf,EA1SqC,EAAK,EAAM,EAAM,GAElD,IAAI,EAAO,EAGX,KAAO,EAAI,IAAI,GAAK,EAAI,IAAI,EAAE,CAC1B,IAAM,EAAO,EAAI,IAAI,CACf,EAAO,EAAI,IAAI,CAErB,GAAI,EAAU,AA+DtB,SAAS,AAAY,CAAG,CAAE,CAAI,CAAE,CAAI,CAAE,CAAO,EACzC,IAAM,EAAI,EAAI,IAAI,CAEd,CADA,CACI,EAAI,IAAI,CAEhB,GAAI,EAAK,GAAG,CAAG,IAAM,EAAG,OAAO,EAE/B,IAAM,CAFgC,CAE3B,EAAE,CAAC,CAAE,EAAK,EAAE,CAAC,CAAE,EAAK,EAAE,CAAC,CAAE,EAAK,EAAE,CAAC,CAAE,EAAK,AAL3C,CAGwD,CAEX,CAAC,CAAE,EAAK,EAAE,CAAC,CAG1D,EAAK,KAAK,GAAG,CAAC,EAAI,EAAI,GACxB,EAAK,KAAK,GAAG,CAAC,EAAI,EAAI,GACtB,EAAK,KAAK,GAAG,CAAC,EAAI,EAAI,GACtB,EAAK,KAAK,GAAG,CAAC,EAAI,EAAI,GAGpB,EAAO,EAAO,EAAI,EAAI,EAAM,EAAM,GACpC,EAAO,EAAO,EAAI,EAAI,EAAM,EAAM,GAElC,EAAI,EAAI,KAAK,CACb,EAAI,EAAI,KAAK,CAGjB,KAAO,GAAK,EAAE,CAAC,EAAI,GAAQ,GAAK,EAAE,CAAC,EAAI,GAAM,CACzC,GAAI,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAAM,IAAM,GAAK,IAAM,GACrE,EAA2B,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAE,CAAC,CAAE,EAAE,CAAC,GAAK,EAAK,EAAE,IAAI,CAAE,EAAG,EAAE,IAAI,GAAK,IAC/F,EAAI,EAAE,KAAK,CAEP,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAAM,IAAM,GAAK,IAAM,GACrE,EAA2B,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAE,CAAC,CAAE,EAAE,CAAC,GAAK,EAAK,EAAE,IAAI,CAAE,EAAG,EAAE,IAAI,GAAK,GAJG,AAIA,OAJO,AAIA,EACzG,EAAI,EAAE,KAAK,AACf,CAGA,KAAO,GAAK,EAAE,CAAC,EAAI,GAAM,CACrB,GAAI,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAAM,IAAM,GAAK,IAAM,GACrE,EAA2B,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAE,CAAC,CAAE,EAAE,CAAC,GAAK,EAAK,EAAE,IAAI,CAAE,EAAG,EAAE,IAAI,GAAK,EAAG,OAAO,EACzG,EAAI,EAAE,KAAK,AACf,CAGA,KAAO,GAAK,EAAE,CAAC,EAAI,GAAM,CACrB,GAAI,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAAM,IAAM,GAAK,IAAM,GACrE,EAA2B,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAE,CAAC,CAAE,EAAE,CAAC,GAAK,EAAK,EAAE,IAAI,CAAE,EAAG,EAAE,IAAI,GAAK,EAAG,OAAO,EACzG,EAAI,EAAE,KACV,AADe,CAGf,OAAO,CACX,EA/GkC,EAAK,EAAM,EAAM,GAoCnD,AApC8D,SAoC/C,AAAN,CAAS,EACd,IAAM,EAAI,EAAI,IAAI,CAEd,CADA,CACI,EAAI,IAAI,CAEhB,GAAI,EAAK,EAHD,CAGI,CAAG,IAAM,EAAG,OAAO,EAG/B,IAAM,CAHgC,CAG3B,EAAE,CAAC,CAAE,EAAK,EAAE,CAAC,CAAE,EAAK,EAAE,CAAC,CAAE,EAAK,EAAE,CAAC,CAAE,EAAK,CAHa,CAGX,CAAC,CAAE,EAAK,EAAE,CAAC,CAG1D,EAAK,KAAK,GAAG,CAAC,EAAI,EAAI,GACxB,EAAK,KAAK,GAAG,CAAC,EAAI,EAAI,GACtB,EAAK,KAAK,GAAG,CAAC,EAAI,EAAI,GACtB,EAAK,KAAK,GAAG,CAAC,EAAI,EAAI,GAEtB,EAAI,EAAE,IAAI,CACd,KAAO,IAAM,GAAG,CACZ,GAAI,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAAM,EAAE,CAAC,EAAI,GAC9C,EAA2B,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAE,CAAC,CAAE,EAAE,CAAC,GAC3D,EAAK,EAAE,IAAI,CAAE,EAAG,EAAE,IAAI,GAAK,EAAG,MAAO,GACzC,EAAI,EAAE,IAAI,AACd,CAEA,OAAO,CACX,EA7DoE,GAAM,CAC9D,EAAU,IAAI,CAAC,EAAK,CAAC,CAAE,EAAI,CAAC,CAAE,EAAK,CAAC,EAEpC,CAFuC,CAE5B,GAGX,EAAM,EAAK,IAAI,CACf,EAAO,EAAK,IAAI,CAEhB,CAR8D,OASlE,CAKA,GAHA,AAGI,GAHE,CAAA,IAGM,EAAM,CAET,EAIM,AAAS,GAAG,CAJZ,EAMP,EADA,EAAM,AA4FtB,SAAS,AAAuB,AA3FH,CA2FQ,CAAE,CAAS,EAC5C,IAAI,EAAI,EACR,EAAG,CACC,IAAM,EAAI,EAAE,IAAI,CACZ,EAAI,EAAE,IAAI,CAAC,IAAI,AAEf,EAAC,EAAO,EAAG,IAAM,EAAW,EAAG,EAAG,EAAE,IAAI,CAAE,IAAM,EAAc,EAAG,IAAM,EAAc,EAAG,IAAI,CAE5F,EAAU,IAAI,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC,CAAE,EAAE,CAAC,EAG5B,EAAW,GACX,EAAW,EAAE,IAAI,EAEjB,EAAI,EAAQ,GAEhB,EAAI,EAAE,IAAI,AACd,OAAS,IAAM,EAAO,AAEtB,OAAO,EAAa,EACxB,EAhH6C,EAAa,GAAM,GAC9B,EAAW,EAAK,EAAM,EAAM,EAAS,GAGvC,GAAG,CAAZ,GACP,AA8GhB,SAAS,AAAY,CAAK,CAAE,CAAS,CAAE,CAAG,CAAE,CAAI,CAAE,CAAI,CAAE,CAAO,EAE3D,IAAI,EAAI,EACR,EAAG,CACC,IAAI,EAAI,EAAE,IAAI,CAAC,IAAI,CACnB,KAAO,IAAM,EAAE,IAAI,EAAE,SACjB,GAAI,EAAE,CAAC,GAAK,EAAE,CAAC,GAsPF,CAtPM,AAsPL,CAtPqB,EAsPnB,CAAC,CAtPqB,EAuPvC,EAAE,IAAI,CAAC,CAAC,GAAK,EAAE,CAAC,EAAI,EAAE,IAAI,CAAC,CAAC,GAAK,EAAE,CAAC,EAAI,CAAC,AA2CpD,SAAS,AAAkB,CAAC,CAAE,CAAC,EAC3B,IAAI,EAAI,EACR,EAAG,CACC,GAAI,EAAE,CAAC,GAAK,EAAE,CAAC,EAAI,EAAE,IAAI,CAAC,CAAC,GAAK,EAAE,CAAC,EAAI,EAAE,CAAC,GAAK,EAAE,CAAC,EAAI,EAAE,IAAI,CAAC,CAAC,GAAK,EAAE,CAAC,EAC9D,EAAW,EAAG,EAAE,IAAI,CAAE,EAAG,GAAI,OAAO,EAC5C,EAAI,EAAE,IACV,AADc,OACL,IAAM,EAAG,AAElB,OAAO,CACX,EApDsE,EAAG,KAC7D,CADmE,CACrD,EAAG,IAAM,EAAc,EAAG,IAAM,AA6D1D,SAAS,AAAa,CAAC,CAAE,CAAC,EACtB,GA/D2G,CA+DvG,EAAI,EACJ,GAAS,EACP,EAAK,CAAC,EAAE,CAAC,CAAG,GAAE,AAAC,EAAI,EACnB,EAAK,CAAC,EAAE,CAAC,CAAG,EAAE,CAAC,EAAI,EACzB,GAAG,AACO,EAAE,CAAC,CAAG,GAAS,EAAE,IAAI,CAAC,CAAC,CAAG,GAAQ,EAAE,IAAI,CAAC,CAAC,GAAK,EAAE,CAAC,EAC/C,EAAK,CAAC,EAAE,IAAI,CAAC,CAAC,CAAG,EAAE,CAAC,EAAK,EAAD,CAAM,GAAE,AAAC,GAAK,CAAD,CAAG,IAAI,CAAC,CAAC,CAAG,GAAG,AAAD,EAAK,EAAE,CAAC,GAChE,EAAS,CAAC,CAAA,EACd,EAAI,EAAE,IAAI,OACL,IAAM,EAEf,AAFkB,OAEX,CACX,EA1EuE,EAAG,KAC7D,CADmE,CAC9D,EAAE,IAAI,CAAE,EAAG,EAAE,IAAI,EAD+D,CAC1D,EAAK,EAAG,EAAE,IAAI,CAAE,EAAA,CAAE,EAC9C,EAAO,CAD4C,CACzC,IAAM,EAAK,EAAE,IAAI,CAAE,EAAG,EAAE,IAAI,EAAI,GAAK,EAAK,EAAE,IAAI,CAAE,EAAG,EAAE,EAD4B,EACxB,GAAI,CAAC,EA1PhC,CA0PmC,AAxPzE,IAAI,EAAI,EAAa,EAAG,GAGxB,EAAI,EAAa,EAAG,EAAE,IAAI,EAC1B,AAoPoG,EApPhG,EAAa,EAAG,EAAE,IAAI,EAG1B,EAAa,EAAG,EAAW,EAAK,EAAM,EAAM,EAAS,GACrD,EAAa,EAAG,EAAW,EAAK,EAAM,EAAM,EAAS,GACrD,MACJ,CACA,EAAI,EAAE,IAAI,AACd,CACA,EAAI,EAAE,IAAI,AACd,OAAS,IAAM,EAAO,AAC1B,EArI4B,EAAK,EAAW,EAAK,EAAM,EAAM,GAT7C,EAAa,EAAa,GAAM,EAAW,EAAK,EAAM,EAAM,EAAS,GAYzE,KACJ,CACJ,CACJ,EA9FiB,EAAW,EAAW,EAAK,EAAM,EAAM,EAAS,GAEtD,CACX,CAGA,SAAS,EAAW,CAAI,CAAE,CAAK,CAAE,CAAG,CAAE,CAAG,CAAE,CAAS,EAChD,IAAI,EAEJ,GAAI,IAAe,AAimBvB,SAAS,AAAW,CAAI,CAAE,CAAK,CAAE,CAAG,CAAE,CAAG,EACrC,IAAI,EAAM,EACV,IAAK,IAAI,EAAI,EAAO,EAAI,EAAM,EAAK,EAAI,EAAK,GAAK,EAC7C,EADkD,CAC3C,CAAC,CAAI,CAAC,EAAE,CAAG,CAAI,CAAC,EAAA,AAAE,GAAK,CAAD,AAAK,CAAC,EAAI,EAAE,CAAG,CAAI,CAAC,EAAI,EAAA,AAAE,EACvD,EAAI,EAER,OAAO,CACX,EAxmBkC,EAAM,EAAO,EAAK,GAAO,EACnD,CADuD,GAClD,IAAI,EAAI,EAAO,EAAI,EAAK,GAAK,EAAK,EAAO,EAAW,EAAI,EAAM,EAAG,CAAI,CAAC,EAAE,CAAE,CAAI,CAAC,EAAI,EAAE,CAAE,QAE5F,IAAK,IAAI,EAAI,EAAM,EAAK,GAAK,EAAO,GAAK,EAAK,EAAO,EAAW,EAAI,EAAM,EAAG,CAAI,CAAC,EAAE,CAAE,CAAI,CAAC,EAAI,EAAE,CAAE,GAQvG,OALI,GAAQ,EAAO,EAAM,EAAK,IAAI,GAAG,CACjC,EAAW,GACX,EAAO,EAAK,IAAI,EAGb,CACX,CAGA,SAAS,EAAa,CAAK,CAAE,CAAG,EAC5B,GAAI,CAAC,EAAO,OAAO,CACf,CAAC,IAAK,EAAM,CAAA,EAEhB,IAAI,EAAI,EACJ,EACJ,GAAG,AAGC,GAFA,GAAQ,EAEJ,CAAC,EAAE,OAAO,GAAK,CAAD,CAAQ,EAAG,EAAE,IAAI,OAAK,EAAK,EAAE,IAAI,CAAE,EAAG,EAAE,IAAI,CAAM,CAAC,CAAG,CAGpE,GAFA,EAAW,GACX,AACI,GADA,EAAM,EAAE,IAAA,AAAI,IACN,EAAE,IAAI,CAAE,MAClB,GAAQ,CAEZ,MACI,CADG,CACC,EAAE,IAAI,OAET,GAAS,IAAM,EAAK,AAE7B,OAAO,CACX,CAwMA,SAAS,EAAe,CAAC,CAAE,CAAC,EACxB,IAAI,EAAS,EAAE,CAAC,CAAG,EAAE,CAAC,CAWtB,OARe,GAAG,CAAd,GAEI,AAAW,GAAG,CADlB,EAAS,EAAE,CAAC,CAAG,GAAE,AAAC,IAId,EAAS,CAFO,EAAE,IAAI,CAAC,CAEL,AAFM,CAAG,EAAE,CAAC,EAAK,EAAD,CAAG,IAAI,CAAC,CAAC,CAAG,GAAE,AAAC,EAClC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAG,GAAG,AAAD,GAAM,CAAD,CAAG,IAAI,CAAC,CAAC,CAAG,GAAE,AAAC,CAC/B,EAGnB,CACX,CAqJA,SAAS,EAAO,CAAC,CAAE,CAAC,CAAE,CAAI,CAAE,CAAI,CAAE,CAAO,EAerC,MAPA,CAOO,EAPH,CAAC,CADL,EAAI,CAAC,CADL,EAAI,CAAC,CADL,EAAI,CAAC,CAHL,EAAI,CAAC,EAAI,CAAA,CAAI,CAAI,GAAU,EAGjB,IAAK,CAAE,CAAI,QAAA,EACX,IAAK,CAAE,CAAI,SAAA,EACX,IAAK,CAAE,CAAI,UAAA,EACX,IAAK,CAAE,CAAI,UAAA,EAOT,CAFZ,EAAI,CAAC,CADL,EAAI,CAAC,CADL,EAAI,CAAC,CADL,EAAI,CAAC,CAPL,EAAI,CAAC,EAAI,CAAA,CAAI,CAAI,GAAU,EAOjB,IAAK,CAAE,CAAI,QAAA,EACX,IAAK,CAAE,CAAI,SAAA,EACX,IAAK,CAAE,CAAI,UAAA,EACX,GAAK,CAAE,EAAI,UAAA,GAEJ,CACrB,CAeA,SAAS,EAAgB,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EACnD,MAAO,CAAC,EAAK,CAAA,CAAE,EAAK,EAAD,AAAM,CAAA,CAAE,EAAK,CAAC,EAAK,CAAA,CAAE,EAAK,EAAD,AAAM,CAAA,CAAE,EAC7C,CAAC,EAAK,CAAA,CAAE,EAAK,EAAD,AAAM,CAAA,CAAE,EAAK,CAAC,EAAK,CAAA,CAAE,EAAK,EAAD,AAAM,CAAA,CAAE,EAC7C,CAAC,EAAK,CAAA,CAAE,EAAK,EAAK,AAAN,CAAM,CAAE,EAAK,CAAC,EAAK,CAAA,CAAE,EAAK,EAAD,AAAM,CAAA,CAAE,AACxD,CAGA,SAAS,EAA2B,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAC9D,MAAO,CAAC,AAAC,IAAO,GAAM,IAAO,CAAA,CAAE,EAAK,EAAgB,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EAAI,EACpF,CAWA,SAAS,EAAK,CAAC,CAAE,CAAC,CAAE,CAAC,EACjB,MAAO,AAAC,GAAE,CAAC,CAAG,GAAE,AAAC,GAAK,CAAD,CAAG,CAAC,CAAG,GAAE,AAAC,EAAI,CAAC,EAAE,CAAC,CAAG,GAAE,AAAC,GAAK,CAAD,CAAG,CAAC,CAAG,GAAE,AAAC,CAC/D,CAGA,SAAS,EAAO,CAAE,CAAE,CAAE,EAClB,OAAO,EAAG,CAAC,GAAK,EAAG,CAAC,EAAI,EAAG,CAAC,GAAK,EAAG,CAAC,AACzC,CAGA,SAAS,EAAW,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,CAAE,EAC9B,IAAM,EAAK,EAAK,EAAK,EAAI,EAAI,IACvB,EAAK,EAAK,EAAK,EAAI,EAAI,IACvB,EAAK,EAAK,EAAK,EAAI,EAAI,IACvB,EAAK,EAAK,EAAK,EAAI,EAAI,aAEzB,IAAO,GAAM,IAAO,GAEb,CAFiB,GAExB,GAAY,CAFmB,CAET,EAAI,EAAI,CAFO,GAG9B,CAD4B,GACnC,GAAY,CAD8B,CACpB,EAAI,CAH0B,CAGtB,CADkB,GAEzC,CAD4B,GACnC,GAAY,CAD8B,CACpB,EAAI,EAAI,CADkB,GAEzC,CAD4B,GACnC,GAAY,CAD8B,CACpB,EAAI,EAAI,CADkB,EAIxD,CAGA,CAN2C,OAAO,CAMzC,EAAU,CAAC,CATsF,AASpF,CAAC,AANiC,CAM/B,CAAC,EACtB,OAAO,EAAE,CAAC,EAAI,AATwF,KASnF,GAAG,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC,CARuE,EAQlE,EAAE,CAAC,EAAI,KAAK,GAAG,CAAC,CAPkD,CAOhD,CAAC,CAAE,EAAE,CAAC,GAAK,EAAE,CAAC,EAAI,KAAK,GAAG,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC,GAAK,EAAE,CAAC,EAAI,KAAK,GAAG,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC,CAC1H,CAEA,SAAS,EAAK,CAAG,EACb,OAAO,EAAM,EAAI,EAAI,EAAM,EAAI,CAAC,EAAI,CACxC,CAeA,SAAS,EAAc,CAAC,CAAE,CAAC,EACvB,OAAiC,EAA1B,EAAK,EAAE,IAAI,CAAE,EAAG,EAAE,IAAI,EACzB,EAAK,EAAG,EAAG,EAAE,IAAI,GAAK,GAAK,EAAK,EAAG,EAAE,IAAI,CAAE,IAAM,EAC5B,EAArB,EAAK,EAAG,EAAG,EAAE,IAAI,GAAS,AAAqB,IAAhB,EAAG,EAAE,IAAI,CAAE,EAClD,CAoBA,SAAS,EAAa,CAAC,CAAE,CAAC,EACtB,IAAM,EAAK,EAAW,EAAE,CAAC,CAAE,EAAE,CAAC,CAAE,EAAE,CAAC,EAC/B,EAAK,EAAW,EAAE,CAAC,CAAE,EAAE,CAAC,CAAE,EAAE,CAAC,EAC7B,EAAK,EAAE,IAAI,CACX,EAAK,EAAE,IAAI,CAcf,OAZA,EAAE,IAAI,CAAG,EACT,EAAE,IAAI,CAAG,EAET,EAAG,IAAI,CAAG,EACV,EAAG,IAAI,CAAG,EAEV,EAAG,IAAI,CAAG,EACV,EAAG,IAAI,CAAG,EAEV,EAAG,IAAI,CAAG,EACV,EAAG,IAAI,CAAG,EAEH,CACX,CAGA,SAAS,EAAW,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAI,EAC7B,IAAM,EAAI,EAAW,EAAG,EAAG,GAY3B,OAVK,GAKD,EAAE,CALK,GAKD,CAAG,EAAK,IAAI,CAClB,EAAE,IAAI,CAAG,EACT,EAAK,IAAI,CAAC,IAAI,CAAG,EACjB,EAAK,IAAI,CAAG,IAPZ,EAAE,IAAI,CAAG,EACT,EAAE,IAAI,CAAG,GAQN,CACX,CAEA,SAAS,EAAW,CAAC,EACjB,EAAE,IAAI,CAAC,IAAI,CAAG,EAAE,IAAI,CACpB,EAAE,IAAI,CAAC,IAAI,CAAG,EAAE,IAAI,CAEhB,EAAE,KAAK,GAAE,EAAE,KAAK,CAAC,KAAK,CAAG,EAAE,KAAA,AAAK,EAChC,EAAE,KAAK,GAAE,EAAE,KAAK,CAAC,KAAK,CAAG,EAAE,KAAA,AAAK,CACxC,CAEA,SAAS,EAAW,CAAC,CAAE,CAAC,CAAE,CAAC,EACvB,MAAO,GACH,IACA,IAAG,EACH,KAAM,KACN,KAAM,KACN,EAAG,EACH,MAAO,KACP,MAAO,KACP,SAAS,CACb,CACJ,IAFuB,gBWxlBsB,OAAW,CDXtB,CCWsB,CNGnB,UAXrB,EAAA,CAEZ,CAAA,CAAA,CACA,CAAA,CL6lB+D,AK5lB/D,CACA,CAAA,CAAA,CAEA,CAAA,CACA,CAEJ,EAAA,MACsB,EAAO,EAAA,EAAe,OAEnC,iBAKI,EAAA,EAAA,EAAA,EAAqB,CKZT,AEiBA,CAAA,IPLS,CAAQ,GAAK,CAC3C,CAAA,MAC2B,CAAK,CAAU,COIrB,APJqB,CAAC,AOItB,CFdO,ALUmB,CKVnB,ALUmB,AQc/C,IRbY,IAAe,CAAA,CAAe,CAAA,CAAA,AFVJ,CYqGiC,AF5E5B,CRhBI,AQgBJ,CRhBI,AACI,CAAA,SACnB,CAAU,CAAA,CAAA,AU6K9C,CV7K8C,EAAS,CIV/C,MJaA,COOM,CAAA,EPPmB,EAE7B,CKFuB,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,MAAA,CAAA,GLEiB,CACxC,CAAA,MACsB,CAAA,EAAA,KACD,EAAA,CAAA,CAAA,CAAA,EAAgB,EAAA,YIpCZ,EAAA,oCAWD,GCAK,CAAA,QAAA,CDCzB,KAAA,sCAK0B,MAAA,CAAA,MAAA,CAAA,IAC1B,cJU+C,CAAA,6BIE/C,CAAA,CAAA,CAEA,CAAA,CACA,CAEJ,EAAA,IACiC,CMkMe,CNlMH,AMkMG,Cd1L1B,CQRiC,ARQjC,EQRiD,EAAgB,CLFvF,CKE6C,AAAmD,OF9BxC,ME8BqD,CAAA,CAAA,qFFnB3F,EAAS,KAAA,GACR,EAAA,MAAS,CAAA,ENmBL,YMjBA,EAAA,CAAA,IACnB,EAIO,EAAA,CAAA,IACA,EAAA,CAAA,MACC,CAAA,EAAQ,CDMD,eCJC,GACT,CAAA,EAAA,CAAA,EAAS,GAChB,CAAA,EAAA,CAAY,GACL,CAAA,EAAA,CAAK,EAAA,GAEL,gBAIP,CAAA,CAEA,CAAA,CACA,CAAA,CACA,CAAA,CAEA,CAAA,CACA,CAEJ,EAAA,SAKI,CAAS,OAAiB,EAAS,CAAA,CKsCD,CLtCQ,EAAC,GAClC,EAAiB,EAAQ,EAAA,CAAA,CAAA,CAAY,CAAC,CAAA,CAAA,GAEtC,EKsCT,CLpCA,CAAS,EAAiB,EAAA,CAAA,CAAS,CAAO,CAAC,CAAA,GAClC,EAAiB,EAAQ,CAAC,AKuChB,CLvCgB,CAAA,CAAA,CAAW,CAAC,CAAA,CAAA,CSAH,CAAA,GHqBH,ENjBhC,EMoBT,ANpB0B,EAAA,CAAS,CAAA,CAAA,EAAQ,CAAA,CAC3C,CAAS,EAAiB,EAAA,EAAA,CAAA,CAAA,CAAoB,CAAC,CAAA,CAAA,GAEtC,GAET,CAAS,EAAiB,AGS9B,EHTuC,AMqBnC,CP3BwB,ACMW,CAAA,CAAO,CAAC,CAAA,EAC3C,CAAS,EAAiB,EDNK,ACMG,CAAC,CAAA,CAAI,CGSG,AE6BX,ALtCQ,CAAO,CAAC,CAAA,CAAA,AAEtC,GAAA,CSGL,STDmC,GAGvC,CAAQ,CGOR,AITD,GAAA,CPE4B,GACnB,CAAA,IAAA,CAAA,EAAmC,CAAA,CAAA,ASED,CTDlC,CAAA,IAAA,CAAmB,EAAA,IAGnB,CGMR,GHNuB,CAAA,EAAoB,IACnC,IAAA,CAAA,EAAA,GACA,CAAA,CGOR,GAAA,CAAA,EAAA,INnFK,EAA6C,WAC3C,CACP,KAAM,EAAA,aAAA,CAAA,YAAA,CACN,KAAA,+BAKY,EAAA,CAAA,2BAGM,EAAA,CMaK,ANbL,CGAK,AJIP,AKMF,AJTP,CAAA,EAAA,CAAK,EAAM,EAAA,2BAOlB,CAAA,CAAA,CAAA,CAGA,CACA,CAAA,CAAA,CAEA,CKKmE,CLJnE,CAEJ,AKE6C,EAA0B,ILD/D,CHWJ,AOTA,CAAA,GCDmE,ULGhC,CIEvC,CAAA,CJF8C,CAAC,CAAA,CAAA,SYZS,EZaN,EAAC,CAAA,AIEA,GJAtC,EAET,CAAA,CAAA,EAA0B,EAAA,CAAS,CAAA,CAAO,CAAC,CAAA,OACT,EAAA,CAAK,CYNT,CZMgB,CYNhB,AZMiB,CYNjB,AZMiB,CAAA,AIEC,CAAA,KJEhD,CAAA,EAA0B,EAAS,CAAA,CAAA,CAAO,CAAC,CAAA,CAAA,CAC3C,CAAS,EAAA,EAAyB,EAAC,CAAI,CAAA,CAAO,CAAC,CAAA,CAAA,IAEzC,EAAA,EAAiC,CWiPC,GX9OhC,IAAmB,CAAA,SACA,EAAA,GACnB,CAAA,IAAA,CAAA,EAAmC,yGW6D0C,CAAE,MAAA,AV3FxC,CAAA,AU2FgD,CAAG,CAAA,KAAA,CAAO,OAAA,CAAS,CAAA,CAAA,yEAsH/F,CAAA,yBASvB,CAAA,UAAA,CAAA,EAAA,gBA2UK,AACL,CAEJ,EAAA,AACI,IAAI,EAAA,CAAW,CAAA,EAAM,EAAK,CAAA,CAAC,CAAA,AAkBpB,EHlN0B,KGmMV,QAAY,EAA/B,OAAO,GAAwB,CAAA,CAAK,EAAC,AACzC,EAAA,KAEI,EAAA,WAAA,EAAA,QAAqB,2BAA4B,CAAA,EAGvC,EAAA,CHpMQ,AGqMd,KAAA,SACA,MAAO,GAAK,CAAA,CAAK,CAAC,CAAG,CAAA,CAAA,CHpMM,CGoME,CAAA,CAAC,CAAE,CAAA,CAChC,IAAK,CAAE,CAAG,CAAA,CAAA,CAAK,EAAA,CAAI,CAAA,CAAG,CAAK,CAAA,CAAC,CAAE,CAAA,CAC9B,aAAc,CAAA,CAAK,CAAC,CAAA,aACP,CHlME,CGkMG,CHlMH,AGkMI,CAAA,EAAK,EAAa,oBAAqB,CAAA,WAAA,GAI3D,YA/SG,AAA4B,WAA5B,EAAA,IAAmB,CAAS,ERrPhB,AQqPwC,CRrPxC,mBQqPwC,CAAuB,EAAa,WAAA,SAAA,CAAA,AAErE,GAAA,CAAA,EAAA,EAAA,YAAA,EAAA,EAAyB,CAAA,CFjOG,AEiOH,oBAEtB,CFlOH,ADkBA,UGgNG,CAAA,AHhNQ,ARlCO,iBWmPlB,QAAA,wBAIrB,CAAK,MAAA,CAAA,EAAA,MAAiB,KACjB,CAAA,WAAA,CTzPe,ESyPO,ECpPG,SAAA,EDoPY,IAAK,CAAA,MAAA,CAAA,IAC/C,CAAK,WAAA,CAAc,ERpPG,AQoPK,ERpPA,SAAA,KQqP3B,CAAA,WAAA,CAAA,EAA2B,CL3OK,UK2OL,CAAA,KACtB,CF7Nb,IAAA,CAAA,EAAA,KE6N6B,CAAA,ETxPD,AM2CD,CN3CC,AM2CD,EG8Md,QAAA,CAAA,EAAA,QAAmB,QAInB,KAAA,CAAA,EAAgB,CRnPhB,IQmPgB,YACF,GAAA,CAAA,uCAKlB,IAAA,CAAO,EAAQ,CRlPZ,EAAe,CAAA,qBQmPI,CAAA,AAAC,IAExB,IAAA,CAAA,YAAkB,CAAA,EAAK,MAAA,CAAA,EAAa,KAAA,mBAUR,CACpC,CAAA,YACI,CAAA,UAAA,CAAgB,CH7MC,GAAA,CAAA,QG6MM,EAAQ,ECnON,CAC7B,CDkO2B,CAAe,CAAA,EAAA,KAAA,CAAM,MAAO,CAAA,QAAA,CAAS,GAAO,EAAF,CAAA,GAAS,EAAA,CAAG,CAAA,CAAA,0BAWjF,GD3PgH,CAAA,CAAA,GC4PnG,CAAA,OAAA,CAAA,cAEA,CAAI,CAAG,CAAA,CAAA,CAAA,CAAO,CC/NA,GD+NK,CAAA,KAAA,IACnB,CAAA,CAAA,EAAA,CAAO,CAAA,CAAO,EDrMN,CAAA,CCqMW,CAAA,GAAA,CAAA,IAEd,EACV,EAAK,CChOiB,CDgOZ,IAGD,EAAK,CAAA,EAAA,EAAU,CAAA,CAAA,GAExB,kBAAA,IAAA,CAAA,SAAA,CACJ,IACQ,CH5LR,CAAA,EAAA,CG8LQ,IAAM,EAAO,IAER,EACA,EAAA,EACC,EAAA,CAAA,CAAA,KAEN,EAAA,EACJ,CACI,CT1PM,GS0PA,CTzPC,AUiBL,CAAA,ED0OG,EAAA,EAAA,ACxOjB,AVlBmB,AS2PF,EAAA,ECxOH,GDyOI,IAId,IAAM,EAAa,CT1PAG,CMiEJ,ANjEIA,ES0PA,CAAA,UAAgB,CAAA,CHzLX,KAAA,CGyLoB,IAAA,CAAK,UAAA,CAAa,EAE9D,EAAoB,CT3PDE,GS2PM,CAAA,CCvOH,WDuOG,CAAA,AAEnB,CAAE,QAAA,CAAA,QAAA,CAAQ,CHtLM,AGsLM,CAAA,EAAU,EAAa,CAAC,CAAA,CAE9C,AAF8C,EAE9C,AAFsB,AAEV,EAEZ,AT/PaD,CAAAA,CS+PL,AAFI,KAEJ,eAAA,CAAqB,IAAA,CAAK,YAAc,CAAA,CAAA,CAAG,EAAG,CAAC,CAAA,CAAA,AADvD,EAAQ,ICxOlB,gBDwOkB,CAAqB,EAAG,EAAA,IAAG,CAAK,YAAc,CAAA,CAAC,MAGrC,mBAGhB,QAAS,CAAA,EAAG,EAAG,EAAa,CAAC,CAAA,KAEhC,CAAA,OAAA,CTlQU,ISkQI,CTlQAD,CAAAA,OSkQQ,CAAA,CACvB,OAAQ,IAAI,CHzLG,CAAA,WGyLS,CAAA,UACV,CHzLC,CEvBb,0BCiNoB,CD9M1B,UCoNa,KAAK,EH1LR,CAAA,CG0LQ,CAAM,EAAK,EC5NJ,AD4NI,AAAO,CC5NX,CD4NgB,EAAG,CAAA,CAAA,CAC9B,KAAK,KAAM,CAAA,EAAI,CHzLF,EG8LrB,EAAI,CTvQC,GAAA,EAAA,MAAA,aSyQmB,KAC5B,MAAA,CAAA,GACA,CAAA,CAAA,SAAA,CAAA,EAAc,CTxQD,CAAA,ASwQG,CAEd,AAAK,SACT,CADI,GDhN8B,CCgN9B,CAAK,YAAA,YAEgB,GAEzB,IAAA,CAAK,SAAA,CAAY,CAAA,CAAA,ATxQE,CAAA,cSiRvB,CACQ,CAAC,IAAA,CAAK,GH3LE,IG2LF,EAAc,CHzLnB,GGyLmB,CAAA,KAAA,CCtNd,EDuNQ,UAClB,KADI,CAAK,ETnQK,AM0ET,EAAA,gCG+LD,CAAA,mBAAyB,CTpQF,ES6QxB,qBAAA,QAEM,CAAA,OAAA,CAAA,aAEU,IAAA,CAAK,GD3MJ,OAAA,CC2Me,MAAA,CAAA,IAAA,CAAc,UAAa,CAAA,EAExD,EAAc,EClNoD,CAAA,CAAA,ADkN/C,CAAA,MAFqC,CAAA,KAErC,CAAA,SACT,CAAA,QAAA,CAAA,CAAY,CT/PG,CAAA,CS+PO,ET/PH,EAAA,CAAA,KSiQpB,EAAG,CAAA,CAAA,CAAA,IAAA,CAAY,MAAA,CACxB,CAAA,EAAA,CAAK,CAAA,EAAO,CAAA,CAAA,CAAA,IAAA,CAAA,WAAA,CAEZ,CD1MN,ARvDI,CSiQO,CH3LO,CIrBlB,EDgNgB,CAAA,WAAA,CACV,CDzMN,CCyMW,IAAK,CAAA,WAAA,CAAA,AAEV,EAAK,EAAA,EACL,EAAK,EDxMD,ACwMM,AChNhB,EDkNM,EAAA,KAAuB,CAAK,CAAA,AChNV,ADgNU,CTjQC,AUiDX,AVjDW,ASiQD,AAE5B,CTnQ6B,ASiQD,CAE5B,CAAM,CH5LE,CG4LG,CAAA,CAAM,CAAA,EACjB,CDxME,CCwMI,AAAN,CCjNN,EDiNiB,CAAA,CAAM,CAAA,0BAEE,CAAA,EAErB,EAAA,AACA,EAAK,EAAA,CAAA,EACC,CAAA,CAAM,CAAA,EAAA,CACX,EAAA,CAAA,CAAW,CAAA,EAAA,EAAA,KAIF,EAAA,cAEM,CAAA,CAAA,CAAW,EAAW,EC3ML,ID2MK,CAAS,CAAC,CAAE,CAAA,KAAA,CAAA,EAC9C,QAAS,CAAA,EAAG,CAAG,CAAA,EAAa,KAE5B,MAFuC,CAAA,CAAA,CAE3B,CH7LL,AG6LK,CH7LL,OG6LK,CAAA,IAGZ,CAAU,CDpMX,CAAA,ACoMe,EAAE,CAAA,AAGhB,CAHgB,CAGhB,EHhMR,CAAY,GGgMJ,CAAA,IAAA,CAAY,EHhMM,MGgME,CAAA,CAAA,AHhMF,EGmMlB,KAAA,CAAA,EAAA,IAAS,CAAA,KAAU,IAGnB,SAAU,CAAA,CAAA,EAAA,CAAM,EAAE,CAAA,CAAA,CAElB,QAAS,CAAA,EAAG,CD1MsB,CC0MnB,CD1MmB,CAAA,AC0MN,GDxMf,CAAA,KCwME,EAAwB,CAAA,CAAA,EAE1C,CHtMI,CAAA,GGsMU,EAAA,OAAQ,CAAA,CACvB,OAAQ,IAAI,EAAA,WAAA,CAAA,YAER,YAAA,IAAkB,CAAA,CHpMC,QGoMD,CHpMC,UGwMjB,IAAA,EAAA,MAAW,CDrMM,CCqMN,ADrMM,CCwMzB,AAHmB,KAGb,CAAA,CAAA,CAAI,EHvMF,CAAA,CGuMa,KACrB,SAAA,CAAU,EAAI,GAEU,OAC1B,EAAA,oBACM,CAAA,CAAA,KAAA,CAAM,EAAa,OAGzB,CAAK,SAAA,CAAY,CAAA,CACrB,AAGO,SACP,MACS,EHnMK,KAAA,EGmMI,SAAQ,GACtB,CAD0B,CAAA,CAAA,CAC1B,CAAK,OAAA,CAAU,KACf,IAAA,CAAK,SAAY,CAAA,KACjB,GHpMkC,CGoMlC,CAAK,UAAA,CAAA,EAAc,CAAA,IACnB,CAAK,KAAQ,CAAA,KACb,IAAA,CAAK,GAAM,CAAA,GHpMW,EGqMtB,IAAA,CAAK,MAAS,CAAA,KACd,GHrMkC,CAAA,CGqM7B,WAAc,CAAA,IAAA,CAAA,AAQvB,IAAW,UACX,CACI,IHtM0D,EGsM1D,CAAwB,cAAA,EAAA,IAAA,CAAK,GAAG,CAAA,CAAA,EAAI,IAAA,CAAK,KAAK,CAAA,CAAA,CAAA,AAEtD,CAAA,CAAA,AAEA,SAAS,EAAc,CH3KI,CG2KsB,CACjD,CH5KsC,CAAA,AG4KtC,AACI,IAAA,IAAS,EAAI,EAAG,CAAI,CAAA,EH5KG,MG4KQ,CAAQ,CACvC,EAAA,AH7KkC,CG6KlC,OACiB,CAAA,CAAW,CAAC,CAAA,CAEzB,AAFyB,CH3KnB,CG6KG,SH5KH,GAAA,CG4KgB,EAAK,MAAQ,CAAA,EAAK,EAAL,EH5KY,CG4KF,CAAA,CACjD,AACJ,CAAA,SAES,EAAU,CH3KX,CAAA,AG2K0B,CAClC,EAAA,AACI,EAFK,EAEL,EAAe,EAAA,UAAW,CAAA,GAAA,CH5KY,CG4KN,CAAA,YAAA,CAAa,EAAO,GAC9C,EAAU,EAAO,UAAA,CAAW,IAAI,CAAA,CAAA,AAE/B,MAAA,QAAE,IH3Ka,MG2KL,CAAQ,CAAA,AAC7B,CAlBA,AH1JuC,AG2KV,AAC7B,CH5KuC,CG0JvC,AH1JuC,oBGtLkC,CAAA,CACjE,KAAO,CAAA,CAAE,CAAG,CAAA,EAAG,EAAG,CAAE,CAAA,CACpB,IAAK,CAAE,EAAG,CAAA,CAAG,EAAG,CAAE,EAClB,WAAY,EAAA,CACZ,aAAc,QACd,IAAM,CAAA,SACN,YAAA,IACA,SAAU,eAAA,IAIS,oBAA8C,CH2ItC,AG3IsC,CACjE,MAAQ,CH0I+B,AG1I/B,CAAE,CAAG,CAAA,GAAA,AAAK,EAAG,EAAI,CAAA,CACzB,YAAa,CAAA,CACb,YAAa,GAAA,AACb,WAAY,EAAC,CACb,MAAO,EACP,aAAA,QACA,KAAM,SACN,YAAA,IACA,SAAU,eACd,CAAA,CAAA,wBAxBG,oBFnMuB,EAAA,MAAO,CAM/B,GAAW,CVCA,AGCH,ALeO,GAAA,EAAA,SYjBU,EAAA,CDgBN,AChBM,CDgBN,4BIDF,ETCC,CAAA,YAAA,CAAA,YSDa,CAAc,aAAa,CAAA,CAAA,QACjC,EAAc,EAAe,EAAa,EAAc,OAA3B,OAEvC,CJqBA,CXOjB,AWPiB,AXOjB,Ke9BwG,CAAA,CAAA,Ef8BxG,0Be8FK,GACL,CAAA,CACA,CACA,CAAA,CAAA,CACA,CAAA,CACA,CAMJ,EAAA,AACI,GAAM,UAAE,CAAA,KAAU,CAAK,CVhCAC,QAAAA,CUgCA,CAAY,CAAA,CDgOG,CAAA,AC9N5B,CD8N4B,CC9N5B,QAFyB,CAAA,MAEzB,CAAgB,OAAA,CAAQ,CAAC,CAAE,OAAA,CAAO,SAAW,CAAA,CAAA,OAAQ,CAAA,CAC/D,IACI,CADJ,GACU,CD+NN,CC/NyB,EAAA,CACnB,EAAQ,EAAA,CAAc,EAAM,GAAN,CAAU,CAAA,CAAA,GAMlC,CAAC,EAAM,KAAM,CAAA,EAAO,GAEpB,MADJ,OAIoB,EAAQ,IJiCI,CAAA,CIjCJ,CAAA,AACtB,EAAa,EAAS,MAAS,CAAA,CAAA,CAAA,EACZ,ED4NP,yBCzNlB,EAIK,EAwBL,KACU,EV7CI,CM0ET,AN1ES,CU6CuB,SAAa,GAAA,EAC5B,EAD4B,AAG/B,CAH+B,QAI9C,EAAA,CDqNyB,SPzajC,CAAA,CACA,CPkBkB,COjBlB,APiBkB,CAAA,AOjBlB,CACA,CAEJ,EAAA,GAGe,GACX,GADW,MAAA,gBAOO,EAAA,QAGlB,EAAA,CAAA,CAAA,EAAA,MAAA,CAAA,EAAmC,CAAA,MAEV,MAAA,CAAA,EAAU,CAAA,eAED,EPSG,COTH,CAAI,EAAK,ITVlB,ASU+B,EAAP,EAAY,MAAA,GAAA,CAAI,EAAK,EAAE,CAAI,GAAA,GAAA,CAAA,GAI7C,CAAA,MACN,MAAS,CAAA,MAElC,IAAS,EAAA,EAAO,EAAI,EAAQ,CLPG,AKQ/B,GAAA,QACe,CAAY,CAAE,AHEhB,CGFU,EHEV,QGDE,CAAA,CAAA,CAAA,AAAY,CAAA,CAAZ,EAAiB,CAAC,CAAC,CAAA,CAAA,AAGlC,CEGA,GFHA,IAAA,EAAA,EAAgB,EAAA,EAAA,EAAgB,CJDG,AIEnC,UACiB,EAAA,EAAA,EAA6B,EAAA,mBAKJ,IQ+Kf,EAAQ,EAAO,EAAU,GAC7B,EAAA,CV/CnB,YU0CQ,SJ9DA,CAEZ,CAAA,CAAA,CACA,CACA,CAAA,CAAA,CACA,CAAA,CACA,CAEJ,EAAA,AAKQ,GAAA,AAAkB,CACtB,AN7DuB,EM6DvB,CADI,EAAA,MAAA,MG6LA,EHtLJ,IAAA,EAAA,EAAA,SAAA,IAE4B,GAC5B,EADI,EAAA,SAAA,CACJ,OAEsB,SVvLa,CACvC,MACU,EDsBM,CAAA,CCtBK,MAAA,CAAA,4BASjB,IAAS,EAAA,EAAO,EAAK,CAAA,CAAA,EAAA,EAAA,CAAe,EAAK,CAAA,CAAA,EAAW,CAAC,CAAA,CAAA,EAAO,CAAA,CAAG,GAAK,CACpE,CAAA,KACU,EAAA,CAAA,CAAA,EAAA,GACK,CAAA,CAAA,EAAA,EAAA,aAEe,CAAA,CAAA,kBAMnB,QUiKkC,GAErC,GAF2C,AAE3C,CAF2C,AAE3C,CAF2C,AI/CA,CAAA,CAAA,AJiDd,EAAA,EAEnB,EAAA,CAAA,EAAY,EAAA,EAAO,EAAe,GAAA,CAAA,GAI9C,EAAa,IAAA,EAAA,KAAA,CAAU,CAAA,CAAA,EAAW,CAAA,CAAA,CAAO,CAAC,CAAC,CAAA,CAAA,AAC3C,EAAY,IAAA,EAAA,KAAA,CAAU,CAAA,CAAO,EAAO,MAAA,CAAS,CAAC,CAAA,CAAG,CAAO,CAAA,EAAO,MAAS,CAAA,CAAC,CAAC,CAAA,CAAA,EAE7D,UAAK,GAAI,CAAA,EAAW,CAAA,CAAI,AI9Cd,CAAA,CJ8CwB,CAAC,CAAI,GAAA,IACnD,KAAK,GAAI,CAAA,EAAW,CAAI,CAAA,CGwLmC,CHxLzB,AGwLyB,CHxLxB,CAAI,EAA9B,CAA8B,EAAf,CAAe,AAI9C,CAJ8C,IAM1B,KAAA,GAEZ,SAEW,CNxEA,ASgQf,EHzLA,KAEe,CNxEA,IMyED,CNxEC,EAAA,CAAA,CMwEU,CAAA,EAAO,IGyLT,EAAA,CAAA,EHzLmB,CAAG,CAAO,CAAA,EAAO,IAAP,EAAgB,CAAA,CAAC,CAAC,CAAA,CAAA,OAGnD,CAAA,EAAW,CAAI,CAAA,EAAU,CAAK,EAAA,KAC9B,CAAA,EAAU,CAAI,CAAA,EAAW,CAAK,EAAA,KAE1C,OAAA,CAAQ,EAAW,KACnB,IAAA,CAAA,EAAgB,GAKrB,CItC0B,GJsC1B,EAAS,EAAO,CEtBd,KFsBuB,CGyLF,EHxL7B,EAAA,EAAA,MAAA,CACM,EAJN,AAImB,CN1EA,CM0EM,MAAS,CAAA,CAAA,CAAA,AAG5B,EAAA,EAAc,CEvBgB,IFuBR,CAAA,EACtB,EAAA,EAAA,EACA,EAAA,EAA0B,GG8L5B,OAAA,CH9LyC,EAAM,GAAA,OAAA,CAAA,AAG/C,EAAK,CAAA,CAAO,CAAC,CAAA,CACb,EAAK,CAAA,CAAA,EAAQ,CACb,CEnBI,CFmBC,CAAA,CAAA,EAAQ,CG6LjB,EH5LS,CAAA,CAAA,EAAQ,CACb,EAAK,EACL,EAAA,EAGA,EAAQ,CAAA,AAAE,GAAK,CAAA,CAAA,CAAA,CAAA,CACP,EIhCA,AJgCK,EACb,EAAA,EACJ,EAAa,CAAA,CAAA,AAET,EAAA,KAAY,IAAA,CAAM,EAAQ,EAAU,CAAV,CAAkB,GAEvC,EAF6C,CAAA,AAE7C,CAF6C,CAG7C,GAAA,EACA,GAAA,OAGT,IAAM,EAAQ,EEnBd,EAAA,CAAA,EFoByB,CAAA,CAAS,CAAA,YAKZ,SAClB,CADI,EAAM,GAAA,IAEQ,EACV,EAAA,GAAe,EAAc,CAAA,CAAe,CAAA,ENzEX,CM0EjC,EAAM,EI1BV,CJ0BmB,EAAA,AAAc,CAAA,CAAe,CAAA,AEpBlB,CAAA,EFoBkB,AAC5C,EAAA,EAAA,EACA,EAAM,EAAQ,EACd,EAAM,EAAQ,EACd,EAAA,EAAA,EA9CZ,EA8CY,CAAA,GAAA,EAIR,AACe,UACf,CAFA,EACe,GAAA,GAEG,GAAA,EAAO,EAAA,EAAQ,EAAO,EAAO,EIrBf,AJqB4B,CIrB5B,EJqByC,EArD7E,EAqDwF,CAAA,CAAxB,AAAmB,AAAK,CArDxF,AA0DM,CAL0D,CAK1D,IAAA,CAAA,EACI,EAAA,EAAA,EACA,EAAQ,GA5DlB,AA6DM,EAAA,IAAA,CAAA,EACI,EAAQ,CENd,CFMc,EACR,EAAQ,CENL,MFQb,IAAS,EAAI,CAAG,CAAA,EAAI,EAAS,CAAA,CAAG,CEJR,CAAA,EFKxB,CACS,EAAA,CAAA,CAAA,CAAA,EAAY,CAAA,CG6LD,CH7LM,EAAC,CAAA,AACvB,EAAK,CAAS,CAAA,CAAA,EAAA,CAAA,AAAS,CIhBjB,CAAA,EJgBsB,CAAC,CAAA,CAAA,AAExB,CG4LL,CAAA,AH5LK,CAAA,CAAO,AAAI,CAAC,GAAA,GACZ,CAAA,CAAY,CAAA,AIdX,CJcO,CAAI,AG6LjB,CC3MM,EJciB,CAAA,EAElB,CAAA,CG6LL,AH7LK,CAAQ,CAAI,CIdD,CAAA,EAAA,EJcO,CACvB,EAAK,CAAS,CG6Ld,AH7Lc,CAAA,EAAA,CAAA,EAAS,EAAK,CAAC,CAAA,QAKjB,IAAA,CAAM,KAHR,EAAK,CAAA,CAAA,EAGW,EAAU,KAFvB,CAAA,CAAA,CAE+B,AAF/B,KAEqC,CAAA,AACzC,CADyC,IAEzC,KACA,CEHT,IFIS,EAKT,EAAO,IAAK,CAAA,IAAA,CAAA,GAHH,EAAE,EAAK,CAAA,CAAA,CAAA,CAAA,AAGW,EAAW,GAF7B,EAAK,CAAA,EAEiC,GACrC,GAD4C,AAC5C,CAD4C,CAAA,GAE5C,IAAA,CAAA,KAEA,EAGV,CGqME,GHrMI,EAAA,EAAW,EACX,EAAM,EAAK,EACX,EAAM,EAAK,EACX,EAAM,EAAK,EAAA,AAGX,CAHW,CAGJ,CAAP,CAAO,EAAc,EAAM,GAAA,CAAA,MAEE,EAC7B,EAAA,EAAA,EAIF,GAAA,CGoMR,IHpMa,GAAA,CAAI,GAAS,EAAJ,CAAA,EAAY,IAAK,CAAA,GAAA,CAAI,GACvC,AAD0C,CA5G9C,AA6GI,EACU,IAAA,CAAA,EACI,EAAQ,EGmMP,AHlMP,CGkMO,CHlMD,EAAA,GACJ,AAjHd,EAiHc,AAFY,IAEZ,CAAA,EACI,EAAQ,EAAA,EACR,EAAQ,CGoMR,CAAA,CHjMN,GAAO,CACX,AE9Lc,GF+LS,CALL,QAMd,GADU,IAAA,CAEQ,GAAA,CEnN3B,CAAA,EFoNqB,EAAA,AACJ,EAAM,EAAQ,EAAc,CAAd,CGqMlC,EHrM8D,EAAA,EACpC,CADQ,CACR,EAAA,EAA6B,CADO,CACE,EA7HhE,GA8H2B,GAAS,CAAA,CAAA,GAAhB,AAIU,CAAA,CAlI9B,AAkI8B,GAJV,GAOF,CACF,EAAM,CG7IZ,CH6IqB,EACf,EADe,AACf,EAAe,GAvI/B,AAwIkB,EAFa,AAEb,GAAA,CAAA,CACF,CAFe,CAET,EAAS,EACf,EAAM,AADS,CGxJtB,CHyJsB,IAAA,AAGvB,CAJuB,QAQrB,IAAA,EAAA,CAAO,CAAC,EAAQ,CAAA,CAAO,CAAf,CAAe,CAAC,CAAD,CAAS,CAAA,CAAA,CAAA,CAAS,CAAC,EAAQ,CAAA,CAAO,CAAf,CAAe,CAAC,CAAD,CAAS,CAAA,CAAA,CAAA,AAClE,CADkE,CAClE,CAAA,CAAQ,EAAS,CAAA,CAAO,EAAA,CAAC,CAAD,CAAU,CAAA,CAAA,CAAA,CAAA,AAAS,CAAC,EAAS,CAAA,CAAO,EAAA,AAAhB,CAAiB,CAAD,CAAU,CAAA,CAAA,CAAA,AACtE,CADsE,CAC/D,CAAA,EAAA,EAAa,EAAM,CAAN,AAAM,CAAO,CAAA,EACjC,EAAO,AG7IA,CAAA,AH6IA,AAD0B,CAAA,CG5I1B,AH6IM,CAAN,CAAa,EAAM,CAAN,AAAM,CAAO,CAAA,EACvC,EAAA,AAAgB,CADuB,CAAA,CAClB,CAAA,CAAA,CG7IX,CH6IkB,EAAK,CAAA,CAAS,CAAA,CAAA,EAAK,CAAA,CAAA,EAAO,EAAP,AAAY,CAAA,CAAA,CAAA,AAGrD,CAHqD,CAG/C,CAAN,CAAa,CAAA,EAAA,AAAK,CAAA,CAAM,CAAA,EACxB,EAAA,EAAa,CAAA,EAAA,CAAA,CADW,CAAA,AACX,EAEb,EAAM,CAAN,CAAa,CAAA,EAAK,CAAA,CAAM,CAAA,EACxB,EAAA,EAAa,CAAA,EAAK,CAAA,CAAM,CG4Kd,EAAA,AHxKV,EAAA,EAAA,EAAA,EAEgB,GAHS,AAEC,EACD,EAHK,CAAA,CAGL,EAHK,CAAK,EAAM,CAAA,CAAQ,CAAR,CAAc,EAAO,CAAA,CAAM,CAAN,CAAc,CAAA,AAExB,CAF8B,CAAN,EAExB,AAFkC,CAAA,CAEnB,AAFmB,CAG7D,CADyD,AACzD,EAIR,MALmC,EAA8B,EAAA,AAKhF,CALgF,CAK1E,IAAA,EAAoB,EAAQ,EAAe,CAAvB,AG4KoB,CAAA,CAAA,AH1K1C,GAxKhB,AA0KsB,EAAA,IAAA,CAAK,CADf,CG0KW,AHzKI,EAHnB,CAvKR,AA2KgB,CAJR,CAIc,IAAA,CAAK,EAAM,EAAQ,EAAc,CAAtB,CAAsB,AAAM,EAAQ,GAC/C,AA5KtB,EA2KuD,AACjC,GAAA,CAAA,CAAK,CADsD,CAAA,AACjD,CADiD,EA3KjF,AA4KmC,AACnB,CADmB,CACnB,CGgMD,EHhMC,CAAA,CAAA,EAAiB,EAAS,EAAc,EAAA,AAAM,EAAS,KA7KvE,AA6KwD,AAIxC,EAAA,IAJmE,AAInE,CAJmE,AAIxD,CAJwD,CAIlD,EAAQ,EAAc,EAAA,EAAc,GAjLrE,AAkLsB,CGoMR,CHpMQ,IAAA,CAAK,EAAK,GAlLhC,AAkLmC,CAAA,CAAA,AACb,IAAA,CAAK,EAAM,EAAS,EAAc,EAAvB,AAAuB,AAAM,EAAS,GAnLvE,AAoLsB,CGoMd,CHrMgD,AGqMhD,IHpMc,CAAK,CADwD,CAAA,AACnD,CADmD,MAIzD,GAEM,OACxB,EAAA,CADS,EAAM,IAAA,CAEP,GAEM,AA7LtB,EA6LsB,GAAA,CAAA,CAAK,CADf,CACoB,GA7LhC,AA6LmC,AACnB,CADmB,CAAA,AACb,CGiMf,EHjMS,CGiMT,CHjMoB,EAAM,EAAQ,EAAc,CAAtB,CAAsB,AAAM,EAAQ,GAEvC,EAFyB,CAEzB,EACV,EAAA,AAAI,CADM,AAFmD,CAAA,AAGzD,AACJ,CAJ6D,CAIvD,EAAQ,EAAc,CAAd,CAAoB,EAAQ,EAC1C,CAD0C,CACpC,CADQ,CACC,EAAc,EAAd,AAAoB,CADO,CACE,EAnMhE,EAmMgE,CACrC,GACP,CADO,AACP,CArMpB,AAuMsB,EAAA,CAHF,EAGE,CAAA,CAAK,EAAK,GAChB,AAxMhB,AAuMmC,CAAA,CAAA,AACb,IAAA,CAAK,EAAM,EAAS,EAAc,EAAvB,AAAuB,AAAM,EAAS,KAxMvE,AA4MgB,AAJwC,EAIlC,GAAN,CAJmE,AAI7D,CAJ6D,AAIxD,CAJwD,CAIlD,EAAQ,EAAc,CAAtB,CAAsB,AAAM,EAAQ,GA5MrE,AA6MsB,EADiC,AACjC,GAAA,CAAA,CAAK,CADsD,CAAA,AACjD,CADiD,EAC9C,AAEL,CAFK,CAAA,CAEL,EACV,EAAA,AAAI,CADM,CACN,AACJ,CAFU,CAEJ,EAAQ,EAAc,CAAd,CAAc,EAAc,EAC1C,EAAM,CADQ,CACC,EAAc,EAAM,EAAS,EAlNhE,GAmN2B,GAAA,EAnN3B,AAmN2B,AAGX,EAAM,CAHF,EAGJ,CAAM,CAAK,EAAM,EAAS,EAAc,EAAvB,AAAuB,AAAM,EAAS,GAtNvE,AAuNsB,EADkC,AAClC,GAAA,CAAA,CAAK,CADwD,CAAA,AACnD,CADmD,EAChD,CAAA,CAvNnC,AAuNmC,AAKjB,EAAA,GAAA,CAAA,CAAK,EAAK,GA5N5B,AA4N+B,AACb,CADa,CAAA,AACb,IAAA,CAAK,EAAK,GAAG,CAAA,CAAA,AAKvB,AAlOR,EAkOc,GAAN,CAAM,CAAK,EAAM,EAAQ,EAAc,CAAtB,CAAsB,AAAM,EAAQ,GAlO7D,AAmOQ,EAAM,AADiC,IACjC,CAAK,CADsD,CAAA,AAChD,CADgD,CACxC,EAAc,CAAtB,CAAsB,AAAM,EAAQ,GAClC,EADoB,KAEvC,CAFiE,CAAA,AAEjE,CAFiE,AAC7D,EAAM,GAAN,CAAM,CAEF,EAEc,GAAA,EACV,EAFR,AAEQ,AAAI,EAFZ,AAEY,AACJ,CAFU,CAEJ,EAAQ,EAAc,CAAd,CAAoB,EAAQ,EAC1C,EAAA,CADc,CACd,EAA6B,EAAM,CADO,CACE,EA3OhE,EA2OgE,CAAA,GAE5C,CAAA,CAAA,AAIU,CANkC,EAMlC,EACV,EAAA,AAAI,CADM,CACN,AACJ,CAFU,CAEJ,EAAQ,EAAc,CAAd,CAAoB,EAAQ,EAC1C,CAD0C,CACpC,CADQ,CACC,EAAc,EAAM,CADO,CACE,EApPhE,GAqP2B,GACP,CAAA,CAAA,AAGY,GAJZ,OAIH,EAAM,GAAA,CAAA,EAAoB,EAAQ,GAAgB,IAEnD,GA3PhB,AA6PsB,EAAA,GAAA,CADV,AACU,CAAK,CADf,CACoB,CAHxB,EAAA,AAG2B,AACb,AA9PtB,CA6PmC,CACb,AADa,GACb,CAAA,CAAK,EAAK,GAAG,CAAA,CA9PnC,AA8PmC,AAIb,EAAA,GAAA,CAAA,CAAK,EAAK,GAAG,AACb,AAnQtB,CAkQmC,CAAA,AACb,GAAA,CAAA,CAAK,EAAK,GAAG,CAAA,AAET,CAFS,EAET,CAAA,EAElB,AAvQR,EAuQc,IAAA,CAAK,EAAM,EAAS,EAAc,EAAvB,AAAuB,AAAM,EAAS,GACvD,AAxQR,EAuQgD,AAClC,IAAA,CAAK,CADwD,CAClD,AADkD,CAAA,CACzC,EAAc,EAAA,AAAM,AAA7B,EAAsC,GACzC,EAD0B,CAC1B,CAAA,CAAA,AAClB,CACJ,AAEK,EALsE,AAKtE,CALsE,AAKtE,CALsE,AAKtE,CAAQ,GAAS,CAAA,CAAK,CAAL,AAAM,CAAA,CAAA,AAC5B,EAAK,CAAS,CAAA,CAAA,GAAS,CAAK,CAAA,CAAd,AAAc,CAAK,CAAC,CAAA,CAE7B,AAF6B,EAE7B,CAAA,CAAA,CAAQ,GAAS,CAAA,CAAK,CAAL,AAAM,CAAA,CAAA,AAM5B,EAAO,EAAP,GAAY,IAAA,CAAM,CAHlB,EAAQ,CAAA,CAAE,EAAK,CAFf,EAAK,AAEU,CAFD,CAAA,CAAA,GAAS,EAAK,CAAA,CAAK,EAAC,CAAA,AAEnB,CAAA,CAAA,CAAA,AAGW,EAAU,CAFpC,EAAQ,EAAK,CAAb,AAAa,CAAA,CAAA,AAEuB,GAC3B,GAAA,EAAA,AACA,GAAA,EAAA,AACA,GAAA,EAAA,AACA,GAAA,EA1RT,AA0RS,AAET,EAAM,GAAN,CAAM,CAAK,EAAM,EAAA,EAAsB,EAAM,EAAQ,GA5RrD,AA6RA,EAAM,GAAN,CAAM,CAAK,CADsD,CAAA,AAChD,CADgD,CACxC,EAAc,CAAtB,CAAsB,AAAM,EAAQ,GArTjC,EAqTmB,EAI/B,AAAc,IAJ2C,CAAA,CAAA,CAK7D,EAAA,CADI,EAAA,GAAM,CAEQ,GAAA,EACV,EAAA,AAAM,CADI,EACK,EAAA,AAAc,CAAA,CAAe,CAA7B,AAA6B,GAAA,EACtC,CADS,EACA,EAAA,AAAc,CAAA,CAAe,CAAA,AAA7B,AAA6B,GAAA,AAC5C,EAAM,CADS,CACD,EACd,CADc,CACR,EAAQ,EACd,CADc,CACR,CAFQ,CAEA,EACd,CADc,CACR,CAFQ,CAEA,EAzS1B,CAyS0B,EADA,AAGd,GACA,CAAA,CAAA,AAEe,CALD,EACd,KAKR,AALQ,EAKR,CADS,EAAM,GAAA,GAEG,GAAA,EAAO,EAAI,EAAX,AAAe,EAAO,EAAO,CAAd,CAA2B,EAAa,GAhT7E,EAgTyF,CAAA,CAAzB,AAAoB,AAAK,CAKzF,CALgE,GAK1D,EAAO,KbzfO,CGnBH,EU4gBO,EAGxB,CAHwB,GAGxB,IAAS,CAHe,CAGX,AAHW,EAGC,CAAA,CAAI,EAAa,EAAa,CAAA,CAA9B,AAAiC,EAAE,CAC5D,CAAA,AACS,EA1TT,AA0TS,AAF8C,CAE9C,CAAW,EAAJ,EAAI,CACX,EAAA,AA3TT,AA2TS,CAAA,CAAO,AAAI,CAAA,GAAK,CAAC,CAAA,CAAA,AAEjB,EA7TT,AA6TS,CAAA,CAAA,CAAO,CAAI,EAAA,CAAA,CAAK,CAAC,CAAA,CACtB,AADsB,EACjB,AA9TT,AA8TI,CAAa,CAAA,CAAA,CAAA,EAAI,CAAK,CAAA,CAAA,CAAK,CAAC,CAAA,CAEvB,EAhUT,AAgUS,CAAA,CAAA,CAAO,CAAI,EAAA,CAAA,CAAK,CAAC,CAAA,CAAA,AAIlB,IAAK,CAAA,GAAA,CAAA,EAAW,CAAA,EAAA,CAHpB,EAjUJ,AAiUI,AAAK,AAGoB,CAHZ,CAAA,CAAA,GAAI,CAAK,CAAA,CAAA,CAAK,EAAA,AAAC,CAAA,AAGH,CAAQ,CAAA,EAAA,CAAM,EAAN,AAAW,CAAA,CAAA,CAAA,AAAQ,GAAM,EAAA,AAAK,CAAA,CAAI,CAAA,CAAA,GAKnE,EAAA,IAAa,CAAb,AAAa,CAAA,CAAG,CAAI,CAAA,CAAA,CAAG,EAAI,CAAC,CAAA,AAEpC,CAFoC,CItUV,KAAmB,EAAO,EAAO,CAAP,CAAiB,CAAjB,MAAwB,CAAA,CAAA,SA1BtD,EAAwB,EFa9B,AEb8B,GAEV,EAAO,GD6NC,CAAA,CAAA,GC3NT,UAiE1B,AAAc,CACvB,MACU,EAAA,EAAA,CAEN,IAAA,IAAS,EAAA,EAAA,EAAA,EAA0B,MAAA,CAAQ,CAC3C,EAAA,CAAA,KACU,EAAgB,CJgBC,AIhBc,CAAA,CAAC,CAAE,CAAA,KAAA,CAGlC,AAHkC,EAGlC,EAAwB,CAAA,AAExB,EAA4B,CAAA,CD2MA,CAAA,AC3Mc,IAAI,CAAA,CAAA,AAEpC,KAFkB,AAElB,CAAA,EAAqB,ID2MK,ACzMtC,CFQA,CAAA,IAAA,CERgB,EADpB,CAKG,CFQP,MERO,IApFsC,GAEtB,EAF2B,CAAA,CAAA,GAE3B,CAAQ,AAAC,IAEJ,EAAA,IADhB,AACgB,CAAA,EAAiB,EADjC,IACiC,CAAS,CAAC,CAAA,CAAA,AAC3B,EAAA,IAAA,CAAK,GAAG,KAGxB,EAAqB,CJ+B7B,CI/B0C,CAHA,CAAA,AAGa,CAHb,CAGuB,CAAG,CAAA,EAAY,EAAzB,AAAkC,CAAlC,KAAa,GAGhE,EAHgG,CAAA,CAAA,SAI1E,CV7C1B,CU6CkC,EAAU,CAAG,CAAA,EAAY,EAAzB,AAAkC,MAArB,CAmBzC,EAAY,EAnB6D,AAmBzD,CAnByD,AJ+C7D,CI/C6D,IAmBhD,CAAA,MAET,IFOH,GEPG,CAAA,CV9Cc,MUgDpB,EAAA,OAAA,CAAQ,CV/CJ,EAAA,CAAA,CAAA,CAAA,CUiDhB,IAAM,EHzMX,AGyM2BE,SHzMI,CDJb,CAAA,ACI0B,CAAgC,CAAA,CAAA,CAAuB,CAC1G,EAEU,IAAA,EAAgB,CXxBC,ACIZ,CUoBiB,CRXE,EQWF,GAAA,CACtB,EAAI,QAAA,CAAS,EAAM,MAAM,CAAE,CAAA,MAAA,EAC3B,CAAA,EAAI,CAAJ,OAAa,EAAA,CAAA,AAEf,CJ1BJ,EI0B2B,UAAvB,EAAA,YAAA,CACJ,CAEU,IAAA,EAAA,EAAe,SAAA,CAAA,aAIV,EAAA,GAAA,CAAA,EAAA,KAAA,cAGc,CAAA,CRhBF,AFTJ,CU0Bb,EAAA,EAAA,EAAgB,KAAA,aACA,IAET,EAAA,cAGY,CAAA,IACA,CAAA,GACd,EAAA,CAAA,iBAIQ,EAAA,IACL,CAAA,EAAA,IACA,CAAK,EAAA,EAEnB,CHXA,AIRA,CDmBc,EAAA,CAAA,EAAA,EAAmB,EAAA,EAAY,EAAc,EAAA,QACjC,EAAO,EAAM,CAAN,CAAY,CEkOL,CFlOmB,EAAA,CAAA,OTfpB,ASoBzB,CAL6C,ATfpB,QSoBzB,CAAA,EAAgB,CNpBC,MMoBO,CAAA,KAAA,CAAA,CAAA,CAAS,CEiOC,CFjOK,OAAA,CAAQ,KAAA,CAAM,CAAC,CAAA,CAAA,OACtD,CAAA,EAAW,EAAA,OAAc,CAAA,MAAA,CAAO,KAAA,CAAQ,CAAK,CAAA,EAAM,GAAN,IAAc,CAAA,MAAA,CAAO,MAAO,CAAA,CAAA,AAGrF,IAAA,EAAA,EAAA,OAAA,CAAA,MAAmC,CAAA,CGpBK,IAAA,QHuB1C,EAAA,IAAQ,eAA6D,SAA5B,MAC7C,EAAA,CAD6C,EAAY,WAAA,KAEzC,WAAA,CAAA,WACA,CGnBF,KAAA,YHwBd,IACyB,EAAA,QAAA,CAA2B,GAAQ,CGnBE,CAAA,IAAA,OAoKN,GAAmB,EAAO,EAAO,CAAd,KAAoB,CAAA,CAAA,EAApB,Gf/N3E,CFOyB,CENzB,CACA,CAAA,CAAA,CAAA,CAAA,CAGA,CACA,CAAA,CAAA,CAEA,CACA,CAAA,EAAiB,IAErB,AAFI,EAEJ,AACI,IAAA,EAAA,UeqN0D,EfhN1D,CCtBA,GAAA,EAAA,EAAA,CAAA,GDuBU,EAAO,CAAA,WAEA,CAAA,2CAOuB,CAAC,CAAA,CAAA,EINZ,CAAA,EJQP,EAAI,EAAA,EAAU,CORL,ADV3B,AJG4B,AFeS,CAAA,EAAA,CAAA,AACrC,CAAA,EAAgB,EAAA,CAAA,EAAA,EAAA,EAAoB,EAAK,EAAA,CAAA,eemM5B,EAAU,CJwBD,AIxBI,CAAA,EAAY,EJwBhB,AIxBgB,IAAoB,EAAS,MAAA,CAAS,CAAK,CAAA,EAAY,QAAZ,CAGjF,GfpLJ,CeiL8G,CAIlF,AAJkF,CAAA,Cf/K9G,EemLuC,EAAa,AfjLxD,EAAA,IeiLwD,CAAS,EAAK,GfpLlE,ceoLuC,Ef5KhC,EAAA,IAEH,CAAA,CAJS,CAIT,CAAiB,GACb,CAAA,EAAA,EAAiB,CAAA,UeyKyC,OAGxC,EAAA,OAAQ,CAAA,GAAA,CAAI,GDgNN,EC9Md,WAAA,CAAA,IACA,SAAA,CAAY,EAAQ,MAAA,CAAS,IAE7B,OAF6B,CAAA,OAEX,CAAA,GFMG,CFeF,AEfE,AELrB,CFKqB,YELrB,CAAiB,EAAS,MAAA,CAAS,CAAK,CAAA,UAAA,CAAA,GAE5B,EAAM,KAAA,GAClB,KAAA,CAAQ,EAAM,KAAA,CAAA,IVhDD,CAAA,SUmDb,YAAe,CAAA,YAAA,AACJ,CADI,AACJ,QAEjB,CAAK,KF3Od,MAAA,iBAKH,IAAA,CAAA,OAAA,CAAA,EAAuC,KACvC,CAAA,YAAA,CAAoC,CVVd,AIWR,EDXc,SOWb,CACX,IAAK,EAAA,CACL,QAAS,EAAC,SAKd,CACQ,IAAA,CAAK,OACT,EACS,CRJL,GQIK,CAAA,OAAA,CAAQ,OAAA,CAAQ,AAAC,IAElB,CVCC,CAAA,OUDD,CAAA,MAAA,CAAe,KAGvB,IAAA,CAAA,YACA,WACY,CAAA,MAAA,CAAO,IAAA,CAAK,CbwBH,AGrBK,WUHU,MAGpC,CAAK,WAAc,CAAA,CAAA,MACnB,CAAK,OAAU,CAAA,CRFA,IQIf,IAAA,CAAK,OAAA,CAAQ,MAAS,CAAA,EACjB,IAAA,CAAA,YAAA,CAAa,OAAA,CAAA,MAAiB,CAAA,EAC9B,IAAA,CAAA,YAAA,CAAa,QAAA,CAAS,MAAS,CCsPX,ADtPW,CJSH,AITG,CAC/B,IAAA,CAAA,YAAA,CAAa,GAAA,CAAI,MAAS,CAAA,MAE/B,CAAK,YAAe,CAAA,IAAA,CACxB,AAEO,CFwCP,QAAA,CEtCI,IAAA,CAAK,KAAM,EAAA,AEGD,AJqCG,CEvCb,IAAA,CAAA,OAAe,CAAA,KACf,IAAA,CAAK,YAAe,CAAA,4BASrB,MAGI,CRTC,CM2CM,UElCP,CAAA,IAAmB,EAAA,cAAe,CAAA,AAElC,CEEP,IFFY,CACZ,CFoCU,AEpCV,CACI,IAAM,EAAc,CFqCI,ALpChB,CODoB,WAAA,CAE5B,CCiPC,GDjPD,CAAK,OAAA,CAAU,IAAA,CAAK,CPAZ,AKqCa,MErCO,CAAA,kBAAA,CAAmB,GAAe,IAAK,CAAA,OAAA,CAAU,IAAI,EAAA,cAAA,CAAe,aAAE,CAAA,CAAa,CAAA,CAAA,AAC/G,IAAA,CAAK,EAD6F,AFsCxF,UAAA,CErCQ,KAAM,GAQ5B,CFqCA,GErCI,UAAA,CAMA,CRRA,IMyCM,AFzBV,iBIXI,EAAY,CRND,CAAA,MAAA,CQMS,0FAGb,IAAA,CAAK,OAAQ,CAAA,QAAA,CAAA,ACgPxB,ACnOA,AFZA,AAEO,SACP,CACI,IAAA,CAAK,CFgCiB,ANzCb,MMyCa,CEhCT,OAAQ,EAAA,CAAA,AFgCe,AE/BpC,CJKoB,AE0BoB,CF1BpB,AMMI,EFXxB,CAAK,CRTI,AMyCM,WAAA,CAAA,OEhCW,GAE1B,IAAA,CAAA,OAAe,CAAA,CRTD,CAAA,CIcA,CAAA,AILC,CAAA,AACf,IAAA,CAAK,CRTI,CMuCC,UE9BU,CAAA,CF8BC,GE9BD,CAAA,AAE5B,CAAA,AAkBO,IAAA,GAAA,MAAM,EAwBT,CFTA,WESY,CACZ,CAAA,KACI,CAzBR,AAyBa,CAzBb,QAyByB,CAAA,MACZ,CAAA,gBAAA,CAAmB,IAAI,EAAA,aAAc,CAAA,UAAE,EAAU,IAAM,CAAA,UAAA,CAAY,IAAM,CAAA,iBAAA,CAAmB,CAAA,CAAA,AACrG,AAMO,KAAK,CAAA,CAAA,GAEc,cAAe,CAAA,gBAAA,CAAmB,GAAS,IAAA,YAAA,EAC1D,EAAsB,cAAe,CAAA,gBAAA,CAAA,AAQzC,qBAAqB,CAC5B,CAAA,CACW,OAAA,EAAQ,QAAA,CAAA,IAAc,CAAA,SAAA,CAAU,GAAG,CAAE,CAAA,YAAA,EAAgB,IAAK,CAAA,CFiBP,qBEjBO,CAAuB,GAUrF,IAV4F,CAAA,CAAA,WAU3E,CACxB,CAAA,CACI,CRlDA,GQkDM,ECgNF,ADhNe,CAAC,CAAC,CEXJ,CFWY,QAAS,CAAA,IAAA,CAAK,SAAA,CAAU,GAAG,CAAA,CAAA,AAClD,CRjDD,CQiDkC,CCgNrB,CDhN6B,CFuB5B,OEvBqC,CAAA,IAAA,CAAK,EFuB5B,OAAA,CEvBsC,CFuBtB,CAAA,CEvByB,CAAA,EAAK,IAAK,CAAA,YAAA,CAAa,MAE7F,CAFoG,CAE5F,AAF4F,CAAA,ARhD9F,IQkDW,EAAA,CAAA,EACrB,CACQ,GAEA,EAAW,CEZb,IFYmB,EADrB,AACqB,CAAA,AAGrB,SE9JI,AAAoB,CAAA,CAA0B,CAC9D,CZMmD,CYNnD,kBAC0B,SAAA,CAAA,CAAY,CZMJ,CAAA,CYH9B,CRMA,CQNQ,MAAA,CAAA,IACK,OAAA,CAAQ,MAAA,CAAS,aACR,MAAA,CAAA,EACtB,EAAA,GAAA,CAAA,MAA0B,CAAA,MAE1B,IAAS,EAAI,EAAG,EAAA,EAAY,YAAA,CAAa,CZQV,CAAA,CWgPkB,GAAA,CCxPA,CACjD,EAAA,CAAA,KACU,CDsPuC,CCtPzB,EAAA,YAAA,CAAA,EAAA,mCAmCxB,CAAA,CACA,CAAA,CACA,CAMJ,CFVkE,CEUlE,AFVkE,QEWpC,CAAA,KAEE,SAI5B,AAJ4B,CAAA,ANA5B,GMIK,CAAA,CAAI,EAAK,EAAA,CAAA,GACT,CAAA,CAAI,EAAK,EAAA,CAAA,AACd,GAAK,KAAA,CAAA,EAAa,CJuBG,CIvBH,CAClB,AALa,EJwBM,CInBd,MAAA,CAAS,EAAK,EAAA,SAEC,SAAA,CAAA,IAGf,EAAA,KAAY,IAAA,SACjB,IAIM,CAAA,SAAA,CAAA,CAAY,KAAA,SAAK,CAAA,CAAY,CAAA,EAEnC,EAAoB,EAAQ,MAAA,CAAA,AJoBgB,AInBtC,EAAA,EAAsB,MAAS,CJoBA,AIpBA,CAAA,CAAA,AAEjC,CJkByC,IIhBvB,CJiBG,CIjBK,CAD9B,EAIA,EAAA,CAHoC,CAAA,CAAA,QAGpC,CAAkB,CJiBG,CAAA,AIjBK,CJiBL,CIjBe,CAAG,CAAb,AAAa,EAAY,EAAzB,AAAkC,GAE5D,GAFuC,CAEjC,CJgBI,CIhBM,EAFuD,AAEvD,CAFuD,CAAA,GAEvD,KACW,GAAA,CAAA,AAEvB,EAAA,IAAA,CAAA,EAAA,EACW,CAAA,EAAA,EAAe,CAAA,EACf,EAAA,CAAA,EAAe,EAAA,CAAA,EAAA,EAAA,CACX,EAAW,EAAA,CAC1B,EAAA,EAAA,CAAA,EAAA,EAA0B,MAGxB,EAAA,EAAA,OAAwB,CAAA,GAAA,CAAI,GAElC,EAAA,WAAA,CAAA,EACc,EAAA,CJ8CuB,QI9CvB,CVjBgB,CAAA,CUiBI,MAAS,CAAA,EAE3C,EAAc,OAF6B,CAAA,OAE7B,CAAA,EACA,EAAA,CDwOG,YCxOH,CAAiB,EAAS,MAAA,CAAS,CAAK,CAAA,cAE5B,EAAK,KAAA,CAC/B,EAAc,CJ+CI,IAAA,CAAA,EI/CS,KAAA,CAAA,EAEb,OAAU,CVpBDJ,CAAAA,GUqBT,YAAe,CAAA,EAE7B,EAAA,IAAA,CAAa,EJiDb,ANrEmB,QU1EgC,CAAA,EAAS,CNSI,CAAA,UMTQ,CAAA,CAAA,gBAEH,QACjE,KADsD,MAAA,CACtD,OACqB,AAAuB,aAAvB,MAAuB,KAGV,EHoBR,EGpBQ,CAAK,IAAK,CAAA,SAAA,GAE1B,CVNR,CAAA,IAAA,CUMyB,KAAA,CAAA,AAEzB,EAAO,EAAA,IAAA,CAAiB,IAAA,UAG9B,AAC+B,EAAK,CJmCL,CAAA,AChBI,OAAA,CAAA,EAAA,CAAA,EGnByB,EAAS,YAAY,CAAA,CAAA,UAMnE,CAAgB,EAAU,GJiCnB,CAAA,ALpCc,SAAA,CAAA,CSGqB,CAAA,MAAA,CAAS,CAAC,CAAE,CAAA,KAAA,CAAQ,EAAK,SAAU,CAAA,eAAA,CAAA,IAGhE,EAAA,EAAkB,EAAU,EAAS,MFqH5C,EAAS,CC+MF,CAAA,CD7M3B,CEvH4E,CAAA,CAAA,CFuHtE,EAAY,CAFqB,AFuBvB,CEvBuB,AAEb,CAFa,AFuBvB,KIjCgB,CAAA,CAAA,CFYN,AAEtB,CAFsB,AAEtB,EAAQ,YAAgB,EAAc,UAC1C,EAAA,CAD4B,CCkND,CDhNvB,EAAW,CCiNL,CTxQC,SQuDkB,CFqBT,CAAA,AErBS,EAEN,GAFM,CAAA,CFsBR,CAAA,AEnBrB,EAAA,CADS,EAEL,ERvDR,AQuDmB,WAAe,CEbK,AFaL,EAAW,YAAa,CAAA,QAAA,CAAS,MAAS,CAAA,GAAA,CAAA,EAIzD,WAAc,EAAA,EAG7B,EAAQ,AAHqB,CAAA,IAGb,CAAA,CAAA,EAGb,OAAA,gBAUU,CAAA,CACrB,CACW,OAAA,EAAQ,QAAA,CAAS,CRrDG,GAAA,CQqDE,SAAA,CAAU,GAAG,CAAK,EAAA,IAAA,CAAK,YAAA,CAAa,GAG7D,CC8MR,GDjN4E,CAAA,CAAA,iBAG7C,CFmBH,CAAA,AElB5B,CACU,IAAA,CRvDN,CQuDgD,EAAA,OAAQ,CAAA,GAAA,CAAI,GAA2B,CACnF,YAAa,IAAK,CAAA,IADiE,CFsBvF,CN1EY,GQqDU,CAAU,MAAO,CAAA,oBAAA,GAGjC,EAAa,EAAQ,AEPL,QFOc,CAAA,IAAA,CAAK,SAAA,CAAU,GAAG,CAAA,CAAA,AAChD,SAAE,CAAS,cAAA,CAAA,CAAiB,CAAA,EAElC,EAAW,YAAe,CAAA,EAEpB,IAAA,EAAA,EAA0B,CRpDG,OQoDM,CAAA,MAAA,CAAA,AACnC,EEPqC,AFOzB,EAAa,ERpDS,KQoDD,CAAA,MAAA,CAAA,IAEvC,IAAS,EAAI,EAAG,EAAI,EAAQ,GELO,GAAA,CAAA,IFMnC,AACY,CAAA,CAAA,EAAA,CAAG,cAAiB,EAAA,EAGhC,GFeQ,CEfF,CFeE,CEfQ,EAAa,OAAA,4BAI7B,EAAQ,CRvDJ,CAAA,eAAA,CQuDsB,GAE1B,CRxDA,AMsEA,CEdQ,KAAM,GAEd,IAAA,IAAS,CAAI,CAAA,EAAG,CAAI,CCyMJ,ADzMI,CCyMJ,CDzMY,MAAA,CAAQ,IAAA,CAE1B,CFcR,GEdQ,EAAA,CAAA,CAAgB,CAAC,CAAA,CAEvB,EAAA,GAAA,CAAA,GAGI,EAAA,MAAA,CAAO,EAAa,CCwML,ICjNE,CAAA,MFSe,CAAA,CAAA,AAExC,IAAA,EAAiB,EAAQ,QAAA,CAKzB,CEbH,CFaY,CFMK,UAAA,CENO,eAAgB,CAAA,EAAQ,QR3DE,GQ2DW,CAAA,EAAQ,KR3DS,IAAA,EQ2DE,GACpE,EAAA,CFMK,MENL,CAAQ,CAAC,CAAE,CAAA,IFMN,WENM,CAAgB,EAAQ,eAAgB,CAAA,WAAA,CAAa,EAAQ,KAAA,QAAA,EAAe,GAEhG,CAFoG,CAAA,CAAA,CAE9F,EAAc,EAAQ,KAAA,EAAA,CAAA,AAE5B,IAAA,IAAS,EAAI,EAAG,EAAI,EAAY,CFKpC,CAD6B,IAC7B,CEL4C,CACxC,EAAA,CAAA,CACU,IAAA,EAAQ,CAAA,CAAY,CAAC,CAAA,CAAA,CEbf,WFeM,CAAA,EAAA,EAAA,wBAAA,EACd,EAAM,QAAS,CAAA,QAAA,CACf,EAAM,QAAS,CAAA,KAAA,CACf,IAAA,CAAK,SAAA,CAAU,MAAO,CAAA,oBAAA,CETiB,CFaxC,KFKP,EELO,EAGH,aAAa,CACrB,CAAA,KACU,CCwMN,CDxMmB,ECwMI,EDxMA,GAQhB,OANP,EAAW,GFGF,CAAA,GEHY,CAAA,EAErB,EAAQ,QAAS,CAAA,IAAA,CAAK,SAAU,CAAA,GAAG,CAAI,CAAA,EAElC,IAAA,CAAA,CFEL,EEJuC,ACyMnC,CDzMmC,YAElC,CAAiB,GAAA,CAAI,GAEnB,CAAA,CACX,AAEO,EAL8B,CAAA,CAAA,KAMrC,KACI,CAAK,CFAK,eAAA,CEAY,OAAQ,EAAA,CAAA,AAC7B,IAAA,CAAK,SAAA,CAAqB,IAAA,CAC/B,AACJ,CAAA,CAtLa,AAsLb,GAnLkB,CFuLO,QEvLK,CAAA,CACtB,EC6XoC,CAAA,CAAA,CD7X9B,CACF,EAAA,aAAc,CAAA,WAAA,CACd,CFwL6B,CExL7B,aAAc,CAAA,GF0LG,SE1LH,gBACA,CAAA,YAAA,CF0LS,AEzL3B,CFyL2B,AExL3B,KAAM,iBACV,CAAA,CAAA,AAVS,GAac,cAA+C,CAAA,CAKlE,CCgYJ,gBDhYsB,EACtB,CADsB,AACtB,kCAnBG,CFmN2B,0MY1T9B,CAAA,CAAA,CAAc,CAAA,CAAA,CACA,CAAA,CAAA,CACd,CAAY,CAAA,CAAA,CACZ,CAEJ,EAAA,cAOQ,EAAA,CAAqB,EDtBpB,KAAA,GCkBkB,CAAA,aAI0B,KAFnB,EAAA,qBAAA,CAAsB,cAAA,CAAe,gBAAgB,CAAA,CAElC,CAAa,CALhD,GAKgD,KAAA,CAAA,mBAsBhD,AAMF,CD1BQ,AJMZ,AITQ,AAGI,CAAA,CAAA,CAAA,ACoBF,CAQlB,CKnBJ,ACkB6C,ANC7B,CAAA,CAAA,CACZ,CAAY,CAAA,CAAA,CACZ,CACA,CAAA,CAAA,CACA,CACJ,EAAA,EAbwC,GA1DhB,GA0DsB,CIkCM,EJpBpC,CAdkC,EAAA,AMCX,ENDe,QAAQ,GMCG,CAAA,CAAA,ENqBhD,CFvBI,CEuBC,CAAA,EAAA,KAtBwC,eAwBlC,CAAA,CAAA,EAClB,CAAA,EAAA,CAAA,EAAA,EACA,EAAA,CAAO,EAAK,CAAA,EAAM,CAAA,CAAA,GACV,EAAM,CAAA,CAAO,CAAA,CAAA,ALvBH,CKuBG,AACrB,EAAA,CAAA,EAAA,CAAA,CAAqB,CAAA,EACrB,EAAA,CAAA,EAAA,CAAA,CAAqB,CAAA,CKpBD,ALoBC,CAAA,QACA,CAAA,CACrB,EAAA,CAAS,EAAO,CAAA,EAAQ,CAAA,QACA,CAAA,EAE9B,GAAI,EAAQ,EACZ,OAGa,CDpCG,CCoCE,AOhBA,EPiBd,EAAS,EAAA,EGtBT,EAAA,KHwBgB,GAAM,CAAA,CAAA,EAAK,CAAA,CAAA,CAAA,EAAc,CAAA,EAAK,AAAL,CAAK,CAAA,CAAM,EAAG,CAAA,CAAA,CAC5C,KAAK,GAAA,CAAA,CAAA,EAAW,CAAA,CAAA,CAAM,CKZzC,CLYiD,CAAA,EAAA,AAAK,CAAA,CAAA,CAAM,EAAG,CAAA,CAAA,kBAI/B,KAAK,CGrBT,YHsBpB,CAGS,GAAA,CAAA,CAAK,EDpCC,ACoCM,EAAK,CDpCH,GAAA,ECoCgC,EAAK,CAAA,EAAA,AAAO,EAAK,CAAA,CACpE,CAAA,AAKI,EALJ,YAMe,CDxCN,GAAA,CAAA,EAAA,WCiFJ,kBACT,GAGa,EAAM,ALdJ,CKcI,EAAA,CAAA,EAAA,EAAkC,EAAA,CAAA,CACjD,CAAA,AAEI,EAFJ,UAGe,EAAA,IAAA,CAAK,EAAA,QA4BxB,COlCI,AJaO,EAAA,KHsBG,aACd,EI8CyB,IJ3CN,CI6CL,CAAA,CAAA,EAAA,EJ7CuC,EAAK,CAAA,CLflB,CKkBhC,YACW,EAAA,IAAA,CAAK,EAAO,KAAK,CAAA,CAAA,CAmChC,GAAA,KAFe,GDdC,CAAA,CCcU,CAAA,CAAA,EAEhB,EAAO,EAAK,CADjB,EAAA,CAAU,EAAK,CAAA,CAAM,CLpBR,CAAA,EKqBI,GAAO,EAC7B,YACW,EAAA,IAAA,CAAK,EAAA,KASd,EAAA,AAAI,EAAI,EAAK,EAAK,CAAA,CAAM,EAAM,CMvBC,CNuBM,EAAO,EAAQ,CAAR,CAA2B,EAA3B,AAAmC,CAAC,CAAA,CAAT,AAAS,AAChF,EAAA,EAAO,EAAO,EDZQ,ECWiD,AACzD,ADZQ,CAAA,CAAA,ECYc,EAAI,AAAJ,EAAQ,EAAQ,EAAmB,EAA3B,AAAmC,CAAC,CAAA,CAAT,AAAS,UAAT,CAjNjD,EAYhC,EAZsC,AAYtC,EAAY,CG9BuC,CHkBT,AAa1C,CG/BmD,CHkBL,AAa9C,CDnByD,CCMX,EAAA,EAa9C,AAM6E,CDzBpB,ACyBqB,CAL9E,AAK8E,AAnBhC,CAmBgC,EACvE,CClBD,AFLA,GCuBC,CAAK,EAAA,OAJhB,EAAA,ONhDI,CAAA,CAAA,CACW,CAAA,CAAA,CAAA,CAAA,CAEX,CACA,CAAA,CAAA,CACA,CAAA,CACA,CAEJ,EAAA,WAGoB,GAAI,CAAA,EAAQ,IAEvB,GAAA,EAAA,MAEW,KAAK,EAAA,CAAA,EACrB,GAAA,EAAA,MAGY,CAAA,AKzBH,CAAA,KLyBY,EAAA,CAAA,CAAA,gBAKN,CAAI,CAAG,CAAA,KAAK,KAAA,CAAA,EAAA,KAAe,GAAA,CAAI,EAAQ,EAAI,CAAC,CAAA,EAAK,CAAL,CAAa,IAAA,CAAK,EAAA,CAAI,EAAC,CAAA,CAAA,CAAA,KAK1E,OAAQ,GAFH,GAAA,CAAA,EAAA,EAAA,sCASb,KAIU,EAAA,EAAA,YAAA,MACU,KAHA,GAAA,CAAI,CAAC,EAGL,IAET,IAAA,CAAA,EAAA,eKrDO,EAAV,KAAA,EAAU,YAGT,CAAA,yCAQG,EACZ,CEcyC,CFdzB,EAChB,EAAiB,EACjBK,IAEJ,CAHqB,IAGrB,WAIyB,AEYK,CFZL,CEYK,AEZF,CFYE,UFXL,EAAM,CL0BF,AUXiB,CCJb,aNTrB,CLyBE,CKzBG,IACT,CAAA,CAAA,EAAS,KAmCX,EAAA,CAAA,EAA2B,EAAY,EAAA,SAIrC,CGoCI,CHpCG,EAAK,EAAO,EAAK,CJcA,CIdA,AJcA,CIdA,CQoBI,ORlBtB,SAKN,EAAM,CACV,CAAA,EAAA,GJYwB,AIXd,EAAA,EAGH,OAdyB,EAAA,AAAM,EAAA,CAAU,CAAA,AMiBT,CNjBS,AIYN,CJZM,CAAA,CAczC,KAAA,IAAA,CAAiB,0CQvBZ,CAAA,CAAA,2CAL2B,CNPV,IMSZ,IAAA,CAAA,OAAA,CAAA,IAAA,EAAA,MAAA,sCAMgB,aAAA,UASR,CAAA,CAAA,sBAEhB,CAAA,EAAA,eAWK,CAAA,CAAW,CAAA,CAAA,MAEhB,WAAA,SAEU,IAAA,CAAA,YAAkB,CAAA,MAAA,CAE3B,EAAA,CAAA,CAAe,EAAO,MAAA,CAAS,CAAC,CAAA,CAAA,IACjB,EDwBR,CH/Be,AD0BD,AIKd,KAAA,CCxBwB,CAAC,ALmBI,CAAA,CKZnC,CZPP,MYEI,CHmBD,GAAA,GAAA,KGnB0B,CAC7B,cZHA,IAAA,OYqBkB,CAAA,CAAA,CAAA,CAA2B,CAAA,CAAoB,CL6BvC,AHtBO,CGsBP,CK5B9B,AL4B8B,CK5B9B,CASW,MLmBwD,MKzB1D,WAAA,EAAY,GAIjB,EAFe,IAAA,CAAK,CZLE,WYKW,CAAA,MAAA,CAEhB,CAAG,CJGxB,EIH2B,EAAQ,EAAY,EAAU,GAE9C,CJQX,CGaQ,ECrBG,CAAA,AAaJ,MAAA,CAAA,CAfkE,AAelE,CAfkE,AAepC,CAfoC,AAepC,CZoBlB,AYpBkB,CAAY,CAAA,CAAY,CAC7D,CZmB+B,AKY3B,AO/BJ,CAOW,uBANU,eAIN,CPiCQ,CCzJX,CACZ,CHRJ,AGQI,CAAA,CAAY,CAAA,CACZ,CAEJ,AJFmC,CAAA,CIEnC,gBACgC,CAAS,CAAC,CAAA,GAG3B,CAFG,AELA,CFKO,EAAA,MAAO,CAAA,EAAU,CAEnB,IACR,EAAQ,+BAGmB,CFf1B,CEe6B,YAEtB,IAAA,EACnB,eACgC,EHHC,CAAA,AGGK,CHHL,EGGW,CAAA,CAAO,EAAO,IAAA,EAAA,CAAS,CAAC,CAAA,GAAM,CAAA,CACtE,EAAA,AACW,EAAA,IAAA,CAAA,EAAA,oCAQH,EAAK,CEjBE,CFiBF,EAAY,IAClB,CCIN,CAAA,KAAA,IDJoB,CAAK,GAAA,IACnB,CDQN,CAAA,KAAA,IAAA,CAAA,GCR+B,gBAEf,oBAEQ,IAKV,KAAA,KAAA,CAAW,GAHb,CHDI,CGCC,CAAA,EAGa,EAAA,GAJlB,EAAA,CAAA,CAAK,CAIsB,CHQhD,CGRkD,CAAA,CAAA,OIOS,CAAK,IJNhC,EAAK,GAFX,CAAA,EAEW,EAAI,KAHf,CNKC,CMLD,CAGoB,SAGhC,EAAA,EACA,EAAA,EAAA,EAAA,EAAA,EAID,EAAA,EAAU,CEOJ,GIiEI,IAAA,CAAK,CROV,WQPuB,CAAA,MAAA,CAAA,AAEd,CRMT,CQNS,ARMT,AQNa,CZkBF,CYlBM,CD0BuB,CC1BnB,CPiCK,AMJ5B,CC7B2B,GAE5B,GAFkC,CAAA,AAElC,CAFkC,AAiBtC,SAAA,CAAA,CAAA,CACS,CRmCA,CAAA,CQlCW,CAAA,CAAsB,CAAA,CAC7C,CAAA,CAAW,CAEf,CAAA,iBREY,AACZ,CAAA,CAAA,CAEA,CAAA,CAAA,CAAA,CAAA,CAEA,CAAA,CAAA,CAEA,CIVuD,AJUvD,CAAA,CKwDoD,ALvDpD,EAAgB,CAAA,CAChB,EAAe,CAAA,CACf,EAAY,CAEhB,EAJoB,AAIpB,GAHmB,yBA7CT,MAiDF,GAAO,AAAP,CAAY,GAAZ,GAAY,IAAA,SAKhB,IAAA,EAAA,KAAA,GAAA,CAAA,EAAwC,CJTK,CISC,GAAG,CAAA,CAAA,AAC3C,EAAA,KAAc,GAAI,CAAA,COCI,CPDY,EAAM,GAAG,CAAA,CAAA,AAEjD,EAAa,CJTL,CIOgB,AJPhB,CAAA,EISoB,CAAA,EAAM,EAAM,GAAU,EAAK,CAAf,AAAe,CODc,APCR,CODQ,APCR,CAAA,CAAA,AACvD,EAAA,CAAQ,EKqDC,CLrDS,CKqDE,CEtDE,ANMG,ADLP,CCMZ,AMPgB,CAAA,CPCO,CAAM,CAAA,GAAU,EAAK,CAAf,AAAe,CAAM,CAAA,CAArB,AAAqB,CAE1D,AAF0D,GAE1D,AAAQ,CAAK,GAAb,GAAa,AAAQ,IAAR,SAQjB,IAAA,EAAgB,CIlBP,GJkBY,CAAA,CJTL,CAAA,CISK,CAAI,EAAK,CAAC,CAAA,CAAI,KAAK,GAAI,CAAA,EAHvC,AAGuC,KAHvC,GAAA,CAAS,GAGkC,CAAC,CAAM,CAAA,IAAA,CAAK,GAAA,CAAI,EAAK,CAAA,AAAC,EAAI,IAAK,CAAA,GAAA,CAAI,AAF9E,EAAA,KAAA,GAAA,CAAA,GAEkF,CAAC,CAAA,CAAA,AAExF,EAAA,GACA,cACoB,GACV,GAAA,KAAA,IAAA,CAAU,IAhHpB,EAAA,AAuHI,EAtHJ,EAsHI,SAtGc,GAAI,CAAA,EAAA,AAAI,CGqBG,AHrBF,AAd3B,CGmC6B,AHrBF,AINS,CJMT,OAb3B,AAckB,EAdlB,CAcsB,CAAA,EAAA,EAdtB,EACA,CAcc,KAbd,AAamB,EAbnB,CAamB,CA0Gf,CAvHJ,CAamB,CAZnB,KACAA,AAcgB,CCuBE,CDvBK,EAAS,AANpC,KAAA,EAM2C,GAFpB,GAAA,CAyGf,EAzGwB,CJPA,AIOC,CAAA,CCwBI,ADxBJ,CAEU,EAAiB,MAGxD,CCqBuB,CIsBL,CDnDM,ARAN,ASmDA,QLvCE,EAAU,EAAO,OAC1B,ECmBK,GAAA,IAAA,CDnBK,IAyFjB,AAzF8B,MAA6B,CAAK,CAAA,EAAA,CAAA,CAAA,CAExC,AAFwC,EAExC,CJVuC,CIuG/D,AJvG+D,EIW7D,CADgC,GACrB,EAAW,CAAA,EAAM,EA4F9B,AA5FmC,EAUjC,CAViC,CAUjC,AAVsB,EAUH,CAAG,CAAA,GAAG,EAkF3B,AAvFS,EJTK,CIckB,AJdlB,EAAA,CIcqB,CAAA,AAJjC,EAAA,CAsFF,AAtFS,EIKG,AJLG,CK+ED,EL/Ea,EAAA,AIKQ,CAC3B,AJNmB,EAKpB,EAAY,CIUP,CJVO,EAJjB,CAAA,CAqFF,CAjF6B,CAJ3B,CAAA,CAA0B,CAAA,CAIM,CAJN,AAC1B,CAAO,AADmB,CAqF5B,AApFU,EAAM,CJRO,CIQK,CJRL,AIQK,GAK5B,AAAc,CAAK,MAAA,EAAO,COsBtB,APrBR,CADuB,CACvB,CACY,GAAA,CAAA,EAGM,IAwEd,CJJA,EIpEc,EAAY,CAC9B,EAAA,OAyEI,EArEA,OAAA,CArBa,AA0Fb,EA1FsB,AAqBZ,EArByB,AAyFnC,EAzF4C,EAAA,CAAc,AAiF1D,CAjF4C,CAkF5C,CAlF+D,CAAM,CAAzB,AAAmB,AAAM,CAAA,CAAA,AA0FrE,EApEA,OAAA,GArBsB,AAqBZ,CCEF,CDvB2B,CCuB3B,CDvBoC,CJRX,CAAI,AIQO,CJRP,AIQqB,AAiF1D,CAjFsB,AAAsB,CAmF5C,CAnF+D,CAAM,CAAzB,AAAmB,AAAM,CAAA,CAyFrE,AAnEJA,AAtByE,EAsBzEA,IAAW,CAAA,AJaE,EIsDT,EAlEA,IAAO,CAAA,EAwEP,CIhEY,EJgEZ,CAAA,KAAA,CAAA,MAAQ,CAAA,CAAA,CAAA,EACN,SAAE,CAAA,SAAS,CAAA,CAAA,CAAY,EAM7B,CAN6B,CAM7B,AAN6B,KAMZ,CJPA,EAAA,CIOI,IAAS,CJPG,EIOG,CAAA,CAAA,AAER,CAFQ,IAEhC,CACJ,CCaa,GAAA,EMlB4C,CPIhD,AOJgD,CPIhD,AOJgD,EPIhD,KAEG,EAAA,CAAA,EAGZ,IAAA,EAAiB,KAAK,GAAA,CAAI,KAAK,IAAA,CAAK,GKmFW,ELnFN,EJRL,AS2FW,ELjFvC,QAEI,CAAA,CAAO,CQrCE,CRqCK,AQrCL,IRqCK,EAAA,CAAS,CAAC,CAAA,CAChC,AADgC,EACxB,CAAA,CAAO,CORV,CPQU,MAAO,CAAS,CAAC,CAAA,CAAA,EAEd,KAAQ,COTjB,CPSoB,CAAE,EAEnC,IAAA,IAAA,EAAa,EAAA,EAAO,EAAU,CAC9B,AOXa,GAAA,gBPtMR,CAAA,CAAA,CAAA,gCAKqC,CAAA,cAAkB,EAAI,CAAI,CAAA,KAAK,GAAI,CAAA,EAAO,CAAC,CAAR,AAAQ,CAAA,yBAE7C,cAAiB,0BAGzC,CAAA,GACV,EAAA,KAAA,GAAc,CAAA,EAAA,yBAGb,EAEC,CAAA,CAAA,EAAA,EAAA,cAIG,CEKX,CAAA,EAAA,EFJQ,CAAA,CAAG,EAAA,EAAA,QAIH,CAAG,CAAA,UA2LD,CAAE,CAAG,AOZP,CPYO,CAAA,CAAI,CAAG,CAAA,CAAA,CAAA,CAAA,EAAA,CAAoB,CAAM,CAAC,CAAA,CAAG,EAAI,EAAI,EAAQ,EAAQ,EAAS,AAAzB,EAAgB,AAAkB,GAAlB,AACxE,CAAQ,CAAG,CAAA,CAAA,CAAA,EAAO,CAAA,CAAA,CAAO,AAD8E,CAAA,CACjE,AADiE,CACjE,CAAM,CAAC,CAAA,CAAG,EAAI,EAAI,CAAlB,CAA0B,EAAQ,EAAhB,AAAyB,EAAT,AAAkB,GAAlB,AAClE,GAAE,CAAA,CAAA,EAAA,CAAK,CAAA,CAAI,AADsF,CAAA,CACzE,AADyE,COZtD,CAAA,EAAA,APaT,CAAA,EAAA,AAAI,EAAI,EAAQ,EAAQ,EAAS,AAAzB,EAAkC,AAAlB,GAAA,AAEhE,EAAA,EAAA,EAAA,EAAA,EAF+F,AAE/F,CAF+F,CAAA,AAE/F,EAAA,EAAA,EAAA,GAMQ,EAAA,EACA,EAAA,EAEA,CKyGR,ELzGQ,GONA,CC3FO,CR+BH,GAAA,CQ/BQ,YAAa,CAAA,MAAA,CAAA,KAKxB,YAAa,CAAA,KAAA,CAAA,IAAA,CAAA,YAAA,CAAA,KACA,CAClB,CAAA,CACA,CAAA,CACA,EAAA,EAEA,EAAA,EAAA,GAKG,IAAA,CACX,eAgBkB,CAAA,CAAA,CAAc,CAAA,CAAc,CAC1C,CAAA,CAAA,CAAW,CAAA,CACX,CAEJ,CAAA,CACI,CD4BA,GC5BA,CAAK,ERqCG,SQrCS,OAEX,CRoCE,CQpCY,IAAA,CAAK,YAAA,CAAA,AAYlB,0BANe,CAAA,MAAA,CAClB,CDwBI,CAAA,KCxBQ,CP+CI,EO/Ce,KAAA,CAAA,EACzB,EAAA,EAAA,EAAA,EAAqB,CAAA,CAAA,GAIxB,IAAA,CAAA,AAaJ,iBAAiB,CAAA,CAAA,CAA4B,CAAA,CAAA,CAAW,AHgJzB,CGhJyB,CAAW,CAC1E,CAAA,KLzMA,CGJoB,CHKpB,MAuBA,EAAA,EAAA,EAAA,EAAA,EAGA,EACA,QHhB0C,AQ8LtC,IAAA,CAAK,CH+ID,EElHA,CJzMZ,OK4KyB,EAAA,CAAA,IAEX,EAAc,IAAK,CAAA,CD6BpB,WC7BoB,CAYlB,AAZkB,2BAMH,MAAA,GAAA,CDyBb,CCxBO,KAAA,CLlNR,EKkNQ,EAAmB,KAAA,CLjNzB,AI0OD,GJhOY,CATzB,CAKkB,CALlB,IAKuB,GAAA,CAAA,cAI0B,CTUrD,Ac8L2B,0BL1MO,CAAsB,cAAA,CAAe,gBAAgB,CAAA,CTYvF,CSVkE,CALhD,EAiBd,CAZ8D,GAY9D,EAZ8D,AAGpD,CAHoD,CAY9D,EATc,AKoMyB,EL3LvC,EK2LuC,EL3LvC,AIqNa,EAAA,EJrNb,EK4LuB,CAAA,GLrMT,QAA4B,UAqBrC,EAAA,CAAA,CAAA,CAAA,CAEO,CAAA,CHpBmB,AGqB/B,CAAA,CAAY,CACZ,CAAA,CAAA,CAAY,CACZ,CAAA,CAAA,CACA,CAEJ,EAAA,GACQ,kBAOS,CH5BS,CAAA,CAAA,CG4BE,CAAA,IAJR,EAAA,CDrBM,ACqBN,CPhBO,qBOuBC,CAAA,IAClB,CAAA,EAAA,CAAA,EAAqB,OACP,CAAA,EAAA,UAGX,CFMH,CAAA,SELS,CPhBK,AW6BJ,EJbM,CAAA,CAAA,EAAA,CAAA,EAAA,EAAA,CAAmB,EAAA,CAAA,EAAW,EAAI,CAAA,CAAA,EAEpD,IAAI,YAIJ,EAHJ,CAGI,EAAA,GAAA,GAAmC,EAAK,EAAA,AAAO,EAAK,CAAA,CACpD,CAAA,AAKI,EALJ,gBAMe,CAAA,EAAW,CHrCD,OGgEzB,CC3BA,EAAA,CDyBK,CP9BL,CAAA,EO8BK,CAAS,EAAA,CAAA,EAAA,CAAA,EAEJ,EAAO,cAAK,GAAO,EAAA,cAElB,IAAA,CAAK,EAAA,OAQF,CFHK,CAAA,EEGG,EAAK,EAAK,CP9BM,CO8BA,EAAM,EAAmB,CP9BN,CAAA,AO8Bc,CP9Bd,AO8Be,CAAA,CAAT,AAAS,MACpD,EAAA,EAAW,EAAA,EAAS,EAAI,EP9BY,EAAA,AO8Be,CAAC,CAAA,CAAA,CAjFlE,EAAA,EAAA,EAAgB,EAAA,EAAA,EAAgB,EAAI,EAAmB,CAAC,CAAA,CAAA,OAEtD,EAAA,GKuLD,CD4BH,GC5BG,CAAA,AAQJ,CHmJP,UAAA,CG/IW,OAFP,IAAA,CAAK,ID4BO,GAAA,EC5BC,GAEN,IAAA,CAAA,AASJ,KDmBK,GCnBG,CAAA,CD0BgB,CCzB/B,CAAA,CACI,IAAA,CAAA,OAAa,MAGI,CAAC,EAAU,UAAA,IAC5B,AAEI,GADO,EAAK,EAAL,GAAK,EAAM,EAAI,CAAA,CACjB,AADiB,SACjB,CAAA,OAGH,EDqBO,ICrBgB,CAAA,eAAA,CACvB,EAAQ,EAAgB,MAAA,CAE9B,IAAA,IAAS,EAAI,CAAG,CAAA,CAAA,ADoBR,CCpBY,EAAK,EAAA,UAAA,CAAa,MAAA,CAAQ,CAC9C,EAAA,CAAA,CACU,IAAA,EAAc,EAAA,YAAA,CAAA,EAAmB,CAAA,IAEvC,CAAK,CDiBL,CCjBiB,MAAM,CAAE,CAAA,GAAI,EAAY,GHyKJ,CGzK8D,KAOnG,EAAK,CDcJ,YCdI,EAAiB,EAAgB,MAAA,CAAS,EAAQ,CAC3D,CAAA,EAD0C,GAElC,EDaJ,ACbgB,IAAA,CAAA,AAGhB,EAHgB,EAGhB,IAAS,CAAI,CAAA,EAAO,CAAI,CAAA,EAAgB,MAAA,CAAQ,CAChD,EAAA,CAAA,EADwB,GAEd,EAAiB,CAAA,CAAgB,CAAC,CAAA,CH+KA,AG/KA,GAEN,SAClC,GADI,EAAe,KAAM,CAAA,IAAA,CACzB,CACI,IAAA,EAAgB,EAAe,KAAA,CAAA,AACzB,EAAc,GAAW,CADA,IACA,CAAA,AAE3B,GAAe,EAAY,SAAZ,MAA4B,CAAA,IAGjC,CDSd,CCTc,CAHwC,CACtD,EAAA,CAEc,GAAV,EAAU,KAAA,CH0LoB,EAAA,AG1LT,CAAA,CAAA,AH0LS,AGzLpB,EAAA,CH2LZ,IG3LY,CAAM,IAAA,CAAK,KAGL,EDShB,OCZmC,CAAA,AAGnB,CAHmB,AAGnB,EAAA,EAAkB,CAAC,CAAA,CAAA,AACnB,EDUhC,IAAA,ECVgC,EAAA,CAAA,AAChB,EDS0B,GCLd,EAAA,WAMrB,GANqB,CAAA,AAMrB,CAOJ,OAAO,GAAY,CAC1B,CAAA,CACI,IAAA,CAAK,OAAA,CAAQ,EAAS,CAC1B,AAWO,IAAK,CAAA,CAAA,AAZc,CAAA,AAYH,CAZG,AAYQ,CAAA,CAAA,CAAW,CAAA,CAAW,CACxD,CAAA,CAGW,OAFF,IAAA,CAAA,SAAA,CAAU,IAAI,EAAA,SAAU,CAAA,CAAA,CAAG,EAAG,CAAG,CAAA,CAAC,EAAG,GAEnC,IAAA,CAAA,AACX,AAUO,CAbgD,CAAA,CAAA,IAazC,CAAA,CAAW,CAAW,CAAA,CAAA,CHkOX,AGlO2B,CACpD,CAAA,YACI,CAAK,SAAA,CAAU,GHiOK,CAAA,EAAA,MAAA,CGjOM,EAAG,CAAG,CHiOF,AGjOE,GAAS,GAAH,AAE/B,IAAA,CAAA,AACX,AAUO,CAb+C,CAAA,CAAA,EAa1C,CAAgC,CAAA,CHoOjC,AGpOiC,CAAiB,CAC7D,CAAA,CACU,IAAA,EAAU,IAAI,CAAd,CAAc,OAAA,CAAQ,GAMrB,GAN2B,CAAA,CAAA,EAElC,EAAQ,KAAR,IAAoB,CAAA,EAEf,GAFe,CAEf,AAFe,CAEf,SAAA,CAAU,EAAS,GAEjB,IAAA,CAAA,AACX,AAYO,CAf8B,CAAA,CAAA,SAelB,CAAW,CAAA,CAAA,CAAA,CAAA,CAA2B,CAAe,CAAA,EAAW,CAAA,CAAG,CACtF,CAAA,CAEI,IAAM,EAAc,CAAA,CAAA,AHuOM,CGvOD,IAAK,CAAV,AAAU,EAAA,CAAA,EAAU,EAClC,EAAmB,CAAK,CAAf,CAAT,CAAwB,EAAV,CAAA,EAAA,AAAU,CAAA,CAF9B,EAAQ,KAAK,GAAA,CAAY,CAAA,CAAR,EAAQ,EHsOX,AGtOW,CAAA,CAGnB,EAAU,EAAC,CAAA,IAEjB,IAAS,CAAI,CAAA,CAAA,CAAG,CAAI,CAAA,EAAO,CAC3B,CHsOO,CAAA,AGvOa,AACpB,CAAA,CACU,IAAA,EAAQ,EAAc,CAAtB,AAA0B,CAAA,EAExB,CHuOhB,CGvOgB,CAFwB,CAAA,EAExB,CAAA,EACC,EAAA,IAAA,CAAc,GAAA,CAAI,GAAA,EAClB,EAAS,CHuOR,CAAA,EGvOa,CAAA,GAAA,CAAI,IAMxB,CAN6B,CAAA,KAI/B,IAAA,CAAA,IAAA,CAAK,EAAS,GAAM,CAAN,CAAA,CAEZ,IAAA,CAAA,AAeJ,CAjB+B,CAAA,CAAA,OAkBlC,CAAA,CAAW,CACX,CAAA,CAAA,CACA,CHoOsB,CGpOP,CACf,CAAA,EAAW,CAAA,CACX,CAEJ,CAAA,EAHI,EAIA,EAAQ,KAAA,GAAK,CAAa,CAAA,CAAR,EAAY,CAAC,CAAA,CAE3B,AAF2B,AAAL,GAEZ,CACd,CH8NiB,AG7Nb,CADJ,MACW,IAAA,CAAK,EH8NC,SG9NW,CAAA,CAAA,CAAG,CAAG,CAAA,EAAQ,EAAO,EAAf,GAKzB,GALgD,CAAA,CAAA,AAK3C,GAAA,CAAA,EAFM,EAAS,IAAA,AAEH,CAFQ,GAAA,CAAI,IAAK,CAEP,AAFO,CAEP,CAFO,AAEP,CAFY,GAAU,EAAL,CAAK,CAAA,CAAA,CAI1D,IAAA,EAAoB,GAAK,IAAK,CAAA,EAAA,CAAK,CAAK,CAAA,EAClC,EAAmB,CAAK,CAAf,EADyB,CAAA,CACpB,CAAA,EAAA,CAAU,EACxB,EAAkB,CADM,AACN,CADM,EACE,CAAK,CAAb,AAAa,IAAA,CAAK,EAAA,CAAM,EAAQ,CAAA,CAAA,CAAA,GAExD,GH4NW,CG5NF,CAAI,CAAA,CAAA,CAAG,CAAI,CAAA,EAAO,CAC3B,EADoB,AACpB,CAAA,CACU,IAAA,EAAS,EAAI,EAAS,EAC5B,CAD4B,CAC5B,EAAgB,EAAS,EADG,CAAA,CACH,CAAK,GAAA,CAAI,GAClC,EADuC,AACvC,CADuC,CAAA,AACvB,EAAS,IAAA,CAAK,GAAA,CAAI,GAC5B,EADiC,AAC5B,CAD4B,CAAA,AACnB,GAAA,CAAA,CAAK,EAAM,CAAA,EACzB,EAAK,EAAS,GAAA,CAAA,CAAK,EADM,AACA,CAAA,AADA,EAEzB,EAAA,EAAW,EAAS,IAAA,CADK,AACA,CADA,EACA,CAAI,KACxB,EAAM,AAAN,CH8NL,CG9NoB,IAAA,CAAK,GAAA,CAAI,EAAE,GAC1B,EAAM,EAAS,IAAA,CAAK,CH8NN,EG9NM,CAAI,EAAE,CAAA,AAC/B,CAD+B,CAC1B,EAAA,AAAM,EAAS,KAAK,GAAA,CAAI,EAAE,CAE3B,AAF2B,CAAA,AAGrC,EAAA,CADI,CH+NK,CAAA,IG7NA,CAAA,MAAA,CAAO,CH8NP,CG9NW,EAAE,CAAA,AAIb,CAJa,GAIb,CAAA,MAAA,CAAA,EAAW,EAAE,CAAA,AAEtB,CAFsB,GAEtB,CAAK,gBAAiB,CAAA,EAAI,CH8NY,CG9NR,EH8NQ,AG9NR,AAAI,CH8NI,CG9NA,EAAU,CACpD,AAEA,OAAO,AAH6C,CAAA,CAAA,EAG7C,CAAK,SAAU,EAAA,CH6NT,AG7NS,AAC1B,AAeO,WAAW,CHiOF,AGjOE,CAAwB,CAAgB,CAAA,GAAe,CAAA,CAAO,CAChF,CAAA,KAD0D,GAElD,EAAO,MAAA,CAAS,CHgOK,AG/NzB,CACW,CADX,GACW,EAGP,GAE2B,SZrWvB,AACZ,CAAA,CACA,AKgBgB,AOkVZ,CDrViC,CAAA,CXZrC,CWYgE,AXXhE,CAEJ,EAAA,IACU,CKYM,CLZK,CAAC,EAAe,CWSX,CXTW,EAC7B,KAAK,IAAO,CAAA,CAAA,EAAA,AAAG,CAAI,CAAA,EAAA,CAAG,GAAM,CAAO,CAAA,CAAA,EAAA,AAAG,CAAI,CAAA,EAAA,CAAG,GAAM,CAAE,CAAA,CAAA,AAEnD,EAAA,CAAa,EAAe,EAAe,CAAe,IAAA,KWOjB,CAAA,KXN5B,CAAA,EAAO,CAAK,EAAA,IACxB,EAAA,CAAG,CQJK,ARIL,CAAA,EAAS,CAAA,CAAA,EAAA,CAAA,AAAY,EAAA,GAC/B,CAEA,EAAkB,EAAA,MAAO,CKee,ALff,cAEL,EAAW,CAC/B,EAAA,CAAA,CACI,IAqBI,ES8DA,CE1E4B,CXT1B,EAAY,CAAA,CAAA,CAAQ,EAAA,CAAA,CAAI,CAAA,EAAA,GACd,EAAU,MAAU,EAAA,WAItB,CS8DH,AT7DP,EAAA,CADI,IAEE,CIUV,KAAA,CAAA,EAAA,CJV8B,CAAA,EAAA,CAAA,IAIpB,MAAA,CAAA,EAAA,CAAA,CAAA,EAA8B,CAAC,WAMnC,IAAA,EQNK,ARMO,CAAA,CAAO,EAAA,CACnB,CIUN,CJVkB,CAAA,CAAA,CAAQ,CKeQ,ALfJ,CS8DC,AJ/CG,CAAA,ELfC,EAAS,CAAA,AAEtC,EAAiB,EAAA,EAAoB,AAFC,KAKxC,CKcI,CAAA,ELjB4C,CAAA,CAAA,CAKxC,CADZ,ES4DkC,CTpD1B,EACA,EAAA,QAJgC,CAAA,EAAiB,CKgBrD,CLhBwD,GAK/B,IALsC,AWarC,CXbqC,CAAA,GAS5C,CKkBiB,CAAA,ELlBG,GAKjC,IAFW,EAH+B,CAAA,CAAA,CAK1C,CADV,CAOU,EAAA,CSoDe,CTpDf,EAGF,AALuB,IAAA,CAAA,GAAS,CAAA,EAAiB,EAAG,GAK/B,CWA0C,CAAA,CAAA,AXI7D,CWMM,AXLhB,AAVmE,CAAA,CAAA,CAA3B,OAKX,MAMV,CAAA,CAAG,EAAM,CIOP,AJPO,EAAN,QAIT,CAAA,CKoBJ,CLpBU,CAAG,CWEV,AXFU,EAAM,CAAA,IAE1B,CWCE,eAAA,CXDe,EAAA,CAAa,CAAA,EAAA,CAAA,CAAa,ES2FF,AT3FM,CAAA,CAAG,EAAI,CAAA,CAAG,KYkR5B,IAAA,CZlRsC,AYkRhC,CZlRgC,CAAA,AYkRxB,EAAQ,IAAR,AAIzB,MAJ2C,CAAA,CAAA,EZnenE,CAAA,CAAA,CACA,CAEJ,EAAA,kBAGc,EAAA,EAAA,CAAO,CAAI,EAAA,CAAA,CACX,EAAI,EAAA,CAAG,CAAA,EAAA,CAAA,CACP,EAAA,KAAW,IAAA,CAAM,CKdD,ALcK,AOdL,CRsBJ,COPM,APON,CCRe,EAAI,GAI9B,MAAA,UAHI,EAAI,EAGG,EDWP,ACXU,AQPD,CRKT,CAAI,CScvB,CHZuB,AGYvB,MTTyB,EAAW,KAElB,CMAK,APYX,ACXJ,KACI,EAAA,MAAA,CAAA,EAAA,CAAA,CAAA,EAAgB,CAAC,EAIjB,CAAA,CAAA,MAAA,CAAA,EAAA,CAAA,CAAA,EAAA,CAAiB,uBAMzB,IAAA,EAAA,EAAA,EAAA,EAAA,MAAA,CAAmC,CKEG,ALDtC,GAAA,KA+CQ,EA9CE,CDaD,CCbM,CAAA,CAAO,EAAI,EAAA,MAAa,CAAA,GACnB,EAAA,MAAA,EAAa,CMFD,AKgBA,CXZ5B,CSiDA,EAAA,GAAA,EAAA,CT/CI,EAAA,EAAA,GACK,EAAA,EACL,aAGE,COgBR,CPhBa,AGPF,CHOE,CAAA,CAAQ,EAAA,CAAA,EAAS,EAAO,CUA5B,CAA8B,IVAI,CAAA,CUAJ,AVAI,AACnC,CKuBR,CLvBQ,AGNJ,AHMI,EAAa,EAAA,GACb,EAAK,CITO,CIhBL,ADyCD,APhBO,EAAI,CMLL,ENOlB,GAAA,EAAA,GAAA,CAAa,MAAQ,EAAA,GAAA,CAAS,CUDvB,IVEP,CUFqC,AVGjC,EAAY,EAAA,sBAKJ,KAAA,IAAK,CAAM,CKuBH,CAAA,ALvBM,COgBH,CPhBG,CAAK,EAAG,EAAO,CAAA,EAAA,AAAG,EAAK,CAAA,EAAA,AAAG,EAAG,CAAA,CAAA,EACpC,CAAA,CAAA,GACC,WAEJ,EAAA,CAAA,CAAA,EAAA,EAAA,CAAe,EAAA,AAAI,EAAA,EAAM,CACzC,MAEI,MACiB,EAAA,CAAK,UAIL,CYIJ,CAAA,CAAA,IZHM,CAAA,KACC,QAIxB,gBAKM,EAAY,EAAQ,CAAA,CO6B1B,AP7B0B,EAGb,KAAK,CQCG,ERDH,CAAA,KACR,GAAI,CAAA,CK4BK,EL5BQ,EAAA,KAAgB,GAAA,CAAI,CSuCP,OTpC3B,EIQJ,GJRS,GAAI,CAAA,EAAG,CIQF,AGqBE,CHrBF,CAAA,CJRQ,CAAG,CAAA,EAAA,AAAG,GAAM,CAAA,CAAC,CAC5C,EAAA,QAEwB,CK+BK,ELhChB,AO8Ba,AHtBP,KJRN,GAAA,CAAA,EAAY,CION,EAAA,CJPY,CAAG,CAAA,EAAG,GAAA,CAAA,EAAA,EIQlB,KJPmB,GAAA,CAAI,GAAc,CK+BC,CAAA,CAAA,CL/BD,CAAK,GAAI,CAAA,IAInD,KAJ4D,CAAC,AAOrE,CO8BA,APrCqE,CAAA,AAOhE,EAAA,CAAQ,CAAA,EAAG,CO8BA,CAAA,CP9BK,CO8BL,CP9BgB,CAAC,EO8BD,AP9BI,EAAA,CAAK,EAAU,OACtC,CAAA,CO6B4C,CP7B5C,EAAA,CAAA,EAAmB,EAAG,EAAA,CAAK,CO8BN,CP9BgB,EAClD,EAAA,KAAA,KAAkB,CAAM,EAAG,EAAA,CAAA,EAAO,EAAE,CAAA,ASmEG,CL3Df,AJRkB,KAAA,EAAK,CAAA,EAAU,SACzC,CISE,IJTF,CAAM,EAAG,AK8BK,EAAA,CL9BD,EAAG,EAAA,EAAQ,IAAK,CAAA,EAAA,CAAK,CAAK,CAAA,EAEnD,GACV,IACM,CAAA,CAAA,CAJuD,CAAA,IAIvD,CAAA,EACQ,EW4Bd,GAAA,GX5BuB,CAAA,GAAc,EAAA,EAAA,KAClB,GAAA,CAAA,GAAkB,GAIrC,CAAA,CAAA,GAAA,CAAM,CIQJ,ACwBU,CAAA,ELhCE,CIQJ,CJRa,EAAY,EW6BS,AX7BC,EQgBC,CAAO,ARdhD,EAAA,EAEb,CAAA,CY0X4B,IAAA,CAAA,EAAA,GAGb,IAAA,CAAK,OH+NC,EG/NS,EAAA,CAAA,CAYnB,AAXP,WAWkB,CAAA,CAAW,CAAW,CAAA,CAAA,CAAe,CAAA,CAAgB,CHsO7C,AGrO1B,CAAA,CACI,GAAe,CACf,EAAA,CADI,EAEA,OAAO,IAAK,CAAA,CHoOH,GGpOG,CAAK,CAAG,CAAA,CAAA,CAAG,EAAO,GAGlC,GAHwC,CAGlC,AAHkC,CAAA,CAGtB,IHmON,AGnOM,CAAK,EAAL,CAAS,CAAA,EAAO,GAAP,AAAiB,CAAA,CAAA,AACtC,CADkC,CAC1B,AAD8B,IHoO/B,CGnOM,GAAI,CAAA,EAAW,KAAK,EAAhB,CAAoB,CAAA,CAAC,EAAW,IACvD,EAD6D,AAC/C,CADyC,AAAO,AAC5C,CAAA,AAD4C,CAAA,CAE9D,EAAe,CADG,AACC,CADD,AACC,EACb,EAAM,EADO,AACP,CHiOU,AGlOH,CACK,CAAC,AAAb,EAAqB,CAAA,CAAA,AAC3B,CAD2B,CAC3B,KAAY,GAAA,CAAI,GAEtB,EAF2B,CAAA,CAAA,EHmOL,CGjOf,IACF,CAAA,MAAA,CAAO,CAAG,CAAA,CAAA,CAAI,GACd,CADkB,CAAA,GACZ,CAAA,CAAA,CAAI,EAAK,CAAA,CAAI,EAAK,CAAA,CAAI,EAAM,CAAA,CAAA,AAAG,GACrC,CADyC,CAAA,IAClC,CAAA,EAAQ,EAAM,CAAC,AAAf,CAAc,AACrB,CAAA,KAAA,CAAM,EAAQ,EAAK,CAAL,AAAS,CAAA,EAAK,CAAL,CAAY,CAAA,CAAI,CAAJ,CAAU,GAC7C,CADiD,CAAA,IAC1C,CAAA,EAAO,EAAS,CAAhB,EACP,CADuB,AAAI,CAC3B,GAAA,CAAM,EAAQ,EAAK,CAAL,CAAc,EAAK,CAAI,AAAT,CAAS,AAAT,EAAiB,EAAM,CAAd,CAAc,AAAQ,GAC3D,CADmD,AAAY,CAAA,IACxD,CAAA,CAAA,CAAI,EAAM,EAAA,CACjB,GADuB,CACvB,CAAA,CAAM,CAAI,CAAA,EAAK,CAAL,CAAc,EAAK,CAAL,AAAQ,CAAR,AAAQ,EAAS,EAAM,EAAf,AAAe,CAC/C,CADmD,QACzC,EAAA,CAAA,AAYZ,YAAY,CAAW,CAAA,CAAA,CAAW,CAAe,CAAA,CAAA,CAAgB,CAAA,CAAiB,CACzF,CAAA,OACmB,CACf,CACI,OAAO,IAAK,CAAA,IAAA,CAAK,CAAG,CAAA,CAAA,CAAG,EAAO,GAG5B,GAHkC,CAAA,AAGlC,CAHkC,CH8N5C,AG3NkB,KAAK,GAAI,CAAA,EAAS,KAAT,AAAc,GAAI,CAAA,EAAO,GAAP,AAAiB,CAAC,CAAA,CAAL,AAAK,AACrD,CADgD,CACxC,CAAI,CAAA,EACZ,EAAS,CAAI,CAAA,EACb,EAAS,CACX,CAAI,AAFW,CAEX,AAFW,CACJ,CACA,CAAA,CACX,CADI,CACI,EAAO,CAAP,AAAO,CACf,CADQ,CACD,CAAI,CAAA,CAAX,CACA,EAAO,CADI,CACK,CAAhB,CACA,EAAQ,AADQ,CAAA,CACD,CAAP,CACR,CADQ,AACJ,CAAA,EADW,AACJ,EACX,CADI,AACJ,CAAG,EADQ,AACC,EACZ,CAAA,CADY,AACT,CAAI,CAAA,EACX,CAGA,AAHA,EADW,EAIX,IAAS,EAAI,AHkOT,EGlOgB,IAAA,EAAA,CAAS,EAAG,CAAK,EAAA,CAAA,CAAG,GAAK,CAC7C,CAAA,EACe,CAAC,CAAM,GAAA,CAAA,CAAO,EAAI,CAAC,CAAA,EAAK,CAAO,CAAA,CAAA,CAAI,CAAC,CAAA,GAAM,CAAO,CAAA,CAAA,CAAI,CAAC,CACjE,EAAA,AACW,EAAA,CHqOJ,CAAA,IGrOI,CAAO,CAAI,CAAA,CAAA,CAAG,CAAC,CAAA,CAAA,AAI9B,OAAO,EHsOH,CAAA,CGtOQ,CAAA,IAAA,CAAK,GAAQ,EAAM,CAAN,CAAA,CAatB,MAbqC,CAAA,CAAA,AAa7B,CAAA,CAAA,CAAsB,CAAA,CAAA,CAAiB,CH2OlB,CG3OmC,CACvE,CAAA,CAKW,CHqOyB,MGvO3B,IAAA,CAAA,KHwOG,IGxOH,CAAU,IAAI,EAAA,OAAQ,CAAA,CAAA,CAAG,EAAG,EAAS,GAAU,EAAV,CAEnC,CAF0C,GAE1C,CACX,AAcO,AAfI,CAFsD,CAAA,CAAA,OAiBhD,CAAW,CAAA,CAAA,AHwNf,CGxN0B,CAAW,CAAA,CAAA,CHuOtC,CAAA,CAAA,CGtOZ,CAAA,QACS,IAAA,CAAA,KHsOG,IGtOH,CAAU,IAAI,EAAA,gBAAiB,CAAA,CAAA,CAAG,EAAG,CAAG,CAAA,CAAA,CAAG,GAAS,GAAH,AAE/C,CAF+C,GAE/C,CAAA,AAYJ,CAd+D,CAAA,CAAA,MAc/D,CAAU,CAAA,CAAuB,CACxC,CAAA,CAKW,OAJP,IAAA,CAAK,OAAQ,EAAA,CAAA,AAEb,IAAA,CAAK,eAAA,CAAgB,IAAK,CAAA,OAAE,EAAO,GAAA,MAAA,CAAW,CAAA,CAAQ,CAAA,CAAA,AAE/C,IAAA,CAAA,AACX,AASO,SAAA,CAAU,CAAA,CAAW,CAC5B,CAAA,CACI,IAAI,EAAc,IAAK,CAAA,YAAA,CAAA,AAahB,OAXH,GAEA,IAAA,CAAK,GADT,EAAA,EACiB,EAAA,CAKL,AALK,CAGjB,EAAc,IAAI,EAAA,EAEN,CAFZ,IAA0B,CAAA,CAAA,AAEd,MAAA,CAAO,IAAK,CAAA,CAAA,CAAG,CAAC,CAAA,CAAA,AAE5B,IAAA,CAAK,YAAe,CAAA,EAEb,IAAA,CAAA,AACX,AAUO,IAbiB,CAAA,EAajB,CAAQ,GAAY,CAC3B,CAAA,CACI,IAAM,EAAQ,IAAK,CAAA,YAAA,CAAA,AAWZ,OATH,GAAS,EAAA,AAAM,GAAN,GAAa,CAAA,MAAA,CAAS,CACnC,EAAA,CACI,EAAM,GAAN,MAAkB,CAAA,EAElB,IAAA,CAAK,EAFa,CAAA,YAEG,CAAA,IAAA,CAAK,OAAE,CAAA,CAAO,CAAA,CAAA,CAGvC,AAHgC,IAGhC,CAAK,YAAe,CAAA,IAAA,CAEb,AAFa,IAEb,CAAA,AACX,AAEQ,WAAA,CAAY,EAAQ,EAC5B,CAAA,CACI,IAAI,IAAK,CAAA,YAAA,EAAc,CAElB,IAAA,CAAA,CAFkB,WAElB,CAAe,IAAI,EAAA,OAAQ,CAE5B,CAF4B,CAAA,CAGhC,CAEI,CAFJ,GAEU,EAAY,IAAK,CAAA,eAAA,CAAgB,IAAK,CAAA,eAAA,CAAgB,MAAA,CAAS,CAAC,CAAA,CAAA,AAEtE,GAAI,EACJ,CAEQ,IAAA,EAFR,AAEQ,AAAK,EAAU,KAAM,CAAA,CAAA,CAAA,AACrB,EAAA,AAAK,EAAU,KAAM,CAAA,CAAA,CAAA,AAEzB,GAAI,EAAU,SAAa,EAAA,CAAC,EAAU,OAAA,EAAA,CAAU,UAAA,EAChD,CAAA,CACI,IAAM,EAAI,EAAU,OAAA,EAAA,CAAA,AAEd,EAAQ,EAAA,AAEd,CAFc,CAEd,AAAM,EAAE,CAAI,CAAA,EAAO,AAAP,CAAS,CAAA,CAAA,CAAI,EAAM,CAAE,CAAA,EAAA,CAAA,AACjC,EAAA,AAAM,EAAE,CAAI,CAAA,EAAU,CAAE,CAAA,CAAZ,AAAY,CAAI,EAAM,CAAE,CAAA,EAAA,CACxC,AAEA,AAHwC,IAGxC,CAAK,YAAa,CAAA,MAAA,CAAO,IAAK,CAAA,EAAA,AAAI,EAAE,CAAA,AAGxC,CAHwC,IAIpC,CADJ,GACI,CAAK,YAAa,CAAA,MAAA,CAAO,IAAK,CAAA,CAAA,CAAG,CAAC,CAAA,AACtC,CADsC,AAE1C,CACJ,AAGO,SACP,EAAA,CACI,IAAM,EAAO,IAAK,CAAA,eAAA,CAElB,AAFkB,IAElB,CAAK,eAAA,CAAgB,MAAS,CAAA,CAAA,CAAA,AAC9B,IAAA,CAAK,YAAe,CAAA,IAAA,CAAA,AAEpB,IAAA,IAAS,EAAI,CAAG,CAAA,CAAA,CAAI,EAAK,EAAA,UAAA,CAAa,MAAA,CAAQ,CAC9C,EAAA,CAAA,CACU,IAAA,EAAc,EAAK,EAAA,KAAnB,KAAmB,CAAa,CAAC,CAAA,CAGvC,AAHuC,IAGvC,CAAK,EAAY,MAAM,CAAE,CAAA,CAAR,EAAY,EAAY,IAA0D,CAAA,CACvG,AADuG,AAGvG,IAAA,CAAK,MAAO,EAAA,CAAA,AAIhB,AAHA,IAGI,MACJ,EAAA,CACI,IAAM,EAAS,IAAK,CAAA,OAAA,CAAA,AAEpB,EAAO,IAAP,CAAa,EAAA,CAAA,AAEb,IAAM,EAAkB,IAAK,CAAA,eAAA,CAAA,AAE7B,IAAA,IAAS,CAAI,CAAA,CAAA,CAAG,CAAI,CAAA,EAAgB,MAAA,CAAQ,CAC5C,EAAA,CAAA,CACU,CAFU,GAEV,EAAiB,CAAA,CAAgB,CAAC,CAAA,CAAA,AAElC,EAAa,EAAe,GAF5B,EAEkC,CAArB,AAAqB,MAArB,GAAqB,CAAU,GAE9C,EAAe,QAF4C,CAAA,AAG/D,CAH+D,AAIpD,CADX,CACW,IAAA,GAAA,CAAQ,EAAY,EAAe,MAAf,GAAwB,CAAA,CAInD,AAJmD,CAAxB,CAIpB,IAAP,GAAO,CAAQ,EACnB,CACJ,AAEO,OAAA,AAJ0B,CAI1B,AAJ0B,CAKrC,AACJ,AANyC,IAI1B,CAAA,sBHxqBX,CAAA,MAlDO,YAAA,CAAA,EAAA,sEAmDkB,EAEO,UAC5B,YACI,EAAA,YAAA,EAAA,EAAA,IAAA,uBAIkC,SAAA,EAAY,CAAA,IA/BlD,CLlBI,UKmBR,QLlBI,IAAA,CAAA,UAAA,OKqBS,CAAA,UAAA,CAAA,IAAA,EAAA,KAA+B,CAAA,MAG/B,MAAA,OAEL,CAAA,MAAc,CAAA,CAAA,MACd,CAAA,UAAA,CAAA,SAA0B,mBAGlB,SA4BD,CAAA,CAAA,CACf,CAAA,CAMW,SALA,CJJD,AOfK,CAAA,KAAA,OHoBN,CAAA,YAAA,CAAA,IAAkB,CAAA,CAAE,CFArB,MEA6B,SAAA,CAAW,KAAM,CAAC,IAAA,AAAe,CCfZ,ADee,CAAA,CAAA,aAEvD,EAEP,IAAA,QAeG,CAAA,CACd,CDtCoB,OCuChB,IAAA,CAAA,YAAA,CAAkB,ELjDtB,AJU2B,EIV3B,CKiD2B,QAAU,WAAa,CAAA,CTvCU,ASuCJ,CTvCI,ASuCJ,CAAA,AL5CxD,aK8CkB,CL/BL,CKiCF,CLhCE,CGqBJ,CP7BD,CAAA,WSuDR,CAAA,QACI,CTlDA,GAAA,CSkDK,YAAA,CAAa,IAAK,CAAA,CAAE,OAAQ,QAAS,KAAM,mBAIzC,CL5CI,AOmBX,CH3BA,AH4BuB,AMDvB,EAAA,6CF4CuB,CAAA,CAAE,EL3DA,CAAK,IAAA,WK2De,KAAA,QAE7C,CAAK,MAAS,CJtCK,AOzBb,ARIJ,CCqBiB,EIwCZ,CE3CP,ACpBA,GAAA,kBHoFoB,CACxB,CL/E0B,AK+E1B,QACI,IAAA,CAAK,YAAA,CAAA,IAAA,CAAA,QAA4B,MTvFI,SSuFa,CAAA,IAAA,CAAM,CAAA,CAAM,CAAA,CAAA,AAE9D,IAAA,CAAK,EL/EH,IAAA,CAAA,CAAA,0BK+FoB,CAAA,CAAc,CAAA,CAAc,CAAA,CAAW,CAAA,CAAA,CACjE,CT9DgD,AS8DhD,CACI,IAAA,EAAa,IAAK,CAAA,YAAA,CAAa,IAAA,CAAA,YAAK,CAAa,MAAA,CAAS,CAAC,CAAA,CAErD,EAAY,IAAA,CAAA,YAAA,CAAkB,EAAA,KAAA,CAAA,MAAA,EAEhC,CDjEI,CCiEG,EACX,EAAW,EAEX,GAAA,GAAA,iBACA,CADA,EAAA,MAAA,CAMA,CDnEI,ACoEO,EAAA,EAAA,IAAA,CAAU,EAAA,CACV,EAAA,CLpDX,CKoDgB,IAAA,CAAA,EAAM,CAAA,MAED,CJ/CO,CI+CG,CAAA,CAC3B,EAAiB,CT7Df,CQPD,CCoE0B,CAAA,AT7DC,AWOQ,OFwDN,CDrEH,ICsEpB,EAAA,CAAA,EAAA,CAAA,CAAuB,CAAA,CAAA,IAZ9B,EAAO,CLpDA,AIbH,CCiEa,CAAA,GACV,EAAU,CAAA,YAcrB,CAAK,YAAa,CAAA,IAAA,CAAA,CAAO,OAAA,gBAAyB,KAAA,CAAO,EAAM,EAAA,AAAM,EAAN,AAAY,EAAM,CAAA,CAAA,AAAG,CAAG,CAAA,EAAU,CAAG,CAAA,CAAA,IAEpG,CAFiG,AAE5F,MAAA,CAAA,CAAA,OAUF,WACP,CGtFQ,YHuFC,YAAA,CAAA,IAAA,CAAA,QAA4B,YAAa,IAAM,CAAA,EAAA,CAAI,CAAA,CAAA,IAExD,CAAA,MAAc,EAAA,MAEP,CAAA,AAcJ,CJxDS,OIwDT,GAAW,CAClB,CAAA,ETvEc,MKiBiB,AIuD3B,CJtDQ,EAAA,ADdR,CKoEA,CAAK,YAAA,CAAa,IAAK,CAAA,CAAE,CJpDb,EAAA,IIoDqB,SAAW,CAAA,IAAA,CAAM,CAAA,CAAM,CAAA,CAAA,AAIxD,GLvEA,CKuEA,CAAK,GJvDkB,GIuDT,CAAA,CT1EN,AKmBe,EIyDhB,CJvDS,AIqDF,CAAA,AJvDS,CAAK,CIyDrB,CAAA,EJzDyB,CAEhB,CAFkB,CAAA,CAAA,ILlBL,CSsFjC,CAAA,CAKW,CTlFP,MS8EA,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,CAAE,OAAQ,IE7EQ,CAAA,CAAA,EF6EE,CAAA,IAAA,CAAM,CAAA,CAAM,CAAA,CAAA,KAElD,MAAA,CAAA,CAAA,EThFL,IAAA,ASkFO,CACX,AASO,CLnFP,MAAA,GAAA,CKoFA,CJvEkB,AMnBmB,CF6F1B,OAFP,CT3FE,GAAA,CS2FG,KJtEU,OAAA,CAAA,IIsEQ,CAAA,CAAE,GJtEO,IIsEC,kBAE1B,CE3FH,GF2FG,qBAcgB,CAC3B,CL/F0B,aKgGjB,YAAA,CAAa,CG/HlB,GAAA,CH+HuB,2BAA8B,IAAA,CAAM,CAAA,CAAM,CAAA,CAAA,AAEjE,IAAA,CAAK,MAAA,CAAA,CAAA,MAEE,CAAA,AAUJ,CG3Ia,AP+CV,EO5CN,mBHwIyB,CAAW,CAAA,CAAA,CAAW,CACnD,CE5GY,AAA4B,AF4GxC,KAEU,EAAO,IAAK,CAAA,YAAA,CAAa,CE7GnB,GF6GwB,CAAA,YAAA,CAAA,MAAA,CAAsB,CAAC,CAAA,CAAA,AAErD,EE9GO,AF8GK,IAAA,CAAK,UE9GV,EF8GuB,CAAA,CE9GK,CAAA,KF8GL,CAAM,KE9GD,CF8GO,EAEhD,EAAW,CAAA,CAAA,AACX,EAAW,CAAA,CAAA,AAEX,CLxGA,EKwGK,AAAD,GAAS,AAAgB,CE9GzB,KAJK,IACA,QFkHT,EAAA,GADkB,MAAA,CAMlB,GACW,EAAK,EAAL,EAAK,CAAK,CAAC,CAAA,CAAA,EACX,EAAK,CE9GR,CF8GG,EE9GH,CF8Ga,CAAC,CAAA,CAAA,AAElB,IAAM,EEhHiB,CAAA,CFgHI,CAAA,CAAA,AACrB,EAAW,CEjH4B,CAAA,AFiHlB,CEjHkB,AFiHlB,CAAA,AAE3B,EAAO,CElHH,CAAqB,CFgHE,AAER,EAAW,CAAA,CAAA,CAAA,CAAA,AElHqB,CAAA,AFmH5C,CEnH4C,EFmHhC,EAAW,CAAA,CAAA,CAAA,CAAA,EAAA,EAZ9B,EAAA,EAAA,CAAA,KACiB,CAAA,CAkBd,AAlBc,YAchB,YAAa,CAAA,IAAA,CAAK,CAAE,IElHhB,GAAA,mBFkH4C,IAAA,CAAM,CAAC,EAAM,EAAN,AAAY,CAAA,CAAA,AAAG,CAAG,CAAA,EAAU,CAAG,CAAA,CAAA,AAE3F,IAAA,CAAK,AAFmF,MAE1E,EAAA,EAEP,EAFO,EAEP,CAAA,AAYJ,CGzJa,IHyJR,CAAA,CAAW,CAAA,CAAW,CAAA,CAAW,CAAA,CAAW,CACxD,CAAA,CAKW,EE1HE,KFsHT,IAAA,CAAK,YAAa,CAAA,IAAA,CAAK,CAAE,IErHhB,GAAA,YFqHsC,CAAC,CAAA,CAAG,CAAG,CAAA,CAAA,CAAG,CAAG,CAAA,EAAS,CAAG,CAAA,CAAA,AAExE,IAFqE,AAErE,CAAK,MAAS,EAAA,EAEP,EAFO,AEpHV,CFoHU,CAEP,CAAA,AAWJ,OAAO,CEnID,AFmIC,CAAW,CAAW,CAAA,CAAA,CAAgB,CACpD,CAAA,AEvHY,QFwHR,IAAA,CAAK,YAAa,CAAA,IAAA,CAAA,QAAe,CExHgB,CAAA,CAAA,KFwHN,CAAA,IAAA,CAAM,CAAC,CAAA,CAAG,CAAG,CAAA,EAAQ,EAAS,CAAG,CAApB,AAAoB,CAAA,IAAH,OAE3D,CAAA,CAAA,EAEP,IAAA,CAgBJ,UAAA,GAAa,CAAA,CAAA,QAEhB,CG/JA,GH+JA,CAAK,SEzIc,GAAA,CFyID,EEzIC,EFyII,CAAA,CAAE,OAAA,YAAqB,IAAA,CAAM,CAAA,CAAM,CAAA,CAAA,AAE1D,IAAA,CAAK,MAAA,EAAS,EAEP,EAFO,AEzIF,CFyIE,CAEP,CAAA,AAaJ,EEzJU,GFyJV,GAAQ,CACf,CExJiC,QFyJ7B,IAAA,CAAK,YAAA,CAAa,IAAK,CAAA,QAAU,MAAQ,CAAA,KAAA,IAEzC,CG1KA,GH0KA,CAAA,MAAc,EAAA,EAEP,CGtKE,CHoKK,CAAA,CAEP,CAAA,AAcJ,YAAA,GAAe,CACtB,CAAA,CGhLqB,OHiLjB,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,CAAE,OAAQ,cAAe,IAAA,CAAM,IAEtD,IAAA,CAAK,MAAS,CAAA,GAEP,CAFO,CAAA,EAEP,CGjLK,cHiMhB,CAAA,CAKW,GGjMwB,QH6L/B,CAAK,YAAA,CAAA,IAAkB,CAAA,CAAE,OAAQ,IG1LP,aH0L0B,CAAA,CAAM,CAAA,CAAA,AAE1D,IAAA,CAAK,MAAS,EAAA,EAEP,CG7LmB,GH6LnB,eAiBU,CACrB,CAAA,CAKW,OAJP,IAAA,CAAK,YAAA,CAAa,IAAK,CAAA,CAAE,OAAQ,YAAc,CAAA,IAAA,CAAM,CAAA,CAAM,CAAA,CAAA,AAE3D,IAAA,CAAK,MAAS,EAAA,EAEP,CG3MqB,CHyMd,CAAA,CAEP,CAaJ,AAbI,WAaJ,GAAc,CACrB,CAAA,CAKW,OAJP,CGtNA,GHsNA,CAAK,YAAA,CAAa,IAAK,CAAA,CAAE,OAAQ,YAAc,CAAA,IAAA,CAAM,CAAA,CAAM,CAAA,CAAA,IAE3D,CAAK,MAAA,EAAS,EAEP,EAFO,CAAA,CAEP,CAAA,AAaJ,YAAA,GAAe,CACtB,CAAA,CAKW,IGpOJ,GHgOH,IAAA,CAAK,YAAA,CAAa,IAAK,CAAA,CAAE,OAAQ,aAAe,CAAA,IAAA,CAAM,CAAA,CAAM,CAAA,CAAA,AAE5D,IAAA,CAAK,MAAS,EAAA,EAEP,EAFO,CAAA,CAEP,CAAA,AAsBJ,KAAK,CAAW,CAAA,CAAA,CAAW,CAAA,CAAgB,CAAgB,CAAA,CAAA,CAAsB,CAAA,CAAmB,CAC3G,CAAA,CACI,IAAA,EAAgB,GAAS,CAAA,CAAzB,AAAyB,AAEzB,CAFyB,GAAzB,AAEM,EAAc,CAAA,CAAA,CAAK,IAAK,CAAA,AAAV,EAAU,CAAK,CAAK,CAAA,EGjO9B,EHkOE,AAAS,CAAA,CAAA,EADmB,AAElC,CAFkC,CAElC,AAAmB,EAAnB,CAAA,IAAA,EAAc,CAAU,EACxB,EAAU,EAAC,CAAA,AAEjB,IAAA,IAAS,CAAI,CAAA,CAAA,CAAG,CAAI,CAAA,EAAK,CAAL,AACpB,EAAA,CAAA,CACU,IAAA,CAAA,CAAI,CAAI,CAAA,CAAA,CAAI,EAAc,EAC1B,EAAS,EAAI,AADa,CAC1B,AAD0B,CACJ,CADI,CAGxB,CAFoB,CAEpB,IAAA,CAAA,AACJ,CAHwB,AAGnB,CAHmB,AAGnB,CAAA,CAAI,IAAK,CAAA,GAAA,CAAI,GAClB,CAAK,CADkB,AAClB,CADkB,AAClB,CAAI,IAAK,CAAA,GAAA,CAAI,IAMnB,CANwB,CAAA,AG9N5B,KHkOE,IAAA,CAAA,IAAA,CAAK,GAAS,EAAM,EAAN,CAEZ,IAAA,CAWJ,CAb+B,CAAA,CAAA,EAa/B,CAAM,GAAO,CACpB,CAAA,CACU,IAAA,EAAoB,IAAI,EAI9B,GAFA,CAEI,CAFc,IAFZ,CAAqC,EAAA,CAAA,KAEzB,CAAgB,CAAlC,GAAuC,CAAA,aAAA,CAAA,AAElC,EAMD,EALJ,EAAA,AAKI,IAAA,EAAa,EAAG,CAAA,CAAI,IAAK,CAAA,YAAA,CAAa,MAAA,CAAQ,CAC9C,EAAA,CAAA,CACU,CGtOd,GHsOc,EGtOD,AHsOe,IAAK,CAAA,YAAA,CAAa,CAAC,CAAA,CAAA,AAErB,EAAA,YAAA,CAAa,IAAK,CAAA,CAAE,IGvON,CAAA,CHuOc,CAAA,EAAY,MAAQ,CAAA,EAApB,EAAoB,CAAM,EAAY,IAAA,CAAK,IAAL,CAAW,EAAA,CAAG,CAAA,CAAA,KARpF,EAAA,YAAA,CAAe,EAAf,EAAoB,CAAA,YAAA,CAAa,KAAM,EAAA,CAAA,AAYtD,OAAA,CAAA,CACX,AAEO,OACP,CAIW,EG3OK,CAGR,CAAA,GHqOJ,IAAA,CAAK,YAAA,CAAa,GGvOS,GHuOA,CAAA,CAAA,CAC3B,AAD2B,EGvOS,CAAA,CHwOpC,CAAK,MAAS,EAAA,EAEP,IAAA,CAAA,AAiBJ,UAAU,CACjB,CAAA,CACI,GAAI,EGvOD,CAAA,SHuOmB,GAAU,GG/NhC,IH+NgC,GG/NnB,CAAA,CHiOb,IAAM,EAAI,EAAA,CAAO,CACX,AADW,EACP,EAAO,CAAA,CAAA,AACX,EAAI,EAAO,CAAA,CAAA,EAAA,AACP,EAAO,CAAA,CACX,EADW,AACN,EG5NF,EH4NS,CAAA,EACP,CG7NO,CH6NA,EAAA,CG3NE,AH6NhB,CAAI,AAFU,CAEV,CAAA,CAAA,AACJ,CG7NE,AH6NE,CAAA,CAAA,CAAA,AAEJ,EAAO,CAAA,CACP,EAAO,CAAA,CG3ND,AH2NC,AACP,CGhOoB,CHgOb,CAAA,CACP,EAAO,CAAA,CAEP,EAAK,CG5NC,AH4ND,CAAA,AACL,EAAK,CAAA,AG5NC,CH8NV,AAFS,IAET,IAAS,CG7NM,CAAA,EH6NC,CAAA,CAAI,IAAA,CAAK,YAAA,CAAa,CG7NG,CAAA,IAAA,CH6NK,CAC9C,EAAA,CAAA,OACwB,EG9NM,EH8ND,CAAA,YAAA,CAAA,EAAc,CAAA,kBAGnB,EG/NM,IHgO1B,EACI,CGjOsB,GHiOjB,sBAGD,CAAA,CAAI,CAAA,CAAK,CAAC,CAAA,CAAA,AACV,CAAA,CAAI,CAAA,CAAA,EAAM,CAAA,AAEV,CAAA,CAAK,CAAC,CAAA,CAAK,CAAI,CAAA,CAAA,CAAM,EAAI,CAAK,CAAA,EAAA,CAC9B,AAD8B,CACzB,CAAC,CAAA,CAAK,CAAI,CAAA,CAAA,CAAA,EAAA,EAAA,EACf,KACJ,CADI,IACC,gBAED,EAAO,CAAA,CAAP,AAAY,CAAC,CAAA,CAAA,AACb,EAAO,CAAA,CAAP,AAAY,CAAC,CAAA,CAAA,AACb,EAAO,CAAA,CAAP,AAAY,CAAC,CAAA,CAAA,AACb,EAAO,CAAA,CAAP,AAAY,CAAC,CAAA,CAEb,AAFa,CAEb,CAAI,CAAA,CAAK,CAAC,CAAA,CACV,AADU,CACV,CAAI,CAAA,CAAK,CAAC,CAAA,CAAA,AAEV,CAAA,CAAK,CAAC,CAAA,CAAK,CAAI,CAAA,EAAS,EAAI,AAAb,EAAqB,EAAA,AACpC,CADoC,AACpC,CAAK,CAAC,CAAA,CAAK,CAAI,CAAA,EAAS,EAAT,AAAa,EAAQ,EAAA,AACpC,CADoC,AACpC,CAAK,CAAC,CAAA,CAAK,CAAI,CAAA,EAAS,EAAT,AAAa,EAAQ,EAAA,AACpC,CADoC,AACpC,CAAK,CAAC,CAAA,CAAK,CAAI,CAAA,EAAS,EAAT,AAAa,EAAQ,EAAA,AACpC,CADoC,AACpC,CAAK,CAAC,CAAA,CAAK,CAAI,CAAA,CAAA,CAAM,EAAI,CAAK,CAAA,EAAA,AAC9B,CAD8B,AAC9B,CAAK,CAAC,CAAA,CAAK,CAAI,CAAA,CAAA,CAAM,EAAI,CAAK,CAAA,EAC9B,AAD8B,CAAA,IAGlC,CAFI,IAEC,kBAAA,CAED,EAAO,AGjOL,CHiOK,CAAK,CAAC,CAAA,CAAA,AACb,EAAO,CAAA,CAAP,AGhOR,AHgOoB,CAAC,CAAA,CAEb,CAAA,CAAI,CAAA,CAAK,CAAC,CAAA,CACV,AADU,CACV,CAAI,CAAA,CAAK,CAAC,CAAA,CAAA,AAEV,CAAA,CAAK,CAAC,CAAA,CAAK,CAAI,CAAA,EAAS,EAAT,AAAa,EAAQ,EAAA,AACpC,CADoC,AACpC,CAAK,CAAC,CAAA,CAAK,CAAI,CAAA,EAAS,CG/NL,CH+NS,AAAb,EAAqB,EAAA,AAEpC,CAFoC,AG/NH,AHiOjC,CAAK,CAAC,CAAA,CAAK,CAAI,CAAA,CAAA,CAAM,EAAI,CAAK,CAAA,EAAA,AAC9B,CAD8B,AAC9B,CAAK,CAAC,CAAA,CAAK,CAAI,AG9NP,CH8NO,CAAA,CAAA,EAAU,CAAK,CAAA,EAAA,AAE9B,CAF8B,GG9NF,CAAA,AHkOhC,CGlOgC,AHgO5B,IAEC,WAED,CAAA,CAAI,CAAA,CAAK,CAAC,CAAA,CAAA,AACV,CAAA,CAAI,CAAA,CAAK,CAAC,CAAA,CAAA,AAEV,EAAK,AAAL,CAAK,CAAK,CAAC,CAAA,CAAA,AACX,EAAA,AAAK,CAAA,CAAK,CAAC,CAAA,CAAA,AAIX,CAAA,CAAK,CAAC,CAAA,CAAK,CAAI,CAAA,EAAA,AAAO,CAAI,CAAA,EAAA,AAC1B,CAD0B,AAC1B,CAAK,CAAC,CAAA,CAAK,CAAI,CAAA,EAAA,AAAO,CAAI,CAAA,EAAA,AAE1B,CAF0B,AAE1B,CAAK,CAAC,CAAA,CAAK,CAAI,CAAA,CAAA,CAAM,EAAI,CAAK,CAAA,EAC9B,AAD8B,CAC9B,AAD8B,CACzB,CAAC,CAAA,CAAK,CAAI,CAAA,CAAA,CAAM,EAAI,CAAK,CAAA,EAE9B,AAF8B,CAAA,IAIlC,CAFI,IAEC,QAAA,CACD,CGtOE,CAAA,AHsOG,EAAA,CAAK,EAAgB,CAAA,CAAK,EAAA,CAAI,GACnC,GADyC,CAAA,CAE7C,AAF6C,CACzC,IACJ,OACI,CAAA,CAAK,CAAC,CAAI,CAAA,EAAgB,CAAK,CAAA,CAAC,CAAA,CAAG,MAAM,CAAA,CAAA,AAE7C,AAFc,KAET,EGnOP,SHoOM,CAAK,CAAC,CAAI,CAAA,EAAgB,CAAK,CAAA,CAAC,CAAA,CAAG,GACnC,GADyC,CAAA,CAE7C,AAF6C,CACzC,IACC,YACD,CAAA,CAAK,CAAC,CAAA,CAAI,CGnOJ,CHmOoB,CAAK,CAAA,CAAC,CAAA,CAAG,GACnC,GADyC,CAAA,CAAA,AAE7C,KAAK,SAAA,CACI,CAAA,CAAA,CAAC,CAAE,CAAA,SAAA,CAAU,GAClB,GADwB,CAAA,CAE5B,AAF4B,CACxB,IACC,MAAA,CACD,CAAA,CAAK,CAAC,CAAI,CAAA,EAAgB,CAAK,CAAA,CAAC,CAAA,CAAG,GACnC,GADyC,CAAA,CAA/B,AAA+B,AAE7C,CADI,WAGK,EAAA,IAAA,EAAA,0BAAA,CAA4B,EAAY,MAAM,CAAA,AAEnD,CAFmD,AAG3D,CAKG,YAFF,MAAS,EAAA,EAEP,IAAA,CAAA,AACX,AAEA,IAAI,QACJ,QACW,IAAA,CAAK,SAAU,CAAA,CG3NJ,CAAA,IH2NI,CAAA,AAiBnB,aAAA,CACP,CAAA,CACQ,IAAA,EAAQ,GAAR,CAAa,CAAA,YAAA,CAAa,MAAS,CAAA,CAAA,CAAA,AAEnC,EAAkB,IAAK,CAAA,YAAA,CAAa,EAAK,CAAA,AAE7C,EAF6C,CAEzC,CAAC,EAKM,OAHP,EAAI,CAAI,CAAA,CAAA,CAAA,AADZ,EAAA,AAEQ,CAAI,CAAA,CAAA,CAED,CGrOI,CHwOR,CGtOP,IHsOkC,WAClC,GADO,EAAgB,MAAA,EACvB,CAGI,IAJG,CAIC,EAAQ,CACZ,CAIW,CAJX,MACI,EAAI,CAAJ,AAAQ,CAAA,CAAA,CACR,AADQ,EACJ,CAAJ,AAAQ,CAAA,CAAA,CAAA,AAED,EAGO,CAHP,CAGO,AAHP,IAGO,CAAK,QAAL,IAAK,CAAa,EAAK,CAAA,AAC7C,AAEA,EAH6C,KAGrC,EAAgB,MACxB,EACI,IAAK,QAAA,CAAA,AACL,IAAK,QAAA,CACG,EAAA,CAAA,CAAI,EAAgB,IAAA,CAAK,CAAC,CAAA,CAAA,AAC1B,CG3OD,CH2OC,CAAA,CAAA,CADoB,CACpB,IAAoB,CAAK,CAAC,CAAA,CAAA,KAElC,KAAA,mBACQ,EAAA,CAAA,CAAI,EAAgB,IAAA,CAAK,CAAC,CAAA,CAAA,AAC1B,EAAA,CAAA,CAAI,CADgB,CACA,IAAA,CAAK,CAAC,CAAA,CAAA,AAC9B,KACJ,AAF4B,CACxB,IACC,eAAA,CACG,EAAA,CAAA,CAAI,EAAgB,IAAA,CAAK,CAAC,CAAA,CAAA,AAC1B,EAAA,CAAA,CAAI,CADgB,CACA,IAAA,CAAK,CAAC,CAAA,CAAA,AAC9B,KACJ,AAF4B,CACxB,IACC,KAAA,CAAA,AACL,IAAK,UAAA,CACG,EAAA,CAAA,CAAI,EAAgB,IAAA,CAAK,CAAC,CAAA,CAAA,AAC1B,EAAA,CAAA,CAAI,CADgB,CACA,IAAA,CAAK,CAAC,CAAA,CAAA,AAC9B,KACJ,AAF4B,CACxB,IACC,SAAA,CAED,EAAgB,IAAK,CAAA,EAAG,CAAA,YAAA,CAAa,GAItC,AAJyC,CAAA,CAAA,KAIzC,EAEf,CAEA,AAFA,AAFe,CAAA,QAIN,EAAgB,CAAA,CAAwB,CACjD,EAAA,OACI,AAAI,CAFC,CAIM,EAAc,OAAA,CAAQ,CADjC,EAAA,AACW,AAGJ,EAAU,IAHyB,CAAA,AAGnB,CAHmB,CAGnB,AAC3B,CAD2B,4EP90B6B,CAAA,CAAA,CAAY,CACpE,EAAA,MACkB,CHOH,CAAA,YGPO,CAAA,oCDOtB,eAEsB,CAAM,CFFJ,8ESNZ,KAAA,gBAAwB,mBACd,CFQF,ADfD,IGOS,SAAU,QAAA,gBAGlB,QAAS,QAAS,CAAE,kBAClB,KAAA,iBAAyB,CAAE,CAAA,mBACzB,KAAM,CLUE,gBKViB,CAAE,mBAC7B,eAAkB,QAAS,IV0B7C,EU1BoD,2CACN,OAAQ,CAAA,4CACN,wBAC1B,CFmBD,CAAA,AFLG,GAAA,SIdc,EGwCtC,MHxC+C,MAAO,CAAA,4CACN,WAGvC,CRyBC,sBQzB0B,CAAE,CEyBG,AFzBH,WA0B1B,EAAA,CAAA,CAAA,CAAA,sBAEM,CAAa,qBAMH,oCAGf,oBAKb,IAAA,KAAA,EACA,qBAC0B,CAAA,QAIH,EAAS,CIOA,CAAA,EAAA,EJPuB,IAAA,gBAOhC,EAAM,CD2BK,AGfP,CHeO,GC3BL,CAAA,SAEzB,IAAA,EAAa,CAAA,CAAG,CAAI,CAAA,EAAW,MAAA,CAAQ,CHsBvC,AGrBA,GAAA,KAGW,EAAK,EAAS,CRDP,AQCO,AAFH,CAAA,CAAA,EAAY,CAAE,IAAK,EAAA,CAAA,AAEN,KAAA,CAAM,GAAG,CAEpC,AAFoC,CAAA,CAEpC,CAAA,EACJ,EAAA,EHwBI,EGvBwB,EAAQ,EAAK,CAAA,CAAb,AAAmB,GAAN,CAAM,EAAM,CAAA,CAAA,QAMzD,CD4BA,WAAA,EAAA,SC5BoB,CAAa,EAAuC,IAAA,KAAA,MAC7D,EAAO,OAAA,CAAW,EAAmC,IAAA,GAAA,MACvD,EAAA,OAAA,sBACS,WAYjB,EAAA,CACL,CACA,CACA,CAAA,CAAA,CJFuC,CIK3C,EAAA,0BAI0B,WACd,gBACyB,CAAA,QACrB,CAEUC,IAAAA,EAAAA,EAAqB,KAEpB,WAAY,CAAA,IAAA,CAAA,EAAe,IAAA,CAAA,EAAO,CAAA,CGaT,CAAA,KHRzB,CRrBuC,AKoCnC,CLpCmC,AKoCnC,CLpCmC,GKoCnC,CDzBhB,ACyBqB,IAAA,CGfG,KAAQ,CAAA,EAAA,KAAA,CAAA,MAAA,CAAa,CGWC,OHXQ,CAAA,GAAO,EAAF,MAAE,cAGzC,CAAA,GGYM,AHT7B,CAHuB,AHiBvB,CGjBuB,GAI3B,CHcA,IAAA,iBGbW,WAAA,CAAA,KAAA,CAAoB,OAAA,GAC3B,UACC,OACD,GAAA,SAAA,EACA,CACQ,CHoBJ,EAAA,EAAA,UAAA,CAAA,QGnBA,KAEUA,EAAAA,EAAAA,KAEC,SAAA,CAAA,IAAA,CAAiB,EAAQ,IAAA,CAAA,EAAA,uBAKP,CHkB7B,AMLsB,EAAA,KAAA,CHba,CRGF,CAAA,IAAA,CAAA,QQHkB,CAAA,GAAO,EAAF,MAAW,EAAA,CAAA,EAG5D,OAAA,EAAU,YAGpB,CCmEM,CLrDT,CCKU,6BGlBiB,CAAA,OAAA,GACzB,UACC,iBACM,EAAA,WAAA,CAAY,KAAQ,CAAA,OAAO,CCqEJ,CAAA,CDpE9B,EADuC,QAEtC,ERSO,UQPD,SAAA,CAAA,KAAkB,CAAA,OAAO,KACzB,AAD8B,CAAA,AJoBnC,CIpBmC,CGgBT,QPI1B,CAAA,KAAA,CAAA,OInBgC,iBLrHE,CGPT,AHQvC,eAG8B,YAAS,GKLG,CAAA,CAAA,OLMtC,CAAA,EACiB,YAAA,CAAA,IAAA,CAAkB,CQwBZ,WAtDX,EACZ,CLVgB,AILN,AJKM,CAAA,AKWhB,CRbwB,AQe5B,EAEQ,GAAA,AAAe,UAAf,OAAA,EACJ,OAEgB,SAAS,aAAA,CAAc,qBAEf,IAAK,GACnB,CXbN,CWaM,EAAA,aAAA,CAAkB,CDhBX,MCoBjB,CNZA,GMYM,EAAA,SACO,EACT,KAAM,CAAA,eAKV,CRnBA,AJkBA,qCWzCwB,CAAiB,kBAG5B,CAAA,AVKK,AQPF,AHPD,CNyBf,EAAA,EAAA,MAAA,CAAA,IAAA,OWduB,CAAA,CAAY,CAAC,CAAA,CAGhC,IAAA,IAAA,EAAA,EAAA,EAAA,EAA+B,QAAA,CAAS,ENX5B,IAAA,CMWoC,CAChD,CNZY,CMYZ,AZG4B,CYH5B,KACU,CPA2B,AQkB/B,CAAA,EDlBuB,QAAA,CAAS,CAAC,CAAA,CAAA,CCkBC,CAAA,CAAA,IDf5B,EAAA,QAAA,CAAe,CCiBF,UAAA,IDfjB,IAAA,0BAEuB,EAAE,CAAA,CAAA,SAiBhC,APLQ,CGEP,AFLK,ADGE,EAAA,QOQqB,EAAO,KAAM,CAAC,CAAA,CAAA,WACD,CAAC,CAAA,CAAA,IACd,CCeuB,CDfhB,ACegB,CAAA,GDfhB,CAAM,CAAC,CAAA,CAAA,AAC1C,EAAA,EAA4B,EVE9B,AUFqC,IAAA,CAAM,CAAC,CAAA,CAAA,IAGrB,YAAA,CAAa,kBAAoB,mBAAA,CAAA,qDAQjB,OAAU,CAAA,QAAA,MAIrD,IAAA,EAAa,EAAA,EAAA,EAAa,QAAA,CAAS,MAAA,CAAQ,CAC3C,EAAA,CAAA,KACU,EAAA,EAAa,QAAA,CAAS,CAAC,CAAA,GAGd,EAAuB,CC0BA,CAAA,AD1BM,EAAA,IHoBxC,GGpBkD,CAAC,CAAA,CAAA,AACjD,EAAQ,EAAA,KAAA,CAAM,MAAO,CAAA,QAAA,CAAS,EAAK,YAAa,CAAA,YAAY,CAAC,CAAA,CAAE,QAAS,EAAA,CAAA,EAErE,YAAA,CAAA,EAAqB,UAG3B,GAjDsD,KAAmB,CAAA,CAAA,8BAGnD,EAAM,CJGN,APaJ,AQdK,CRcL,CAAA,GWhBgB,UA0DpC,UA1DwD,6CA6DtD,IAAI,CHeQ,CAAA,YGfR,CAAA,EAAA,EAAA,EAAsB,CAAC,CAAA,CAAA,AFZI,CAAA,CAAA,GG3BlB,EAAA,mBAGC,CAEf,WAAE,CAAW,CAAA,YAAA,CAAA,CAAgB,CAAA,CNDL,CMCmB,EAAK,ENDI,CMG1D,CDvBA,AEeA,GDQA,IAAS,CRtBI,AQsBA,CAAA,CAAA,CPzBG,EAAA,EOyBa,MAAA,CHvCD,AGuCS,IACrC,CACU,IAAA,ERvBG,CAAA,CQuBc,EAAA,CAEc,QAAQ,CXlB7C,EWkBU,QAAS,CAAA,WAAA,IAe3B,SAAA,EAAwB,CCjBG,CAAA,CAAA,CDiBgC,CAAA,CL/BX,AK+BiC,CACjF,CRxBqD,CAAA,AQwBrD,CRxBqD,GQyD7C,CP7CM,AO6CN,CACA,CAAA,CFLJ,EEOI,EACA,EACA,EACA,EFWJ,EETI,CAAA,CACA,EACA,EACA,EAEA,EACA,EACA,EACA,EAhDE,EAAW,EAAI,CRvBV,OQuBU,CChBrB,CAAA,UDmBmB,CAAI,CH7BW,AG6BX,YAAa,CAAA,CAAO,CAAA,CRxBG,CAAA,AQwBW,CRxBX,CQwBgB,ERvB9D,CAAA,GQyBU,CX3BF,AWyB6D,CAAA,CAA1B,AAA0B,CAIrD,CAAE,CJXJ,EIWO,CAAW,CAAA,CFlBE,CAAA,CEkBC,CAAG,CAAA,CAAA,AAE7B,IACT,CJbc,CAAA,AIcE,CAAA,EAGZ,GAAA,EAEA,EAAc,CAAE,GAAG,CAAa,CAAA,GAAG,CAAG,QAIxB,CAAA,EAGZ,IAAA,EAAU,CAAC,GAAa,CAAC,EA4BvB,CFyCR,MElEI,CP5CM,KO8CM,CAAE,CJRoB,KIQb,CAAE,GAuBnB,EAAI,QAAS,CAAA,CPlBK,UOkBL,CPlBK,COmB1B,EACI,IAAK,CX3BS,EK8BF,KMDJ,CAAA,CAAA,CPnBN,CAAA,YAAA,CAAA,KOqBQ,CX7BN,GW6BM,EAAW,CNGO,CMHH,CAAA,WAAA,CAAa,WAAW,CAAA,CAAA,AAEvC,EAA2B,ARtIxB,AADH,CQuI4B,CRvInB,AQuImB,CAAA,CHdM,CAAA,CTzGrB,AONC,AE+GoB,CF/GpB,CHVC,CILb,AFAA,AM4IS,CN5IT,AEAA,UJMO,MAAA,CAAA,AAAQ,GAAS,EAAK,IAAA,GAAO,MAAA,CAAS,CAAC,CAAA,CQwIhD,ARxIgD,EQwI1B,EAAS,MAAS,CAAA,CAAA,CAAA,AAI9C,GALwC,AAGb,CAEvB,ENIQ,GDzBhB,ICyBgB,EMTe,GAGsB,EAGjD,CACI,IAAM,EAAmB,EXdrC,AWc8C,GAAI,CAAA,AAAC,IAAa,CAChD,IAAM,CAAA,EACN,EHXR,EGWQ,CAAM,APpBlB,ADjHD,CH8He,QG9HY,CAClC,QACmB,EAAA,KAAS,CAAM,6BAEzB,GAAA,EAAiB,MAAA,CAAS,EAAA,OAAA,QAEf,EAAO,GAAA,CAAA,YACX,sBAGgB,CLYhB,KKZgB,CAAA,GAAa,CACzC,eAEI,CMK4C,CAAA,CAAA,KFH3B,AJDL,CICK,AJDL,CAAA,EAAU,EAClB,EAAA,IAAA,CAAA,CAAA,CAAA,EAAA,EAAA,oBAI6B,IAAd,CIaG,ADXD,CAAA,MAAA,CHFY,OAAA,oBAEZ,CCHD,AIdI,CLiBD,QAET,GAAA,IAAO,SAGnB,CAJO,AAIC,KAJI,GAAI,CAAA,GAAA,GAIR,CAAA,GAAgB,CQsBK,IRxBjB,GAAA,IAAO,GAEY,COMI,CAAA,ECqGD,GAC1B,GAOF,IAAI,CALa,IAAA,CAAK,CAAC,CAAA,CAAG,IAAM,CHZT,CAAA,IGYW,CAAO,EAAE,IAAI,AAM/C,CAN+C,CAGd,EAAS,MAAA,CAAS,CAAK,EAAA,CAAC,SbvJzD,AAAsB,CAAA,EAE9B,GAAA,ECFQ,ADES,CEKrB,KAAA,EFL+B,CCUA,ADT/B,CIEiC,AJDtB,ACQoB,CDT/B,CIEiC,KJDtB,cAGwB,GAAO,CAAA,CAAA,IAAM,EAAE,CKNE,GLMG,CAAA,CGOgB,AHPf,CGOe,AHPZ,CGOY,AHPZ,CAAA,GAAM,EAAI,CAAC,CAAA,CAAA,GAElD,CUHN,AFOK,ANFA,CMEA,ARJe,CAAA,KACb,CAAM,EAAM,GAAA,GAAA,CAAS,CAAC,CAAA,CAAA,EYJI,CAAA,CAAA,mBZYS,CACxD,EaoI2F,AbpI3F,EMfiB,COwJD,IAAA,CXXH,AYlBF,CPiCK,EMJS,EAAI,CAAA,CAAG,CAAI,AALuE,CAKvE,AALuE,CAAA,AXNvF,CWWiC,MAAA,CAAQ,CAC7C,EAAA,CAAA,CACU,IAAA,CPzBf,AJcW,CS6DI,AElDU,CAAA,CAAiB,CAAC,CAAA,CAAA,AXXN,AWYtB,EAAoB,IAAN,EAEpB,EAAQ,CNKL,CGpBP,KHoBO,CMLa,SAAU,GAC1B,IAAM,EAAU,CNIQ,GMJJ,EAAa,KAAA,CAAA,EAAW,EAAX,EAAe,CAAA,AAElC,CAFkC,CAE1B,IAAA,CAAA,GACd,EAAA,OAAA,CAAQ,CNKF,CAAA,EAAA,CMLO,GAErB,GAEQ,CAJoB,CAAA,CAAA,APGjC,AOCgC,EAAA,EPCxB,EKgDnB,CElDgB,EAC2B,CAAQ,IAAA,CAAK,GAChC,GPCJ,AODyB,CFuDlC,CEvDkC,OAAA,CAAA,MAAA,CAAe,IHZnB,AGgBrB,CHhBqB,CAAA,AGgBb,GNQZ,EMZuD,AAInD,CAJmD,CAAA,AAI3C,CAAQ,EFsDL,CEtDS,QAO5B,IAAA,CPGhB,GOHyB,EAAI,CAAA,CAAG,EAAI,EAAiB,MAAA,CAAQ,CAC7C,EAAA,AFoD4C,CAAA,CEnDlC,IAAA,EAAU,CAAA,CAAiB,CHjBN,AGiBO,CAAA,CAAA,AAC5B,CNOwB,CMPf,CPET,COFa,CAAM,EAAA,CAAA,CAAA,AAEzB,EAAQ,ENSL,KMTK,CAAQ,ONQxB,EMRkC,EAAA,CAAA,AAC1B,EPEpB,EOF0B,CXPd,AKiBI,CMVoB,IAAI,CAAJ,CAAiB,KAAA,CAAA,EAAW,EAAX,CAEnB,CAFkC,CAAA,AAElC,CAFkC,CAE1B,IAAA,CAAM,GXRf,AWSL,CADM,CACN,EAD2B,CAAA,CAAA,GAC3B,CAAQ,IAAA,CAAA,GAEZ,EAEA,EAAQ,EXTtB,EWQU,GXRV,CWS8B,GAAI,EXTR,AWSQ,EAIhB,GAAmB,EAAA,OAAA,CAAQ,IAAA,CAAK,GAChC,GAAqB,EAAA,CADoB,CAAA,CAAA,EACpB,CXLd,AWKP,CAAqB,CAAQ,MAAA,CAAO,WAMxD,CAGmB,GPHN,COGU,EAAa,CAAA,EAFE,AAEC,GAFW,AAAa,IAE3B,CAFc,GAAA,CAA0B,GAAA,GAGhE,CAHgE,CAGhE,AAHgE,KAEZ,CAAA,CAAA,AACpD,CAAQ,IAAA,CAAA,GACZ,GAAmB,EAAA,OAAA,CAAQ,IAAA,CAAK,CPKhD,ACakC,CAAA,CMjBlB,CPKJ,EOLyB,EAAA,OAAA,CAAQ,CNmBf,KAAA,CMnBsB,GAE5C,MAGJ,CNoBA,CMzB2D,CAAA,CAAA,AAKtD,ENeD,OMdK,EAAA,EAAuB,EAAK,IAAA,CAAM,CAAC,CAAA,CACnC,AADmC,EACnC,EAAuB,CPWpC,COXyC,CNuBD,AI+EiB,IEtGV,CAAC,CNuBR,AMvBQ,CAAA,IACb,EAAK,CAAA,ANuBJ,ADZJ,EOXQ,ANuBJ,CDZM,AOXG,CPWH,AOXI,CAAA,CNuBA,AMvBA,AACtC,EAAQ,OAAQ,CAAA,OAAA,CAAQ,EAAI,EAAA,AAAI,EAAG,MACZ,EAAA,OAAA,CAAQ,IAAA,CAAK,GAChC,GAAqB,EC1BP,AD0BO,EPezB,GOfyB,CAArB,CAAqB,CAAQ,MAAA,CAAO,GACxC,CC3BwB,IR0CxB,AObJ,CAFI,EADmD,CAAA,CAAA,AAGlD,EPaM,IObN,CACG,CAAA,CPaJ,AObI,EAAuB,EAAK,CAAA,CC7BhC,CD6BgC,CAAK,CAAC,CAAA,CAClC,AADkC,CAClC,CAAA,APYA,EOZuB,EAAK,CAAA,GAAK,CAAC,AADlC,CACkC,CAAA,AAC9B,EF0GT,AL/FS,AOXA,EAAuB,EAAK,OAAA,CAAS,GACpC,EPUG,AOVH,EAAuB,EF8GlB,AE9GuB,SAAU,CAAC,AF8GJ,CE9GI,CAAA,EAC3C,CF+GE,CE/GqB,EAAK,CAAA,GAAA,CAAM,CAAC,CAAA,CAAA,AACnC,CPQc,CORd,CF+GE,CE/GqB,EAAK,CAAA,GAAA,CAAM,CAAC,CAAA,CAAA,AAEpC,GF+GH,AE/GS,EAEN,CPOA,COPQ,AADZ,AFgHA,CAFc,KAEG,CAAA,CE/GG,CF+GH,QE/Ga,CAAA,CAAA,CAAG,EAAG,EAAO,EAAQ,CAAR,EAAc,CAAd,CAAgB,CAAA,AAIvD,CAJuD,CAI/C,CPMR,MONgB,CAAA,IAAA,CAAK,CAAG,CAAA,CAAA,CAAG,EAAO,GAGlC,GAHwC,AAGrB,CAHqB,CAAA,AAGrB,OAAA,CAAQ,IAAA,CAAK,GFgHT,AE/GvB,GAAqB,EFkHzB,AElHyB,EC9BT,KD8BS,CAAQ,MAAA,CAAO,QAG5C,CFiHA,IEjHK,UACI,EAAA,EAAuB,CFkHP,CElHY,IAAA,CAAM,CAAC,CAAA,CAAA,AACnC,EAAA,EAAuB,EAAK,CFiHgB,AEjHhB,GAAA,CAAM,CAAC,CAAA,CACnC,AADmC,EACnC,EAAuB,EAAK,CAAA,GAAA,CAAM,CAAC,CAAA,CAAA,AACnC,EAAA,EAAuB,EAAK,CAAA,CC1BF,ED0BE,CAAM,CAAC,CAAA,CAAA,AAExC,EAAQ,EC3BR,GD2BA,EAAQ,CAAQ,SAAU,EAAA,CAAA,AAC1B,EAAQ,EC5BF,GD4BN,EAAgB,CAAA,OAAA,CAAQ,EAAI,EAAA,AAAI,EAAI,EAAE,CAAA,AAElC,CAFkC,EAEf,EAAA,IAAnB,CAAmB,EAAA,CAAQ,IAAA,CAAK,GAChC,GAAqB,EC9BzB,AD8ByB,CADoB,CAAA,CAAA,EACpB,CAArB,CAAqB,CAAQ,MAAA,CAAO,GACxC,KAEJ,GAHuD,CAAA,CAAA,AAGlD,MAAA,CACI,EAAA,EAAuB,EAAK,CAAA,GAAA,CAAM,CAAC,CAAA,CAAA,AACnC,EAAA,EAAuB,EAAK,CAAA,GAD5B,AAC4B,CAAM,CAAC,CAAA,CAAA,AACnC,EAAA,EAAuB,CFqHP,CErHY,IFqHI,AErHJ,CAAM,CAAC,CAAA,CAAA,AACnC,CFoHgC,CEpHhC,EAAuB,EAAK,CAAA,GAAA,CAAM,CAAC,CAAA,CAAA,AAExC,EAAQ,OAAA,CAAQ,SAAU,EAAA,CAAA,AAClB,EAAA,GC5BhB,ED4BgB,EAAA,CAAQ,MAAO,CAAA,EAAA,AAAI,EAAE,CAAA,AACrB,CADqB,CACrB,OAAA,CAAQ,CC5BH,KD4BU,CAAA,EAAI,AAAJ,EAAM,CAAA,AAEzB,CAFyB,EAEJ,EAAA,KAAA,EAAA,CAAQ,MAAA,CAAO,GACxC,KAEJ,CAFI,EADmD,CAAA,CAAA,AAGlD,SAAA,CAEQ,EADM,AACN,EADU,CAAJ,CACN,QAAA,EADU,CAAa,QAAQ,CAAA,CAAA,AAClB,KAAM,CAAA,QAAQ,CAAE,CAAA,GAAA,CAAI,AAAC,CAAM,EAAA,QAAA,CAAS,CAAG,CAAA,EAAE,CAAC,CAAA,CAAA,AACxD,EAAA,KAAA,EAAA,CAAQ,IAAK,CAAA,GAAQ,GAAR,AACjB,CAD6B,CAAA,CAAA,AAC7B,EAAmB,OAAA,CAAQ,IAAA,CAAK,GAChC,GFuHiB,AEvHI,EAAA,CCtBZ,MDsBY,CAAQ,MAAA,CAAO,QAG5C,KAAK,CCtBD,UDwBS,EADM,AACN,EADU,YAAA,CAAa,QAAQ,CAAA,CFyIE,AEzIF,AAClB,KAAM,CAAA,QAAQ,CAAE,CAAA,GAAA,CAAI,AAAC,CAAM,EAAA,QAAA,CAAS,CAAG,CAAA,EAAE,CAAC,CAAA,CACxD,AADwD,EACxD,OAAA,CAAQ,IAAK,CAAA,GAAQ,GAAR,ACrBK,ADsBtB,GAAqB,EAAA,OAAA,CAAQ,MAAA,CAAO,WAAW,EAIlD,GAAA,CAAA,AACL,IAAK,MACD,KAEJ,YAES,EAAA,IAAA,EAAA,CAAA,cAAA,EAAiB,EAAI,QAAQ,CAAwB,sBAAA,CAAA,CFmKF,AEnKE,AAE9D,CFiK4D,AEnKE,AAK9D,IAEY,EAAA,GADhB,CACgB,CAAA,CAIhB,IAAA,IAAS,EAAI,CAAA,AFiLF,CEjLK,CAAI,CAAA,EAAS,GCTO,GDSP,CAAQ,CACrC,ACVkD,GDUlD,AACI,EAAe,CAAS,CAAA,CAAC,CAAiB,CAAA,EAAS,EAAW,QAvP/B,EAAW,CDhBL,ACuQoC,CAAA,CAAA,AApPtE,OAAA,CXhBI,AUDA,AJLL,sFOlCV,IAAM,EAAgB,CAClB,MAAQ,CAAA,CACJ,EAFc,UAEA,CAAA,QAAA,CACd,YAAc,CAAA,QAAA,CAClB,CACA,UAAY,CAAA,CACR,YAAc,CAAA,QAAA,CACd,YAAc,CAAA,eAAA,CAClB,CACA,UAAY,CAAA,CACR,YAAc,CAAA,eAAA,CACd,YAAc,CAAA,QAAA,CAClB,CACA,WAAa,CAAA,CACT,YAAc,CAAA,eAAA,CACd,YAAc,CAAA,eAAA,CAClB,AACJ,CAAA,AAsBO,CAtBP,MAsBa,EAkBT,SAjBJ,CAAA,CAiBI,CAAY,CAAA,CAAkB,CAC9B,CAAA,CAbgB,IAAA,CAAA,GAAA,CAAA,CAAA,EAAc,EAAA,GAAA,EAAI,aAAa,CAAA,CAM/C,AAN+C,IAM/C,CAAO,KAAgB,CAAA,CAAA,CAAA,AAIhB,IAAA,CAAA,SAAA,CAAY,IAAI,EAAA,MAAO,CAI1B,CAJ0B,CAAA,EAI1B,CAAK,OAAU,CAAA,EAEf,IAAA,CAFe,AAEV,CAFU,QAEA,CAAA,KAAA,CACX,CAAA,CAAI,EAAQ,KAAM,CAAA,KAAA,CAClB,CAAA,CAAI,EAAQ,KAAM,CAAA,MAAA,EAGlB,IAEA,EAAQ,IADZ,CACI,CAAe,AADnB,CACmB,KAAA,CAAM,YAAe,CAAA,CAAA,CAAc,EAAY,CAAA,OAAF,KAAE,CAAA,AAC9D,EAAQ,KAAR,CAAe,CAAA,KAAA,CAAM,YAAe,CAAA,CAAA,CAAc,EAAY,CAAA,OAAF,KAAE,CAAA,AAClE,CACJ,AAOO,aAAa,CACpB,CAAA,CACI,IAAM,EAAU,IAAK,CAAA,OAAA,CAAA,AAEhB,IAAA,CAAA,SAAA,CAAU,QAAA,CAAS,GACxB,IAAA,CAAK,CAD4B,CAAA,CAAA,MAC5B,CAAU,MAAO,EAAA,CAAA,AAEtB,IAAA,CAAK,SAAU,CAAA,KAAA,CACX,CAAA,CAAI,EAAQ,KAAM,CAAA,KAAA,CAClB,CAAA,CAAI,EAAQ,KAAM,CAAA,MAAA,EAGjB,IAAA,CAAA,KAAA,EAAA,CACT,AAGA,AAJS,IAIE,OACX,EAAA,CACI,OAAO,IAAK,CAAA,QAAA,CAAA,AAChB,AACA,IAAW,QAAQ,CACnB,CAAA,CACQ,IAAA,CAAK,QAAa,GAAA,IAEtB,CAFsB,EAAO,CAE7B,CAAK,KAFwB,GAEb,CAAA,EACX,GADW,CAAA,AACX,CAAA,KAAA,EAAA,CAAA,CAQT,AAPA,IAOW,QACX,EAAA,CACI,MAAO,CAAgB,aAAA,EAAA,IAAA,CAAK,GAAG,CAAA,CAAA,EAAI,IAAA,CAAK,KAAK,CAAA,CAAA,CAAA,AACjD,AAGO,OACP,EAAA,CACS,IAAA,CAAA,OAAA,CAAQ,OAAA,EAAQ,GACrB,CADyB,CAAA,CAAA,CACzB,CAAK,OAAU,CAAA,IAAA,CAAA,AACnB,AACJ,kOCzHS,EAAc,CACvB,EAAA,AACI,OAAO,KAAiB,QAAA,EAAA,WAAA,AAC5B,CAD4B,AAC5B,AAEA,SAAS,EAAe,CACxB,EAAA,AACI,OAAO,KAAiB,ACLtB,QAAA,EAAA,YDKsB,CAAA,SAwDnB,EACL,CACA,CAAA,CAAA,CACA,CAEJ,EAAA,AAMI,OALA,CANK,CAMA,EAAL,EAAY,CAAA,EACZ,EAAK,CADO,CAAA,AACZ,GAAa,CAAA,QAAA,CAAA,AACb,EAAK,OAAA,CAAU,EAAM,GAAA,IAAA,CACrB,AADqB,EAChB,MAAA,CAAS,EAAA,SAAM,CAAA,AAEb,CAAE,GAAG,CAAc,CAAA,GAAG,CAAK,CAAA,CAWtC,AAXsC,SAW7B,EACL,CACA,CAAA,CAAA,CACA,CAEJ,EAQI,AARJ,OACI,EAAA,aAAoB,EAAA,CACpB,EAAK,IAAO,CAAA,EACZ,EAAK,CADO,CAAA,GACC,CAAA,SACb,EAAK,OAAA,CAAU,EAAM,OAAA,CAAA,AACrB,EAAK,MAAA,CAAS,EAAA,SAAM,CACpB,EAAK,YAAA,CAAA,EAAqB,YAAA,CAAA,AAE1B,CAAS,CCkDqC,EDlDlC,CAAA,CAAc,GAAG,CAAK,CAAA,AACtC,CADsC,AACtC,OCkDsD,EDdtC,EACZ,CAAA,CACA,CAEJ,EAAA,IAvBI,AAmBY,EAjBZ,EAsBI,SAAA,EAEO,GAFP,ACuBJ,IDrBW,CAFG,GAEH,CAAA,AAGX,CAL2B,CAAA,EAKrB,CCqBF,CD1BuB,AAKM,CAAA,CAAC,CAAA,AAG9B,EARuB,CA/IpB,CAuJH,CAvJG,EA+I8B,AC4B3B,GD3KH,CAAM,AAgJb,EAAA,SAhJa,CAAY,AAuJT,KAvJ6B,CAAA,CAAA,CAwJ7C,AAtHA,SAuHW,AArHN,AAqHM,EArHN,KAAA,CAAQ,CAFb,EAAa,EAAA,KAAA,CAAM,MAAO,CAAA,QAAA,CAuHO,AAvHE,GAAS,CAAC,CCuCyB,ADvCzB,EAE3B,QAAS,EAAA,CAqHhB,AArHgB,AAC3B,EAAK,KAAA,CAAa,IAAL,EAAK,EAAA,GAAA,CAAA,EAA2B,KAAA,CAAQ,EAAK,EAAA,GAAA,CAAA,AAC1D,AAmHW,EAnHN,OAAA,CAAU,EAAA,OAAQ,CAAA,KAAA,CAEvB,AAFuB,CAEd,GAAG,AAiH4B,CAAA,CAjHd,GAiHf,AAjHkB,CAiHlB,AAjHuB,CAAA,AAiHM,CAjHN,CAAA,EAmHzB,AA5IF,CA4IE,GCzFN,CDnDqB,GA6IxB,KA7IwB,EAAA,OAAA,CAAA,OA8Ib,AAxGX,EAAK,EAAL,KAAe,CAwGgB,EAxGhB,AAER,CAAE,GAAG,AAsG0B,CAAA,AAxGvB,CAEW,AAFX,GAEc,AAsGlB,CAAA,AAtGuB,CAAA,CAAA,CAAA,EAwGzB,CAxGiB,CAwGH,QACvB,EACW,EAAkB,EAAM,EAAO,GAC1C,GACS,EAAe,CCcC,CAAA,EDhB6B,CAAA,AAEzB,CAFyB,AAGtD,EAAA,IAC8B,EAAM,EAAA,AAAO,GAAP,KAAmB,GAE9C,ACGC,CDL6C,CAAA,AAElC,CAFkC,GAElC,EAAQ,EAAc,ACGjC,CDHW,CAAkC,IAAI,CAC3D,CACI,CADJ,EAD2C,IAEhC,ECCD,EDDgC,ACChC,EDD4C,IAAA,CAAM,IAAN,EAAzB,CAAA,IAEpB,ACDC,CDD8D,CAAA,AAEnD,CAFmD,GAEnD,CAFQ,CAEA,EAAe,ACDlC,CDCW,CAAmC,IAAI,CAC5D,CACI,CADJ,EAD4C,CAAA,GAEjC,ECHD,EAAA,ADGiC,EAAY,IAAA,CAAM,GAGtD,CAHgD,GAAzB,CAAA,EAGvB,AAzDP,EAsDyE,AAtDzE,CAsDyE,AAtDzD,CAsDyD,EAGpC,AAzDlB,CAyD8B,CAzDhB,AAyDgB,CAHnB,AAGmB,ECNvC,ADnD2B,CCmD3B,ADnD+C,CAAA,CAEzD,AAFyD,EAE3C,AAF2C,EAE3C,AAFK,KAEL,CAAM,MAAO,CAAA,QAAA,CAAS,EAAM,KAAK,CAAA,CAAA,AAE/C,CCmCuB,CDnCjB,GAAN,EAAM,EAAS,EAAM,GAAA,EAAA,CAAA,EACf,KAAA,CAAQ,EAAM,QAAS,EAAA,CAEtB,AAFsB,KAEtB,CAAA,KA2DK,EAAA,CAAA,CAAkC,CAClD,EAAA,AACU,GAAA,OAAE,CAAA,WAAO,CAAW,YAAA,CAAA,CCKe,GAAnB,CDLgB,CAAA,MAAK,CAAM,WAAA,CAAA,CAAW,GAAG,CCKtB,CDL+B,CAAA,CAAT,CACzD,EAAO,EAAP,AAAmB,EAAO,GAAP,CAAW,CAAA,CAAA,CAAX,GAEpB,EAKE,EAJP,AADI,EACJ,ICQA,WDFI,SAAA,IACA,MACA,GAAA,IACA,IAAA,QACA,EACA,GAAG,CAAA,EAVI,CASP,GAGR,AAZe,CAAA,uDC3Lf,IAAM,EAAW,IAAI,EAAA,KAAM,CAkDrB,CAlDqB,CAAA,AAkDR,IAAI,EAAA,EAAjB,IAAwB,CAWjB,CAXiB,CAAA,AAWvB,CDpDP,KCoDa,UAAwB,EAAA,IAAxB,GAKb,CAAA,aALO,CAAA,KAAA,CAAA,GAAA,SAAA,CAAA,CAOI,AAPJ,IAOI,CAAA,GDvCM,KCuCN,CAAA,OAA+D,MAAA,CAAO,IAAI,CAAA,CAAA,AAIjF,EDxCA,ECwCA,CAAO,kBAAqB,EAAA,CDxCI,CC0ChC,IAAA,CAAO,WAAc,CAAA,CAAA,CAAA,CAkDL,IAAA,CAAA,GAAA,CAAA,CAAA,EAAc,EAAA,GAAA,EAAI,iBAAiB,CAAA,CAKnD,AALmD,EDtDnD,EC2DA,CAAO,KAAQ,EAAA,EAEf,EAFe,AD3DK,EC6DpB,CAAO,SAAuB,CAAA,MAAA,CAAA,AAE9B,GD5CA,CC4CA,CAAO,YAAA,CAAA,EAAwC,CAQ/C,AAR+C,ED1C/C,ECkDA,CAAO,SAAY,CAAA,EDlDN,CAAA,ACoDL,EAFW,ADjDnB,CCiDmB,CAEX,CAAA,WAAA,CDnDa,CAAA,GCmDmB,EAAA,YAAa,CAC7C,CAD6C,CDlDrD,ACkDqD,EAC7C,CAAA,UAAA,CAAqB,CDnDT,GCmDa,EAAA,MAAO,CAExC,CAFwC,CAAA,ADlDxC,ECoDA,CAAQ,UAAiC,CAAA,CAAE,GAAG,EAAgB,gBAAiB,CAAA,CAC/E,AAD+E,IAC/E,CAAA,YAA6C,CAAA,CAAE,GAAG,EAAgB,kBAAmB,CAAA,CAAA,AACrF,IAAA,CAAQ,WAAA,CAAyG,EAAC,CAAA,AAElH,IAAA,CAAQ,KAAQ,CAAA,CAAA,CAAA,AAER,IAAA,CAAA,CDxCH,GAES,GCsCN,CAAU,IAAI,EAAA,MAAO,CAC7B,CAD6B,CAAA,EAC7B,CAAQ,IDrCM,QAAA,ECqCS,EAOhB,OACP,CACU,IAAA,EAAQ,GAAR,CAAY,EAYX,OAVP,EAAM,KAF4B,EAAA,CAAA,CAE5B,CAAY,IAAK,CAAA,SAAA,CACjB,AADiB,EACjB,SDrBU,GAAA,CCqBK,EDrBL,CAAA,CCqBU,CAAA,YAAA,CAAa,KAAM,EAAA,CAAA,AACvC,EAAA,ODpBN,ICoBM,CDpBW,CAAA,GCoBQ,CAAA,WAAA,CAAY,KAAM,EAAA,CAAA,AACrC,EAAA,GAAA,OAAA,CAAa,GDnBZ,CAAA,CCmBiB,GDnBK,OCmBL,CAAW,KAAM,EAAA,CACzC,AADyC,EACnC,GDpB0C,CAAA,CAAA,KCoB7B,CAAA,CAAE,ADlBN,GCkBS,CDjB5B,GCiB4B,CAAK,UAAW,CAAA,CAAA,AACxC,EAAM,GAAN,SAAqB,CDjBd,CAAA,ACiBgB,EDjBI,CCiBD,IAAA,CAAK,CDjBJ,WCiBiB,CAAA,CACtC,ADlBwC,ACiBF,CDjBE,CAAA,ACkBxC,WAAA,CAAc,EDhBD,ECgBM,CAAA,GDhBD,CAC5B,OCe6B,CAAY,KAAM,EAAA,CAAA,AACrC,EAAA,GAAA,IAAA,CAAU,IAAK,CAAA,GDfd,ICec,CAAQ,KAAM,EDfJ,ACeI,CAAA,AACnC,EAAM,YAAe,EAAA,EDdD,ACgBb,EAMX,CDXA,ECKW,CAAA,AAMP,SACJ,EAAA,CDrBW,ACsBP,OAAO,IAAK,CAAA,SDXT,CAAA,CCcP,IAAI,UAAU,CACd,CDNY,ACMZ,CACI,IAAA,CAAK,UAAa,CAAA,EAAY,EAAO,EAAgB,gBAAgB,CAAA,CAAA,AAMzE,IAAI,MDXoE,CAAA,MCYxE,QACW,IAAK,CAAA,YAAA,CAAA,AAChB,AAEA,IAAI,QDLA,ICKY,CAChB,CAAA,KACI,CAAK,YAAe,CAAA,EAAc,EAAO,EAAgB,CAAhB,MAArB,OAAqB,IAAkC,CAAA,CAAA,AAC/E,AASO,aAAa,CACpB,CAAA,CAGW,OAFP,IAAA,CAAK,UAAa,CAAA,EAAY,EAAO,EAAgB,CAAhB,IAAnB,SAAmB,EAAgC,CAAA,CAAA,AAE9D,IAAA,CAAA,AACX,AASO,eAAe,CACtB,CAAA,CAGW,OAFP,IAAA,CAAK,YAAe,CAAA,EAAY,EAAO,EAAgB,CAAhB,IAAnB,SAAmB,IAAkC,CAAA,CAAA,AAElE,IAAA,CAAA,AACX,AA0BO,QAAQ,CAAkB,CAAA,CAAA,CAAoB,CAAa,CAAA,CAAA,CAAa,CAAA,CAAa,CAC5F,CAAA,CAoBW,OAnBP,IAAA,CAAK,YAAA,CAAa,IAAK,CAAA,CACnB,MAAQ,CAAA,SAAA,CACR,IAAM,CAAA,CACF,KAAO,CAAA,EAEP,GAAI,EAFG,AAEG,CAAA,CAAA,CACV,GAAI,EAAM,CAAA,CAAA,CAEV,EAAA,CAAI,EAAM,CAAA,EAAQ,KAAR,AAAc,CAAA,KAAA,CACxB,EAAA,CAAI,EAAM,CAAA,EAAQ,KAAR,AAAc,CAAA,MAAA,CAExB,SAAA,CAAW,IAAK,CAAA,UAAA,CAAW,KAAM,EAAA,CACjC,KAAA,CAAO,IAAA,CAAK,UAAW,CAAA,KAAA,CACvB,KAAA,CAAO,EAAO,EAAA,KAAM,CAAA,MAAA,CAAO,QAAA,CAAS,GAAM,CAAF,CAAA,MAAE,EAAa,CAAA,QAAA,CAC3D,CACH,CAAA,CAAA,AAED,IAAA,CAAK,QAAS,EAAA,CAAA,AAEP,IAAA,CACX,AADW,AAQJ,SACP,EAAA,CAGW,OAFF,IAAA,CAAA,WAAA,CAAc,IAAI,EAAA,YAAa,CAE7B,CAF6B,CAAA,EAE7B,CAAA,AACX,AAWO,IAAA,CAAK,CAAA,CAAmB,CAC/B,CAAA,CAGI,IAFI,EAEE,EAFF,AAEoB,CAFpB,GAEyB,CAAA,YAAA,CAAa,IAAK,CAAA,YAAA,CAAa,MAAA,CAAS,CAAC,CAAA,CAAA,OAIlE,EAFe,CAAK,CAEpB,EAFA,IAAK,CAAA,KAAA,EAAe,GAAiB,SAAW,GAA5B,KACxB,CACW,CADX,CAC2B,IAAK,CAAA,IAAA,CAIrB,AAJqB,IAIrB,CAAK,WAAA,CAAY,KAAM,EAAA,CAAA,GAMrB,IACb,EADI,AACJ,IACkB,KAAA,CAAA,GAAV,GAAwC,AAAjB,EAAb,MACd,EAAA,OADkC,KAAA,EAG9B,EAAA,WAAA,EAAY,EAAA,MAAA,CAAQ,sGAAsG,CAAA,CAAA,AAGlH,EAAA,CAAE,EAAF,GAAS,CAAA,KAAA,GAAO,CAAM,CAAA,CAAA,CAElC,CAFkC,GAElC,CAAK,UAAa,CAAA,EAAY,EAAO,EAAgB,CAAhB,IAAnB,SAAmB,EAAgC,CAAA,CAAA,CAIzE,IAAA,CAAK,YAAA,CAAa,IAAK,CAAA,CACnB,MAAQ,CAAA,MAAA,CAER,IAAM,CAAA,CAAE,KAAO,CAAA,IAAA,CAAK,SAAA,CAAW,IAAK,EAAA,CAAA,CACvC,CAAA,CAAA,AAED,IAAA,CAAK,QAAS,EAAA,CAAA,AAEd,IAAA,CAAK,qBAAsB,EAAA,CAAA,AAC3B,IAAA,CAAK,KAAQ,CAAA,CAAA,CAAA,CA1BK,IA4BX,AA5BW,CA6BtB,AAEQ,AA/Bc,qBAgCtB,EAAA,CAEU,GAAA,CAAE,GAAA,GAAG,CAAE,CAAA,CAAI,IAAA,CAAK,WAAY,CAAA,YAAA,CAAa,EAAA,KAAA,CAAM,MAAM,CAAA,CAAA,AAE3D,IAAA,CAAK,WAAA,CAAY,KAAM,EAAA,CAAA,AAClB,IAAA,CAAA,WAAA,CAAY,MAAO,CAAA,CAAA,CAAG,CAAC,CAAA,CAAA,AAChC,AAQO,OAAO,CACd,CAAA,CAGI,IAFI,EAEE,EAAkB,AAFpB,CAAA,GAEyB,CAAA,YAAA,CAAa,IAAK,CAAA,YAAA,CAAa,MAAA,CAAS,CAAC,CAAA,CAAA,OAIlE,EAFe,CAAK,CAEpB,EAFA,IAAK,CAAA,KAAA,EAAe,GAAiB,SAAW,GAA5B,GACxB,CACW,CADX,CAC2B,IAAK,CAAA,IAAA,CAAA,AAIrB,IAAA,CAAK,WAAA,CAAY,KAAM,EAAA,CAAA,GAMrB,IACb,EADI,AACJ,IACI,IAAA,CAAK,YAAe,CAAA,EAAc,EAAO,EAAgB,CAAhB,MAArB,OAAqB,KAAkC,CAAA,CAI/E,AAJ+E,IAI/E,CAAK,YAAA,CAAa,IAAK,CAAA,CACnB,MAAQ,CAAA,QAAA,CAER,IAAM,CAAA,CAAE,KAAO,CAAA,IAAA,CAAK,WAAA,MAAa,CAAK,CAAA,CACzC,CAAA,AADyC,CACzC,AAED,IAAA,CAAK,QAAS,EAAA,CAAA,AAEd,IAAA,CAAK,qBAAsB,EAAA,CAAA,AAC3B,IAAA,CAAK,KAAQ,CAAA,CAAA,CAAA,CAlBK,IAoBX,AApBW,CAqBtB,AAQO,AA7Be,GA8BtB,EAAA,CACI,IAAA,IAAS,CAAI,CAAA,CAAA,CAAG,CAAI,CAAA,CAAA,CAAG,CACvB,EAAA,CAAA,CACI,IAAM,EAAkB,IAAK,CAAA,YAAA,CAAa,IAAA,CAAK,YAAa,CAAA,MAAA,CAAS,EAAI,CAAC,CAAA,CAAA,AAEpE,EAAW,IAAK,CAAA,CAAhB,UAAgB,CAAY,KAAM,EAAA,CAExC,AAFwC,GAEpC,GAEI,CAA2B,QAAY,GAD/C,EAAA,AACwB,CAAA,KAAA,EAAkD,SAA3B,EAAgB,MAAA,AAAW,CACtE,CACQ,CADR,EACQ,EAFmC,AAEnB,IAAA,CAAK,IACzB,CACoB,CADpB,CACoB,CAFhB,GAEgB,CAAK,IAAK,CAAA,GAAV,IAAU,CAAQ,OAGtC,CAH8C,AAI1C,CAJ0C,CAAA,AAI1B,IAAA,CAAK,IAAO,CAAA,EAC5B,CADA,IACA,CAGZ,AAJwC,AAC5B,AACJ,CAOL,AAJP,AAL4C,OAO5C,IAAA,CAAK,qBAAsB,EAAA,CAAA,AAEpB,IAAA,CAAA,AACX,AAaO,IAAI,CAAW,CAAA,CAAA,CAAW,CAAgB,CAAA,CAAA,CAAoB,CAAA,CAAkB,CACvF,CAAA,CACS,IAAA,CAAA,KAAA,EAAA,CAAA,AAEL,IAAM,EAAI,IAAK,CAAA,UAAA,CAAA,AAWR,OATP,IAAA,CAAK,WAAY,CAAA,GAAA,CACZ,EAAE,CAAI,CAAA,CAAA,CAAM,CAAE,CAAA,CAAA,CAAI,EAAK,CAAE,CAAA,EAAA,CACzB,EAAE,CAAI,CAAA,CAAA,CAAM,CAAE,CAAA,CAAA,CAAI,EAAK,CAAE,CAAA,EAAA,CAC1B,EACA,EACA,EAFA,AAGA,GAGG,GALH,AACA,CAIG,CAAA,AACX,AAYO,KAAM,CAAA,CAAA,CAAY,AAhBjB,CAgB6B,CAAA,CAAA,CAAY,CAAA,CAAY,CAC7D,CAAA,CACS,IAAA,CAAA,KAAA,EAAA,CAAA,AAEL,IAAM,EAAI,IAAK,CAAA,UAAA,CAUR,AAVQ,OAEf,IAAA,CAAK,WAAY,CAAA,KAAA,CACZ,EAAE,CAAI,CAAA,EAAA,AAAO,CAAE,CAAA,CAAA,CAAI,EAAM,CAAE,CAAA,EAAA,CAC3B,EAAE,CAAI,CAAA,EAAO,AAAP,CAAS,CAAA,CAAA,CAAI,EAAM,CAAE,CAAA,EAAA,CAC3B,EAAE,CAAI,CAAA,EAAA,AAAO,CAAE,CAAA,CAAA,CAAI,EAAM,CAAE,CAAA,EAAA,CAC3B,EAAE,CAAI,CAAA,EAAA,AAAO,CAAE,CAAA,CAAA,CAAI,EAAM,CAAE,CAAA,EAAA,CAC5B,GAGG,GAHH,CAGG,CAAA,AACX,AAcO,SACH,CAAY,CAAA,CAAA,CACZ,CAAA,CACA,CACA,CAAA,CAAA,CACA,CAAA,CAAW,CAEf,CAAA,CACS,IAAA,CAAA,KAAA,EAAA,CAAA,AAEL,IAAM,EAAI,IAAK,CAAA,UAAA,CAAA,AAWR,OATP,IAAA,CAAK,WAAY,CAAA,QAAA,CACb,EAAA,AAAI,EAAA,AACJ,EACA,EACA,EACC,EAAE,CAAI,CAAA,CAAA,CAAM,CAHb,AAEA,AACe,CAFf,AAEe,CAHf,AAGe,CAAI,EAAK,CAAE,CAAA,EAAA,CACzB,EAAE,CAAI,CAAA,CAAA,CAAM,CAAE,CAAA,CAAA,CAAI,EAAK,CAAE,CAAA,EAAA,EAGvB,IAAA,CAAA,AACX,AAeO,UAvBC,IAuBa,CAAc,CAAA,CAAA,CAAc,CAAA,CAAc,CAAc,CAAA,CAAA,CAAW,CAAA,CAAW,CACnG,CAAA,CACS,IAAA,CAAA,KAAA,EAAA,CAAA,AAGL,IAAM,EAAI,IAAK,CAAA,UAAA,CAAA,AAYR,OAVP,IAAA,CAAK,WAAY,CAAA,aAAA,CACZ,EAAE,CAAI,CAAA,EAAS,CAAE,CAAX,AAAW,CAAA,CAAI,EAAQ,CAAE,CAAA,EAAA,CAC/B,EAAE,CAAI,CAAA,EAAS,CAAE,CAAX,AAAW,CAAA,CAAI,EAAQ,CAAE,CAAA,EAAA,CAC/B,EAAE,CAAI,CAAA,EAAS,CAAE,CAAA,AAAX,CAAW,CAAI,EAAQ,CAAE,CAAA,EAAA,CAC/B,EAAE,CAAI,CAAA,EAAS,CAAE,CAAX,AAAW,CAAA,CAAI,EAAQ,CAAE,CAAA,EAAA,CAC/B,EAAE,CAAI,CAAA,CAAA,CAAM,CAAE,CAAA,CAAA,CAAI,EAAK,CAAE,CAAA,EAAA,CACzB,EAAE,CAAI,CAAA,CAAA,CAAM,CAAE,CAAA,CAAA,CAAI,EAAK,CAAE,CAAA,EAAA,CAC1B,GAGG,IAAA,CAAA,AACX,AAOO,EAXC,OAYR,EAAA,CAKW,OAJF,IAAA,CAAA,KAAA,EAAA,CAEL,AAFK,IAEL,CAAK,WAAA,EAAa,SAAU,EAAA,CAAA,AAErB,IAAA,CAAA,AACX,AAWO,OAAQ,CAAA,CAAA,CAAW,CAAW,CAAA,CAAA,CAAiB,CACtD,CAAA,CAKW,OAJF,IAAA,CAAA,KAAA,EAAA,CAAA,AAEA,IAAA,CAAA,WAAA,CAAY,OAAA,CAAQ,CAAG,CAAA,CAAA,CAAG,EAAS,EAAS,IAAA,CAAA,AAAK,UAAW,CAAA,KAAA,EAAO,CAAA,CAAA,AAEjE,IAAA,CAAA,AACX,AASO,MAAA,CAAO,CAAW,CAAA,CAAA,CAAW,CACpC,CAAA,CAKW,OAJF,IAAA,CAAA,KAAA,EAAA,CAAA,AAEA,IAAA,CAAA,WAAA,CAAY,MAAA,CAAO,CAAG,CAAA,CAAA,CAAG,EAAQ,IAAK,CAAA,UAAA,CAAW,KAAA,EAAO,CAAA,CAAA,AAEtD,IAAA,CAQJ,AARI,AACX,KAOY,CACZ,CAAA,CAKW,OAJF,IAAA,CAAA,KAAA,EAAA,CAAA,AAEL,IAAA,CAAK,WAAA,CAAY,OAAQ,CAAA,EAAM,EAAN,EAAW,CAAA,UAAA,CAAW,KAAA,EAAO,CAAA,CAE/C,AAF+C,IAE/C,CAAA,AACX,AAQO,MAAA,CAAO,CAAA,CAAW,CACzB,CAAA,CACS,IAAA,CAAA,KAAA,EAAA,CAAA,AAEL,IAAM,EAAI,IAAK,CAAA,UAAA,CAAA,AAOR,OALP,IAAA,CAAK,WAAY,CAAA,MAAA,CACZ,EAAE,CAAI,CAAA,CAAA,CAAM,CAAE,CAAA,CAAA,CAAI,EAAK,CAAE,CAAA,EAAA,CACzB,EAAE,CAAI,CAAA,CAAA,CAAM,CAAE,CAAA,CAAA,CAAI,EAAK,CAAE,CAAA,EAAA,EAGvB,IAAA,CAAA,AACX,AAQO,MAAA,CAAO,CAAA,CAAW,CACzB,CAAA,CACS,IAAA,CAAA,KAAA,EAAA,CAAA,AAEL,IAAM,EAAI,IAAK,CAAA,UAAA,CAAA,AAET,EAAe,IAAA,CAAK,KAApB,MAAgC,CAAA,YAAA,CAAA,AAEhC,EAAgB,CAAE,CAAA,CAAA,CAAI,EAAM,CAAE,CAAA,CAAA,CAAI,EAAK,CAAE,CAAA,EAAA,CAAA,AACzC,EAAgB,CAAE,CAAA,CAAA,CAAI,EAAM,CAAE,CAAA,CAAA,CAAI,EAAK,CAAE,CAAA,EAAA,CAAA,OAEnB,AAAxB,CAAwB,KAAX,MAAW,EAAgC,QAC5D,EAAA,CADiC,CAAA,CAAa,CAAC,CAAA,CAAE,MAAA,EAE7C,CAAA,CAAa,CAAC,CAAA,CAAE,IAAK,CAAA,CAAC,CAAI,CAAA,EAC1B,CAAA,CAAa,CAAC,CAAA,CAAE,IAAK,CADK,AACL,CADK,AACJ,CAAI,CAAA,GAI9B,IAAA,CAAK,IAJyB,CAAA,MAIb,CAAA,MAAA,CACb,EACA,GAGG,IAAA,CAAA,AACX,AAYO,EAjBC,EACA,YAgBgB,CAAA,CAAA,CAAa,CAAa,CAAA,CAAA,CAAW,CAAA,CAAW,CACxE,CAAA,CACS,IAAA,CAAA,KAAA,EAAA,CAAA,AAEL,IAAM,EAAI,IAAK,CAAA,UAAA,CAAA,AAUR,OARP,IAAA,CAAK,WAAY,CAAA,gBAAA,CACZ,EAAE,CAAI,CAAA,EAAQ,CAAR,AAAU,CAAA,CAAA,CAAI,EAAO,CAAE,CAAA,EAAA,CAC7B,EAAE,CAAI,CAAA,EAAQ,CAAR,AAAU,CAAA,CAAA,CAAI,EAAO,CAAE,CAAA,EAAA,CAC7B,EAAE,CAAI,CAAA,CAAA,CAAM,CAAE,CAAA,CAAA,CAAI,EAAK,CAAE,CAAA,EAAA,CACzB,EAAE,CAAI,CAAA,CAAA,CAAM,CAAE,CAAA,CAAA,CAAI,EAAK,CAAE,CAAA,EAAA,CAC1B,GAGG,IAAA,CAAA,AACX,AAUO,EAdC,EAcI,CAAA,CAAA,CAAW,CAAW,CAAA,CAAA,CAAW,CAC7C,CAAA,CAKW,OAJF,IAAA,CAAA,KAAA,EAAA,CAEA,AAFA,IAEA,CAAA,WAAA,CAAY,IAAA,CAAK,CAAG,CAAA,CAAA,CAAG,EAAG,CAAG,CAAA,IAAA,CAAK,UAAW,CAAA,KAAA,EAAO,CAAA,CAAA,AAElD,IAAA,CAAA,AACX,AAaO,SAAU,CAAA,CAAA,CAAW,CAAW,CAAA,CAAA,CAAW,CAAA,CAAW,CAC7D,CAAA,CAKW,OAJF,IAAA,CAAA,KAAA,EAAA,CAEA,AAFA,IAEA,CAAA,WAAA,CAAY,SAAU,CAAA,CAAA,CAAG,CAAG,CAAA,CAAA,CAAG,EAAG,EAAQ,IAAA,CAAK,UAAW,CAAA,KAAA,EAAO,CAAA,CAAA,AAE/D,IAAA,CACX,AAUO,AAXI,IAWJ,CAAK,CAAA,CAAgC,CAC5C,CAAA,CAKW,OAJF,IAAA,CAAA,KAAA,EAAA,CAAA,AAEL,IAAA,CAAK,WAAA,CAAY,IAAK,CAAA,EAAQ,EAAO,EAAf,EAAoB,CAAA,UAAA,CAAW,KAAA,EAAO,CAAA,CAAA,AAErD,IAAA,CAAA,AACX,AAYO,YAAY,CAAW,CAAA,CAAA,CAAW,CAAA,CAAgB,CAAe,CAAA,EAAW,CAAA,CAAG,CACtF,CAAA,CAIW,CAL6D,MAE/D,IAAA,CAAA,KAAA,EAAA,CAAA,AACL,IAAA,CAAK,WAAA,CAAY,WAAY,CAAA,CAAA,CAAG,EAAG,EAAQ,EAAO,EAAP,AAAiB,CAAjB,EAEpC,IAAA,CAAA,AACX,AAaO,CAhBkE,CAAA,CAAA,OAgBxD,CAAW,CAAA,CAAA,CAAW,CAAgB,CAAA,CAAA,CAAe,CAAA,CAAgB,CACtF,CAAA,CAIW,OAHF,IAAA,CAAA,KAAA,EAAA,CAAA,AACL,IAAA,CAAK,WAAA,CAAY,SAAU,CAAA,CAAA,CAAG,EAAG,EAAQ,EAAO,EAAP,AAAe,CAAf,EAElC,IAAA,CAAA,AACX,AAHoE,AAkB7D,CAlB6D,CAAA,QAkBlD,CAAA,CAAA,CAAwB,CAAgB,CAAA,CAAA,CAAwB,CAClF,CAAA,CAIW,OAHF,IAAA,CAAA,KAAA,EAAA,CAAA,AACL,IAAA,CAAK,WAAY,CAAA,UAAA,CAAW,EAAQ,EAAQ,EAAc,AAAtB,EAAA,CAE7B,IAAA,CAAA,AACX,AAWO,EAdiE,CAAA,CAAA,MActD,CAAA,CAAA,CAAW,CAAW,CAAA,CAAA,CAAe,CAAA,CAAgB,CACvE,CAAA,CAIW,OAHF,IAAA,CAAA,KAAA,EAAA,CAAA,AACL,IAAA,CAAK,WAAA,CAAY,UAAW,CAAA,CAAA,CAAG,CAAG,CAAA,EAAO,EAAQ,CAAf,EAE3B,GAFgD,CAAA,AAEhD,CAFgD,AAEhD,AACX,AAWO,YAAY,CAAW,CAAA,CAAA,CAAW,CAAe,CAAA,CAAA,CAAgB,CAAA,CAAiB,CACzF,CAAA,CAIW,OAHF,IAAA,CAAA,KAAA,EAAA,CAAA,AACL,IAAA,CAAK,WAAA,CAAY,WAAY,CAAA,CAAA,CAAG,EAAG,EAAO,EAAQ,CAAR,CAAiB,EAAjB,CAEnC,IAAA,CAAA,AACX,AAkBO,CArBiE,CAAA,CAAA,CAqBjE,CAAK,CAAA,CAAW,CAAW,CAAA,CAAA,CAAgB,CAAA,CAAgB,EAAc,CAAA,CAAG,EAAW,CAC9F,CAAA,CAKW,EANqE,KAEvE,IAAA,CAAA,KAAA,EAAA,CAAA,AAEA,IAAA,CAAA,WAAA,CAAY,IAAK,CAAA,CAAA,CAAG,CAAG,CAAA,EAAQ,EAAQ,EAAa,AAA7B,EAAuC,AAAvB,IAAuB,CAAK,CAAL,CAAvB,QAAuC,CAAA,KAAA,EAAO,CAAA,CAAA,AAEnF,IAAA,CAAA,AACX,AAOO,IAAI,CACX,CAAA,CAKW,OAJF,IAAA,CAAA,KAAA,EAAA,CAEL,AAFK,CAEL,EAAA,EAAA,SAAA,EAAU,EAAK,IAAI,CAAA,CAAA,AAEZ,IAAA,CAAA,AACX,AAMO,OACP,EAAA,CACU,IAAA,EAAQ,GAAR,CAAa,CAAA,WAAA,CAAY,GAAI,EAAA,CAAA,AAS5B,OAPH,IAEA,CADJ,EAAA,CACI,CAAK,UAAA,CAAa,EAAM,GAAA,MAAA,CAAA,AACxB,IAAA,CAAK,UAAA,CAAa,EAAM,GAAA,MAAA,CAAA,AACxB,IAAA,CAAK,YAAA,CAAe,EAAM,GAAA,QAAA,CAAA,CAGvB,IAAA,CAAA,AACX,AAGO,IACP,EAAA,CAOW,OANP,IAAA,CAAK,WAAA,CAAY,IAAK,CAAA,CAClB,SAAA,CAAW,IAAK,CAAA,UAAA,CAAW,KAAM,EAAA,CACjC,SAAW,CAAA,CAAE,GAAG,IAAA,CAAK,UAAW,CAAA,CAChC,WAAa,CAAA,CAAE,GAAG,IAAA,CAAK,YAAa,CAAA,CACvC,CAAA,CAEM,AAFN,IAEM,CAAA,AACX,AAMO,YACP,EAAA,CACI,OAAO,IAAK,CAAA,UAAA,CAAA,AAChB,AAMO,cACP,EAAA,CAGW,OAFP,IAAA,CAAK,UAAA,CAAW,QAAS,EAAA,CAAA,AAElB,IAAA,CAAA,AACX,AAOO,OAAO,CACd,CAAA,CAGW,OAFF,IAAA,CAAA,UAAA,CAAW,MAAA,CAAO,GAEhB,EAFqB,CAAA,CAAA,AAErB,CACX,AADW,AASJ,KAAA,CAAM,CAAW,CAAA,CAAA,CAAY,CACpC,CAAA,CAGW,OAFF,IAAA,CAAA,UAAA,CAAW,KAAM,CAAA,CAAA,CAAG,CAAC,CAAA,CAAA,AAEnB,IAAA,CAAA,AACX,AAqBO,aAAa,CAAoB,CAAA,CAAA,CAAY,CAAY,CAAA,CAAA,CAAY,CAAA,CAAa,CACzF,CAAA,QACQ,aAAa,EAAA,MACjB,CACI,CADJ,GACI,CAAK,UAAW,CAAA,GAAA,CAAI,CAAE,CAAA,CAAA,CAAG,CAAE,CAAA,CAAA,CAAG,CAAE,CAAA,CAAA,CAAG,CAAE,CAAA,CAAA,CAAG,CAAE,CAAA,EAAA,CAAI,EAAE,EAAE,CAAA,CAAA,AAKtD,IAAA,CAAK,UAAA,CAAW,GAAI,CAAA,CAAA,CAAG,EAAG,CAAG,CAAA,CAAA,CAAG,EAAI,EAAE,CAAA,AAE/B,CAF+B,GAE/B,CACX,AAqBO,AAtBI,UAsBM,CAAoB,CAAA,CAAA,CAAY,CAAY,CAAA,CAAA,CAAY,CAAA,CAAa,CACtF,CAAA,QACQ,aAAa,EAAA,MACjB,CACS,CADT,GACS,CAAA,UAAA,CAAW,MAAA,CAAO,CAAC,CAAA,CAAA,CAK5B,EAAW,GAAA,CAAI,CAAG,CAAA,CAAA,CAAG,AAArB,CAAwB,CAAA,CAAA,CAAG,EAAI,EAAE,CAAA,AAC5B,CAD4B,GAC5B,CAAA,UAAA,CAAW,MAAA,CAAO,IAEhB,IAAA,CAAA,AACX,AAQO,CAX8B,CAAA,CAAA,MAW9B,CAAU,CAAW,CAAA,CAAA,CAAY,CACxC,CAAA,CAGW,OAFF,IAAA,CAAA,UAAA,CAAW,SAAU,CAAA,CAAA,CAAG,CAAC,CAAA,CAAA,AAEvB,IAAA,CAAA,AACX,AAOO,KACP,EAAA,CAOW,OANP,IAAA,CAAK,WAAA,CAAY,KAAM,EAAA,CACvB,AADuB,IACvB,CAAK,YAAA,CAAa,MAAS,CAAA,CAAA,CAAA,AAC3B,IAAA,CAAK,cAAe,EAAA,CAAA,AAEpB,IAAA,CAAK,QAAS,EAAA,CAAA,AAEP,IAAA,CAGD,AAHC,AACX,QAGA,EAAA,CAGI,IAAA,CAAK,YAAe,EAAA,EAIhB,EAJgB,CAAA,CAIX,CAAA,KAAA,EAAO,CACX,IAAA,CAAA,CADW,GACX,CAAK,QAAU,CAAA,IAAA,CAAM,EAAI,CAAA,CAC9B,AAD8B,IAC9B,CAAK,KAAQ,EAAA,EAAA,CACjB,AAGA,CAJiB,CAAA,EAIb,MACJ,EAAA,CACI,GAAI,CAAC,IAAK,CAAA,YAAA,CAAc,OAAO,IAAK,CAAA,OAAA,CAEpC,AAFoC,IAEpC,CAAK,YAAe,EAAA,EAGpB,GAHoB,CAAA,AAGd,EAAS,IAAK,CAAA,OAAA,CAAA,AAEpB,EAAO,IAAP,CAAa,EAAA,CAAA,AAEb,IAAA,IAAS,EAAI,CAAG,CAAA,CAAA,CAAI,IAAK,CAAA,YAAA,CAAa,MAAA,CAAQ,CAC9C,EAAA,CAAA,CACU,IAAA,EAAc,IAAK,CAAA,IAAnB,QAAmB,CAAa,CAAC,CAAA,CAAA,AACjC,EAAS,EAAY,MAAA,CAAA,AAE3B,EAF2B,CAEZ,MACf,GADI,EACJ,CACI,IAAM,EAAO,EAAY,IAAA,CAAA,AAElB,EAAA,EAFkB,EAElB,KAAA,CAAU,EAAK,EAAA,EAAA,CAAK,MAAM,CAAA,CACrC,AADqC,KACrC,GACoB,SACpB,GADS,EACT,CACI,IAAM,EAAO,EAAY,IAAA,CAAA,AAEzB,EAAO,EAFkB,EAEzB,IAAgB,CAAA,EAAK,EAAI,AAAT,CAAS,EAAK,EAAL,AAAK,CAAI,EAAK,EAAA,CAAK,EAAK,EAAA,CAAI,EAAK,EAAA,CAAK,EAAK,EAAA,CAAI,EAAK,SAAS,CAAA,CAAA,AAC1F,AACA,GAAe,QACf,GADI,EACJ,CACI,IAAM,EAAO,EAAY,IAAA,CAAA,AAEnB,EAAY,EAFO,AAEF,KAAjB,AAAuB,CAAA,SAAA,CAAA,AAEvB,EAAgB,EAAK,EAAL,GAAW,CAAA,EAAX,GAAW,EAAS,CAAT,AAAa,CAAA,CAAA,CAAA,CAAA,AAExC,CAFwC,CAE9B,EAAK,GAAf,CAAoB,CAAA,MAAA,CAAA,AAEnB,EAAA,IAAA,IAAA,CACH,EAAQ,IAAO,CAAA,EACf,EAAQ,IAAO,CAAA,EACf,CAFe,CAEP,IAAO,CAAA,EACf,CAFe,CAEP,IAAO,CAAA,EACnB,CAFmB,AAGvB,CACJ,AAEO,OAAA,CALoB,AAKpB,CACX,AAOO,IARI,CAAA,SAQU,CACrB,CAAA,CAEI,GAAI,CAAC,IAAK,CAAA,MAAA,CAAO,aAAA,CAAc,EAAM,CAAA,CAAG,CAAH,CAAS,CAAC,CAAA,CAAU,OAAA,EAEzD,GAFyD,CAAA,AAEnD,EAAe,IAAK,CAAA,YAAA,CAAA,AACtB,GAAS,EAEb,CAFa,EAAA,CAEb,AAFa,IAEJ,CAAI,CAAA,CAAA,CAAG,CAAI,CAAA,EAAa,MAAA,CAAQ,CACzC,EADoB,AACpB,CAAA,CACU,IAAA,EAAc,CAAA,CAAa,CAAC,CAAA,CAAA,AAE5B,EAAO,EAFP,AAEmB,IAAA,CACnB,AADmB,EACZ,EAAK,AADO,EACP,EAAA,CAAA,AAEd,GAAA,CAAC,EAAY,MAAA,EAAU,CAAV,AAAW,EAAM,EAAN,OAAM,AAElC,IAAM,EAAQ,EAAK,EAAA,GAAA,CAAA,AACb,EAAS,EAAK,EAAd,OAAwB,CAAA,eAAA,CAAA,AAE9B,IAAA,IAAS,CAAI,CAAA,CAAA,CAAG,CAAI,CAAA,EAAO,IAAP,EAAO,CAAQ,CACnC,EAAA,CAAA,CACU,IAAA,EAAQ,CAAO,CAAA,CAAf,AAAgB,CAAE,CAAA,KAAA,CAAA,AAEpB,GAAA,CAAC,GAAS,CAAC,EAAO,GAAP,MAAO,AAEhB,IAAA,EAAY,CAAO,CAAA,CAAC,CAAE,CAAA,EAAtB,OAAsB,CAAA,AAEtB,EAAmB,EAAY,EAAU,KAAV,EAAA,KAAuB,CAAA,EAAO,GAAP,AAAmB,EAI3E,EAFuB,CAFgD,AAAI,CAAA,EAI3E,EADJ,EAAA,CADI,EAAY,MAAA,CAEH,EAAM,AAFf,GAEe,KAAA,CAAS,EAAiB,CAAA,CAAG,EAAiB,CAAC,CAAA,CAAA,AAMrD,EAAM,GAAN,EANgC,SAM1B,CAAe,EAAiB,CAAA,CAAG,EAAiB,CAAG,CAAA,EAAY,KAAO,CAFpE,AAE0B,AAA0C,EAAY,CAA/B,EAFjD,CAAA,KAEoE,AAAqB,CAAA,CAAA,AAGlH,IAAM,EAAQ,EAAK,EAAA,EAAA,CAEnB,AAFmB,GAEf,EACJ,CACU,EADV,EACU,EAAa,EAAM,MAAnB,GAA8B,EAAA,eAAA,CAAA,AAEpC,GAAI,EAEA,IAAA,IADJ,AACa,CAAI,CADjB,AACiB,CAAA,CAAG,CAAI,CAAA,EAAW,MAAA,CAAQ,CACvC,AADoB,EACpB,CAAA,AACQ,CAAA,CAAW,CAAC,CAAE,CAAA,KAAA,CAAM,QAAA,CAAS,EAAiB,CAAA,CAAG,EAAiB,CAAC,CACvE,EAAA,CACa,GAAA,CAAA,CAFqC,AAErC,AAGrB,CAHqB,AAIzB,AAEA,GARkF,AAQ9E,EAEO,IADX,EAAA,CACW,CACX,CACJ,CAGG,AAFP,CAHmB,CAAA,KAKZ,CAAA,CACX,AAGO,IAJI,CAAA,CAKX,EAAA,CAEe,IAAA,IAAA,GAAA,EADN,IAAA,CAAA,IAAA,CAAK,SAAU,IAAI,CAAA,CAAA,AACN,IAAA,CAAK,QACvB,CAAA,AACS,IAAA,CAAA,QAAA,CAAS,EAAG,CAAA,CAAG,OAAQ,EAAA,CAAA,AAE3B,IAAA,CAAA,QAAA,CAAkB,EAAlB,IAAkB,CAAA,MAAA,CAAO,CAAzB,GAA6B,CAAA,CAY/B,AAXP,AADsC,OAY/B,CAAQ,GAA6C,CAC5D,CAAA,CACI,IAAI,IAAK,CAAA,SAAA,EAAW,AAWpB,GAVA,CAUI,GAXgB,AACpB,CAAK,SAAY,CAWjB,CAXiB,EACjB,EADiB,CAAA,CACjB,CAAK,WAAA,CAAY,MAAS,CAAA,CAAA,CAAA,AAC1B,IAAA,CAAK,UAAa,CAAA,IAAA,CAAA,AAElB,IAAA,CAAK,MAAO,EAAA,CACP,AADO,IACP,CAAA,IAAA,CAAK,UAAW,IAAI,CAAA,CAAA,AACzB,IAAA,CAAK,kBAAmB,EAAA,CAAA,AAEkB,SAAA,EAAnB,OAAO,EAAwB,EAAU,GAAtB,AAA+B,IAAA,GAAA,CAAA,AAGzE,CACI,IAAM,EAA0C,SAAA,EAAnB,OAAA,AAAO,EAAwB,EAAU,GAAtB,AAA+B,IAAA,SAAA,CAAA,AAE3E,IAAA,CAAK,UAAA,CAAW,OACpB,EAAA,CACI,IAAA,CAAK,UAAW,CAAA,IAAA,EAAQ,KAAS,GAAA,IAAA,CAAK,UAAA,CAAW,IAC3C,CAAA,IAAA,CAAK,UAAW,CAAA,IAAA,CAAK,OAAA,EACrB,CAAA,IAAA,CAAK,UAAW,CAAA,OAAA,CAAQ,OAAA,CAAQ,EAAoB,CAAA,CAAA,AAG1D,IAAA,CAAK,YAAA,CAAa,OACtB,EAAA,CACI,IAAA,CAAK,YAAa,CAAA,IAAA,EAAQ,KAAS,GAAA,IAAA,CAAK,YAAA,CAAa,IAC/C,CAAA,IAAA,CAAK,YAAa,CAAA,IAAA,CAAK,OAAA,EACvB,CAAA,IAAA,CAAK,YAAa,CAAA,OAAA,CAAQ,OAAA,CAAQ,EAAoB,CAAA,AAChE,CADgE,AAEpE,AAEA,IAAA,CAAK,UAAa,CAAA,IAAA,CAAA,AAClB,IAAA,CAAK,YAAe,CAAA,IAAA,CAAA,AAEpB,IAAA,CAAK,YAAe,CAAA,IAAA,CAAA,AACpB,IAAA,CAAK,WAAc,CAAA,IAAA,CAAA,AACnB,IAAA,CAAK,OAAU,CAAA,IAAA,CAAA,AACf,IAAA,CAAK,WAAc,CAAA,IAAA,CAAA,AACnB,IAAA,CAAK,YAAe,CAAA,IAAA,CACpB,AADoB,IACpB,CAAK,UAAa,CAAA,IAAA,CAAA,CACtB,AACJ,CAAA,CAAA,AA5qCa,EAgBK,cAhBL,EAgB4C,CAAA,CAEjD,KAAO,CAAA,QAAA,CAEP,KAAO,CAAA,CAAA,CAEP,QAAS,EAAA,OAAQ,CAAA,KAAA,CAEjB,MAAQ,CAAA,IAAA,CAER,IAAM,CAAA,IAAA,CAEN,YAAc,CAAA,OAAA,AAClB,CAAA,CAAA,AA7BS,EAgCK,cAhCL,IAgCgD,CAAA,CAErD,KAAO,CAAA,CAAA,CAEP,KAAO,CAAA,QAAA,CAEP,KAAO,CAAA,CAAA,CAEP,SAAW,CAAA,GAAA,AAEX,UAAY,CAAA,EAAA,CAEZ,GAAK,CAAA,MAAA,CAEL,IAAM,CAAA,OAAA,CAEN,QAAS,EAAA,OAAQ,CAAA,KAAA,CAEjB,MAAQ,CAAA,IAAA,CAER,IAAM,CAAA,IAAA,CAEN,YAAc,CAAA,OAAA,CAEd,SAAW,EAAA,CACf,CAAA,CAAA,EADe,yBAxDZ,2ECWA,OAAM,UAAiB,EAAA,aAC9B,CAAA,AAaI,YAAY,CACZ,CAAA,CACQ,aAAmB,EAAA,eACvB,EAAA,CACc,EAAA,CAAE,IAAF,IAAW,EAAQ,CAAA,CAAA,AAGjC,GAHiC,EAG3B,SAAE,CAAS,CAAA,aAAA,CAAa,GAAG,EAAK,CAAI,CAAJ,EAAe,CAAA,CAAC,CAAA,AAEhD,KAAA,CAAA,CACF,KAAO,CAAA,UAAA,CACP,GAAG,CAAA,CACN,CAAA,CAAA,AAvBL,IAAA,CAAyB,YAAuB,CAAA,UAAA,CAAA,AAyBvC,EAOD,IAAA,CANJ,AAMS,EANT,KAMmB,CAAA,GALf,IAAA,AAKe,CALV,AAKU,OALA,CAAA,IAAA,CAAK,aAAgB,CAAA,IAAI,EAAA,eAAgB,CACnD,CADmD,CAAA,EACnD,CAAA,OAAA,CAAQ,kBAAA,CAAqB,IAAK,CAAA,kBAAA,CAAA,CAO3C,IAAA,CAAK,aAAgB,EAAA,EAErB,EAFqB,CAAA,CAErB,CAAK,aAAgB,EAAA,EACrB,GADqB,CACrB,AADqB,CAChB,WAAA,CAAc,GAAe,EAAA,CACtC,AAEA,EAHsC,CAAA,CAGlC,CAHkC,OAG1B,CACZ,CAAA,CACQ,IAAY,IAAK,CAAA,QAAA,EAAU,CAE3B,IAAA,CAAK,CAFsB,OAG/B,EAAA,CACI,IAAA,CAAK,QAAS,CAAA,GAAA,CAAI,QAAU,CAAA,IAAA,CAAK,YAAA,CAAc,IAAI,CAAA,CAAA,AACnD,IAAA,CAAK,QAAS,CAAA,GAAA,CAAI,QAAU,CAAA,IAAA,CAAK,MAAA,CAAQ,IAAI,CAAA,CAAA,CAGjD,IAAA,CAAK,QAAW,CAAA,EAGhB,IAAA,CAAK,AAHW,CAAA,OAGF,CAAA,EAAA,CAAG,QAAU,CAAA,IAAA,CAAK,YAAA,CAAc,IAAI,CAAA,CAAA,AAClD,IAAA,CAAK,QAAS,CAAA,EAAA,CAAG,QAAU,CAAA,IAAA,CAAK,MAAA,CAAQ,IAAI,CAAA,CAAA,AAE5C,IAAA,CAAK,YAAa,EAAA,CAAA,CACtB,AA0BA,IAAI,OACJ,EAAA,CACI,OAAO,IAAK,CAAA,QAAA,CAChB,AADgB,AAwBhB,IAAa,MACb,EAAA,CACI,OAAO,IAAA,CAAK,QAAS,CAAA,MAAA,CAAA,AACzB,AAMU,YAAqB,EAAA,CAAA,CAAS,AAwBxB,cAAc,CAC9B,CAAA,CACW,OAAA,IAAA,CAAK,QAAS,CAAA,aAAA,CAAc,EAAK,CAC5C,AAqBgB,EAtB4B,CAAA,CAAA,IAsBpB,CACxB,CAAA,CACQ,IAAA,CAAK,aAAiB,EAAA,CAAC,EAElB,IAAA,CAAA,AADT,EAAA,WACS,CAAc,OAAA,CAAQ,KAEV,EAFiB,CAAA,CAAA,AAE7B,AAAqB,GAAA,GAAmC,CAAxD,GAAqB,OAA+C,CAAA,CAC7E,EAAA,AACS,IAAA,CAAA,QAAA,CAAS,OAAA,CAAQ,GAGzB,IAHgC,AAGhC,CAHgC,AAG3B,CAH2B,YAGF,CAAA,IAAA,CAAA,AAC/B,IAAA,CAAK,QAAW,CAAA,IAAA,CAEhB,AAFgB,KAEhB,CAAM,QAAQ,EAAO,CACzB,AAMO,IAPkB,CAAA,CAAA,GAOT,CAChB,CAAA,CACI,IAAA,CAAK,WAAc,CAAA,EACnB,CADmB,CAAA,EACnB,CAAK,QAAA,CAAS,WAAc,CAAA,CAAA,CAChC,AAEQ,CAHwB,CAAA,gBAGxB,CAAmB,CAAA,CAA+B,CAC1D,CAAA,CAGW,OAFN,IAAK,CAAA,OAAA,CAAgB,EAAM,CAAE,GAAF,AAAK,GAE1B,CAF8B,CAAA,CAAA,CAE9B,CAAA,AACX,AA+CO,aAAA,GAAgB,CACvB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,cAAA,CAAgB,EAAI,CACvD,AAuDO,CAxDgD,CAAA,CAAA,YAwDhD,GAAkB,CACzB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,gBAAA,CAAkB,EAAI,CACzD,AAwDO,CAzDkD,CAAA,CAAA,EAyDlD,GAAQ,CACf,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,MAAA,CAAQ,EAAI,CAC/C,AAkDO,CAnDwC,CAAA,CAAA,IAmDxC,GAAU,CACjB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,QAAA,CAAU,EAAI,CACjD,AAwCO,CAzC0C,CAAA,CAAA,KAyC1C,GAAW,CAClB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,SAAA,CAAW,EAAI,CAClD,AAkBO,CAnB2C,CAAA,CAAA,MAoBlD,EAAA,CACI,OAAO,IAAK,CAAA,kBAAA,CAAmB,WAAa,CAAA,EAAE,CAAA,CAAA,AAClD,AAkBO,GACP,EAAA,CACI,OAAO,IAAK,CAAA,kBAAA,CAAmB,KAAO,CAAA,EAAE,CAAA,CAAA,AAC5C,AAmCO,IAAA,GAAO,CACd,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,KAAA,CAAO,EAAI,CAC9C,AAkCO,CAnCuC,CAAA,CAAA,GAmCvC,GAAS,CAChB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,OAAA,CAAS,EAAI,CAChD,AAkDO,CAnDyC,CAAA,CAAA,MAmDzC,GAAY,CACnB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,UAAA,CAAY,EAAI,CACnD,AA2CO,CA5C4C,CAAA,CAAA,WA4C5C,GAAiB,CACxB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,eAAA,CAAiB,EAAI,CACxD,AAoBO,CArBiD,CAAA,CAAA,MAsBxD,EAAA,CACI,OAAO,IAAK,CAAA,kBAAA,CAAmB,WAAa,CAAA,EAAE,CAAA,CA4B3C,AA3BP,AADkD,QA4B3C,GAAW,CAClB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,SAAA,CAAW,EAAI,CAClD,AAkCO,CAnC2C,CAAA,CAAA,IAmC3C,GAAU,CACjB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,QAAA,CAAU,EAAI,CACjD,AA4BO,CA7B0C,CAAA,CAAA,EA6B1C,GAAQ,CACf,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,MAAA,CAAQ,EAAI,CAC/C,AA6BO,CA9BwC,CAAA,CAAA,IA8BxC,GAAU,CACjB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,QAAA,CAAU,EAAI,CACjD,AA4CO,CA7C0C,CAAA,CAAA,IA6C1C,GAAU,CACjB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,QAAA,CAAU,EAAI,CACjD,AAuCO,CAxC0C,CAAA,CAAA,cAwC1C,GAAoB,CAC3B,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,kBAAA,CAAoB,EAAI,CAC3D,AA8BO,CA/BoD,CAAA,CAAA,EA+BpD,GAAQ,CACf,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,MAAA,CAAQ,EAAI,CAC/C,AAwBO,CAzBwC,CAAA,CAAA,OAyBxC,GAAa,CACpB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,WAAA,CAAa,EAAI,CACpD,AA6CO,CA9C6C,CAAA,CAAA,EA8C7C,GAAQ,CACf,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,MAAA,CAAQ,EAAI,CAC/C,AA6CO,CA9CwC,CAAA,CAAA,SA8CxC,GAAe,CACtB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,aAAA,CAAe,EAAI,CACtD,AAsCO,CAvC+C,CAAA,CAAA,OAuC/C,GAAa,CACpB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,WAAA,CAAa,EAAI,CACpD,AAoDO,CArD6C,CAAA,CAAA,QAqD7C,GAAc,CACrB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,YAAA,CAAc,EAAI,CACrD,AA6BO,CA9B8C,CAAA,CAAA,QA8B9C,GAAc,CACrB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,YAAA,CAAc,EAAI,CACrD,AAiCO,CAlC8C,CAAA,CAAA,SAkC9C,GAAe,CACtB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,aAAA,CAAe,EAAI,CACtD,AAoCO,CArC+C,CAAA,CAAA,EAqC/C,GAAQ,CACf,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,MAAA,CAAQ,EAAI,CAC/C,AAuBO,CAxBwC,CAAA,CAAA,CAwBxC,GAAO,CACd,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,KAAA,CAAO,EAAI,CAC9C,AA8BO,CA/BuC,CAAA,CAAA,KA+BvC,GAAW,CAClB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,SAAA,CAAW,EAAI,CAClD,AAoCO,CArC2C,CAAA,CAAA,CAsClD,EAAA,CACI,OAAO,IAAK,CAAA,kBAAA,CAAmB,MAAQ,CAAA,EAAE,CAAA,CAC7C,AA2BO,AA5BsC,YA6B7C,EAAA,CACW,OAAA,IAAA,CAAK,OAAA,CAAQ,YAAa,EAAA,CAAA,AACrC,AA0BO,cACP,EAAA,CACI,OAAO,IAAK,CAAA,kBAAA,CAAmB,gBAAkB,CAAA,EAAE,CAAA,CAAA,AACvD,AAoBO,gBAAA,GAAmB,CAC1B,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,QAAA,CAAU,EAAI,CACjD,AA2BO,CA5B0C,CAAA,CAAA,YA4B1C,GAAkB,CACzB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,OAAA,CAAS,EAAI,CAChD,AA+CO,CAhDyC,CAAA,CAAA,UAgDzC,GAAgB,CACvB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,cAAA,CAAgB,EAAI,CACvD,AA8CO,CA/CgD,CAAA,CAAA,OA+ChD,GAAa,CACpB,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,WAAA,CAAa,EAAI,CACpD,AAsBO,CAvB6C,CAAA,CAAA,gBAuB7C,GAAsB,CAC7B,CAAA,CACW,OAAA,IAAA,CAAK,kBAAmB,CAAA,WAAA,CAAa,EAAI,CACpD,AAgCO,CAjC6C,CAAA,CAAA,EAkCpD,EAAA,CACI,OAAO,IAAK,CAAA,kBAAA,CAAmB,OAAS,CAAA,EAAE,CAAA,CAAA,AAC9C,AA0CA,IAAI,SACJ,EAAA,CACI,OAAO,IAAA,CAAK,QAAS,CAAA,SAAA,CACzB,AACA,AAFyB,IAErB,UAAU,CACd,CAAA,CACI,IAAA,CAAK,QAAA,CAAS,SAAY,CAAA,CAAA,CAC9B,AA4CA,GA7C8B,CAAA,AA6C1B,WACJ,EAAA,CACI,OAAO,IAAA,CAAK,QAAS,CAAA,WAAA,CAAA,AACzB,AACA,IAAI,YAAY,CAChB,CAAA,CACI,IAAA,CAAK,QAAA,CAAS,WAAc,CAAA,CAAA,CAChC,AAuCO,GAxCyB,CAAA,CAwCzB,CAAM,GAAO,CACpB,CAAA,QACI,AAAI,EAEO,EADX,EAAA,AACe,EAAS,IAAK,CAAA,CAAd,OAAc,CAAS,KAAA,EAAO,CAAA,CAAA,CAG5C,IAAA,CAAK,aAAyB,CAAA,IAAA,CACjB,AADiB,IACb,EAAS,IAAA,CAAK,CAAL,OAAa,CAAA,CAAA,AAEjC,CACX,AAUO,SAAA,CAAU,CAAgB,CAAA,CAAA,CAAqB,CACtD,CAAA,IAEI,EAAA,WAAA,EAAY,EAAA,MAAA,CAAQ,8FAA8F,CAAA,CAAA,AAGlH,IAAM,EAAoC,CAAA,CAAC,CAAA,AASpC,OANP,IAAU,CAAV,CAAsB,GAAtB,EAA8B,CAAA,CAAA,CAAA,CAAA,AAC9B,CAD8B,GACpB,CAAV,CAAsB,GAAtB,EAA8B,CAAA,CAAA,CAAA,CAAA,AAC9B,CAD8B,GACpB,CAAV,CAAsB,GAAtB,EAA8B,CAAA,CAAA,CAAA,CAE9B,AAF8B,CAAA,GAE9B,CAAK,OAAA,CAAQ,WAAc,CAAA,EAEpB,IAAA,CACX,AAOO,AARI,IAFoB,CAAA,IAUxB,CAAU,CAAA,CAAoB,CACrC,CAAA,IAGI,EAAA,WAAA,EAAY,EAAA,MAAA,CAAQ,qGAAqG,CAAA,CAAA,AAGzH,IAAM,EAAgC,CAAA,CAAC,CAAA,AAQhC,OALO,KAAA,CAAA,GAAV,IAAqB,CAAX,CAAqB,KAAQ,CAAA,CAAA,AAAlB,CAAkB,CAAA,AAC7B,KAAA,CAAA,GAAV,IAAqB,CAAX,CAAqB,KAAQ,CAAA,CAAlB,AAAkB,CAAA,CAAA,AAE3C,IAAA,CAAK,OAAA,CAAQ,SAAY,CAAA,EAElB,IAAA,CAAA,AACX,AAKO,EARsB,CAAA,IAS7B,EAAA,IAGI,EAAA,WAAA,EAAY,EAAA,MAAA,CAAQ,mGAAmG,CAAA,CAGvH,AAHuH,IAGvH,CAAK,OAAA,CAAQ,IAAK,EAAA,CAAA,AACZ,IAAA,EAAc,IAAA,CAAK,IAAnB,GAA2B,CAAA,WAAA,CAS1B,AAT0B,MAE7B,GAAY,KAAA,GAAA,AAAU,EAAA,eAAgB,CAAA,kBAAA,CAAmB,KAAA,EACtD,EAAY,KAAA,GAAU,CAAV,CAAU,eAAgB,CAAA,kBAAA,CAAmB,KACzD,EAAA,EAAY,KAAU,GAAA,CAAtB,CAAsB,eAAA,CAAgB,kBAAA,CAAmB,KAAA,AAChE,EAAA,CACI,IAAA,CAAK,OAAA,CAAQ,MAAO,EAAA,CAAA,AAGjB,IAAA,CAAA,AACX,AAMO,WAAA,GAAc,CACrB,CAAA,CAKW,SAHP,EAAA,WAAA,EAAY,EAAA,MAAA,CAAQ,yDAAyD,CAAA,CAAA,AAGtE,IAAA,CAAK,kBAAmB,CAAA,QAAA,CAAU,EAAI,CACjD,AAMO,CAP0C,CAAA,CAAA,SAO1C,GAAe,CACtB,CAAA,CAKW,SAHP,EAAA,WAAA,EAAY,EAAA,MAAA,CAAQ,2DAA2D,CAAA,CAAA,AAGxE,IAAA,CAAK,kBAAmB,CAAA,SAAA,CAAW,EAAI,CAClD,AAMO,CAP2C,CAAA,CAAA,SAO3C,GAAe,CACtB,CAAA,CAKW,SAHP,EAAA,WAAA,EAAY,EAAA,MAAA,CAAQ,wDAAwD,CAAA,CAAA,AAGrE,IAAA,CAAK,kBAAmB,CAAA,MAAA,CAAQ,EAAI,CAC/C,AAMO,CAPwC,CAAA,CAAA,MAOxC,GAAY,CACnB,CAAA,CAKW,SAHP,EAAA,WAAA,EAAY,EAAA,MAAA,CAAQ,qDAAqD,CAAA,CAAA,AAGlE,IAAA,CAAK,kBAAmB,CAAA,MAAA,CAAQ,EAAI,CAC/C,AAMO,CAPwC,CAAA,CAAA,aAOxC,GAAmB,CAC1B,CAAA,CAKW,SAHP,EAAA,WAAA,EAAY,EAAA,MAAA,CAAQ,iEAAiE,CAAA,CAAA,AAG9E,IAAA,CAAK,kBAAmB,CAAA,WAAA,CAAa,EAAI,CACpD,AAMO,CAP6C,CAAA,CAAA,MAO7C,GAAY,CACnB,CAAA,CAKW,SAHP,EAAA,WAAA,EAAY,EAAA,MAAA,CAAQ,qDAAqD,CAAA,CAAA,AAGlE,IAAA,CAAK,kBAAmB,CAAA,MAAA,CAAQ,EAAI,CAC/C,AACJ,CAFmD,CAAA,CAAA,8IGn/D/C,EAAkC,KAClC,EAAqD,IAAA,CDFrD,ACEqD,SAAA,AAoBhD,EAAS,CAAyB,CAAA,CAAA,CAAe,CAC1D,CEoBsC,CFnBzB,IAAA,IAAA,CAAA,CAAI,EAAA,EAAW,EAAI,CAAA,CDUQ,ACVJ,CDUI,CCVG,EAAI,CAAJ,CAAW,EAAA,CAAA,CAAK,GAAS,CAChE,IAC4B,CAAA,GAApB,CAAA,CAAK,EAAQ,CAAC,CAAA,ACuIA,CDvID,AAAO,OAAU,CEqBvB,CFlBR,MAAA,YAGF,EEoBD,AFpBa,CAAA,CAAyB,CAAe,CAAA,CAAA,CEoBtB,CAAA,CFpB8C,CACrF,EAAA,AACI,IAAM,EAAS,EAAI,MAEnB,IAAS,CAAI,CAAA,EAAA,AG6BH,CH7BG,CAAc,EAAM,CAAN,CAAiB,CAAA,AG6Bc,CAAA,AH7BV,CAAI,CAAA,GAAK,EAAQ,EAAE,CAAG,CAAL,AAAK,GAAS,EAAT,GAE1C,CAD5B,AAC4B,CAD5B,EACQ,CAAA,CAAK,EG8BQ,EH9BO,CG8BP,AH9BA,AAAiB,GEqBH,GFrBG,EGgCpB,CH7BX,OAAA,EFvBX,MAAM,EAcL,YAAa,EAAM,CAAC,CAAE,EAAM,CAAC,CAAE,GAAW,CAAK,CAAE,CAChD,IAAI,CAAC,KAAK,CAAG,KACb,IAAI,CAAC,KAAK,CAAG,OAAO,MAAM,CAAC,MAC3B,IAAI,CAAC,IAAI,CAAG,KACZ,IAAI,CAAC,GAAG,CAAG,EACX,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,IAAI,CAAG,EACZ,IAAI,CAAC,GAAG,CAAG,CACZ,CAaA,OAAS,CAMR,OALA,IAAI,CAAC,KAAK,CAAG,KACb,IAAI,CAAC,KAAK,CAAG,OAAO,MAAM,CAAC,MAC3B,IAAI,CAAC,IAAI,CAAG,KACZ,IAAI,CAAC,IAAI,CAAG,EAEL,IAAI,AACZ,CAiBA,OAAQ,CAAG,CAAE,CACZ,GAAI,IAAI,CAAC,GAAG,CAAC,GAAM,CAClB,IAAM,EAAO,IAAI,CAAC,KAAK,CAAC,EAAI,AAE5B,QAAO,IAAI,CAAC,KAAK,CAAC,EAAI,CACtB,IAAI,CAAC,IAAI,GAES,MAAM,CAApB,EAAK,IAAI,GACZ,EAAK,IAAI,CAAC,IAAI,CAAG,EAAK,IAAA,AAAI,EAGT,MAAM,CAApB,EAAK,IAAI,GACZ,EAAK,IAAI,CAAC,IAAI,CAAG,EAAK,IAAA,AAAI,EAGvB,IAAI,CAAC,KAAK,GAAK,IAClB,EADwB,EACpB,CAAC,KAAK,CAAG,EAAK,IAAA,AAAI,EAGnB,IAAI,CAAC,IAAI,GAAK,IACjB,EADuB,EACnB,CAAC,IAAI,CAAG,EAAK,IAAA,AAAI,CAEvB,CAEA,OAAO,IAAI,AACZ,CAkBA,QAAS,EAAO,IAAI,CAAC,IAAI,EAAE,CAAE,CAC5B,IAAM,EAAS,AAAI,MAAM,EAAK,MAAM,EACpC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAAK,CACrC,IAAM,EAAM,CAAI,CAAC,EAAE,CACnB,CAAM,CAAC,EAAE,CAAG,CAAC,EAAK,IAAI,CAAC,GAAG,CAAC,GAAK,AACjC,CAEA,OAAO,CACR,CAeA,MAAO,GAAS,CAAK,CAAE,CACtB,GAAI,GAAU,IAAI,CAAC,IAAI,CAAG,EAAG,CAC5B,IAAM,EAAO,IAAI,CAAC,KAAK,AAEvB,QAAO,IAAI,CAAC,KAAK,CAAC,EAAK,GAAG,CAAC,CAEvB,AAAgB,GAAG,EAAjB,IAAI,CAAC,IAAI,EACd,IAAI,CAAC,KAAK,CAAG,KACb,IAAI,CAAC,IAAI,CAAG,OAEZ,IAAI,CAAC,KAAK,CAAG,EAAK,IAAI,CACtB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAG,KAEpB,CAEA,OAAO,IAAI,AACZ,CAiBA,UAAW,CAAG,CAAE,CACf,IAAI,EAMJ,OAJI,IAAI,CAAC,GAAG,CAAC,IACZ,EADkB,CACT,IAAI,CAAC,KAAK,CAAC,EAAI,CAAC,MAAA,AAAM,EAGzB,CACR,CAiBA,IAAK,CAAG,CAAE,CACT,IAAM,EAAO,IAAI,CAAC,KAAK,CAAC,EAAI,CAE5B,QAAa,IAAT,OAAoB,EAEvB,AAAI,IAAI,CAAC,GAAG,CAAG,GAAG,AACb,EAAK,MAAM,EAAI,KAAK,GAAG,IAAI,IAC9B,IAAI,CAAC,MAAM,CAAC,IAOd,IAAI,CAAC,SAAS,CAAC,GAER,EAAK,KAAK,CAInB,CAiBA,IAAK,CAAG,CAAE,CACT,OAAO,KAAO,IAAI,CAAC,KAAK,AACzB,CAaA,UAAW,CAAI,CAAE,CAEZ,IAAI,CAAC,IAAI,GAAK,IAKA,EALM,IAKA,CAApB,EAAK,IAAI,GACZ,EAAK,IAAI,CAAC,IAAI,CAAG,EAAK,IAAA,AAAI,EAGvB,AAAc,MAAM,GAAf,IAAI,GACZ,EAAK,IAAI,CAAC,IAAI,CAAG,EAAK,IAAA,AAAI,EAIvB,IAAI,CAAC,KAAK,GAAK,IAClB,EADwB,EACpB,CAAC,KAAK,CAAG,EAAK,IAAI,AAAJ,EAInB,EAAK,IAAI,CAAG,IAAI,CAAC,IAAI,CACrB,EAAK,IAAI,CAAG,KAEM,MAAM,CAApB,IAAI,CAAC,IAAI,GACZ,IAAI,CAAC,IAAI,CAAC,IAAI,CAAG,CAAA,EAGlB,IAAI,CAAC,IAAI,CAAG,EAGO,MAAM,CAArB,IAAI,CAAC,KAAK,GACb,IAAI,CAAC,KAAK,CAAG,CAAA,EAEf,CAgBA,MAAQ,CACP,IAAM,EAAa,AAAJ,MAAU,IAAI,CAAC,IAAI,EAC9B,EAAI,IAAI,CAAC,KAAK,CACd,EAAI,EAER,KAAa,KAAM,EAAZ,GACN,CAAM,CAAC,IAAI,CAAG,EAAE,GAAG,CACnB,EAAI,EAAE,IAAI,CAGX,OAAO,CACR,CAmBA,eAAgB,CAAG,CAAE,CAAK,CAAE,EAAW,IAAI,CAAC,QAAQ,CAAE,CACrD,IAAI,EAAU,KAEd,GAAI,IAAI,CAAC,GAAG,CAAC,GACZ,GADkB,CACd,CAAC,GAAG,CAAC,EAAK,GAAO,EAAM,OACrB,CACF,IAAI,CAAC,GAAG,CAAG,GAAK,IAAI,CAAC,IAAI,GAAK,IAAI,CAAC,GAAG,EAAE,CAC3C,EAAU,CAAC,GAAG,IAAI,CAAC,KAAK,EACxB,IAAI,CAAC,KAAK,EAAC,IAGZ,IAAI,EAAO,IAAI,CAAC,KAAK,CAAC,EAAI,CAAG,CAC5B,OAAQ,IAAI,CAAC,GAAG,CAAG,EAAI,KAAK,GAAG,GAAK,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,GAAG,CACvD,IAAK,EACL,KAAM,IAAI,CAAC,IAAI,CACf,KAAM,WACN,CACD,EAEoB,GAAG,AAAnB,EAAE,IAAI,CAAC,IAAI,CACd,IAAI,CAAC,KAAK,CAAG,EAEb,IAAI,CAAC,IAAI,CAAC,IAAI,CAAG,EAGlB,IAAI,CAAC,IAAI,CAAG,CACb,CAEA,OAAO,CACR,CAoBA,IAAK,CAAG,CAAE,CAAK,CAAE,GAAS,CAAK,CAAE,EAAW,IAAI,CAAC,QAAQ,CAAE,CAC1D,IAAI,EAAO,IAAI,CAAC,KAAK,CAAC,EAAI,CAmC1B,OAjCI,QAAmB,IAAT,GAEb,EAAK,EAF4B,GAEvB,CAAG,EAET,CAAW,OAAS,IACvB,EAAK,IAD4B,EACtB,CAAG,IAAI,CAAC,GAAG,CAAG,EAAI,KAAK,GAAG,GAAK,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,GAAA,AAAG,EAI9D,IAAI,CAAC,SAAS,CAAC,KAGX,IAAI,CAAC,GAAG,CAAG,GAAK,IAAI,CAAC,IAAI,GAAK,IAAI,CAAC,GAAG,EAAE,AAC3C,IAAI,CAAC,KAAK,EAAC,GAGZ,EAAO,IAAI,CAAC,KAAK,CAAC,EAAI,CAAG,CACxB,OAAQ,IAAI,CAAC,GAAG,CAAG,EAAI,KAAK,GAAG,GAAK,IAAI,CAAC,GAAG,CAAG,IAAI,CAAC,GAAG,CACvD,IAAK,EACL,KAAM,IAAI,CAAC,IAAI,CACf,KAAM,WACN,CACD,EAEoB,GAAG,AAAnB,EAAE,IAAI,CAAC,IAAI,CACd,IAAI,CAAC,KAAK,CAAG,EAEb,IAAI,CAAC,IAAI,CAAC,IAAI,CAAG,EAGlB,IAAI,CAAC,IAAI,CAAG,GAGN,IAAI,AACZ,CAkBA,OAAQ,EAAO,IAAI,CAAC,IAAI,EAAE,CAAE,CAC3B,IAAM,EAAS,AAAI,MAAM,EAAK,MAAM,EACpC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAAK,AACrC,CAAM,CAAC,EAAE,CAAG,IAAI,CAAC,GAAG,CAAC,CAAI,CAAC,EAAE,EAG7B,OAAO,CACR,CACD,CA0BA,SAAS,EAAK,EAAM,GAAI,CAAE,EAAM,CAAC,CAAE,GAAW,CAAK,EAClD,GAAI,MAAM,IAAQ,EAAM,EACvB,CAD0B,KACpB,AAAI,UAAU,qBAGrB,GAAI,MAAM,IAAQ,EAAM,EACvB,CAD0B,KACpB,AAAI,UAAU,qBAGrB,GAAwB,WAApB,AAA+B,OAAxB,EACV,MAAM,AAAI,UAAU,0BAGrB,OAAO,IAAI,EAAI,EAAK,EAAK,EAC1B,8BC1eM,EAAsB,CACxB,OAAA,CACA,QAFwB,IAExB,CACA,WAAA,CACA,gCAGJ,aASA,EAEU,IAAA,EAA4C,AAA1B,GCJ0B,cDInB,EAAM,QAAA,CCJa,CAAA,EDIe,EAAM,GAAN,ECJP,GDIqB,CAAA,EAAA,CAAA,CCJK,ADIE,CCJF,CDIQ,GAAA,KAAA,CAAA,AAIxF,EAAA,EAAwC,UAAA,AAExC,CAAC,AAFuC,IGUD,EHRhC,OAAA,CAAA,EAAc,UAAA,GACzB,GACmB,EAAM,EGWG,QHXQ,CAAA,KAAA,CAAA,IAAA,EAGpC,IAAA,IAAS,EGWM,CAAA,CAAA,MHXW,CAAA,EAAY,CAAA,CCPI,CAAA,ADOC,EAAG,CAC9C,GAAA,KAEQ,EAAa,CGQyC,AAC1D,AHTiB,CAAa,CAAC,AGSA,CAAA,CAAA,IHTO,EAAA,AAGlC,CAHkC,ACTE,ADYlC,CCZkC,CAAA,mBDYZ,IAAK,CAAA,IAAgB,EAAoB,IAA1B,IAAmC,CAA9B,AAA8B,KAE1E,EAAa,CAFgC,AAEhC,CAAA,CAFuE,AGWzE,CAAA,AHVf,EAC+B,AAD/B,EAC+B,CAAA,EAE9B,CAA0B,EAAA,CAAK,CCVpB,CDchB,MAAO,CAAG,EAAA,EAAM,CCZsB,QDYb,CAAA,CAAA,EAAI,EE8HG,AF9HG,WAAW,CAAA,CAAA,EAAI,EAAM,GAAA,OAAU,CAAA,CAAA,EAAA,EAAA,CAAkB,EAAK,EAA0B,IAAA,CAAK,GAAG,CAAC,CAAA,CAAA,CAAA,IE+H3D,6CAxH/D,EAAqD,ED5CrB,CDFlC,ACEkC,QAAA,EC4CqB,QAEnC,IAAA,GD3Cf,0DCyJG,EAAS,EAAkB,mCAAA,CAAA,GAE3B,KACJ,CAAA,GADI,EACJ,CACI,IAAA,EAAA,EAAA,UAAc,CAAW,GAAA,GAAM,2BAAA,GAA8B,SAAA,CAAA,EAGvD,EF9HJ,AE8HsB,mCAAA,CAAA,kBACC,GAAS,EF/HyE,AE+HlF,oBAAgC,EAGtD,GAHsD,CAAA,GAGtD,ED3IJ,ACoMP,CDpMO,GC2II,ACvHH,QDgLI,CAAA,CAAc,CAAkB,CAAA,CAAA,CAAe,CAAA,CAAgB,CD9GnB,AC8GoC,CAAA,CAAA,CACxF,CAAoB,CAAA,CAAA,CAAsB,CAC9C,CAAA,MACS,IAAO,CAAA,CC1JR,GD0JQ,CAAA,EACP,KAAQ,CAAA,OACR,KAAQ,CAAA,EACb,IAAA,CAAK,MAAS,CAAA,EACd,IAAA,CAAK,KAAA,CAAA,EACL,IAAA,CAAK,UAAa,CAAA,EAClB,IAAA,CAAK,UAAa,CAAA,EAClB,IAAA,CAAK,YAAe,CAAA,CDzGxB,MC0GS,cAAiB,CAAA,EAW1B,OAAc,KAXY,CAAA,MAYtB,CD5GQ,CC4GD,ECpJiB,CDqJxB,CAAA,CAAA,CACA,EAAkB,ADvHmC,CAAA,CCuHjB,ADvHiB,OCuHjB,CACpC,EAAoB,EAAM,GAAN,CADgB,AAChB,IAExB,CAAA,KACU,EAAU,CAAG,EAAA,EAAI,CAAA,EAAI,EAAM,GAAA,KAAQ,CAAA,UAAA,EAAa,EAAQ,CAAA,CAAA,AAG9D,GC3JI,AD2JA,CAH0D,CAGxC,WErJtB,MFqJsB,CAAkB,GAAI,CAAA,GAEjC,OADX,AACW,EAAkB,IDnHE,aAAA,CAAA,GCmHgB,CAAI,WAGd,OACI,WAAA,CAAY,GAGrB,CAChC,AAJyD,CCvJjB,ADuJiB,CAAA,gBAKtC,QAAA,CAAA,EAAiB,QAAA,CAAA,AAChC,EAAA,CC1JI,KD0JJ,CAAwB,EAAM,CElJJ,AH6BF,OCqHM,CAAA,OAGlB,EAAkB,GElJZ,MFkJY,CAAA,OAEnB,MAGT,CEnJN,ADPY,CD0JE,CADK,EAAA,EAA6B,SAAA,CAAU,EAAM,EAAA,AAAO,GAAP,AAAiB,CAAA,CAAA,CAAA,AACxD,AADoD,CAAI,EElJpD,EFmJJ,CAAM,0BACM,EAAM,MAAA,EACvC,ED5H8C,AC4H/B,CD5H+B,AC4H/B,CAAA,AAEnB,CCzJA,GAAA,IAAA,EDyJa,CAAA,CAAG,EAAI,CD7HL,CC6HW,ED7HE,IAAA,CAAA,IAAA,KC+HlB,CE/IN,CAAA,EF+IoC,KCxJpC,ODwJiD,CAAA,CAAA,CAAM,CAAC,CAAG,CAAA,EAAM,GAAN,UAAM,CAAe,OAEhE,AAFuE,CAEvE,AAFuE,CAAA,QAGnE,GAAI,CAAA,EAAc,GEhJR,IFmJ5B,EAAA,AAH6C,CAAA,CAG7C,AAH6C,OAGzB,EAAS,OAAS,IAEhC,ED/HhB,AC+H+B,IAEjB,KD/Hd,EC6H+B,AE9IvB,GFiJJ,GACI,ED/HD,CAAA,EC+HgB,UAAW,CAAA,QAAA,EAGxB,IAAA,EAAa,CEnIT,CFmIe,GEnIM,OFmIN,EAAA,EAA6B,QAAA,CAAA,AAElD,EAAS,IAAA,CAAK,EEnIR,CFmIY,CAAA,EAAY,CEnIM,CFmIS,GEnIC,KAAA,CAAA,GFmIuB,CACjE,CEpI2E,CAAA,MFoIrE,EAAS,CAAM,EAAA,EAAA,AAAa,EAAM,GAAA,GAAnB,CAAmB,CAAA,CAAA,AAE5C,EAAA,UACJ,EAAA,IACc,EAAM,UAAW,CAAA,QAAA,CAAA,CAG/B,IAAM,EAAe,IAAI,EACrB,EACA,EACA,EACA,EACA,EACA,EACA,EAAa,EAAM,OAAA,CACnB,EACA,OE5HyB,CAAA,EFgIX,EAAA,iBAAA,CAAkB,GAAI,CAAA,EAAS,GAE1C,EAFiC,AAK5C,CE/HiE,MF+HlD,aACX,CACA,CAAA,CAAA,CACA,CAEJ,CAAA,CACI,GE/HqD,CF+HjD,CE9HI,EF8H2B,KAAA,CAAA,gCAGnC,EAAA,CACQ,EAAkB,yBACtB,EACY,AADZ,EACY,YE/HR,CF+HQ,CAAA,CAAA,EAAmB,EAAa,EAAA,CAAA,CAAA,AAChC,CEhI2B,CFgI3B,IE9HR,AAFmC,aFgI3B,CAAoB,CE9HA,EF8HG,EAAa,EAAA,CAAA,CAAA,GACb,IAAA,AAI/B,CAJ+B,CAIvB,OE9HN,MF8HsB,CE9HF,CAAA,KF+HtB,EAAQ,CE5HC,gBF4HmB,CAAA,QAI9B,IAAA,EAAU,EAAA,WAAQ,CAAY,GAChC,CADoC,CAAA,AACtB,CADsB,AEzHX,CF0HH,KAAA,CACpB,AADoB,EACI,CAAA,AE3HD,EF2HC,qBAAS,CAAA,AAEvC,EAD+B,AACb,EADqB,GExHT,EFwHS,eACI,EADJ,CAAA,AACI,EAE3C,GAAA,EAAkB,CAClB,CACI,GAAA,EAEmB,GAAA,EACA,EAPoB,CAOpB,AAPoB,MAUvC,CACI,CALe,CAAA,EAKT,EAJS,AAIT,CAJS,AAIF,EAAkB,EE3HP,EFqH5B,CEtHY,YF4HuB,CAAkB,GAAM,CAAF,CAAA,IAAE,EAAS,CAAK,CAAA,EAEtD,GAAA,EACA,CADA,CAAA,CACA,EAMhB,CANgB,AAHsD,CAGtD,AAHsD,KAStE,KAAK,CE9HA,EF8HI,CAAA,EAAA,GAWpB,OAAe,SACX,CAAA,CAAA,CACA,CACA,CAAA,EAAkB,EAAkB,EAApC,KAEJ,CAAA,CACI,IAAM,EAAU,EAAO,GAAP,CAAA,MAAkB,CAAA,IAAA,CAAM,GAEpC,EAAQ,CAAA,CACR,AADQ,CAAA,CACD,EAAA,CAAA,AACP,EAAQ,CAJ2C,CAI3C,AAJ2C,CAI3C,AAEN,AANiD,EAMb,GAApC,GAAA,AAAoC,CAAA,MAAA,CAAO,IAAI,CAAA,AAA/C,CAA+C,AAC/C,eAAE,CAAe,YAAA,CAAA,CAAe,CAAA,EAGhC,EAAiB,CAHe,CAAA,AAGG,UAAnC,KAAmC,CAAA,AAAgB,GACnD,EAAmB,EAAkB,GADwB,CAAA,CAAA,OAC7D,IAAqC,CAAA,CAAkB,GAGzD,EAAmB,CAAC,EAQlB,EAXiE,AAWjD,CAXiD,CAAA,AAW3C,QARJ,CAAA,AAQlB,IAAsC,CAAA,EAGtC,EAAS,EAAkB,EAA3B,KAHsC,CAAA,CAGX,CAAU,GAE3C,CAF+C,CAAA,CAAA,CAE/C,IAAS,CAAI,CAAA,CAAA,CAAG,EAAI,EAAO,MAAA,CAAQ,CACnC,EAAA,CAAA,CAEQ,IAAA,EAAQ,CAAA,CAAO,CAAf,CAAgB,CAAA,AAGhB,GAAA,EAAkB,UAAW,CAAA,GACjC,CAEI,CAHA,AAAkC,CACtC,CAEQ,CAAC,EACL,CACa,GAAA,EAAA,AAAkB,QAAA,CAAS,GACpC,CADwC,CAAA,AACrB,CADqB,AACpB,CADX,CAEF,EAAA,GACC,EAAA,CAAA,CAAA,GAFY,CAAA,OAQhB,SAKZ,KAEU,CEnJE,CFmJoB,EAAkB,UEnJN,KFmJM,CAAgB,GACxD,CEnJE,CFkJ2D,AElJ3D,CFkJ2D,CAAA,AElJ3D,eFmJsC,CAAgB,CAAA,CAAK,EAAK,EAAA,IAAA,CAAS,CAAC,CAAC,CAAA,CAAA,GAE/E,GAAuB,CEpJI,CFsJ3B,aAKF,EAAa,EAAkB,EANjC,WAMiC,CAAc,EAAd,AAAqB,EAAe,CAAf,CAAsB,GAGhF,GAAI,CAHmF,CAAA,AAGtE,CAHsE,AAA7B,CAetD,GATI,IACJ,CADI,GAFR,EAAA,EAKiB,EAAkB,QAAA,CAAS,GAC7B,CADiC,CACjC,AADiC,CAAA,CACjC,CAAA,AACC,AEzJJ,EFyJI,CAAA,CAAA,CAIR,EAAkB,aAAA,CAAc,EAAd,AAAqB,EAAM,CAAN,EAAA,OAAgB,CAC3D,CAAA,CAEU,GEzJd,CFyJc,EAAa,EAAkB,MAA/B,OAA+B,CAAc,EAAd,CAGrC,EAHwD,CAAA,CAAA,AAGxD,IAAS,CAAI,CAAA,CAAA,CAAG,CAAI,CAAA,EAAW,MAAA,CAAQ,CAAnB,AACpB,EAAA,CAAA,CACQ,IAAA,EAAO,CAAA,CAAP,AAAkB,CAAC,CAAA,CAAA,AACnB,EAAW,EAEX,CAAI,AE5JlB,CF0JyB,AAEP,CAFO,AAEP,AE3JJ,CF2JI,AAGD,KAAA,CE7JJ,AF6JI,CAAW,CE/JI,AF+JA,CAAA,CAAC,CACvB,EAAA,CACU,IAAA,EAAW,CAAW,CAAA,EE7JhB,AF6JgB,EAAK,CAG7B,GAAC,CAAD,CE9Jd,EAAA,WF8J+C,CAAA,EAAU,EAAU,EAAO,CAAA,CAA3B,AAA8B,CAAH,CAAS,GAAA,OAAU,CACnF,CAMI,CANJ,KAMI,AAJQ,EE9J5B,CF8J4B,EAOD,EAAA,EACX,CAAA,CARY,CAAA,AAQZ,AE/JF,CF8Ja,AACX,AAGJ,CAAA,CAJe,CAAA,AE1JvB,AF8Ja,CAAI,CAAA,CAAA,CAAA,AAET,IAAM,EAAiB,EAAkB,aAAA,CAAc,EAAd,AAAoB,EAAe,AAAf,EAAsB,GAE/E,EEhKD,AFgKkB,EAFqE,AAErE,CAFqE,CAA7B,AAA6B,EAI7E,GAAA,EAAA,AAAkB,EEjK3C,MFiK2C,CAAS,EEjKF,CFkKf,CADqB,EACrB,CEjKnB,CAAA,AFkKO,EAAA,CADY,CAAA,AACZ,CAAA,AACC,EAAA,CAAA,CAAA,CAAA,AAGJ,GAAA,CAAA,CACC,EADD,CAAA,AEhKnB,AFiKoB,CAAA,CACb,AADa,AACb,CAKJ,IAAA,CAGQ,EAAK,EAAL,EATS,CAAA,CASJ,CAAS,CAClB,EAAA,CACa,GAAA,EAAA,AAAkB,QAAA,CAAS,GAC7B,CADiC,CAAA,AACjC,CADiC,CAA/B,AACF,CACC,AADD,EACC,CAAA,CAAA,CAGN,AAHM,IAGN,EAAc,CAAM,GAAA,EAAO,GAA3B,CAAoB,EAAgB,CAAA,CAAA,CAAA,AAG1C,GAAS,EAAkB,QAAA,CAAS,EAAO,CAAC,EAAD,CACxB,GAAA,EACZ,EAAA,CADY,AADoC,CACpC,AADoC,CAG/C,AAH+C,EAG/C,CAAA,GAFW,GAWnB,EAAa,EAAQ,IAGF,EAHnB,CAGmB,EAGV,GAHU,AAGV,CALb,AAEuB,CAGQ,AAAlB,CALb,KAEuB,EAGQ,CAAS,GAG7B,CAHiC,CAAA,AAGjC,CAHiC,CAGjC,AAHE,AAGF,CACC,AADD,EACC,CAAA,CAAA,CAAA,CAIR,EAAK,EAAL,IAAK,CAAS,CAAK,EAAA,CAAC,EAAkB,eAAgB,CAAA,IAAU,CAAL,AAAK,CACpE,EAAA,IAEY,EAGC,GAAA,EAEjB,AAFiB,CAGrB,AAIO,OAFE,AAEF,AAPc,CAAA,CAKZ,EAAkB,CAAlB,AAEF,CAAA,MAF6B,CAAA,GAAM,CAAN,CAE7B,CACX,AAQA,CAXa,CAAsC,CAAA,CAAA,GAWpC,QAAA,CAAS,CAAc,CAAA,GAAU,CAChD,CAAA,CAKW,CAN2B,MAE3B,AAIA,EAJA,EAAA,AAAkB,AAIlB,CAAA,SAJkB,CAAW,GAE5B,CAFgC,CAAjC,AAAiC,AAEhC,CAFgC,CAErB,AAAX,CAAW,EAAG,EAAd,EAAkB,CAAA;AAAA,CAAO,CAAA,CAE1B,CACX,AAUA,EAbqC,CAAA,IAatB,aAAA,CAAc,CAAa,CAAA,CAAA,CAAuB,CAAA,CAC7D,CACJ,CAAA,CACQ,IAAA,EAAQ,CAAA,CAAM,CAAd,CAAiB,CAAA,AAQd,AARc,MAEA,QACrB,EAAA,AADI,OAAO,IAEP,EAAQ,EAAkB,CAA1B,WAA0B,CAAa,EAAK,CAAlB,AAAkB,CAAe,GAAW,EACtE,CAAA,CADkE,AAC5D,CADgE,CACzD,CAAA,AAAJ,CADmC,EAIzC,CAAA,CAHU,AAWrB,CAXqB,AADyD,CAAA,CAInE,CAAA,GAQI,gBAAgB,CAC/B,CAAA,CACY,MAAe,WAAf,GAA2B,AAAe,OAA1C,GAA0C,CAAA,GAAA,CAQtD,AAPA,OAOe,kBAAkB,CACjC,CAAA,CACI,MAAuB,QAAA,CAAA,EAAf,CAAe,CAC3B,AAOA,OAAe,CARY,UAQD,CAC1B,CAAA,CACQ,GAAgB,QACpB,EADI,AACJ,OADW,EAEA,MAAA,EAAA,CAAA,AAGX,IAAA,IAAS,EAAI,EAAK,MAAA,CAAS,CAAG,CAAA,CAAA,EAAK,EAAG,CACtC,EAAA,CAAA,CACU,IAAA,EAAO,CAAA,CAAP,AAAY,CAAC,CAAA,CAAA,AAEnB,GAAI,CAAC,EAAkB,eAAgB,CAAlC,AAAkC,GAEnC,CAFuC,CAC3C,EAAA,EAIO,EAAA,EAAA,AAAK,EAAL,GAAW,CAAA,CAAA,CAAG,CAAE,CAAA,CAAA,CAC3B,AAEO,AAHoB,OAGpB,CAAA,CACX,AAOA,OAAe,WAAW,CAC1B,CAAA,OACQ,AAAgB,QACpB,EAAA,AADI,OAAO,GAKJ,EAAkB,SAAU,CAAA,QAAA,CAAS,EAAK,EAAA,QAAA,CAAW,CAAC,CAAC,CAAA,CAAA,AAClE,AAYA,OAAc,gBAAgB,CAAA,CAAc,CAC5C,CAAA,OACwB,AAAhB,QACJ,EAAA,AADI,OAAO,GAKJ,EAAkB,eAAgB,CAAA,QAAA,CAAS,EAAK,EAAA,QAAA,CAAW,CAAC,CAAC,CAAA,CAAA,AACxE,AAOA,OAAe,UAAU,CACzB,CAAA,CACI,IAAM,EAAmB,EAAC,CAAA,AACtB,EAAQ,EAAA,CAAA,AAER,AAFQ,GAEQ,QACpB,EADI,AACJ,OADW,EAEA,OAAA,EAGX,IAHW,AAGX,CAHW,GAGF,CAAI,CAAA,CAAA,CAAG,CAAI,CAAA,EAAK,EAAL,IAAK,CAAQ,CACjC,EAAA,CAAA,CACU,IAAA,EAAO,CAAA,CAAP,AAAY,CAAC,CAAA,CAAA,AACb,EAAW,CAAK,CAAA,CAAA,CAAI,CAAC,CAArB,AAAqB,CAAA,AAEvB,GAAA,EAAkB,eAAA,CAAlB,AAAkC,EAAM,EAAA,EAAa,EAAkB,EAAvB,QAAuB,CAAW,GACtF,CAD0F,AAExE,CAFyD,AAC3E,CAEI,EAAA,CADI,IAEA,EAAO,IAAP,AAAO,CAAK,GACJ,EAAA,AADS,CAAA,CACT,AADS,CACT,CAIC,OAAT,GAA8B,CAA9B,KACJ,CADqB,GAEjB,EAAO,GAFU,CAEV,CAAK,MAAM,CAAA,CAAA,AAClB,CAAA,EAAA,CAAA,CAIA,EAAO,IAAA,CAAK,GAGhB,QAAA,CACJ,AAES,GAAA,CAAA,CACb,AAOO,EARM,CAAA,GAGT,AAAU,EACd,EAAA,IACI,EAAO,IAAA,CAAK,GAGT,CAAA,CACX,AAYA,IAbW,CAAA,EAaG,cAAc,CAAA,CAAgB,CAC5C,CAAA,CACW,OAAA,CAAA,CACX,AAgBA,OAAc,CAjBH,CAAA,WAiBiB,CAAA,CAAA,CAAe,CAAmB,CAAA,CAAA,CAAgB,CAAA,CAC1E,CACJ,CAAA,CACW,OAAA,CAAA,CAaX,AAZA,EADW,CAAA,IAaG,cAAc,CAC5B,CAAA,CACW,OAAA,EAAkB,iBAAA,CAAkB,EAAK,CACpD,AAOA,EARoD,CAAA,CAAA,GAQtC,YAAY,CAC1B,CAAA,CAEQ,GAAA,EAAkB,MAAO,CAAA,EAC7B,CACW,CADX,MACW,EAAkB,MAAA,CAAO,EAAI,CAAA,AAGxC,CAHwC,GAGlC,EAAU,EAAkB,QAAA,CAAA,AAElC,EAAQ,IAAO,CAFmB,AAEnB,EACf,IAAM,EAAU,EAAQ,WAAA,CAAY,EAAkB,cAAA,CAAiB,EAAkB,eAAe,CAAA,CAAA,AAElG,EAAa,CACf,OADe,AACP,EAAQ,uBAAA,CAChB,QAAS,EAAQ,KAAA,mBAAA,CACjB,QAAA,CAAU,EAAQ,KAAA,kBAAA,CAA0B,EAAQ,KAAA,mBAAA,CACxD,CAIO,AAJP,OAEkB,EAAA,MAAA,CAAO,EAAQ,CAAA,CAAJ,CAEtB,CAAA,CACX,AAMA,EATsB,IAAe,CAAA,AASvB,aAAa,EAAO,EAAP,AAC3B,CAAA,CACQ,EAEO,EADX,EAAA,GACW,EAAkB,MAAA,CAAO,EAAI,CAAA,AAIpC,CAJoC,CAIlB,IAJX,EAIW,CAAS,CAAA,CAAC,AAChC,CADgC,AAEpC,AAOA,MATQ,KASU,OAClB,EAAA,CACQ,GAAA,CAAC,EAAkB,QACvB,CAAA,CACQ,IAAA,EAGJ,GAAA,CAEI,AALA,CAAA,GAKM,CAAI,CAAA,IAAI,eAAgB,CAAA,CAAA,CAAG,CAAC,CAAA,CAAA,AAC5B,EAAU,CAAA,CAAE,GAAF,OAAa,CAAA,IAAA,CAAM,GAEnC,GAAI,GAAS,MAFqC,CAAA,CAAA,GAGlD,CAGW,CAHX,MACI,EAAkB,QAAW,CAAA,CAAA,CAAA,AAEtB,CAAA,CAAA,AAGF,EAAA,CALL,CAKK,UAAA,CAAW,GAAI,EAAA,CAAE,YAAa,EAAA,CAAA,MAEpC,EACP,CACa,EAAA,EAAA,UAAA,CAAW,GAAI,GAAE,YAAa,EAAA,CAEpC,AADP,AAD2C,EAEpC,IAAA,CAAA,CAAQ,EAAO,MAAS,CAAA,EAAA,CAAA,AAC/B,EAAkB,QAAW,CAAA,CAAA,CACjC,AAEA,IAHiC,CAA7B,AAA6B,EAG1B,EAAkB,QAAA,CAAA,AAC7B,AAMA,OAP6B,IAOX,QAClB,EAAA,CAMI,OALI,AAAC,EAAkB,SACvB,EAAA,AACI,GAAkB,SAAY,CAAA,EAAkB,GAAhD,IAAwD,CAAA,QAA1B,EAA0B,CAAW,KAAM,EAAe,CAAA,CAAA,AAGrF,EAAkB,SAAA,CAAA,AAC7B,AACJ,CAAA,CAAA,AA5zBa,EAiCK,EAyxBe,YAzxBE,CAAA,CAjCtB,MAAA,EAoCK,GAHiB,CAAA,WAGC,CApCvB,AAoCuB,GAAA,CAAA,AApCvB,EAuCK,gBAvCL,GAuC2B,CAAA,GAAA,CAAA,AAvC3B,EA0CK,gBA1CL,CA0CyB,CAAA,CAAA,CAAA,AA1CzB,EAuDK,gBAvDL,CAuDK,CAAA,CAA8C,KAEpD,CADR,EAC8C,YAAtC,OAAQ,IAAgB,EAAA,UAC5B,CACU,IAAA,EAAA,IAAiB,IAAA,CAAe,SAAU,CAEhD,CAFgD,CAAA,KAEzC,AAAC,CACR,GACU,EADV,EACU,EAAW,EAAU,IAArB,GAAqB,CAAQ,CAAC,CAAA,CAAA,AACpC,EAAe,EAAC,CAAA,AAEZ,CAAI,CAAA,CAAA,CAAA,AAER,IAAA,IAAW,KAAW,EAEX,CAAA,CAAA,CAAA,EAAG,CAAA,AADd,CACmB,AADnB,EAC2B,KAAA,EAAA,CAAA,AAGpB,OAAA,CAAA,CACX,CAAA,AACJ,AAEA,GAJe,CAAA,GAIR,AAAC,CAAA,EAAc,CAAC,GAAG,CAAC,CAAA,CAAA,AAC/B,CAAG,GAAA,AA9EM,CA8EN,CAkCW,gBAhHL,SAgHiC,EAAA,EAhHjC,EAmHM,CAH2B,CAAA,IAG3B,CAAsC,CAAA,CAAC,CAAA,AAnH7C,EAsHe,IAtHf,KAsHqC,CAAA,CAC1C,EAAA,CACA,EAxHK,AAwHL,CACJ,CAAA,AAzHS,EA4He,eAA4B,CA5H3C,AA4H2C,CAChD,CAAA,CACA,EAAA,CACA,IAAA,CACA,IAAA,CACA,IAAA,CACA,IAAA,CACA,IAAA,CACA,IAAA,CACA,IAAA,CACA,IAAA,CACA,IAAA,CACA,IAAA,CACA,IAAA,CACA,KAAA,CACJ,CAAA,AA3IS,EAmJe,gBAAA,CAAA,CAAoB,EAAuB,GAAI,CAAA,CAAA,uHClMvE,CAAA,CAAA,CAEA,CAAA,CAAA,CFZ4D,EEalD,CAEd,EAAA,KAEkB,IFhBV,EDIE,CAAA,GGYoB,ECoB9B,CAAA,MDpB8B,CAAQ,CHZG,IGYM,EAAA,CAAA,EAAA,IAC3C,EAAA,CHbiE,KGctD,EAAA,KAAA,CAAM,GFjBb,GEiBoB,CAAA,EHVoB,MGUpB,CAAS,EAAU,KAAA,EAAO,IFjBF,CAAA,GEiBE,CAAS,EAAU,KAAA,EAAA,AAAS,CAAC,CAAA,CAAE,MAAO,EAAA,CAAA,AACxF,GHTK,AGWK,EAAU,EHXD,EGYnB,EAQA,GAES,EAAU,CHTX,GGSW,MHTgB,MGSA,EDmHnC,MAAA,KClHA,CAAA,KACU,EAAA,EAAA,IAAwB,CAAA,AACxB,EAAU,EAAQ,aAAA,CAAA,EAAA,OAAkC,CAAA,MAAA,CAAO,QAAA,CAAU,QAAQ,CAAA,CAAA,AAC7E,EAAA,EAAyB,CDoHE,QCpHQ,CAAA,MAAA,CAAO,EAAA,MAAA,CAAO,MAAM,CAAA,ADoHI,QClHtD,EAAA,KAAA,CACP,EAAY,OAAA,CAAQ,CAApB,IAA0B,CAAA,KAAA,CAC1B,EAAA,OAAA,CAAoB,KAAM,CAAA,MAAA,EAG9B,EAAQ,QFpBK,IAAA,CAAA,GEsBN,OACX,GAES,EAAU,EFrBQ,EEqBR,YAAgB,CFrBS,CAAA,YEsB5C,CAAA,SACyB,EAAU,GCSd,CAAA,GDPa,WAAb,CCSH,CDTgB,IAAA,GACd,AAA8B,GCS/B,SAAA,YDT+B,CAE1C,EAAQ,CAAA,CAAA,EACC,CAAA,CAAA,AAGT,GAAW,CCKU,KDHb,EAAY,KADxB,AACgC,CAAA,MACP,CADO,CAAA,IACE,CAAA,OAAA,CAAA,EAIX,CF2CR,MExCf,CACU,GAAA,CF2CR,ME3CU,CAAO,KAAA,CAAA,CAAQ,CAAA,EAEvB,EAAA,EAAA,oBAAmB,CAAA,EACT,CAAA,CAAI,EAAA,EACJ,CAAA,CAAI,EAAA,EACN,CAAI,CAAA,EAAA,EACJ,CAAI,CAAA,GAIZ,EAAmB,CAJP,IAIY,GAAA,CAAI,EAAA,CAAI,CAAI,EAAM,CAAC,CAAI,CAAL,AAAK,CCOD,CAAA,CAAA,CDPC,CAAK,GAAK,CAAA,CAAA,EAAI,CAAJ,AAAQ,CAAA,GAAM,EAAN,AAAW,GAAG,CAAA,CAAA,GAGnF,CACI,GAAM,QAAE,CAAA,aAAQ,CAAa,aAAA,CAAA,aAAa,CAAA,CAAgB,CAAA,EAE1D,EAAW,EAAQ,IAAnB,CAAmB,CAFuC,CAAA,aAEvC,CACf,CF0CR,CE1Ce,CAAI,CAAA,EACX,EFyCD,AEzCQ,CADI,AACA,CAAA,EACX,EAAc,EADH,AAEX,EAAY,CADE,AACE,CAAA,EAChB,CAFc,CAEd,CAAA,AADgB,CACA,CDoJxB,CCnJQ,EAAc,SAKE,GAAW,EACnC,KACU,EAAS,EAAY,MCWd,IDX4B,CAAA,CD0JH,CAAA,ACxJtC,CDwJsC,GCxJtC,IAAS,EAAI,CAAG,CAAA,CAAA,CDyJd,ECzJ8B,KAAA,CAAM,CDyJD,KAAA,CCzJS,CAC9C,EAAA,CAAA,OACoB,CAAA,EAAI,EAAY,UAAA,CAAe,EAAU,CAAM,EAAA,EAElD,EAAA,EAFkD,CAAA,OAElD,CAAA,OAAmB,CAAA,AAAC,QAGvB,EAAa,EDwJ3B,ACxJoC,CFmCZ,CEnCiB,MAAS,CAAA,CFmCV,GEjCvB,CAFiC,CAAA,UAEjC,ICKW,EDHX,KAAA,CApHX,GAAA,CAAA,AFEd,AEkH+B,CDyJZ,MCzJsC,EAAA,IAAb,CAAa,CAAA,MAAA,CAAJ,AACpB,CADwB,GFiCnC,AEjCmC,IACxB,CAAA,EAAc,CCOP,CDRiB,ACQjB,CAAA,EDPY,EAAE,KAAM,CD0J1B,YCpJ9B,CAEiB,EDyJP,QCzJO,CAAW,OAAQ,CAAA,IAEnB,CF0BnB,CAAA,AGjBM,GAAA,SDTa,CAAa,CDyJV,CAAA,ACzJe,CCSA,CDTA,ICSA,CDTQ,EAAA,KAAM,CAAA,MAAA,CAAO,QAAA,CAAS,EAAK,EAAA,GAAK,CAAE,CAAA,KAAA,EAAO,CAAA,CAAA,gBArGxF,CACI,IAAM,EAAU,EAAQ,EHXT,WGWS,CAAA,EAAwB,OAAQ,CAAA,MAAA,CAAO,QAAA,CAAU,QAAQ,CAAA,CAC3E,AAD2E,EAC9D,EAAU,EFnBI,IEmBd,AAAiB,CAAA,AFnBpB,MEmBoB,CAAO,EAAA,MAAA,CAAO,MAAM,SAE7C,EAAA,KAAA,CAAM,EAAU,OAAQ,CAAA,KAAA,CAAA,KAAA,CAAa,EAAU,OAAA,CAAQ,KAAA,CAAM,MAAM,CAAA,CAAA,EACtE,MHTS,CCTD,KAAA,CEkBK,GAEd,OAAA,CAAA,AAsGX,CAAA,EAAA,EAAA,IAAA,EAAK,2BAAA,iDCtIT,IAAM,EAAW,EHET,EGFa,EAAA,SAAU,CA4VlB,EAAsB,IAtTnC,AAsTuC,MAtTjC,AAiBK,kBAqSqD,EArSjC,CAC3B,CAAA,IACU,MAAE,CAAA,OAAM,CDTP,ACSc,YAAA,CH7BN,CAAA,AG6BmB,CAAA,CAAM,CAAA,EAElC,EAAW,CAFI,CDNN,ACQsB,CAFG,CAAA,cAEc,GAGtD,EAAiB,CH9BC,CG8BiB,CDTJ,UCSgB,CAAA,GAAQ,CAAR,GAAa,GAEtD,EAAA,AAF2D,CAAA,CAAA,GAE9C,IAAK,CAAA,IAAA,CAAK,IAAA,CAAA,KAAW,GAAA,CAAI,CAAG,CAAA,CDTR,CAAA,ACSiB,KAAK,CAAd,AAAc,CAAK,AAAU,CAAG,IAAI,EAAP,CACtE,EAAS,IAAA,CAAK,AADyE,ADRvF,CCQuF,CAAA,EACpE,CAAA,KAAK,IAAA,CAAM,IAAK,CAAA,GAAA,CAAI,CAAG,CAAA,EAAS,IDTX,CAAA,CCSE,AAAe,CAAA,CAAe,CAAG,CAAb,GAAiB,GAE/E,CAFwE,CAErD,CHhCtB,AEuBS,CCSa,AHhCtB,GG8B4F,CAAA,CAAA,KAEtE,CAAW,0BAA2B,CAAA,EAAO,GAAP,AAE/D,GAF4E,CAAA,AAE5E,CAF4E,AAEvE,KDVQ,cCUY,CAAA,EAAM,EAAN,AAAa,EAAS,CAAT,CAAqB,GAArB,AAEhC,IAAA,EAAQ,EAAM,CAAd,GACA,CAHqE,AAGrE,CAHqE,CAAA,OHkCnE,GAAwB,CACxC,EACQ,AADR,IACQ,EAAU,CAAA,CAAK,CAAC,CAAA,AAEhB,CAFgB,AAEf,CGnCK,CHmCG,GE1CL,GF2CR,CGhCQ,CHgCR,IACgB,OAAQ,CAAK,CAAA,CAAC,CAAA,CAAc,WAAY,CAAA,CAAK,CAAC,CAAE,CAAA,CAAA,CAAA,IAGxD,QAAA,CAAW,CAAA,CC+GF,CD5GX,EAAa,CC6GF,CAAA,ED7GO,CAAA,GAAA,CAAI,EAAQ,KAAA,KAAA,EAAc,EAAG,CAAC,CAAA,CAAA,EACxC,EAAA,KAAA,EAAiB,EAAO,CE3CP,CAAA,EF2CO,CAAA,CAAA,UACf,EAAU,EAAO,IAAA,EAAA,CAAA,UACnB,CAKrB,AALqB,EC6GC,CDnOjB,ACmOiB,KDhOlB,EAAmB,CEJT,AFGV,EAAkB,ECyDb,KD1DT,KC0DS,CAAA,GDzDwB,GAAA,YAAA,CAAmB,IAAK,IAAA,EAClB,UAAW,CAAA,KAAA,CAAQ,oBAAoB,6BAC9B,CAAA,OAC5C,EAAA,WAA+B,CAAA,CAAA,GAG/B,EAAgB,KAAA,GAAQ,CEmBL,CAAA,CFnB8B,MAAA,EAAS,CAC9D,AAD8D,EAC9D,QAEoB,CDOM,CAAA,EAAA,EAAA,QAAA,ECuGL,CE5CC,IFjEF,MAAA,CAAA,CAAA,EAAS,EAAA,QAAA,EAAS,AA6GV,EC2GN,CAAA,CDzGtB,CAAK,CAF6B,CAAA,CAAA,KAIpB,UAAU,AADxB,WCyGwB,CAAA,uBDpGP,EAAA,GE9CT,MF8CS,CACb,CE5CA,CF6CA,CAAA,CAAG,CAAA,CADH,AAEA,EAAO,EACP,CAAA,CAAG,CAAA,CACH,EAAQ,EAAY,EAAS,GAKjC,GE5C0B,CF4CpB,EAAO,AADP,EAA6B,WG7BH,CAAA,CAAA,EAAA,EH6BsB,ECmHQ,GAAA,ADlHvC,CCkHuC,GDlHvC,CAEvB,AAFuB,EAEZ,CCmHD,ADnHC,CACX,EAAU,CAAA,CAAA,MAEV,EAAa,EAAS,CAAA,CAAA,AAEtB,CCoHQ,AC1JiB,IFsClB,EAAM,GAAA,EAAA,EAAyB,CEnCM,CAAA,IAAA,EFmCS,EACrD,GAAI,GAAQ,CAAA,EAAA,OAAA,EAAA,SAAyB,CAAA,KAAA,CAC9B,KAAA,EAAA,EAAA,EAAsB,IAAA,EAAW,EACxC,KAAO,EAAA,EAAA,EAAyB,EAAM,EC2HG,AD3HT,AAAM,IAAA,EAAA,EACtC,KAAA,EAAA,EAAyB,EC6HD,AD7HQ,EAAO,EAAK,IAAW,EAAL,AAAK,CAAL,CAc3C,MAZL,EAAA,EACA,EAAA,EAEF,EAAiB,wBAA2B,CAAA,aAAA,CAAA,AAE5C,EAAA,UAAA,CAAA,EAAkC,EAAK,EAAQ,CC8HC,CD9HK,CAAN,CAAe,GAAG,AACjE,CADiE,AE1BjE,CF0BiE,AAChD,EGhBT,CAAA,MF+IuB,eD/Ha,CAAA,MAAA,CAAA,IAE5C,EAAA,IAAA,EAAA,SAAA,CAAyB,CAAA,AAElB,CAFkB,CAElB,GAAA,CE5BmC,AF4B/B,CE5B+B,AAGnC,CAHmC,AF4BxB,EAAA,EAAkB,EAAA,CAAa,EAAQ,CAAA,CAAQ,CAAA,EAAA,CAAa,EAAS,CAAA,CAAA,CAAO,CAAP,CAAtB,CAE1D,GG5FwB,CAAE,GH0FuE,CAAA,CAAA,CG1F/D,CAAA,EAAiB,MAAA,OAAQ,CAAzB,CAAgC,GAAA,GAAA,GAAQ,WAAY,CAAG,CAAA,MAAA,CAAQ,CAAA,CAAU,CAAA,CACxG,EAAS,GAAI,CAAA,CAAA,CAAG,CAAG,CAAA,EAAO,GAAP,AAElB,GAF+B,CAAA,CAAA,CAE/B,kBACH,EACA,KHgCM,AGhCN,EF8IR,EEnIO,CHsCP,ACyGA,ICvJQ,CAAA,iBCQsB,CAC9B,CAAA,CACI,EAAA,UAAA,CAAW,GHuCE,mBAAA,CAAA,EGvCqC,CACtD,AAUQ,CHkCR,mBGjCI,CAAA,CACA,CACA,CAAA,CAAA,CACA,CAAA,CACA,CFkJA,AEhJJ,CAAA,CACU,CDZN,GC6CI,EACA,EAlCE,QAAE,CAAQ,SAAA,CAAA,CAAY,CFgJjB,CAAA,CE9IL,EAAO,EAAP,AAA+B,GAE/B,EDbF,AFuCe,AG5BuB,AAEzB,CAFyB,CAAA,AAEP,EDZnC,SCY+C,CAAA,CDXF,ECWU,CAAR,GAAa,GACtD,EAD2D,AACnD,CADmD,CAAA,AACnD,KAAS,CAAA,AACjB,EAAa,CDTK,AFqCR,CEvCoB,ACWR,UAAA,CAAA,AACtB,EAAa,EAAS,KFkJQ,KElJR,CAAA,AACtB,EDRE,AFqCC,EG7BqB,CFkJI,WElJJ,CACxB,EAAiB,EAAS,cAAA,CAAA,AAEhC,EAAe,EAAO,MAAA,CAAA,GAEtB,EFgJkC,AEhJ1B,cAAe,CHyBU,CGzBV,CAAA,EACf,EDRgC,GCQhC,CAAM,EAAY,EHyBR,GGxBV,CHwB4B,EC2H9B,SAAA,CEnJiB,CFmJE,CEnJI,YAAA,CAAA,AAIzB,EAAM,GF+IqC,CAAA,CAAA,CAC5B,AD3HJ,CAAA,EAAA,MGpBf,CACI,CF8IiC,AD3HT,AE9BxB,GCWM,EAAc,EAAM,GAAA,CF+IX,GE/IW,CAE1B,AAF0B,EAElB,SAAA,CAAY,EAAY,CFgJpC,AD9H4B,IAAA,CGhBxB,EAAQ,GHgBuC,CE1BlC,MAAA,CCUQ,EAAY,UAAA,CACjC,AADiC,EACzB,QAAA,CAAW,EAAY,IAAA,CAAA,EACvB,IFgJO,GAAA,CEhJG,CFgJH,CEhJe,GAAA,CAAA,AAIlC,EF4I4B,AE5IpB,IAAO,CAAA,CHiBnB,AE3BW,CDyJD,AEzIA,EANS,EAMT,CF+IF,CE/IgB,EAAM,GAAA,OAAA,CF+II,AE/IS,CAAI,CAAA,CAAA,AHgBX,CGhBW,IAa3C,IAAS,CAAI,CHKV,AGLU,CHKV,AGLU,CAAG,CAAI,CAAA,EAAa,EAAE,CACnC,CAAA,CACU,IAAA,AAFU,EAEK,CFmIA,CEnIM,IFmIzB,MEnIyB,EAAoB,CAAA,CAAA,EAAN,AFmIS,CEnIH,CAEzC,EAAe,EAAe,IAAA,CAAK,EFmIvB,EEnI4B,CAAA,KAAK,GAAI,CAAA,CAAA,CAAG,GAAqB,CAAE,AFoIvE,CEpI2D,CFmIA,AEnIL,CFmIK,AEnIL,CAAqB,CAAA,CAAA,AAC/E,EAAiB,EAAe,EAEtC,GAAI,EFqIJ,AEpIA,CAII,EAAQ,AAP0B,CAAA,IAOlC,IAAoB,CAAA,OAAA,CAAA,AACpB,EAAQ,WAAc,CAAA,OAAA,CAAA,AAEtB,EFiIJ,EEjIU,EAAgB,EAAM,CFgIX,EEhIW,OAAA,CAAA,AAEtB,EAAkB,EAAc,KAAA,CAAA,AAChC,EAAkB,EAAc,CADA,IACA,CAAA,AAE9B,EAAA,GAF8B,QAE9B,CAAc,EAAA,KAAA,CAAM,MACvB,CAAA,QAAA,CAAS,GACT,QAAA,CAAS,GADe,AAExB,CADA,WACa,AADW,CAAA,CACX,CAAA,AAEZ,GF2HV,CE3HU,EAAiB,EAAc,IAAO,CAAA,EACtC,EAAqB,AF2H/B,CE5HU,CACmC,IADG,CAAA,GACQ,CAAA,EAEpD,EAAQ,CAFF,KAA8C,CAAA,GAE/B,CAAA,EACrB,EAAQ,aAAgB,CAAA,IAAA,CAAK,GAAI,CAAA,EAAc,KAAK,CAAI,CAAA,EACxD,EAAQ,AADyB,IF2HrC,CE1HI,QF0HJ,CE1H6B,AAD+B,CAAA,GAC1B,CAAA,GAAA,CAAI,EAAc,KAAK,EAAI,EAAsB,EAA/B,IAGpD,CAGQ,GAFI,EAAA,EAJuE,CAAA,CAAA,KAIvE,CAAY,EAAM,GAAA,EAAA,CAAQ,EAAmB,EAAM,CF0HN,EE1HA,AF0HA,EAAA,CE1Ha,EAAS,EAAoB,CAAC,CAAI,AAAf,CAAV,EAAyB,CAAzB,GAAyB,AAAL,CAAK,AAEhG,EAAM,OAAA,EAAS,KACnB,CAAA,CACI,IAAM,EAAuC,GAAtB,EAAM,GAAN,GAAA,CAAc,CAAA,KAAA,CAA0B,CAAA,CAAA,AAAV,EAErD,EAAQ,GAFuD,AF2HhE,EEzHC,MFyHD,CEzHuB,EAAmB,EAAM,OAAS,CAAA,EAAS,EAAU,GAAnB,AAG5D,EAAA,QAH4F,CAAA,CAAA,CAGtE,CAAA,OAAA,CAAA,AAGtB,IAAA,EAAA,CAAsB,EF+Hd,AE/H2B,EAAe,CF+HV,OE/HU,AAAY,EAAA,CAAA,CAAA,AAE9D,EAAa,EAAe,CF8HpB,OE9HoB,CAAW,CAC3C,GACyB,GAAA,CAAA,CAAA,AAGnB,IAAA,CF0H6B,CE1Hf,CF8HhB,CE9HgB,OAAM,EAAS,KAAS,EAAA,CAAA,CAAA,AAG5C,IAAA,IAAA,EAAa,CAAA,CAAGC,EAAI,EAAM,MAAA,CAAA,IAEtB,CADJ,CACoB,EAAc,CAAA,CAAA,AAC9B,EAAkB,EAAc,CAAA,CAAMA,CADtC,AAA8B,CACY,EAAe,EAAe,CAAxC,AAAhC,KAA0C,AAAuC,CAAA,EAEvE,SACV,CADI,EAAM,GF2HZ,AE3HM,CAF6E,CAAA,AAEvE,CAEW,GAAA,EF0HH,AE1HkB,CAAA,CAAWA,EAAC,CAAA,AAEvB,OFyHM,GExH/B,CADS,EAAM,GAAA,EAAA,CFyHjB,EEvHwB,GAAA,CAAA,EAAe,CAAWA,CAAAA,EAAM,AAAL,GAA3B,AAAgC,CAAA,CAAA,AAGlD,EAAM,GAAN,IAAM,EAAS,KACnB,EAAA,AACS,IAAA,CAAA,kBAAA,CACD,CAAA,CAAMA,CFyHC,CEzHA,AFwHnB,CEvHY,EFyHO,EEvHP,CAFA,CAEgB,EAChB,EF0HuB,AE1HP,EAAU,CADV,EF6HT,AE3HP,EAD0B,CAKd,AAAhB,CAJI,EFkIA,CANO,CEvHf,CAAA,AANkC,EAMlC,GADU,KAAA,EAED,IAAA,CAAA,kBAAA,CACD,CAAA,CAAMA,EAAC,CACP,EACA,EACA,CAFA,CAEgB,EAChB,EAAgB,EAAU,CADV,EAKhC,CACJ,AAmBQ,CAzB4B,AACU,CAF1B,MAE0B,WAyB1C,CACA,CAAA,CAAA,CACA,CAAA,CACA,CAAW,CAAA,CAAA,CACX,GAAW,CAEf,CAAA,CACU,GAAA,CAAE,SAAA,CAAY,CAAA,EAGd,EAAgB,EAAM,GAAA,OAHR,CAAA,EAGQ,CAAA,AAE5B,GAAmC,EAiB/B,GAjB+B,AAE/B,AFpOL,CEkOoC,CAEb,kCACtB,EAAA,CACQ,EAAkB,YFmJtB,aElJA,EACY,AADZ,EACY,aAAA,CAAgB,CFmJlB,EEnJqB,EAAa,EAAA,CAAA,CAAA,AAChC,CFkJsC,CElJtC,iBAAA,CAAA,CAAA,EAAuB,EAAa,CFmJE,CEnJF,CAAA,CAAA,AACb,GAAA,IAAA,AAI/B,AAL4C,CACb,AFuJ/B,CEnJQ,KAAR,IFiJA,IEjJwB,CAAA,KAAA,CAAA,AACxB,EAAQ,KAAR,YAA4B,CAAA,KAAA,CAAA,EAIhC,AAAkB,IAAlB,GAAuB,EAC3B,YACQ,EAEQ,EAAA,CFuJK,GExJjB,EAAA,IAFJ,AAGgB,CAAW,EAAM,CAAA,CAAA,AAAG,CAAC,CAAA,CAAA,AAIrB,CFsJR,CEtJQ,GFmJK,EEnJL,GAAA,CAAS,EAAM,CAAA,CAAA,AAAG,CAAC,CAAA,CAAA,CAMnC,IAAI,EAAkB,CAAA,CAAA,AAEhB,EAAc,EAAkB,iBAAA,CAAkB,GACpD,CADwD,CAAA,AACxC,CADwC,CAChC,KAAR,MAAoB,CAAA,GAAM,CAAF,CAAE,GAAA,CAAA,AAC1C,EAAe,CAAA,CAAA,AAEnB,IAAA,IAAS,EAAI,CAAG,CAAA,EAAI,EAAY,EF6JN,IE7JM,CAAQ,EAAE,CF6JW,AE5JrD,CAAA,CACU,IAAA,EAAc,CAAA,CAAY,CAAC,CAAA,CAAA,AAE7B,EAEQ,EAAA,UAAA,CAAW,EAAa,EAAiB,CAAC,CAAA,CAAA,AAI1C,EAAA,QAJwB,AAIxB,CAAS,EAAa,EAAiB,CAAC,CAAA,CAAA,AAEpD,IAFkC,AAE9B,EAAU,EAAA,CAEd,AAFc,CAFoB,GAIlC,IAAS,EAAI,CAAI,CAAA,CAAA,CAAG,EAAI,EAAY,MAAA,CAAQ,EAAR,AAAU,CAC9C,CAAA,AACI,GAAW,CAAA,CAAY,CAAC,CAAA,CAG5B,AAH4B,GAGT,GADJ,EAAA,EAAQ,CFgKP,IEhKD,IACoB,EADA,CAAA,GAAS,IAAF,CAAE,AFiKhC,EEhKsC,CFiKM,CEhKxC,EAAA,CAAA,CACpB,CACJ,AACJ,CAAA,IF8J+C,CElKe,CAAA,oLCyVvD,IAAM,EAAN,MAAM,EAAA,QAAkB,AAAlB,EAAkB,OAG/B,CAAA,AAmGI,WAAA,CAAY,EAAmC,CAAA,CAC/C,CAAA,AAD+C,CAErC,KAAA,EAAA,CAAA,AA5EH,IAAA,CAAA,GAAA,CAAA,CAAA,EAAM,EAAA,GAAA,EAAI,WAAW,CAAA,CAAA,AAM5B,IAAA,CAAO,KAAQ,CAAA,CAAA,CAwjBnB,AAxjBmB,AAwEX,SAgfC,AAAmB,CAC5B,EAAA,AAWI,GAAmC,GA5f/B,MA4f+B,EAA/B,OAAO,EAAS,MAAT,IAAwB,EAAa,EAAS,UACzD,CAAA,CACI,IAAM,EAAW,AAxmBlB,EAwmB4B,OAAA,EAxmB5B,QAwmB4B,CAE3B,AAF2B,EAErB,GAAN,OAAmB,CAAA,CACf,KAAA,CAAO,EAAS,MAAA,SAAA,EAAmB,EAAS,KAAA,CAAA,AAC5C,KAAA,CAAO,EAAS,MAAA,SAAA,EAAmB,EAAS,KAAA,CAAA,AAC5C,IAAA,CAAM,EAAS,MAAA,QAAA,EAAkB,EAAS,IAAA,CAC1C,CAD0C,IAC1C,CAAO,EAAS,MAAA,SAAA,EAAmB,EAAS,KAAA,CAAA,AAC5C,QAAA,CAAU,EAAS,MAAA,YAAA,EAAsB,EAAS,MAAA,EAAA,CACtD,CACJ,AAEI,AAHA,GAG6B,KACjC,CAAA,GADI,EAAS,MAAT,SAAS,CACb,IAEI,EAAA,WAAA,EAAY,EAAA,MAAA,CAAQ,yCAAyC,CAAA,CAAA,AAG7D,IAAM,EAAQ,EAAS,MAAA,CAAA,AACnB,EAAiB,CAAA,CAAC,CAAA,AAGlB,GAAA,EAAA,KAAA,CAAM,WAAY,CAAA,GAElB,EAFsC,AAElC,CADR,AACI,EADJ,EACgB,CAAA,KAAA,CAAA,CAGP,GAAA,KAAA,QAAiB,EAAA,YAAgB,EAAA,KAAA,QAAiB,EAAA,WAC3D,CACI,CADJ,CACQ,CAAJ,GAAW,CAAA,KAAA,CAAA,CAGN,GAAA,MAAA,CAAO,cAAe,CAAA,IAAA,CAAK,EAAO,GAAA,IAAO,CAAK,EAAA,MAAA,CAAO,cAAe,CAAA,IAAA,CAAK,EAAO,GAAA,GAAM,CAC/F,CACU,CADV,CACU,CAAA,IAAA,CAAA,CAIA,MAAA,AAAI,MAAM,uBAAuB,CAAA,CAAA,AAG3C,EAAM,GAAN,GAAe,CAAA,CACX,GAAG,CAAA,CACH,MAAO,EAAS,MAAA,SAAA,CACpB,CAAA,AACJ,AAEA,GAAI,KAAM,CAAA,OAAA,CAAQ,EAAS,MAAA,WAAiB,CAC5C,CAAA,CAKQ,MAHJ,EAAA,WAAA,EAAY,EAAA,MAAA,CAAQ,8DAA8D,CAAA,CAAA,AAG9E,CAAC,MAAM,OAAQ,CAAA,AAhEN,EAgEe,GAhEf,CAgEmB,AAhEnB,CAgEwB,CAAlB,CAA2C,CAC9D,EAAA,CADqC,EAAS,IAAK,CAAA,CAAd,KAAc,CAEzC,MAAA,AAAI,MAAM,oEAAoE,CAAA,AAGpF,CAHoF,EAG3E,IAAA,CAAA,AAAK,MAAW,GAAA,EAAS,MAAT,WAAS,CAAkB,MACxD,EAAA,GAEI,EAAA,IAAA,EAAK,yEAAyE,CAAA,CAAA,AAI5E,IAAA,EAAe,IAAI,EAAA,IAAnB,QAAgC,CAAA,CAClC,KAAO,CAAA,CAAE,CAAG,CAAA,CAAA,CAAG,EAAG,CAAE,CAAA,CACpB,GAAK,CAAA,CAAE,CAAG,CAAA,CAAA,CAAG,EAAG,CAAE,CAAA,CAClB,YAAc,CAAA,OAAA,CACjB,CAAA,CAEK,AAFL,EAEyB,EAAS,MAAA,OAA7B,IAA6B,CAAkB,KAAM,EAAA,CAAA,AACrD,EAAkB,EAAS,CAAT,GACnB,CAAA,CADmB,EACnB,CAAI,AAAC,GAAuB,EAAvB,AAAuB,KAAM,CAAA,MAAA,CAAO,QAAS,CAAA,GAAO,EAAF,CAAE,KAAA,EAAU,CAAA,CAAA,AAEtD,EAAA,OAAA,CAAQ,CAAC,EAAM,EAAN,EAAT,CAClB,AACI,EAAa,GADjB,OACI,EAA0B,CAAA,EAAM,CAAM,CAAZ,AAAY,EAAM,CAAA,CAAA,AAC/C,CAD8C,AAC9C,CAAA,AAED,EAAM,GAAN,CAAa,CAAA,CACT,IAAM,CAAA,CAAA,CACV,CAER,AAFQ,AACJ,EAhlBuB,GAEnB,EAFwB,CAAA,CAAA,AA8kBd,EA5kBJ,EAAY,CAAE,GAAG,EAAU,QAAA,QAAA,CAAkB,GAAG,CAAM,CAAA,CAAA,AAE5D,IAAA,MAAW,KAAO,EAIT,IAAA,CAFW,AAEX,EAHT,AAGoB,CAHpB,AACoB,AAEA,CAFA,AAEA,CAAU,EAAd,AAA2C,CAAA,AAG3D,IAAA,CAAK,MAAO,EAAA,CAAA,AACZ,IAAA,CAAK,KAAQ,CAAA,CAAA,CAOjB,AAPiB,AACjB,IAMI,KAAwB,EAAA,CAAE,OAAO,IAAK,CAAA,MAAA,CAAA,AAAQ,AAElD,IAAI,MAAM,CACV,CAAA,CACQ,IAAA,CAAK,MAAW,GAAA,IAEpB,CAFoB,EAAO,CAE3B,CAAK,KAFsB,CAEb,CAAA,EACd,GADc,CAAA,AACd,CAAK,MAAO,EAAA,CAAA,CAIhB,AAHA,IAGI,UAAsB,EAAA,CAAE,OAAO,IAAK,CAAA,WAAA,CAExC,AAFqD,AAAb,IAEpC,WAAW,CACf,CAAA,CACQ,IAAA,CAAK,WAAgB,GAAA,IAEzB,CAFyB,EAAO,CAEhC,CAAK,KAF2B,MAEb,CAAA,EACnB,GADmB,CAAA,AACnB,CAAK,MAAO,EAAA,CAAA,CAChB,AAGA,IAAI,UAA6B,EAAA,CAAE,OAAO,IAAK,CAAA,WAAA,CAE/C,AAF+C,AAAa,IAExD,WAAW,CACf,CAAA,CACQ,IAAA,CAAK,WAAgB,GAAA,IAEX,CAFW,EAAO,CAElB,GAAV,GAAmC,AAFP,EAElB,MACd,EAAA,AADsB,OAAO,EAEpB,GAFoB,CAEpB,CAAA,WAAA,CAAc,IAAA,CAAK,YAAa,CAAA,CAAE,GAAG,EAAU,QAAA,SAAA,CAAmB,GAAG,CAAA,CAAO,CAAA,CAAA,AAI5E,IAAA,CAAA,WAAA,CAAc,EAAQ,IAAK,CAAA,YAAA,CAAa,CAAE,GAAG,EAAU,QAAV,SAA4B,CAAC,CAAI,CAAA,IAAA,CAAA,AAGvF,IAAA,CAAK,MAAO,EAAA,CAAA,CAChB,AAGA,IAAI,UAAgC,EAAA,CAAE,OAAO,IAAK,CAAA,WAAA,CAAA,AAAa,AAE/D,IAAI,WAAW,CACf,CAAA,CACQ,IAAA,CAAK,WAAgB,GAAA,IAEzB,CAFyB,EAAO,CAEhC,CAAK,KAF2B,MAEb,CAAA,EACnB,GADmB,CAAA,AACnB,CAAK,MAAO,EAAA,CAAA,CAChB,AAGA,IAAI,QAAmB,EAAA,CAAE,OAAO,IAAK,CAAA,SAAA,CAAA,AAAW,AAEhD,IAAI,SAAS,CACb,CAAA,CACQ,IAAA,CAAK,SAAc,GAAA,IAEF,CAFE,EAAO,KAG9B,EAH8B,AAE1B,AACJ,OADW,EAGF,IAAA,CAAA,SAAA,CAAY,QAAS,CAAA,EAAiB,EAAE,CAAnB,AAAmB,CAI7C,AAJ6C,IAI7C,CAAK,SAAY,CAAA,EAErB,GAFqB,CAAA,AAErB,CAAK,MAAO,EAAA,CAAA,CAOhB,AANA,IAMI,SAAgC,EAAA,CAAE,OAAO,IAAK,CAAA,UAAA,CAAA,AAAY,AAE9D,IAAI,UAAU,CACd,CAAA,CACQ,IAAA,CAAK,UAAe,GAAA,IAEnB,CAFmB,EAAO,CAE1B,CAAA,KAF0B,KAE1B,CAAa,EAAM,WAAY,EAAA,CAAA,AACpC,IAAA,CAAK,MAAO,EAAA,CAAA,CAChB,AAMA,IAAI,WAAoC,EAAA,CAAE,OAAO,IAAK,CAAA,YAAA,CAAA,AAAc,AAEpE,IAAI,YAAY,CAChB,CAAA,CACQ,IAAA,CAAK,YAAiB,GAAA,IAE1B,CAF0B,EAAO,CAEjC,CAAK,KAF4B,OAEb,CAAA,EACpB,GADoB,CAAA,AACpB,CAAK,MAAO,EAAA,CAAA,CAChB,AAMA,IAAI,UAAkC,EAAA,CAAE,OAAO,IAAK,CAAA,WAAA,CAAA,AAAa,AAEjE,IAAI,WAAW,CACf,CAAA,CACQ,IAAA,CAAK,WAAgB,GAAA,IAEzB,CAFyB,EAAO,CAEhC,CAAK,KAF2B,MAEb,CAAA,EACnB,GADmB,CAAA,AACnB,CAAK,MAAO,EAAA,CAAA,CAChB,AAGA,IAAI,OAAkB,EAAA,CAAE,OAAO,IAAK,CAAA,QAAA,CAEpC,AAFoC,AAAU,IAE1C,QAAQ,CACZ,CAAA,CACQ,IAAA,CAAK,QAAa,GAAA,IAEtB,CAFsB,EAAO,CAE7B,CAAK,KAFwB,GAEb,CAAA,EAChB,GADgB,CAAA,AAChB,CAAK,MAAO,EAAA,CAAA,CAChB,AAGA,IAAI,aAAwB,EAAA,CAAE,OAAO,IAAK,CAAA,cAAA,CAAA,AAAgB,AAE1D,IAAI,cAAc,CAClB,CAAA,CACQ,IAAA,CAAK,cAAmB,GAAA,IAE5B,CAF4B,EAAO,CAEnC,CAAK,KAF8B,SAEb,CAAA,EACtB,GADsB,CAAA,AACtB,CAAK,MAAO,EAAA,CAAA,CAChB,AAGA,IAAI,UAAqB,EAAA,CAAE,OAAO,IAAK,CAAA,WAAA,CAAA,AAAa,AAEpD,IAAI,WAAW,CACf,CAAA,CACQ,IAAA,CAAK,WAAgB,GAAA,IAEzB,CAFyB,EAAO,CAEhC,CAAK,KAF2B,MAEb,CAAA,EACnB,GADmB,CAAA,AACnB,CAAK,MAAO,EAAA,CAAA,CAChB,AAOA,IAAI,OAAkB,EAAA,CAAE,OAAO,IAAK,CAAA,QAAA,CAAA,AAAU,AAE9C,IAAI,QAAQ,CACZ,CAAA,CACQ,IAAA,CAAK,QAAa,GAAA,IAEtB,CAFsB,EAAO,CAE7B,CAAK,KAFwB,GAEb,CAAA,EAChB,GADgB,CAAA,AAChB,CAAK,MAAO,EAAA,CAAA,CAChB,AAQA,IAAI,OAA6B,EAAA,CAAE,OAAO,IAAK,CAAA,QAAA,CAAU,AAEzD,AAF+C,IAE3C,QAAQ,CACZ,CAAA,CACQ,IAAA,CAAK,QAAa,GAAA,IAEjB,CAFiB,EAAO,CAExB,CAAA,KAFwB,GAExB,CAAW,MAAO,CAAA,MAAA,CAAO,GAC9B,EADmC,CAAA,CAAA,AACnC,CAAK,MAAO,EAAA,CAAA,CAChB,AAQA,IAAI,IAAgB,EAAA,CAAE,OAAO,IAAK,CAAA,KAAA,CAAA,AAAO,AAEzC,IAAI,KAAK,CACT,CAAA,CACQ,IAAA,CAAK,KAAU,GAAA,IAEnB,CAFmB,EAAO,CAE1B,CAAK,KAFqB,AAEb,CAAA,EACb,GADa,CAAA,AACb,CAAK,MAAO,EAAA,CAAA,CAChB,AAMA,IAAI,YAAsC,EAAA,CAAE,OAAO,IAAK,CAAA,aAAA,CAAA,AAAe,AAEvE,IAAI,aAAa,CACjB,CAAA,CACQ,IAAA,CAAK,aAAkB,GAAA,IAE3B,CAF2B,EAAO,CAElC,CAAK,KAF6B,QAEb,CAAA,EACrB,GADqB,CAAA,AACrB,CAAK,MAAO,EAAA,CAAA,CAChB,AAaA,IAAI,UAAkC,EAAA,CAAE,OAAO,IAAK,CAAA,WAAA,CAAA,AAAa,AAEjE,IAAI,WAAW,CACf,CAAA,CACQ,IAAA,CAAK,WAAgB,GAAA,IAEzB,CAFyB,EAAO,CAEhC,CAAK,KAF2B,MAEb,CAAA,EACnB,GADmB,CAAA,AACnB,CAAK,MAAO,EAAA,CAAA,CAChB,AAGA,IAAI,QAAoB,EAAA,CAAE,OAAO,IAAK,CAAA,SAAA,CAAA,AAAW,AAEjD,IAAI,SAAS,CACb,CAAA,CACQ,IAAA,CAAK,SAAc,GAAA,IAEvB,CAFuB,EAAO,CAE9B,CAAK,KAFyB,IAEb,CAAA,EACjB,GADiB,CAAA,AACjB,CAAK,MAAO,EAAA,CAAA,CAChB,AAGA,IAAI,aAAwB,EAAA,CAAE,OAAO,IAAK,CAAA,cAAA,CAAA,AAAgB,AAE1D,IAAI,cAAc,CAClB,CAAA,CACQ,IAAA,CAAK,cAAmB,GAAA,IAE5B,CAF4B,EAAO,CAEnC,CAAK,KAF8B,SAEb,CAAA,EACtB,GADsB,CAAA,AACtB,CAAK,MAAO,EAAA,CAAA,CAChB,AA2BA,IAAI,IACJ,EAAA,CACI,OAAO,IAAK,CAAA,aAAA,CAAA,AAChB,AAEA,IAAI,KAAK,CACT,CAAA,CACQ,IAAU,IAAK,CAAA,aAAA,EAAe,CAElC,IAAA,CAAK,CAF6B,YAEb,CAAA,EAEjB,GAFiB,CAEjB,AAFiB,CAEZ,YAAa,CAAA,KAAK,AAElB,CADT,EAAA,CACS,CAAA,aAAA,CAAgB,IAAK,CAAA,YAAA,CAAa,CAAE,GAAG,EAAA,eAAA,CAAgB,gBAAkB,CAAA,GAAG,CAAM,CAAA,CAAG,KAEtF,CADJ,GACI,CAAK,KAAQ,CAAA,CAAA,EAAA,EAAA,WAAA,EACT,CAAE,GAAG,IAAA,CAAK,aAA2B,CAAA,CACrC,EAAA,eAAgB,CAAA,gBAAA,CACpB,EACH,CAAA,CAAA,AAGL,IAAA,CAAK,KAAQ,CAAA,CAAA,EAAA,EAAA,WAAA,EACC,IAAV,EAAgB,GAAhB,IAA0B,CAAA,EAC1B,EAAA,CAD0B,cACV,CAAA,gBAAA,EAEpB,IAAA,CAAK,MAAO,EAAA,CAAA,CAIhB,AAHA,IAGI,MACJ,EAAA,CACI,OAAO,IAAK,CAAA,eAAA,CAAA,AAChB,AAEA,IAAI,OAAO,CACX,CAAA,CACQ,IAAU,IAAK,CAAA,eAAA,EAAiB,CAEpC,IAAA,CAAK,CAF+B,cAEb,CAAA,EAEnB,GAFmB,CAAA,AAEnB,CAAK,YAAa,CAAA,KAAK,AAElB,CADT,EAAA,CACS,CAAA,eAAA,CAAkB,IAAK,CAAA,YAAA,CAAa,CAAE,GAAG,EAAA,eAAA,CAAgB,kBAAoB,CAAA,GAAG,CAAM,CAAA,CAAG,KAE1F,CADJ,GACI,CAAK,OAAU,CAAA,CAAA,EAAA,EAAA,aAAA,EACX,CAAE,GAAG,IAAA,CAAK,eAA+B,CAAA,CACzC,EAAA,eAAgB,CAAA,kBAAA,CACpB,EACH,CAAA,CAAA,AAGL,IAAA,CAAK,OAAU,CAAA,CAAA,EAAA,EAAA,aAAA,EAAc,EAAO,EAAA,CAAA,cAAA,CAAgB,kBAAkB,CAAA,CAAA,AACtE,IAAA,CAAK,MAAO,EAAA,CAAA,CAChB,AAEO,MACP,EAAA,CACS,IAAA,CAAA,KAAA,EAAA,CAAA,AACA,IAAA,CAAA,IAAA,CAAK,SAAU,IAAI,CAAA,CAAA,AAC5B,AAGO,KACP,EAAA,CACI,IAAM,EAAe,EAAU,QAAA,QAAA,CAE/B,AAF+B,IAE/B,IAAW,KAAO,EAET,IAAA,CAAA,EAA4B,CAAJ,AAAI,CAAA,CADrC,AACkD,CADlD,CAC+E,AAC/E,CAD+E,AAEnF,AAOA,IAAW,QACX,EAAA,CACI,MAAO,CAAG,EAAA,IAAA,CAAK,GAAG,CAAA,CAAA,EAAI,IAAA,CAAK,KAAK,CAAA,CAAA,CAAA,AACpC,AAMO,KACP,EAAA,CACI,OAAO,IAAI,EAAU,CACjB,MAAO,CADU,GACL,CAAA,KAAA,CACZ,WAAY,IAAK,CAAA,UAAA,CACjB,WAAY,IAAK,CAAA,WAAA,CAAc,CAAE,GAAG,IAAA,CAAK,WAAA,CAAgB,CAAA,IAAA,CACzD,KAAM,IAAK,CAAA,KAAA,CACX,WAAY,IAAK,CAAA,UAAA,CACjB,SAAU,IAAK,CAAA,QAAA,CACf,UAAW,IAAK,CAAA,SAAA,CAChB,YAAa,IAAK,CAAA,WAAA,CAClB,WAAY,IAAK,CAAA,UAAA,CACjB,QAAS,IAAK,CAAA,OAAA,CACd,cAAe,IAAK,CAAA,aAAA,CACpB,WAAY,IAAK,CAAA,UAAA,CACjB,QAAS,IAAK,CAAA,OAAA,CACd,OAAQ,IAAK,CAAA,OAAA,CACb,aAAc,IAAK,CAAA,YAAA,CACnB,WAAY,IAAK,CAAA,UAAA,CACjB,SAAU,IAAK,CAAA,QAAA,CACf,cAAe,IAAK,CAAA,aAAA,CACpB,QAAS,IAAK,CAAA,QAAA,CAAW,CAAC,GAAG,IAAA,CAAK,QAAQ,CAAI,CAAA,KAAA,CAAA,CACjD,CAAA,CAAA,AACL,AAQO,gBACP,EAAA,CACI,IAAI,EAAgB,CAAA,CAAA,AAEpB,GAAI,IAAA,CAAK,CAFW,OAGpB,CACI,CADJ,GACI,IAAS,EAAI,CAAG,CAAA,CAAA,CAAI,IAAK,CAAA,QAAA,CAAS,MAAA,CAAQ,CAC1C,EAAA,CAAA,AACqB,GAAA,IAAA,CAAK,KAAL,GAAc,CAAA,CAAC,CAAE,CAAA,OAAA,CAAA,AAI1C,OAAO,IAAK,CAAA,GAAA,CAAI,IAAK,CAAA,QAAA,CAAU,EAAa,CAChD,AAWO,OAAA,CAAQ,EAZiC,CAYY,AAZZ,CAAA,AAahD,CAAA,CAKI,GAJA,CAII,GAJJ,CAAK,UAKL,QALwB,EAAA,CAEkB,AAFlB,SAEkB,EAAnB,OAAO,EAAwB,EAAU,GAAS,AAA/B,IAA+B,GAAA,CAAA,AAGzE,CACI,IAAM,EAA0C,SAAA,EAAnB,OAAA,AAAO,EAAwB,EAAU,GAAS,AAA/B,IAA+B,SAAA,CAAA,AAE3E,IAAA,CAAK,KAAA,EAAO,OAChB,EAAA,AACS,IAAA,CAAA,KAAA,CAAM,OAAQ,CAAA,OAAA,CAAQ,GAG1B,IAAA,CAAK,YAHyC,CAAA,AAGzC,CAHyC,CAGZ,OACvC,EACK,AADL,IACU,CAAA,aAAA,CAA4B,OAAQ,CAAA,OAAA,CAAQ,GAGlD,IAAA,CAAK,OAAA,EAAS,GAHwD,CAAA,CAAA,EAI1E,EACS,AADT,IACS,CAAA,OAAA,CAAQ,OAAQ,CAAA,OAAA,CAAQ,GAG5B,IAAA,CAAK,YAH2C,CAAA,CAAA,CAG3C,EAA+B,OACzC,EAAA,AACK,IAAK,CAAA,eAAA,CAA8B,OAAQ,CAAA,OAAA,CAAQ,EACxD,CACJ,AAEA,IAAA,CAAK,KAAQ,CAAA,IAAA,CAAA,AACb,CALgF,CAAA,CAAA,CAKhF,CAAK,OAAU,CAAA,IAAA,CAAA,AACf,IAAA,CAAK,UAAa,CAAA,IAAA,CAAA,AAClB,IAAA,CAAK,eAAkB,CAAA,IAAA,CAAA,AACvB,IAAA,CAAK,aAAgB,CAAA,IAAA,CAAA,AACzB,AAEQ,YAAA,CAA+B,CAAA,CAAU,CACjD,CAAA,CACW,OAAA,IAAI,MAAS,EAAO,CACvB,EADuB,CAClB,CAAA,CAAC,EAAQ,EAAU,EAAV,EAEN,CAAA,CAFM,AAEC,EADf,AACwC,GAAA,EADxC,CACkC,CAE9B,CAAA,CAAO,EAF6B,AAEN,CAAA,CAFuB,CAGrD,EAAA,CAD0B,CACrB,EAHgD,AAEvB,AACL,CADK,EAE9B,CAJqD,CAAA,EAIrD,CADiC,AAC5B,CAD4B,CAAA,IACrB,EAAA,CAAA,CAEL,EACX,CACH,CAFc,AAEd,CAFc,AAEd,AACL,AAEQ,aAAa,CACrB,CAAA,CACa,MAAA,CAAA,GAAS,EAAT,EAAS,CAAU,GAAA,IAAA,EACrB,CAAA,AAAE,GAAA,KAAA,CAAM,WAAA,CAAY,IAAU,CAAL,CAAA,GAAsB,QAAA,EAAA,YAAA,EAAgB,KAAiB,QAAA,EAAA,WAAA,CAAA,CAAA,AAC3F,AACJ,CAAA,CAAA,AAxlBa,EAeK,QAfL,SAeyC,CAAA,CAC9C,KAAO,CAAA,CAAA,CACP,KAAA,CAAO,KAAK,EAAK,CAAA,CAAA,CACjB,IAAM,CAAA,CAAA,CACN,KAAO,CAAA,OAAA,CACP,QAAU,CAAA,CAAA,AACd,CAAA,CAAA,AArBS,EA+CK,QA/CL,QA+C0C,CAAA,CAC/C,KAAO,CAAA,MAAA,CACP,UAAY,EAAA,EACZ,GADY,OACA,CAAA,IAAA,CACZ,IAAM,CAAA,OAAA,CACN,UAAY,CAAA,OAAA,CACZ,QAAU,CAAA,EAAA,CACV,SAAW,CAAA,QAAA,CACX,WAAa,CAAA,QAAA,CACb,UAAY,CAAA,QAAA,CACZ,OAAS,CAAA,CAAA,CACT,aAAe,CAAA,CAAA,CACf,UAAY,CAAA,CAAA,CACZ,OAAS,CAAA,CAAA,CACT,MAAQ,CAAA,IAAA,CACR,YAAc,CAAA,YAAA,CACd,IAAM,CAAA,GACN,EADM,QACM,CAAA,KAAA,CACZ,QAAU,EAAA,EACV,GADU,UACK,CAAA,GAAA,AACnB,CAAA,CAAA","ignoreList":[0,1,2,3,4,5,6,7,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,62,63,65,66,67,68,69,70]}